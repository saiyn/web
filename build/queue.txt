; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\queue.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\queue.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\Driver -I.\web -I.\third_party\lwip-1.4.1\src\include -I.\third_party\fatfs -I.\third_party\lwip-1.4.1\apps\httpserver_raw -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch -I.\third_party\lwip-1.4.1\src\include\ipv4 -I..\MCU -I.\third_party\lwip-1.4.1\apps -I.\third_party -I.\Upnp -I.\Dsp -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C129XNCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DUSE_LWIP -DTM4C129ENCPDT --omf_browse=.\build\queue.crf FreeRTOS\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;245    
;;;246    portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;248    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000006  462c              MOV      r4,r5
;;;249    
;;;250    	configASSERT( pxQueue );
;;;251    
;;;252    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;253    	{
;;;254    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000c  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000010  6820              LDR      r0,[r4,#0]
000012  fb010002          MLA      r0,r1,r2,r0
000016  6060              STR      r0,[r4,#4]
;;;255    		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000018  2000              MOVS     r0,#0
00001a  63a0              STR      r0,[r4,#0x38]
;;;256    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6820              LDR      r0,[r4,#0]
00001e  60a0              STR      r0,[r4,#8]
;;;257    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  6c22              LDR      r2,[r4,#0x40]
000026  6821              LDR      r1,[r4,#0]
000028  fb001002          MLA      r0,r0,r2,r1
00002c  60e0              STR      r0,[r4,#0xc]
;;;258    		pxQueue->xRxLock = queueUNLOCKED;
00002e  f04f30ff          MOV      r0,#0xffffffff
000032  6460              STR      r0,[r4,#0x44]
;;;259    		pxQueue->xTxLock = queueUNLOCKED;
000034  64a0              STR      r0,[r4,#0x48]
;;;260    
;;;261    		if( xNewQueue == pdFALSE )
000036  b976              CBNZ     r6,|L1.86|
;;;262    		{
;;;263    			/* If there are tasks blocked waiting to read from the queue, then
;;;264    			the tasks will remain blocked as after this function exits the queue
;;;265    			will still be empty.  If there are tasks blocked waiting to write to
;;;266    			the queue, then one should be unblocked as after this function exits
;;;267    			it will be possible to write to it. */
;;;268    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000038  6920              LDR      r0,[r4,#0x10]
00003a  b908              CBNZ     r0,|L1.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L1.66|
                  |L1.64|
000040  2000              MOVS     r0,#0
                  |L1.66|
000042  b980              CBNZ     r0,|L1.102|
;;;269    			{
;;;270    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000044  f1040010          ADD      r0,r4,#0x10
000048  f7fffffe          BL       xTaskRemoveFromEventList
00004c  2801              CMP      r0,#1
00004e  d10a              BNE      |L1.102|
;;;271    				{
;;;272    					queueYIELD_IF_USING_PREEMPTION();
000050  f7fffffe          BL       vPortYield
000054  e007              B        |L1.102|
                  |L1.86|
;;;273    				}
;;;274    			}
;;;275    		}
;;;276    		else
;;;277    		{
;;;278    			/* Ensure the event queues start in the correct state. */
;;;279    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       vListInitialise
;;;280    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00005e  f1040024          ADD      r0,r4,#0x24
000062  f7fffffe          BL       vListInitialise
                  |L1.102|
;;;281    		}
;;;282    	}
;;;283    	taskEXIT_CRITICAL();
000066  f7fffffe          BL       vPortExitCritical
;;;284    
;;;285    	/* A value is returned for calling semantic consistency with previous
;;;286    	versions. */
;;;287    	return pdPASS;
00006a  2001              MOVS     r0,#1
;;;288    }
00006c  bd70              POP      {r4-r6,pc}
;;;289    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;290    
;;;291    xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
00006e  e92d47f0          PUSH     {r4-r10,lr}
;;;292    {
000072  4605              MOV      r5,r0
000074  460e              MOV      r6,r1
000076  4691              MOV      r9,r2
;;;293    xQUEUE *pxNewQueue;
;;;294    size_t xQueueSizeInBytes;
;;;295    xQueueHandle xReturn = NULL;
000078  f04f0800          MOV      r8,#0
;;;296    
;;;297    	/* Remove compiler warnings about unused parameters should
;;;298    	configUSE_TRACE_FACILITY not be set to 1. */
;;;299    	( void ) ucQueueType;
;;;300    
;;;301    	/* Allocate the new queue structure. */
;;;302    	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
00007c  b1d5              CBZ      r5,|L1.180|
;;;303    	{
;;;304    		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
00007e  2050              MOVS     r0,#0x50
000080  f7fffffe          BL       pvPortMalloc
000084  4604              MOV      r4,r0
;;;305    		if( pxNewQueue != NULL )
000086  b1ac              CBZ      r4,|L1.180|
;;;306    		{
;;;307    			/* Create the list of pointers to queue items.  The queue is one byte
;;;308    			longer than asked for to make wrap checking easier/faster. */
;;;309    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000088  fb05f006          MUL      r0,r5,r6
00008c  1c47              ADDS     r7,r0,#1
;;;310    
;;;311    			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
00008e  4638              MOV      r0,r7
000090  f7fffffe          BL       pvPortMalloc
000094  6020              STR      r0,[r4,#0]
;;;312    			if( pxNewQueue->pcHead != NULL )
000096  6820              LDR      r0,[r4,#0]
000098  b148              CBZ      r0,|L1.174|
;;;313    			{
;;;314    				/* Initialise the queue members as described above where the
;;;315    				queue type is defined. */
;;;316    				pxNewQueue->uxLength = uxQueueLength;
00009a  63e5              STR      r5,[r4,#0x3c]
;;;317    				pxNewQueue->uxItemSize = uxItemSize;
00009c  6426              STR      r6,[r4,#0x40]
;;;318    				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00009e  2101              MOVS     r1,#1
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       xQueueGenericReset
;;;319    
;;;320    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;321    				{
;;;322    					pxNewQueue->ucQueueType = ucQueueType;
;;;323    				}
;;;324    				#endif /* configUSE_TRACE_FACILITY */
;;;325    
;;;326    				#if( configUSE_QUEUE_SETS == 1 )
;;;327    				{
;;;328    					pxNewQueue->pxQueueSetContainer = NULL;
0000a6  2000              MOVS     r0,#0
0000a8  64e0              STR      r0,[r4,#0x4c]
;;;329    				}
;;;330    				#endif /* configUSE_QUEUE_SETS */
;;;331    
;;;332    				traceQUEUE_CREATE( pxNewQueue );
;;;333    				xReturn = pxNewQueue;
0000aa  46a0              MOV      r8,r4
0000ac  e002              B        |L1.180|
                  |L1.174|
;;;334    			}
;;;335    			else
;;;336    			{
;;;337    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;338    				vPortFree( pxNewQueue );
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       vPortFree
                  |L1.180|
;;;339    			}
;;;340    		}
;;;341    	}
;;;342    
;;;343    	configASSERT( xReturn );
;;;344    
;;;345    	return xReturn;
0000b4  4640              MOV      r0,r8
;;;346    }
0000b6  e8bd87f0          POP      {r4-r10,pc}
;;;347    /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataToQueue PROC
;;;1417   
;;;1418   static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
0000ba  b570              PUSH     {r4-r6,lr}
;;;1419   {
0000bc  4604              MOV      r4,r0
0000be  460e              MOV      r6,r1
0000c0  4615              MOV      r5,r2
;;;1420   	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
0000c2  6c20              LDR      r0,[r4,#0x40]
0000c4  b938              CBNZ     r0,|L1.214|
;;;1421   	{
;;;1422   		#if ( configUSE_MUTEXES == 1 )
;;;1423   		{
;;;1424   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
0000c6  6820              LDR      r0,[r4,#0]
0000c8  bb70              CBNZ     r0,|L1.296|
;;;1425   			{
;;;1426   				/* The mutex is no longer being held. */
;;;1427   				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
0000ca  6860              LDR      r0,[r4,#4]
0000cc  f7fffffe          BL       vTaskPriorityDisinherit
;;;1428   				pxQueue->pxMutexHolder = NULL;
0000d0  2000              MOVS     r0,#0
0000d2  6060              STR      r0,[r4,#4]
0000d4  e028              B        |L1.296|
                  |L1.214|
;;;1429   			}
;;;1430   		}
;;;1431   		#endif /* configUSE_MUTEXES */
;;;1432   	}
;;;1433   	else if( xPosition == queueSEND_TO_BACK )
0000d6  b97d              CBNZ     r5,|L1.248|
;;;1434   	{
;;;1435   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
0000d8  4631              MOV      r1,r6
0000da  6c22              LDR      r2,[r4,#0x40]
0000dc  68a0              LDR      r0,[r4,#8]
0000de  f7fffffe          BL       __aeabi_memcpy
;;;1436   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
0000e2  6c21              LDR      r1,[r4,#0x40]
0000e4  68a0              LDR      r0,[r4,#8]
0000e6  4408              ADD      r0,r0,r1
0000e8  60a0              STR      r0,[r4,#8]
;;;1437   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
0000ea  e9d41001          LDRD     r1,r0,[r4,#4]
0000ee  4288              CMP      r0,r1
0000f0  d31a              BCC      |L1.296|
;;;1438   		{
;;;1439   			pxQueue->pcWriteTo = pxQueue->pcHead;
0000f2  6820              LDR      r0,[r4,#0]
0000f4  60a0              STR      r0,[r4,#8]
0000f6  e017              B        |L1.296|
                  |L1.248|
;;;1440   		}
;;;1441   	}
;;;1442   	else
;;;1443   	{
;;;1444   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000f8  4631              MOV      r1,r6
0000fa  6c22              LDR      r2,[r4,#0x40]
0000fc  68e0              LDR      r0,[r4,#0xc]
0000fe  f7fffffe          BL       __aeabi_memcpy
;;;1445   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000102  6c21              LDR      r1,[r4,#0x40]
000104  68e0              LDR      r0,[r4,#0xc]
000106  1a40              SUBS     r0,r0,r1
000108  60e0              STR      r0,[r4,#0xc]
;;;1446   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00010a  6821              LDR      r1,[r4,#0]
00010c  68e0              LDR      r0,[r4,#0xc]
00010e  4288              CMP      r0,r1
000110  d203              BCS      |L1.282|
;;;1447   		{
;;;1448   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000112  6c21              LDR      r1,[r4,#0x40]
000114  6860              LDR      r0,[r4,#4]
000116  1a40              SUBS     r0,r0,r1
000118  60e0              STR      r0,[r4,#0xc]
                  |L1.282|
;;;1449   		}
;;;1450   
;;;1451   		if( xPosition == queueOVERWRITE )
00011a  2d02              CMP      r5,#2
00011c  d104              BNE      |L1.296|
;;;1452   		{
;;;1453   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
00011e  6ba0              LDR      r0,[r4,#0x38]
000120  b110              CBZ      r0,|L1.296|
;;;1454   			{
;;;1455   				/* An item is not being added but overwritten, so subtract
;;;1456   				one from the recorded number of items in the queue so when
;;;1457   				one is added again below the number of recorded items remains
;;;1458   				correct. */
;;;1459   				--( pxQueue->uxMessagesWaiting );
000122  6ba0              LDR      r0,[r4,#0x38]
000124  1e40              SUBS     r0,r0,#1
000126  63a0              STR      r0,[r4,#0x38]
                  |L1.296|
;;;1460   			}
;;;1461   		}
;;;1462   	}
;;;1463   
;;;1464   	++( pxQueue->uxMessagesWaiting );
000128  6ba0              LDR      r0,[r4,#0x38]
00012a  1c40              ADDS     r0,r0,#1
00012c  63a0              STR      r0,[r4,#0x38]
;;;1465   }
00012e  bd70              POP      {r4-r6,pc}
;;;1466   /*-----------------------------------------------------------*/
                          ENDP

                  prvNotifyQueueSetContainer PROC
;;;2066   
;;;2067   	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopyPosition )
000130  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2068   	{
000132  460d              MOV      r5,r1
;;;2069   	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
000134  9800              LDR      r0,[sp,#0]
000136  6cc4              LDR      r4,[r0,#0x4c]
;;;2070   	portBASE_TYPE xReturn = pdFALSE;
000138  2600              MOVS     r6,#0
;;;2071   
;;;2072   		configASSERT( pxQueueSetContainer );
;;;2073   		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
;;;2074   
;;;2075   		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
00013a  6ba0              LDR      r0,[r4,#0x38]
00013c  6be1              LDR      r1,[r4,#0x3c]
00013e  4288              CMP      r0,r1
000140  d210              BCS      |L1.356|
;;;2076   		{
;;;2077   			traceQUEUE_SEND( pxQueueSetContainer );
;;;2078   			/* The data copies is the handle of the queue that contains data. */
;;;2079   			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
000142  462a              MOV      r2,r5
000144  4669              MOV      r1,sp
000146  4620              MOV      r0,r4
000148  f7fffffe          BL       prvCopyDataToQueue
;;;2080   			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
00014c  6a60              LDR      r0,[r4,#0x24]
00014e  b908              CBNZ     r0,|L1.340|
000150  2001              MOVS     r0,#1
000152  e000              B        |L1.342|
                  |L1.340|
000154  2000              MOVS     r0,#0
                  |L1.342|
000156  b928              CBNZ     r0,|L1.356|
;;;2081   			{
;;;2082   				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
000158  f1040024          ADD      r0,r4,#0x24
00015c  f7fffffe          BL       xTaskRemoveFromEventList
000160  b100              CBZ      r0,|L1.356|
;;;2083   				{
;;;2084   					/* The task waiting has a higher priority */
;;;2085   					xReturn = pdTRUE;
000162  2601              MOVS     r6,#1
                  |L1.356|
;;;2086   				}
;;;2087   			}
;;;2088   		}
;;;2089   
;;;2090   		return xReturn;
000164  4630              MOV      r0,r6
;;;2091   	}
000166  bd7c              POP      {r2-r6,pc}
;;;2092   
                          ENDP

                  prvUnlockQueue PROC
;;;1481   
;;;1482   static void prvUnlockQueue( xQUEUE *pxQueue )
000168  b510              PUSH     {r4,lr}
;;;1483   {
00016a  4604              MOV      r4,r0
;;;1484   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1485   
;;;1486   	/* The lock counts contains the number of extra data items placed or
;;;1487   	removed from the queue while the queue was locked.  When a queue is
;;;1488   	locked items can be added or removed, but the event lists cannot be
;;;1489   	updated. */
;;;1490   	taskENTER_CRITICAL();
00016c  f7fffffe          BL       vPortEnterCritical
;;;1491   	{
;;;1492   		/* See if data was added to the queue while it was locked. */
;;;1493   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
000170  e01c              B        |L1.428|
                  |L1.370|
;;;1494   		{
;;;1495   			/* Data was posted while the queue was locked.  Are any tasks
;;;1496   			blocked waiting for data to become available? */
;;;1497   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1498   			{
;;;1499   				if( pxQueue->pxQueueSetContainer != NULL )
000172  6ce0              LDR      r0,[r4,#0x4c]
000174  b140              CBZ      r0,|L1.392|
;;;1500   				{
;;;1501   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
000176  2100              MOVS     r1,#0
000178  4620              MOV      r0,r4
00017a  f7fffffe          BL       prvNotifyQueueSetContainer
00017e  2801              CMP      r0,#1
000180  d111              BNE      |L1.422|
;;;1502   					{
;;;1503   						/* The queue is a member of a queue set, and posting to
;;;1504   						the queue set caused a higher priority task to unblock.
;;;1505   						A context switch is required. */
;;;1506   						vTaskMissedYield();
000182  f7fffffe          BL       vTaskMissedYield
000186  e00e              B        |L1.422|
                  |L1.392|
;;;1507   					}
;;;1508   				}
;;;1509   				else
;;;1510   				{
;;;1511   					/* Tasks that are removed from the event list will get added to
;;;1512   					the pending ready list as the scheduler is still suspended. */
;;;1513   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000188  6a60              LDR      r0,[r4,#0x24]
00018a  b908              CBNZ     r0,|L1.400|
00018c  2001              MOVS     r0,#1
00018e  e000              B        |L1.402|
                  |L1.400|
000190  2000              MOVS     r0,#0
                  |L1.402|
000192  b938              CBNZ     r0,|L1.420|
;;;1514   					{
;;;1515   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000194  f1040024          ADD      r0,r4,#0x24
000198  f7fffffe          BL       xTaskRemoveFromEventList
00019c  b118              CBZ      r0,|L1.422|
;;;1516   						{
;;;1517   							/* The task waiting has a higher priority so record that a
;;;1518   							context	switch is required. */
;;;1519   							vTaskMissedYield();
00019e  f7fffffe          BL       vTaskMissedYield
0001a2  e000              B        |L1.422|
                  |L1.420|
;;;1520   						}
;;;1521   					}
;;;1522   					else
;;;1523   					{
;;;1524   						break;
0001a4  e005              B        |L1.434|
                  |L1.422|
;;;1525   					}
;;;1526   				}
;;;1527   			}
;;;1528   			#else /* configUSE_QUEUE_SETS */
;;;1529   			{
;;;1530   				/* Tasks that are removed from the event list will get added to
;;;1531   				the pending ready list as the scheduler is still suspended. */
;;;1532   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1533   				{
;;;1534   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1535   					{
;;;1536   						/* The task waiting has a higher priority so record that a
;;;1537   						context	switch is required. */
;;;1538   						vTaskMissedYield();
;;;1539   					}
;;;1540   				}
;;;1541   				else
;;;1542   				{
;;;1543   					break;
;;;1544   				}
;;;1545   			}
;;;1546   			#endif /* configUSE_QUEUE_SETS */
;;;1547   
;;;1548   			--( pxQueue->xTxLock );
0001a6  6ca0              LDR      r0,[r4,#0x48]
0001a8  1e40              SUBS     r0,r0,#1
0001aa  64a0              STR      r0,[r4,#0x48]
                  |L1.428|
0001ac  6ca0              LDR      r0,[r4,#0x48]         ;1493
0001ae  2800              CMP      r0,#0                 ;1493
0001b0  dcdf              BGT      |L1.370|
                  |L1.434|
0001b2  bf00              NOP                            ;1524
;;;1549   		}
;;;1550   
;;;1551   		pxQueue->xTxLock = queueUNLOCKED;
0001b4  f04f30ff          MOV      r0,#0xffffffff
0001b8  64a0              STR      r0,[r4,#0x48]
;;;1552   	}
;;;1553   	taskEXIT_CRITICAL();
0001ba  f7fffffe          BL       vPortExitCritical
;;;1554   
;;;1555   	/* Do the same for the Rx lock. */
;;;1556   	taskENTER_CRITICAL();
0001be  f7fffffe          BL       vPortEnterCritical
;;;1557   	{
;;;1558   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
0001c2  e011              B        |L1.488|
                  |L1.452|
;;;1559   		{
;;;1560   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0001c4  6920              LDR      r0,[r4,#0x10]
0001c6  b908              CBNZ     r0,|L1.460|
0001c8  2001              MOVS     r0,#1
0001ca  e000              B        |L1.462|
                  |L1.460|
0001cc  2000              MOVS     r0,#0
                  |L1.462|
0001ce  b950              CBNZ     r0,|L1.486|
;;;1561   			{
;;;1562   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0001d0  f1040010          ADD      r0,r4,#0x10
0001d4  f7fffffe          BL       xTaskRemoveFromEventList
0001d8  b108              CBZ      r0,|L1.478|
;;;1563   				{
;;;1564   					vTaskMissedYield();
0001da  f7fffffe          BL       vTaskMissedYield
                  |L1.478|
;;;1565   				}
;;;1566   
;;;1567   				--( pxQueue->xRxLock );
0001de  6c60              LDR      r0,[r4,#0x44]
0001e0  1e40              SUBS     r0,r0,#1
0001e2  6460              STR      r0,[r4,#0x44]
0001e4  e000              B        |L1.488|
                  |L1.486|
;;;1568   			}
;;;1569   			else
;;;1570   			{
;;;1571   				break;
0001e6  e002              B        |L1.494|
                  |L1.488|
0001e8  6c60              LDR      r0,[r4,#0x44]         ;1558
0001ea  2800              CMP      r0,#0                 ;1558
0001ec  dcea              BGT      |L1.452|
                  |L1.494|
0001ee  bf00              NOP      
;;;1572   			}
;;;1573   		}
;;;1574   
;;;1575   		pxQueue->xRxLock = queueUNLOCKED;
0001f0  f04f30ff          MOV      r0,#0xffffffff
0001f4  6460              STR      r0,[r4,#0x44]
;;;1576   	}
;;;1577   	taskEXIT_CRITICAL();
0001f6  f7fffffe          BL       vPortExitCritical
;;;1578   }
0001fa  bd10              POP      {r4,pc}
;;;1579   /*-----------------------------------------------------------*/
                          ENDP

                  prvIsQueueFull PROC
;;;1619   
;;;1620   static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
0001fc  b570              PUSH     {r4-r6,lr}
;;;1621   {
0001fe  4605              MOV      r5,r0
;;;1622   signed portBASE_TYPE xReturn;
;;;1623   
;;;1624   	taskENTER_CRITICAL();
000200  f7fffffe          BL       vPortEnterCritical
;;;1625   	{
;;;1626   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000204  6ba8              LDR      r0,[r5,#0x38]
000206  6be9              LDR      r1,[r5,#0x3c]
000208  4288              CMP      r0,r1
00020a  d101              BNE      |L1.528|
;;;1627   		{
;;;1628   			xReturn = pdTRUE;
00020c  2401              MOVS     r4,#1
00020e  e000              B        |L1.530|
                  |L1.528|
;;;1629   		}
;;;1630   		else
;;;1631   		{
;;;1632   			xReturn = pdFALSE;
000210  2400              MOVS     r4,#0
                  |L1.530|
;;;1633   		}
;;;1634   	}
;;;1635   	taskEXIT_CRITICAL();
000212  f7fffffe          BL       vPortExitCritical
;;;1636   
;;;1637   	return xReturn;
000216  4620              MOV      r0,r4
;;;1638   }
000218  bd70              POP      {r4-r6,pc}
;;;1639   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;563    
;;;564    signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
00021a  e92d41ff          PUSH     {r0-r8,lr}
;;;565    {
00021e  b082              SUB      sp,sp,#8
000220  4606              MOV      r6,r0
000222  460f              MOV      r7,r1
000224  461d              MOV      r5,r3
;;;566    signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000226  f04f0800          MOV      r8,#0
;;;567    xTimeOutType xTimeOut;
;;;568    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
00022a  4634              MOV      r4,r6
;;;569    
;;;570    	configASSERT( pxQueue );
;;;571    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;572    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;573    
;;;574    	/* This function relaxes the coding standard somewhat to allow return
;;;575    	statements within the function itself.  This is done in the interest
;;;576    	of execution time efficiency. */
;;;577    	for( ;; )
00022c  bf00              NOP      
                  |L1.558|
;;;578    	{
;;;579    		taskENTER_CRITICAL();
00022e  f7fffffe          BL       vPortEnterCritical
;;;580    		{
;;;581    			/* Is there room on the queue now?  The running task must be
;;;582    			the highest priority task wanting to access the queue.  If
;;;583    			the head item in the queue is to be overwritten then it does
;;;584    			not matter if the queue is full. */
;;;585    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000232  6ba0              LDR      r0,[r4,#0x38]
000234  6be1              LDR      r1,[r4,#0x3c]
000236  4288              CMP      r0,r1
000238  d301              BCC      |L1.574|
00023a  2d02              CMP      r5,#2
00023c  d123              BNE      |L1.646|
                  |L1.574|
;;;586    			{
;;;587    				traceQUEUE_SEND( pxQueue );
;;;588    				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00023e  462a              MOV      r2,r5
000240  4639              MOV      r1,r7
000242  4620              MOV      r0,r4
000244  f7fffffe          BL       prvCopyDataToQueue
;;;589    
;;;590    				#if ( configUSE_QUEUE_SETS == 1 )
;;;591    				{
;;;592    					if( pxQueue->pxQueueSetContainer != NULL )
000248  6ce0              LDR      r0,[r4,#0x4c]
00024a  b140              CBZ      r0,|L1.606|
;;;593    					{
;;;594    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
00024c  4629              MOV      r1,r5
00024e  4620              MOV      r0,r4
000250  f7fffffe          BL       prvNotifyQueueSetContainer
000254  2801              CMP      r0,#1
000256  d110              BNE      |L1.634|
;;;595    						{
;;;596    							/* The queue is a member of a queue set, and posting
;;;597    							to the queue set caused a higher priority task to
;;;598    							unblock. A context switch is required. */
;;;599    							queueYIELD_IF_USING_PREEMPTION();
000258  f7fffffe          BL       vPortYield
00025c  e00d              B        |L1.634|
                  |L1.606|
;;;600    						}
;;;601    					}
;;;602    					else
;;;603    					{
;;;604    						/* If there was a task waiting for data to arrive on the
;;;605    						queue then unblock it now. */
;;;606    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00025e  6a60              LDR      r0,[r4,#0x24]
000260  b908              CBNZ     r0,|L1.614|
000262  2001              MOVS     r0,#1
000264  e000              B        |L1.616|
                  |L1.614|
000266  2000              MOVS     r0,#0
                  |L1.616|
000268  b938              CBNZ     r0,|L1.634|
;;;607    						{
;;;608    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
00026a  f1040024          ADD      r0,r4,#0x24
00026e  f7fffffe          BL       xTaskRemoveFromEventList
000272  2801              CMP      r0,#1
000274  d101              BNE      |L1.634|
;;;609    							{
;;;610    								/* The unblocked task has a priority higher than
;;;611    								our own so yield immediately.  Yes it is ok to
;;;612    								do this from within the critical section - the
;;;613    								kernel takes care of that. */
;;;614    								queueYIELD_IF_USING_PREEMPTION();
000276  f7fffffe          BL       vPortYield
                  |L1.634|
;;;615    							}
;;;616    						}
;;;617    					}
;;;618    				}
;;;619    				#else /* configUSE_QUEUE_SETS */
;;;620    				{
;;;621    					/* If there was a task waiting for data to arrive on the
;;;622    					queue then unblock it now. */
;;;623    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;624    					{
;;;625    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;626    						{
;;;627    							/* The unblocked task has a priority higher than
;;;628    							our own so yield immediately.  Yes it is ok to do
;;;629    							this from within the critical section - the kernel
;;;630    							takes care of that. */
;;;631    							queueYIELD_IF_USING_PREEMPTION();
;;;632    						}
;;;633    					}
;;;634    				}
;;;635    				#endif /* configUSE_QUEUE_SETS */
;;;636    
;;;637    				taskEXIT_CRITICAL();
00027a  f7fffffe          BL       vPortExitCritical
;;;638    
;;;639    				/* Return to the original privilege level before exiting the
;;;640    				function. */
;;;641    				return pdPASS;
00027e  2001              MOVS     r0,#1
                  |L1.640|
;;;642    			}
;;;643    			else
;;;644    			{
;;;645    				if( xTicksToWait == ( portTickType ) 0 )
;;;646    				{
;;;647    					/* The queue was full and no block time is specified (or
;;;648    					the block time has expired) so leave now. */
;;;649    					taskEXIT_CRITICAL();
;;;650    
;;;651    					/* Return to the original privilege level before exiting
;;;652    					the function. */
;;;653    					traceQUEUE_SEND_FAILED( pxQueue );
;;;654    					return errQUEUE_FULL;
;;;655    				}
;;;656    				else if( xEntryTimeSet == pdFALSE )
;;;657    				{
;;;658    					/* The queue was full and a block time was specified so
;;;659    					configure the timeout structure. */
;;;660    					vTaskSetTimeOutState( &xTimeOut );
;;;661    					xEntryTimeSet = pdTRUE;
;;;662    				}
;;;663    				else
;;;664    				{
;;;665    					/* Entry time was already set. */
;;;666    				}
;;;667    			}
;;;668    		}
;;;669    		taskEXIT_CRITICAL();
;;;670    
;;;671    		/* Interrupts and other tasks can send to and receive from the queue
;;;672    		now the critical section has been exited. */
;;;673    
;;;674    		vTaskSuspendAll();
;;;675    		prvLockQueue( pxQueue );
;;;676    
;;;677    		/* Update the timeout state to see if it has expired yet. */
;;;678    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;679    		{
;;;680    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;681    			{
;;;682    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;683    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;684    
;;;685    				/* Unlocking the queue means queue events can effect the
;;;686    				event list.  It is possible	that interrupts occurring now
;;;687    				remove this task from the event	list again - but as the
;;;688    				scheduler is suspended the task will go onto the pending
;;;689    				ready last instead of the actual ready list. */
;;;690    				prvUnlockQueue( pxQueue );
;;;691    
;;;692    				/* Resuming the scheduler will move tasks from the pending
;;;693    				ready list into the ready list - so it is feasible that this
;;;694    				task is already in a ready list before it yields - in which
;;;695    				case the yield will not cause a context switch unless there
;;;696    				is also a higher priority task in the pending ready list. */
;;;697    				if( xTaskResumeAll() == pdFALSE )
;;;698    				{
;;;699    					portYIELD_WITHIN_API();
;;;700    				}
;;;701    			}
;;;702    			else
;;;703    			{
;;;704    				/* Try again. */
;;;705    				prvUnlockQueue( pxQueue );
;;;706    				( void ) xTaskResumeAll();
;;;707    			}
;;;708    		}
;;;709    		else
;;;710    		{
;;;711    			/* The timeout has expired. */
;;;712    			prvUnlockQueue( pxQueue );
;;;713    			( void ) xTaskResumeAll();
;;;714    
;;;715    			/* Return to the original privilege level before exiting the
;;;716    			function. */
;;;717    			traceQUEUE_SEND_FAILED( pxQueue );
;;;718    			return errQUEUE_FULL;
;;;719    		}
;;;720    	}
;;;721    }
000280  b006              ADD      sp,sp,#0x18
000282  e8bd81f0          POP      {r4-r8,pc}
                  |L1.646|
000286  9804              LDR      r0,[sp,#0x10]         ;645
000288  b918              CBNZ     r0,|L1.658|
00028a  f7fffffe          BL       vPortExitCritical
00028e  2000              MOVS     r0,#0                 ;654
000290  e7f6              B        |L1.640|
                  |L1.658|
000292  f1b80f00          CMP      r8,#0                 ;656
000296  d104              BNE      |L1.674|
000298  4668              MOV      r0,sp                 ;660
00029a  f7fffffe          BL       vTaskSetTimeOutState
00029e  f04f0801          MOV      r8,#1                 ;661
                  |L1.674|
0002a2  f7fffffe          BL       vPortExitCritical
0002a6  f7fffffe          BL       vTaskSuspendAll
0002aa  f7fffffe          BL       vPortEnterCritical
0002ae  6c60              LDR      r0,[r4,#0x44]         ;675
0002b0  1c40              ADDS     r0,r0,#1              ;675
0002b2  d100              BNE      |L1.694|
0002b4  6460              STR      r0,[r4,#0x44]         ;675
                  |L1.694|
0002b6  6ca0              LDR      r0,[r4,#0x48]         ;675
0002b8  1c40              ADDS     r0,r0,#1              ;675
0002ba  d100              BNE      |L1.702|
0002bc  64a0              STR      r0,[r4,#0x48]         ;675
                  |L1.702|
0002be  f7fffffe          BL       vPortExitCritical
0002c2  a904              ADD      r1,sp,#0x10           ;678
0002c4  4668              MOV      r0,sp                 ;678
0002c6  f7fffffe          BL       xTaskCheckForTimeOut
0002ca  b9c0              CBNZ     r0,|L1.766|
0002cc  4620              MOV      r0,r4                 ;680
0002ce  f7fffffe          BL       prvIsQueueFull
0002d2  b170              CBZ      r0,|L1.754|
0002d4  f1040010          ADD      r0,r4,#0x10           ;683
0002d8  9904              LDR      r1,[sp,#0x10]         ;683
0002da  f7fffffe          BL       vTaskPlaceOnEventList
0002de  4620              MOV      r0,r4                 ;690
0002e0  f7fffffe          BL       prvUnlockQueue
0002e4  f7fffffe          BL       xTaskResumeAll
0002e8  2800              CMP      r0,#0                 ;697
0002ea  d1a0              BNE      |L1.558|
0002ec  f7fffffe          BL       vPortYield
0002f0  e79d              B        |L1.558|
                  |L1.754|
0002f2  4620              MOV      r0,r4                 ;705
0002f4  f7fffffe          BL       prvUnlockQueue
0002f8  f7fffffe          BL       xTaskResumeAll
0002fc  e797              B        |L1.558|
                  |L1.766|
0002fe  4620              MOV      r0,r4                 ;712
000300  f7fffffe          BL       prvUnlockQueue
000304  f7fffffe          BL       xTaskResumeAll
000308  2000              MOVS     r0,#0                 ;718
00030a  e7b9              B        |L1.640|
;;;722    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueCreateMutex PROC
;;;350    
;;;351    	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
00030c  b570              PUSH     {r4-r6,lr}
;;;352    	{
00030e  4605              MOV      r5,r0
;;;353    	xQUEUE *pxNewQueue;
;;;354    
;;;355    		/* Prevent compiler warnings about unused parameters if
;;;356    		configUSE_TRACE_FACILITY does not equal 1. */
;;;357    		( void ) ucQueueType;
;;;358    
;;;359    		/* Allocate the new queue structure. */
;;;360    		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
000310  2050              MOVS     r0,#0x50
000312  f7fffffe          BL       pvPortMalloc
000316  4604              MOV      r4,r0
;;;361    		if( pxNewQueue != NULL )
000318  b1e4              CBZ      r4,|L1.852|
;;;362    		{
;;;363    			/* Information required for priority inheritance. */
;;;364    			pxNewQueue->pxMutexHolder = NULL;
00031a  2000              MOVS     r0,#0
00031c  6060              STR      r0,[r4,#4]
;;;365    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00031e  6020              STR      r0,[r4,#0]
;;;366    
;;;367    			/* Queues used as a mutex no data is actually copied into or out
;;;368    			of the queue. */
;;;369    			pxNewQueue->pcWriteTo = NULL;
000320  60a0              STR      r0,[r4,#8]
;;;370    			pxNewQueue->u.pcReadFrom = NULL;
000322  60e0              STR      r0,[r4,#0xc]
;;;371    
;;;372    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;373    			an item size of 0 as nothing is actually copied into or out
;;;374    			of the mutex. */
;;;375    			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000324  63a0              STR      r0,[r4,#0x38]
;;;376    			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
000326  2001              MOVS     r0,#1
000328  63e0              STR      r0,[r4,#0x3c]
;;;377    			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
00032a  2000              MOVS     r0,#0
00032c  6420              STR      r0,[r4,#0x40]
;;;378    			pxNewQueue->xRxLock = queueUNLOCKED;
00032e  1e40              SUBS     r0,r0,#1
000330  6460              STR      r0,[r4,#0x44]
;;;379    			pxNewQueue->xTxLock = queueUNLOCKED;
000332  64a0              STR      r0,[r4,#0x48]
;;;380    
;;;381    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;382    			{
;;;383    				pxNewQueue->ucQueueType = ucQueueType;
;;;384    			}
;;;385    			#endif
;;;386    
;;;387    			#if ( configUSE_QUEUE_SETS == 1 )
;;;388    			{
;;;389    				pxNewQueue->pxQueueSetContainer = NULL;
000334  2000              MOVS     r0,#0
000336  64e0              STR      r0,[r4,#0x4c]
;;;390    			}
;;;391    			#endif
;;;392    
;;;393    			/* Ensure the event queues start with the correct state. */
;;;394    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
000338  f1040010          ADD      r0,r4,#0x10
00033c  f7fffffe          BL       vListInitialise
;;;395    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000340  f1040024          ADD      r0,r4,#0x24
000344  f7fffffe          BL       vListInitialise
;;;396    
;;;397    			traceCREATE_MUTEX( pxNewQueue );
;;;398    
;;;399    			/* Start with the semaphore in the expected state. */
;;;400    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
000348  2300              MOVS     r3,#0
00034a  461a              MOV      r2,r3
00034c  4619              MOV      r1,r3
00034e  4620              MOV      r0,r4
000350  f7fffffe          BL       xQueueGenericSend
                  |L1.852|
;;;401    		}
;;;402    		else
;;;403    		{
;;;404    			traceCREATE_MUTEX_FAILED();
;;;405    		}
;;;406    
;;;407    		configASSERT( pxNewQueue );
;;;408    		return pxNewQueue;
000354  4620              MOV      r0,r4
;;;409    	}
000356  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  xQueueGetMutexHolder PROC
;;;415    
;;;416    	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
000358  b570              PUSH     {r4-r6,lr}
;;;417    	{
00035a  4605              MOV      r5,r0
;;;418    	void *pxReturn;
;;;419    
;;;420    		/* This function is called by xSemaphoreGetMutexHolder(), and should not
;;;421    		be called directly.  Note:  This is is a good way of determining if the
;;;422    		calling task is the mutex holder, but not a good way of determining the
;;;423    		identity of the mutex holder, as the holder may change between the
;;;424    		following critical section exiting and the function returning. */
;;;425    		taskENTER_CRITICAL();
00035c  f7fffffe          BL       vPortEnterCritical
;;;426    		{
;;;427    			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
000360  6828              LDR      r0,[r5,#0]
000362  b908              CBNZ     r0,|L1.872|
;;;428    			{
;;;429    				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
000364  686c              LDR      r4,[r5,#4]
000366  e000              B        |L1.874|
                  |L1.872|
;;;430    			}
;;;431    			else
;;;432    			{
;;;433    				pxReturn = NULL;
000368  2400              MOVS     r4,#0
                  |L1.874|
;;;434    			}
;;;435    		}
;;;436    		taskEXIT_CRITICAL();
00036a  f7fffffe          BL       vPortExitCritical
;;;437    
;;;438    		return pxReturn;
00036e  4620              MOV      r0,r4
;;;439    	}
000370  bd70              POP      {r4-r6,pc}
;;;440    
                          ENDP

                  xQueueGiveMutexRecursive PROC
;;;445    
;;;446    	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
000372  b570              PUSH     {r4-r6,lr}
;;;447    	{
000374  4606              MOV      r6,r0
;;;448    	portBASE_TYPE xReturn;
;;;449    	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
000376  4634              MOV      r4,r6
;;;450    
;;;451    		configASSERT( pxMutex );
;;;452    
;;;453    		/* If this is the task that holds the mutex then pxMutexHolder will not
;;;454    		change outside of this task.  If this task does not hold the mutex then
;;;455    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;456    		this is the only condition we are interested in it does not matter if
;;;457    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;458    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;459    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as xTaskHandle is a typedef. */
000378  f7fffffe          BL       xTaskGetCurrentTaskHandle
00037c  6861              LDR      r1,[r4,#4]
00037e  4288              CMP      r0,r1
000380  d10c              BNE      |L1.924|
;;;460    		{
;;;461    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;462    
;;;463    			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
;;;464    			the task handle, therefore no underflow check is required.  Also,
;;;465    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;466    			there can only be one, no mutual exclusion is required to modify the
;;;467    			uxRecursiveCallCount member. */
;;;468    			( pxMutex->u.uxRecursiveCallCount )--;
000382  68e0              LDR      r0,[r4,#0xc]
000384  1e40              SUBS     r0,r0,#1
000386  60e0              STR      r0,[r4,#0xc]
;;;469    
;;;470    			/* Have we unwound the call count? */
;;;471    			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
000388  68e0              LDR      r0,[r4,#0xc]
00038a  b928              CBNZ     r0,|L1.920|
;;;472    			{
;;;473    				/* Return the mutex.  This will automatically unblock any other
;;;474    				task that might be waiting to access the mutex. */
;;;475    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
00038c  2300              MOVS     r3,#0
00038e  461a              MOV      r2,r3
000390  4619              MOV      r1,r3
000392  4620              MOV      r0,r4
000394  f7fffffe          BL       xQueueGenericSend
                  |L1.920|
;;;476    			}
;;;477    
;;;478    			xReturn = pdPASS;
000398  2501              MOVS     r5,#1
00039a  e000              B        |L1.926|
                  |L1.924|
;;;479    		}
;;;480    		else
;;;481    		{
;;;482    			/* We cannot give the mutex because we are not the holder. */
;;;483    			xReturn = pdFAIL;
00039c  2500              MOVS     r5,#0
                  |L1.926|
;;;484    
;;;485    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;486    		}
;;;487    
;;;488    		return xReturn;
00039e  4628              MOV      r0,r5
;;;489    	}
0003a0  bd70              POP      {r4-r6,pc}
;;;490    
                          ENDP

                  prvIsQueueEmpty PROC
;;;1580   
;;;1581   static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
0003a2  b570              PUSH     {r4-r6,lr}
;;;1582   {
0003a4  4605              MOV      r5,r0
;;;1583   signed portBASE_TYPE xReturn;
;;;1584   
;;;1585   	taskENTER_CRITICAL();
0003a6  f7fffffe          BL       vPortEnterCritical
;;;1586   	{
;;;1587   		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
0003aa  6ba8              LDR      r0,[r5,#0x38]
0003ac  b908              CBNZ     r0,|L1.946|
;;;1588   		{
;;;1589   			xReturn = pdTRUE;
0003ae  2401              MOVS     r4,#1
0003b0  e000              B        |L1.948|
                  |L1.946|
;;;1590   		}
;;;1591   		else
;;;1592   		{
;;;1593   			xReturn = pdFALSE;
0003b2  2400              MOVS     r4,#0
                  |L1.948|
;;;1594   		}
;;;1595   	}
;;;1596   	taskEXIT_CRITICAL();
0003b4  f7fffffe          BL       vPortExitCritical
;;;1597   
;;;1598   	return xReturn;
0003b8  4620              MOV      r0,r4
;;;1599   }
0003ba  bd70              POP      {r4-r6,pc}
;;;1600   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataFromQueue PROC
;;;1467   
;;;1468   static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
0003bc  b570              PUSH     {r4-r6,lr}
;;;1469   {
0003be  4604              MOV      r4,r0
0003c0  460d              MOV      r5,r1
;;;1470   	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
0003c2  6820              LDR      r0,[r4,#0]
0003c4  b170              CBZ      r0,|L1.996|
;;;1471   	{
;;;1472   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
0003c6  6c21              LDR      r1,[r4,#0x40]
0003c8  68e0              LDR      r0,[r4,#0xc]
0003ca  4408              ADD      r0,r0,r1
0003cc  60e0              STR      r0,[r4,#0xc]
;;;1473   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
0003ce  6861              LDR      r1,[r4,#4]
0003d0  68e0              LDR      r0,[r4,#0xc]
0003d2  4288              CMP      r0,r1
0003d4  d301              BCC      |L1.986|
;;;1474   		{
;;;1475   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
0003d6  6820              LDR      r0,[r4,#0]
0003d8  60e0              STR      r0,[r4,#0xc]
                  |L1.986|
;;;1476   		}
;;;1477   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
0003da  4628              MOV      r0,r5
0003dc  6c22              LDR      r2,[r4,#0x40]
0003de  68e1              LDR      r1,[r4,#0xc]
0003e0  f7fffffe          BL       __aeabi_memcpy
                  |L1.996|
;;;1478   	}
;;;1479   }
0003e4  bd70              POP      {r4-r6,pc}
;;;1480   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1045   
;;;1046   signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
0003e6  e92d43ff          PUSH     {r0-r9,lr}
;;;1047   {
0003ea  b083              SUB      sp,sp,#0xc
0003ec  4605              MOV      r5,r0
0003ee  4688              MOV      r8,r1
0003f0  461e              MOV      r6,r3
;;;1048   signed portBASE_TYPE xEntryTimeSet = pdFALSE;
0003f2  f04f0900          MOV      r9,#0
;;;1049   xTimeOutType xTimeOut;
;;;1050   signed char *pcOriginalReadPosition;
;;;1051   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0003f6  462c              MOV      r4,r5
;;;1052   
;;;1053   	configASSERT( pxQueue );
;;;1054   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1055   
;;;1056   	/* This function relaxes the coding standard somewhat to allow return
;;;1057   	statements within the function itself.  This is done in the interest
;;;1058   	of execution time efficiency. */
;;;1059   
;;;1060   	for( ;; )
0003f8  bf00              NOP      
                  |L1.1018|
;;;1061   	{
;;;1062   		taskENTER_CRITICAL();
0003fa  f7fffffe          BL       vPortEnterCritical
;;;1063   		{
;;;1064   			/* Is there data in the queue now?  To be running we must be
;;;1065   			the highest priority task wanting to access the queue. */
;;;1066   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0003fe  6ba0              LDR      r0,[r4,#0x38]
000400  b380              CBZ      r0,|L1.1124|
;;;1067   			{
;;;1068   				/* Remember the read position in case the queue is only being
;;;1069   				peeked. */
;;;1070   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000402  68e7              LDR      r7,[r4,#0xc]
;;;1071   
;;;1072   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000404  4641              MOV      r1,r8
000406  4620              MOV      r0,r4
000408  f7fffffe          BL       prvCopyDataFromQueue
;;;1073   
;;;1074   				if( xJustPeeking == pdFALSE )
00040c  b9b6              CBNZ     r6,|L1.1084|
;;;1075   				{
;;;1076   					traceQUEUE_RECEIVE( pxQueue );
;;;1077   
;;;1078   					/* Actually removing data, not just peeking. */
;;;1079   					--( pxQueue->uxMessagesWaiting );
00040e  6ba0              LDR      r0,[r4,#0x38]
000410  1e40              SUBS     r0,r0,#1
000412  63a0              STR      r0,[r4,#0x38]
;;;1080   
;;;1081   					#if ( configUSE_MUTEXES == 1 )
;;;1082   					{
;;;1083   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000414  6820              LDR      r0,[r4,#0]
000416  b910              CBNZ     r0,|L1.1054|
;;;1084   						{
;;;1085   							/* Record the information required to implement
;;;1086   							priority inheritance should it become necessary. */
;;;1087   							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
000418  f7fffffe          BL       xTaskGetCurrentTaskHandle
00041c  6060              STR      r0,[r4,#4]
                  |L1.1054|
;;;1088   						}
;;;1089   					}
;;;1090   					#endif
;;;1091   
;;;1092   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00041e  6920              LDR      r0,[r4,#0x10]
000420  b908              CBNZ     r0,|L1.1062|
000422  2001              MOVS     r0,#1
000424  e000              B        |L1.1064|
                  |L1.1062|
000426  2000              MOVS     r0,#0
                  |L1.1064|
000428  b9b0              CBNZ     r0,|L1.1112|
;;;1093   					{
;;;1094   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
00042a  f1040010          ADD      r0,r4,#0x10
00042e  f7fffffe          BL       xTaskRemoveFromEventList
000432  2801              CMP      r0,#1
000434  d110              BNE      |L1.1112|
;;;1095   						{
;;;1096   							queueYIELD_IF_USING_PREEMPTION();
000436  f7fffffe          BL       vPortYield
00043a  e00d              B        |L1.1112|
                  |L1.1084|
;;;1097   						}
;;;1098   					}
;;;1099   				}
;;;1100   				else
;;;1101   				{
;;;1102   					traceQUEUE_PEEK( pxQueue );
;;;1103   
;;;1104   					/* The data is not being removed, so reset the read
;;;1105   					pointer. */
;;;1106   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00043c  60e7              STR      r7,[r4,#0xc]
;;;1107   
;;;1108   					/* The data is being left in the queue, so see if there are
;;;1109   					any other tasks waiting for the data. */
;;;1110   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00043e  6a60              LDR      r0,[r4,#0x24]
000440  b908              CBNZ     r0,|L1.1094|
000442  2001              MOVS     r0,#1
000444  e000              B        |L1.1096|
                  |L1.1094|
000446  2000              MOVS     r0,#0
                  |L1.1096|
000448  b930              CBNZ     r0,|L1.1112|
;;;1111   					{
;;;1112   						/* Tasks that are removed from the event list will get added to
;;;1113   						the pending ready list as the scheduler is still suspended. */
;;;1114   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00044a  f1040024          ADD      r0,r4,#0x24
00044e  f7fffffe          BL       xTaskRemoveFromEventList
000452  b108              CBZ      r0,|L1.1112|
;;;1115   						{
;;;1116   							/* The task waiting has a higher priority than this task. */
;;;1117   							queueYIELD_IF_USING_PREEMPTION();
000454  f7fffffe          BL       vPortYield
                  |L1.1112|
;;;1118   						}
;;;1119   					}
;;;1120   				}
;;;1121   
;;;1122   				taskEXIT_CRITICAL();
000458  f7fffffe          BL       vPortExitCritical
;;;1123   				return pdPASS;
00045c  2001              MOVS     r0,#1
                  |L1.1118|
;;;1124   			}
;;;1125   			else
;;;1126   			{
;;;1127   				if( xTicksToWait == ( portTickType ) 0 )
;;;1128   				{
;;;1129   					/* The queue was empty and no block time is specified (or
;;;1130   					the block time has expired) so leave now. */
;;;1131   					taskEXIT_CRITICAL();
;;;1132   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1133   					return errQUEUE_EMPTY;
;;;1134   				}
;;;1135   				else if( xEntryTimeSet == pdFALSE )
;;;1136   				{
;;;1137   					/* The queue was empty and a block time was specified so
;;;1138   					configure the timeout structure. */
;;;1139   					vTaskSetTimeOutState( &xTimeOut );
;;;1140   					xEntryTimeSet = pdTRUE;
;;;1141   				}
;;;1142   				else
;;;1143   				{
;;;1144   					/* Entry time was already set. */
;;;1145   				}
;;;1146   			}
;;;1147   		}
;;;1148   		taskEXIT_CRITICAL();
;;;1149   
;;;1150   		/* Interrupts and other tasks can send to and receive from the queue
;;;1151   		now the critical section has been exited. */
;;;1152   
;;;1153   		vTaskSuspendAll();
;;;1154   		prvLockQueue( pxQueue );
;;;1155   
;;;1156   		/* Update the timeout state to see if it has expired yet. */
;;;1157   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1158   		{
;;;1159   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1160   			{
;;;1161   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1162   
;;;1163   				#if ( configUSE_MUTEXES == 1 )
;;;1164   				{
;;;1165   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1166   					{
;;;1167   						portENTER_CRITICAL();
;;;1168   						{
;;;1169   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1170   						}
;;;1171   						portEXIT_CRITICAL();
;;;1172   					}
;;;1173   				}
;;;1174   				#endif
;;;1175   
;;;1176   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1177   				prvUnlockQueue( pxQueue );
;;;1178   				if( xTaskResumeAll() == pdFALSE )
;;;1179   				{
;;;1180   					portYIELD_WITHIN_API();
;;;1181   				}
;;;1182   			}
;;;1183   			else
;;;1184   			{
;;;1185   				/* Try again. */
;;;1186   				prvUnlockQueue( pxQueue );
;;;1187   				( void ) xTaskResumeAll();
;;;1188   			}
;;;1189   		}
;;;1190   		else
;;;1191   		{
;;;1192   			prvUnlockQueue( pxQueue );
;;;1193   			( void ) xTaskResumeAll();
;;;1194   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1195   			return errQUEUE_EMPTY;
;;;1196   		}
;;;1197   	}
;;;1198   }
00045e  b007              ADD      sp,sp,#0x1c
000460  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1124|
000464  e7ff              B        |L1.1126|
                  |L1.1126|
000466  9805              LDR      r0,[sp,#0x14]         ;1127
000468  b918              CBNZ     r0,|L1.1138|
00046a  f7fffffe          BL       vPortExitCritical
00046e  2000              MOVS     r0,#0                 ;1133
000470  e7f5              B        |L1.1118|
                  |L1.1138|
000472  f1b90f00          CMP      r9,#0                 ;1135
000476  d104              BNE      |L1.1154|
000478  a801              ADD      r0,sp,#4              ;1139
00047a  f7fffffe          BL       vTaskSetTimeOutState
00047e  f04f0901          MOV      r9,#1                 ;1140
                  |L1.1154|
000482  f7fffffe          BL       vPortExitCritical
000486  f7fffffe          BL       vTaskSuspendAll
00048a  f7fffffe          BL       vPortEnterCritical
00048e  6c60              LDR      r0,[r4,#0x44]         ;1154
000490  1c40              ADDS     r0,r0,#1              ;1154
000492  d100              BNE      |L1.1174|
000494  6460              STR      r0,[r4,#0x44]         ;1154
                  |L1.1174|
000496  6ca0              LDR      r0,[r4,#0x48]         ;1154
000498  1c40              ADDS     r0,r0,#1              ;1154
00049a  d100              BNE      |L1.1182|
00049c  64a0              STR      r0,[r4,#0x48]         ;1154
                  |L1.1182|
00049e  f7fffffe          BL       vPortExitCritical
0004a2  a905              ADD      r1,sp,#0x14           ;1157
0004a4  a801              ADD      r0,sp,#4              ;1157
0004a6  f7fffffe          BL       xTaskCheckForTimeOut
0004aa  bb08              CBNZ     r0,|L1.1264|
0004ac  4620              MOV      r0,r4                 ;1159
0004ae  f7fffffe          BL       prvIsQueueEmpty
0004b2  b1b8              CBZ      r0,|L1.1252|
0004b4  6820              LDR      r0,[r4,#0]            ;1165
0004b6  b930              CBNZ     r0,|L1.1222|
0004b8  f7fffffe          BL       vPortEnterCritical
0004bc  6860              LDR      r0,[r4,#4]            ;1169
0004be  f7fffffe          BL       vTaskPriorityInherit
0004c2  f7fffffe          BL       vPortExitCritical
                  |L1.1222|
0004c6  f1040024          ADD      r0,r4,#0x24           ;1176
0004ca  9905              LDR      r1,[sp,#0x14]         ;1176
0004cc  f7fffffe          BL       vTaskPlaceOnEventList
0004d0  4620              MOV      r0,r4                 ;1177
0004d2  f7fffffe          BL       prvUnlockQueue
0004d6  f7fffffe          BL       xTaskResumeAll
0004da  2800              CMP      r0,#0                 ;1178
0004dc  d18d              BNE      |L1.1018|
0004de  f7fffffe          BL       vPortYield
0004e2  e78a              B        |L1.1018|
                  |L1.1252|
0004e4  4620              MOV      r0,r4                 ;1186
0004e6  f7fffffe          BL       prvUnlockQueue
0004ea  f7fffffe          BL       xTaskResumeAll
0004ee  e784              B        |L1.1018|
                  |L1.1264|
0004f0  4620              MOV      r0,r4                 ;1192
0004f2  f7fffffe          BL       prvUnlockQueue
0004f6  f7fffffe          BL       xTaskResumeAll
0004fa  2000              MOVS     r0,#0                 ;1195
0004fc  e7af              B        |L1.1118|
;;;1199   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueTakeMutexRecursive PROC
;;;495    
;;;496    	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
0004fe  e92d41f0          PUSH     {r4-r8,lr}
;;;497    	{
000502  4606              MOV      r6,r0
000504  460f              MOV      r7,r1
;;;498    	portBASE_TYPE xReturn;
;;;499    	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
000506  4634              MOV      r4,r6
;;;500    
;;;501    		configASSERT( pxMutex );
;;;502    
;;;503    		/* Comments regarding mutual exclusion as per those within
;;;504    		xQueueGiveMutexRecursive(). */
;;;505    
;;;506    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;507    
;;;508    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
000508  f7fffffe          BL       xTaskGetCurrentTaskHandle
00050c  6861              LDR      r1,[r4,#4]
00050e  4288              CMP      r0,r1
000510  d104              BNE      |L1.1308|
;;;509    		{
;;;510    			( pxMutex->u.uxRecursiveCallCount )++;
000512  68e0              LDR      r0,[r4,#0xc]
000514  1c40              ADDS     r0,r0,#1
000516  60e0              STR      r0,[r4,#0xc]
;;;511    			xReturn = pdPASS;
000518  2501              MOVS     r5,#1
00051a  e00b              B        |L1.1332|
                  |L1.1308|
;;;512    		}
;;;513    		else
;;;514    		{
;;;515    			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
00051c  2300              MOVS     r3,#0
00051e  463a              MOV      r2,r7
000520  4619              MOV      r1,r3
000522  4620              MOV      r0,r4
000524  f7fffffe          BL       xQueueGenericReceive
000528  4605              MOV      r5,r0
;;;516    
;;;517    			/* pdPASS will only be returned if we successfully obtained the mutex,
;;;518    			we may have blocked to reach here. */
;;;519    			if( xReturn == pdPASS )
00052a  2d01              CMP      r5,#1
00052c  d102              BNE      |L1.1332|
;;;520    			{
;;;521    				( pxMutex->u.uxRecursiveCallCount )++;
00052e  68e0              LDR      r0,[r4,#0xc]
000530  1c40              ADDS     r0,r0,#1
000532  60e0              STR      r0,[r4,#0xc]
                  |L1.1332|
;;;522    			}
;;;523    			else
;;;524    			{
;;;525    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;526    			}
;;;527    		}
;;;528    
;;;529    		return xReturn;
000534  4628              MOV      r0,r5
;;;530    	}
000536  e8bd81f0          POP      {r4-r8,pc}
;;;531    
                          ENDP

                  xQueueCreateCountingSemaphore PROC
;;;536    
;;;537    	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxMaxCount, unsigned portBASE_TYPE uxInitialCount )
00053a  b570              PUSH     {r4-r6,lr}
;;;538    	{
00053c  4606              MOV      r6,r0
00053e  460d              MOV      r5,r1
;;;539    	xQueueHandle xHandle;
;;;540    
;;;541    		configASSERT( uxMaxCount != 0 );
;;;542    		configASSERT( uxInitialCount <= uxMaxCount );
;;;543    
;;;544    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000540  2202              MOVS     r2,#2
000542  2100              MOVS     r1,#0
000544  4630              MOV      r0,r6
000546  f7fffffe          BL       xQueueGenericCreate
00054a  4604              MOV      r4,r0
;;;545    
;;;546    		if( xHandle != NULL )
00054c  b104              CBZ      r4,|L1.1360|
;;;547    		{
;;;548    			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
00054e  63a5              STR      r5,[r4,#0x38]
                  |L1.1360|
;;;549    
;;;550    			traceCREATE_COUNTING_SEMAPHORE();
;;;551    		}
;;;552    		else
;;;553    		{
;;;554    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;555    		}
;;;556    
;;;557    		configASSERT( xHandle );
;;;558    		return xHandle;
000550  4620              MOV      r0,r4
;;;559    	}
000552  bd70              POP      {r4-r6,pc}
;;;560    
                          ENDP

                  xQueueAltGenericSend PROC
;;;725    
;;;726    	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
000554  e92d41ff          PUSH     {r0-r8,lr}
;;;727    	{
000558  b082              SUB      sp,sp,#8
00055a  4605              MOV      r5,r0
00055c  460f              MOV      r7,r1
00055e  461e              MOV      r6,r3
;;;728    	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000560  f04f0800          MOV      r8,#0
;;;729    	xTimeOutType xTimeOut;
;;;730    	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000564  462c              MOV      r4,r5
;;;731    
;;;732    		configASSERT( pxQueue );
;;;733    		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;734    
;;;735    		for( ;; )
000566  bf00              NOP      
                  |L1.1384|
;;;736    		{
;;;737    			taskENTER_CRITICAL();
000568  f7fffffe          BL       vPortEnterCritical
;;;738    			{
;;;739    				/* Is there room on the queue now?  To be running we must be
;;;740    				the highest priority task wanting to access the queue. */
;;;741    				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
00056c  6ba0              LDR      r0,[r4,#0x38]
00056e  6be1              LDR      r1,[r4,#0x3c]
000570  4288              CMP      r0,r1
000572  d218              BCS      |L1.1446|
;;;742    				{
;;;743    					traceQUEUE_SEND( pxQueue );
;;;744    					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000574  4632              MOV      r2,r6
000576  4639              MOV      r1,r7
000578  4620              MOV      r0,r4
00057a  f7fffffe          BL       prvCopyDataToQueue
;;;745    
;;;746    					/* If there was a task waiting for data to arrive on the
;;;747    					queue then unblock it now. */
;;;748    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00057e  6a60              LDR      r0,[r4,#0x24]
000580  b908              CBNZ     r0,|L1.1414|
000582  2001              MOVS     r0,#1
000584  e000              B        |L1.1416|
                  |L1.1414|
000586  2000              MOVS     r0,#0
                  |L1.1416|
000588  b938              CBNZ     r0,|L1.1434|
;;;749    					{
;;;750    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
00058a  f1040024          ADD      r0,r4,#0x24
00058e  f7fffffe          BL       xTaskRemoveFromEventList
000592  2801              CMP      r0,#1
000594  d101              BNE      |L1.1434|
;;;751    						{
;;;752    							/* The unblocked task has a priority higher than
;;;753    							our own so yield immediately. */
;;;754    							portYIELD_WITHIN_API();
000596  f7fffffe          BL       vPortYield
                  |L1.1434|
;;;755    						}
;;;756    					}
;;;757    
;;;758    					taskEXIT_CRITICAL();
00059a  f7fffffe          BL       vPortExitCritical
;;;759    					return pdPASS;
00059e  2001              MOVS     r0,#1
                  |L1.1440|
;;;760    				}
;;;761    				else
;;;762    				{
;;;763    					if( xTicksToWait == ( portTickType ) 0 )
;;;764    					{
;;;765    						taskEXIT_CRITICAL();
;;;766    						return errQUEUE_FULL;
;;;767    					}
;;;768    					else if( xEntryTimeSet == pdFALSE )
;;;769    					{
;;;770    						vTaskSetTimeOutState( &xTimeOut );
;;;771    						xEntryTimeSet = pdTRUE;
;;;772    					}
;;;773    				}
;;;774    			}
;;;775    			taskEXIT_CRITICAL();
;;;776    
;;;777    			taskENTER_CRITICAL();
;;;778    			{
;;;779    				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;780    				{
;;;781    					if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;782    					{
;;;783    						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;784    						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;785    						portYIELD_WITHIN_API();
;;;786    					}
;;;787    				}
;;;788    				else
;;;789    				{
;;;790    					taskEXIT_CRITICAL();
;;;791    					traceQUEUE_SEND_FAILED( pxQueue );
;;;792    					return errQUEUE_FULL;
;;;793    				}
;;;794    			}
;;;795    			taskEXIT_CRITICAL();
;;;796    		}
;;;797    	}
0005a0  b006              ADD      sp,sp,#0x18
0005a2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1446|
0005a6  9804              LDR      r0,[sp,#0x10]         ;763
0005a8  b918              CBNZ     r0,|L1.1458|
0005aa  f7fffffe          BL       vPortExitCritical
0005ae  2000              MOVS     r0,#0                 ;766
0005b0  e7f6              B        |L1.1440|
                  |L1.1458|
0005b2  f1b80f00          CMP      r8,#0                 ;768
0005b6  d104              BNE      |L1.1474|
0005b8  4668              MOV      r0,sp                 ;770
0005ba  f7fffffe          BL       vTaskSetTimeOutState
0005be  f04f0801          MOV      r8,#1                 ;771
                  |L1.1474|
0005c2  f7fffffe          BL       vPortExitCritical
0005c6  f7fffffe          BL       vPortEnterCritical
0005ca  a904              ADD      r1,sp,#0x10           ;779
0005cc  4668              MOV      r0,sp                 ;779
0005ce  f7fffffe          BL       xTaskCheckForTimeOut
0005d2  b958              CBNZ     r0,|L1.1516|
0005d4  4620              MOV      r0,r4                 ;781
0005d6  f7fffffe          BL       prvIsQueueFull
0005da  b158              CBZ      r0,|L1.1524|
0005dc  f1040010          ADD      r0,r4,#0x10           ;784
0005e0  9904              LDR      r1,[sp,#0x10]         ;784
0005e2  f7fffffe          BL       vTaskPlaceOnEventList
0005e6  f7fffffe          BL       vPortYield
0005ea  e003              B        |L1.1524|
                  |L1.1516|
0005ec  f7fffffe          BL       vPortExitCritical
0005f0  2000              MOVS     r0,#0                 ;792
0005f2  e7d5              B        |L1.1440|
                  |L1.1524|
0005f4  f7fffffe          BL       vPortExitCritical
0005f8  e7b6              B        |L1.1384|
;;;798    
                          ENDP

                  xQueueAltGenericReceive PROC
;;;803    
;;;804    	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
0005fa  e92d43ff          PUSH     {r0-r9,lr}
;;;805    	{
0005fe  b083              SUB      sp,sp,#0xc
000600  4605              MOV      r5,r0
000602  4688              MOV      r8,r1
000604  461e              MOV      r6,r3
;;;806    	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000606  f04f0900          MOV      r9,#0
;;;807    	xTimeOutType xTimeOut;
;;;808    	signed char *pcOriginalReadPosition;
;;;809    	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
00060a  462c              MOV      r4,r5
;;;810    
;;;811    		configASSERT( pxQueue );
;;;812    		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;813    
;;;814    		for( ;; )
00060c  bf00              NOP      
                  |L1.1550|
;;;815    		{
;;;816    			taskENTER_CRITICAL();
00060e  f7fffffe          BL       vPortEnterCritical
;;;817    			{
;;;818    				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000612  6ba0              LDR      r0,[r4,#0x38]
000614  b380              CBZ      r0,|L1.1656|
;;;819    				{
;;;820    					/* Remember our read position in case we are just peeking. */
;;;821    					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000616  68e7              LDR      r7,[r4,#0xc]
;;;822    
;;;823    					prvCopyDataFromQueue( pxQueue, pvBuffer );
000618  4641              MOV      r1,r8
00061a  4620              MOV      r0,r4
00061c  f7fffffe          BL       prvCopyDataFromQueue
;;;824    
;;;825    					if( xJustPeeking == pdFALSE )
000620  b9b6              CBNZ     r6,|L1.1616|
;;;826    					{
;;;827    						traceQUEUE_RECEIVE( pxQueue );
;;;828    
;;;829    						/* Data is actually being removed (not just peeked). */
;;;830    						--( pxQueue->uxMessagesWaiting );
000622  6ba0              LDR      r0,[r4,#0x38]
000624  1e40              SUBS     r0,r0,#1
000626  63a0              STR      r0,[r4,#0x38]
;;;831    
;;;832    						#if ( configUSE_MUTEXES == 1 )
;;;833    						{
;;;834    							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000628  6820              LDR      r0,[r4,#0]
00062a  b910              CBNZ     r0,|L1.1586|
;;;835    							{
;;;836    								/* Record the information required to implement
;;;837    								priority inheritance should it become necessary. */
;;;838    								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
00062c  f7fffffe          BL       xTaskGetCurrentTaskHandle
000630  6060              STR      r0,[r4,#4]
                  |L1.1586|
;;;839    							}
;;;840    						}
;;;841    						#endif
;;;842    
;;;843    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000632  6920              LDR      r0,[r4,#0x10]
000634  b908              CBNZ     r0,|L1.1594|
000636  2001              MOVS     r0,#1
000638  e000              B        |L1.1596|
                  |L1.1594|
00063a  2000              MOVS     r0,#0
                  |L1.1596|
00063c  b9b0              CBNZ     r0,|L1.1644|
;;;844    						{
;;;845    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
00063e  f1040010          ADD      r0,r4,#0x10
000642  f7fffffe          BL       xTaskRemoveFromEventList
000646  2801              CMP      r0,#1
000648  d110              BNE      |L1.1644|
;;;846    							{
;;;847    								portYIELD_WITHIN_API();
00064a  f7fffffe          BL       vPortYield
00064e  e00d              B        |L1.1644|
                  |L1.1616|
;;;848    							}
;;;849    						}
;;;850    					}
;;;851    					else
;;;852    					{
;;;853    						traceQUEUE_PEEK( pxQueue );
;;;854    
;;;855    						/* We are not removing the data, so reset our read
;;;856    						pointer. */
;;;857    						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
000650  60e7              STR      r7,[r4,#0xc]
;;;858    
;;;859    						/* The data is being left in the queue, so see if there are
;;;860    						any other tasks waiting for the data. */
;;;861    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000652  6a60              LDR      r0,[r4,#0x24]
000654  b908              CBNZ     r0,|L1.1626|
000656  2001              MOVS     r0,#1
000658  e000              B        |L1.1628|
                  |L1.1626|
00065a  2000              MOVS     r0,#0
                  |L1.1628|
00065c  b930              CBNZ     r0,|L1.1644|
;;;862    						{
;;;863    							/* Tasks that are removed from the event list will get added to
;;;864    							the pending ready list as the scheduler is still suspended. */
;;;865    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00065e  f1040024          ADD      r0,r4,#0x24
000662  f7fffffe          BL       xTaskRemoveFromEventList
000666  b108              CBZ      r0,|L1.1644|
;;;866    							{
;;;867    								/* The task waiting has a higher priority than this task. */
;;;868    								portYIELD_WITHIN_API();
000668  f7fffffe          BL       vPortYield
                  |L1.1644|
;;;869    							}
;;;870    						}
;;;871    
;;;872    					}
;;;873    
;;;874    					taskEXIT_CRITICAL();
00066c  f7fffffe          BL       vPortExitCritical
;;;875    					return pdPASS;
000670  2001              MOVS     r0,#1
                  |L1.1650|
;;;876    				}
;;;877    				else
;;;878    				{
;;;879    					if( xTicksToWait == ( portTickType ) 0 )
;;;880    					{
;;;881    						taskEXIT_CRITICAL();
;;;882    						traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;883    						return errQUEUE_EMPTY;
;;;884    					}
;;;885    					else if( xEntryTimeSet == pdFALSE )
;;;886    					{
;;;887    						vTaskSetTimeOutState( &xTimeOut );
;;;888    						xEntryTimeSet = pdTRUE;
;;;889    					}
;;;890    				}
;;;891    			}
;;;892    			taskEXIT_CRITICAL();
;;;893    
;;;894    			taskENTER_CRITICAL();
;;;895    			{
;;;896    				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;897    				{
;;;898    					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;899    					{
;;;900    						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;901    
;;;902    						#if ( configUSE_MUTEXES == 1 )
;;;903    						{
;;;904    							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;905    							{
;;;906    								portENTER_CRITICAL();
;;;907    								{
;;;908    									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;909    								}
;;;910    								portEXIT_CRITICAL();
;;;911    							}
;;;912    						}
;;;913    						#endif
;;;914    
;;;915    						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;916    						portYIELD_WITHIN_API();
;;;917    					}
;;;918    				}
;;;919    				else
;;;920    				{
;;;921    					taskEXIT_CRITICAL();
;;;922    					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;923    					return errQUEUE_EMPTY;
;;;924    				}
;;;925    			}
;;;926    			taskEXIT_CRITICAL();
;;;927    		}
;;;928    	}
000672  b007              ADD      sp,sp,#0x1c
000674  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1656|
000678  e7ff              B        |L1.1658|
                  |L1.1658|
00067a  9805              LDR      r0,[sp,#0x14]         ;879
00067c  b918              CBNZ     r0,|L1.1670|
00067e  f7fffffe          BL       vPortExitCritical
000682  2000              MOVS     r0,#0                 ;883
000684  e7f5              B        |L1.1650|
                  |L1.1670|
000686  f1b90f00          CMP      r9,#0                 ;885
00068a  d104              BNE      |L1.1686|
00068c  a801              ADD      r0,sp,#4              ;887
00068e  f7fffffe          BL       vTaskSetTimeOutState
000692  f04f0901          MOV      r9,#1                 ;888
                  |L1.1686|
000696  f7fffffe          BL       vPortExitCritical
00069a  f7fffffe          BL       vPortEnterCritical
00069e  a905              ADD      r1,sp,#0x14           ;896
0006a0  a801              ADD      r0,sp,#4              ;896
0006a2  f7fffffe          BL       xTaskCheckForTimeOut
0006a6  b9a0              CBNZ     r0,|L1.1746|
0006a8  4620              MOV      r0,r4                 ;898
0006aa  f7fffffe          BL       prvIsQueueEmpty
0006ae  b1a0              CBZ      r0,|L1.1754|
0006b0  6820              LDR      r0,[r4,#0]            ;904
0006b2  b930              CBNZ     r0,|L1.1730|
0006b4  f7fffffe          BL       vPortEnterCritical
0006b8  6860              LDR      r0,[r4,#4]            ;908
0006ba  f7fffffe          BL       vTaskPriorityInherit
0006be  f7fffffe          BL       vPortExitCritical
                  |L1.1730|
0006c2  f1040024          ADD      r0,r4,#0x24           ;915
0006c6  9905              LDR      r1,[sp,#0x14]         ;915
0006c8  f7fffffe          BL       vTaskPlaceOnEventList
0006cc  f7fffffe          BL       vPortYield
0006d0  e003              B        |L1.1754|
                  |L1.1746|
0006d2  f7fffffe          BL       vPortExitCritical
0006d6  2000              MOVS     r0,#0                 ;923
0006d8  e7cb              B        |L1.1650|
                  |L1.1754|
0006da  f7fffffe          BL       vPortExitCritical
0006de  e796              B        |L1.1550|
;;;929    
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;933    
;;;934    signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
0006e0  e92d47f0          PUSH     {r4-r10,lr}
;;;935    {
0006e4  4606              MOV      r6,r0
0006e6  4689              MOV      r9,r1
0006e8  4615              MOV      r5,r2
0006ea  461f              MOV      r7,r3
;;;936    signed portBASE_TYPE xReturn;
;;;937    unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;938    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0006ec  4634              MOV      r4,r6
;;;939    
;;;940    	configASSERT( pxQueue );
;;;941    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;942    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;943    
;;;944    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;945    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;946    	above the maximum system call priority are keep permanently enabled, even
;;;947    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;948    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;949    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;950    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;951    	assigned a priority above the configured maximum system call priority.
;;;952    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;953    	that have been assigned a priority at or (logically) below the maximum
;;;954    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;955    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;956    	More information (albeit Cortex-M specific) is provided on the following
;;;957    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;958    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;959    
;;;960    	/* Similar to xQueueGenericSend, except we don't block if there is no room
;;;961    	in the queue.  Also we don't directly wake a task that was blocked on a
;;;962    	queue read, instead we return a flag to say whether a context switch is
;;;963    	required or not (i.e. has a task with a higher priority than us been woken
;;;964    	by this	post). */
;;;965    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0006ee  f7fffffe          BL       ulPortSetInterruptMask
0006f2  4682              MOV      r10,r0
;;;966    	{
;;;967    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0006f4  6ba0              LDR      r0,[r4,#0x38]
0006f6  6be1              LDR      r1,[r4,#0x3c]
0006f8  4288              CMP      r0,r1
0006fa  d301              BCC      |L1.1792|
0006fc  2f02              CMP      r7,#2
0006fe  d127              BNE      |L1.1872|
                  |L1.1792|
;;;968    		{
;;;969    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;970    
;;;971    			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000700  463a              MOV      r2,r7
000702  4649              MOV      r1,r9
000704  4620              MOV      r0,r4
000706  f7fffffe          BL       prvCopyDataToQueue
;;;972    
;;;973    			/* If the queue is locked we do not alter the event list.  This will
;;;974    			be done when the queue is unlocked later. */
;;;975    			if( pxQueue->xTxLock == queueUNLOCKED )
00070a  6ca0              LDR      r0,[r4,#0x48]
00070c  1c40              ADDS     r0,r0,#1
00070e  d119              BNE      |L1.1860|
;;;976    			{
;;;977    				#if ( configUSE_QUEUE_SETS == 1 )
;;;978    				{
;;;979    					if( pxQueue->pxQueueSetContainer != NULL )
000710  6ce0              LDR      r0,[r4,#0x4c]
000712  b140              CBZ      r0,|L1.1830|
;;;980    					{
;;;981    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
000714  4639              MOV      r1,r7
000716  4620              MOV      r0,r4
000718  f7fffffe          BL       prvNotifyQueueSetContainer
00071c  2801              CMP      r0,#1
00071e  d114              BNE      |L1.1866|
;;;982    						{
;;;983    							/* The queue is a member of a queue set, and posting
;;;984    							to the queue set caused a higher priority task to
;;;985    							unblock.  A context switch is required. */
;;;986    							if( pxHigherPriorityTaskWoken != NULL )
000720  b19d              CBZ      r5,|L1.1866|
;;;987    							{
;;;988    								*pxHigherPriorityTaskWoken = pdTRUE;
000722  6028              STR      r0,[r5,#0]
000724  e011              B        |L1.1866|
                  |L1.1830|
;;;989    							}
;;;990    						}
;;;991    					}
;;;992    					else
;;;993    					{
;;;994    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000726  6a60              LDR      r0,[r4,#0x24]
000728  b908              CBNZ     r0,|L1.1838|
00072a  2001              MOVS     r0,#1
00072c  e000              B        |L1.1840|
                  |L1.1838|
00072e  2000              MOVS     r0,#0
                  |L1.1840|
000730  b958              CBNZ     r0,|L1.1866|
;;;995    						{
;;;996    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000732  f1040024          ADD      r0,r4,#0x24
000736  f7fffffe          BL       xTaskRemoveFromEventList
00073a  b130              CBZ      r0,|L1.1866|
;;;997    							{
;;;998    								/* The task waiting has a higher priority so record that a
;;;999    								context	switch is required. */
;;;1000   								if( pxHigherPriorityTaskWoken != NULL )
00073c  b12d              CBZ      r5,|L1.1866|
;;;1001   								{
;;;1002   									*pxHigherPriorityTaskWoken = pdTRUE;
00073e  2001              MOVS     r0,#1
000740  6028              STR      r0,[r5,#0]
000742  e002              B        |L1.1866|
                  |L1.1860|
;;;1003   								}
;;;1004   							}
;;;1005   						}
;;;1006   					}
;;;1007   				}
;;;1008   				#else /* configUSE_QUEUE_SETS */
;;;1009   				{
;;;1010   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1011   					{
;;;1012   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1013   						{
;;;1014   							/* The task waiting has a higher priority so record that a
;;;1015   							context	switch is required. */
;;;1016   							if( pxHigherPriorityTaskWoken != NULL )
;;;1017   							{
;;;1018   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1019   							}
;;;1020   						}
;;;1021   					}
;;;1022   				}
;;;1023   				#endif /* configUSE_QUEUE_SETS */
;;;1024   			}
;;;1025   			else
;;;1026   			{
;;;1027   				/* Increment the lock count so the task that unlocks the queue
;;;1028   				knows that data was posted while it was locked. */
;;;1029   				++( pxQueue->xTxLock );
000744  6ca0              LDR      r0,[r4,#0x48]
000746  1c40              ADDS     r0,r0,#1
000748  64a0              STR      r0,[r4,#0x48]
                  |L1.1866|
;;;1030   			}
;;;1031   
;;;1032   			xReturn = pdPASS;
00074a  f04f0801          MOV      r8,#1
00074e  e001              B        |L1.1876|
                  |L1.1872|
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1037   			xReturn = errQUEUE_FULL;
000750  f04f0800          MOV      r8,#0
                  |L1.1876|
;;;1038   		}
;;;1039   	}
;;;1040   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000754  4650              MOV      r0,r10
000756  f7fffffe          BL       vPortClearInterruptMask
;;;1041   
;;;1042   	return xReturn;
00075a  4640              MOV      r0,r8
;;;1043   }
00075c  e8bd87f0          POP      {r4-r10,pc}
;;;1044   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1200   
;;;1201   signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
000760  e92d47f0          PUSH     {r4-r10,lr}
;;;1202   {
000764  4605              MOV      r5,r0
000766  4688              MOV      r8,r1
000768  4616              MOV      r6,r2
;;;1203   signed portBASE_TYPE xReturn;
;;;1204   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1205   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
00076a  462c              MOV      r4,r5
;;;1206   
;;;1207   	configASSERT( pxQueue );
;;;1208   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1209   
;;;1210   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1211   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1212   	above the maximum system call priority are keep permanently enabled, even
;;;1213   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1214   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1215   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1216   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1217   	assigned a priority above the configured maximum system call priority.
;;;1218   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1219   	that have been assigned a priority at or (logically) below the maximum
;;;1220   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1221   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1222   	More information (albeit Cortex-M specific) is provided on the following
;;;1223   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1224   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1225   
;;;1226   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00076c  f7fffffe          BL       ulPortSetInterruptMask
000770  4681              MOV      r9,r0
;;;1227   	{
;;;1228   		/* Cannot block in an ISR, so check there is data available. */
;;;1229   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000772  6ba0              LDR      r0,[r4,#0x38]
000774  b1e8              CBZ      r0,|L1.1970|
;;;1230   		{
;;;1231   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1232   
;;;1233   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000776  4641              MOV      r1,r8
000778  4620              MOV      r0,r4
00077a  f7fffffe          BL       prvCopyDataFromQueue
;;;1234   			--( pxQueue->uxMessagesWaiting );
00077e  6ba0              LDR      r0,[r4,#0x38]
000780  1e40              SUBS     r0,r0,#1
000782  63a0              STR      r0,[r4,#0x38]
;;;1235   
;;;1236   			/* If the queue is locked the event list will not be modified.
;;;1237   			Instead update the lock count so the task that unlocks the queue
;;;1238   			will know that an ISR has removed data while the queue was
;;;1239   			locked. */
;;;1240   			if( pxQueue->xRxLock == queueUNLOCKED )
000784  6c60              LDR      r0,[r4,#0x44]
000786  1c40              ADDS     r0,r0,#1
000788  d10e              BNE      |L1.1960|
;;;1241   			{
;;;1242   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00078a  6920              LDR      r0,[r4,#0x10]
00078c  b908              CBNZ     r0,|L1.1938|
00078e  2001              MOVS     r0,#1
000790  e000              B        |L1.1940|
                  |L1.1938|
000792  2000              MOVS     r0,#0
                  |L1.1940|
000794  b958              CBNZ     r0,|L1.1966|
;;;1243   				{
;;;1244   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000796  f1040010          ADD      r0,r4,#0x10
00079a  f7fffffe          BL       xTaskRemoveFromEventList
00079e  b130              CBZ      r0,|L1.1966|
;;;1245   					{
;;;1246   						/* The task waiting has a higher priority than us so
;;;1247   						force a context switch. */
;;;1248   						if( pxHigherPriorityTaskWoken != NULL )
0007a0  b12e              CBZ      r6,|L1.1966|
;;;1249   						{
;;;1250   							*pxHigherPriorityTaskWoken = pdTRUE;
0007a2  2001              MOVS     r0,#1
0007a4  6030              STR      r0,[r6,#0]
0007a6  e002              B        |L1.1966|
                  |L1.1960|
;;;1251   						}
;;;1252   					}
;;;1253   				}
;;;1254   			}
;;;1255   			else
;;;1256   			{
;;;1257   				/* Increment the lock count so the task that unlocks the queue
;;;1258   				knows that data was removed while it was locked. */
;;;1259   				++( pxQueue->xRxLock );
0007a8  6c60              LDR      r0,[r4,#0x44]
0007aa  1c40              ADDS     r0,r0,#1
0007ac  6460              STR      r0,[r4,#0x44]
                  |L1.1966|
;;;1260   			}
;;;1261   
;;;1262   			xReturn = pdPASS;
0007ae  2701              MOVS     r7,#1
0007b0  e000              B        |L1.1972|
                  |L1.1970|
;;;1263   		}
;;;1264   		else
;;;1265   		{
;;;1266   			xReturn = pdFAIL;
0007b2  2700              MOVS     r7,#0
                  |L1.1972|
;;;1267   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1268   		}
;;;1269   	}
;;;1270   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0007b4  4648              MOV      r0,r9
0007b6  f7fffffe          BL       vPortClearInterruptMask
;;;1271   
;;;1272   	return xReturn;
0007ba  4638              MOV      r0,r7
;;;1273   }
0007bc  e8bd87f0          POP      {r4-r10,pc}
;;;1274   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1275   
;;;1276   signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue,  void * const pvBuffer )
0007c0  e92d47f0          PUSH     {r4-r10,lr}
;;;1277   {
0007c4  4605              MOV      r5,r0
0007c6  4688              MOV      r8,r1
;;;1278   signed portBASE_TYPE xReturn;
;;;1279   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1280   signed char *pcOriginalReadPosition;
;;;1281   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0007c8  462c              MOV      r4,r5
;;;1282   
;;;1283   	configASSERT( pxQueue );
;;;1284   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1285   
;;;1286   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1287   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1288   	above the maximum system call priority are keep permanently enabled, even
;;;1289   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1290   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1291   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1292   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1293   	assigned a priority above the configured maximum system call priority.
;;;1294   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1295   	that have been assigned a priority at or (logically) below the maximum
;;;1296   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1297   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1298   	More information (albeit Cortex-M specific) is provided on the following
;;;1299   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1300   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1301   
;;;1302   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0007ca  f7fffffe          BL       ulPortSetInterruptMask
0007ce  4681              MOV      r9,r0
;;;1303   	{
;;;1304   		/* Cannot block in an ISR, so check there is data available. */
;;;1305   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0007d0  6ba0              LDR      r0,[r4,#0x38]
0007d2  b138              CBZ      r0,|L1.2020|
;;;1306   		{
;;;1307   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1308   
;;;1309   			/* Remember the read position so it can be reset as nothing is
;;;1310   			actually being removed from the queue. */
;;;1311   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0007d4  68e7              LDR      r7,[r4,#0xc]
;;;1312   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0007d6  4641              MOV      r1,r8
0007d8  4620              MOV      r0,r4
0007da  f7fffffe          BL       prvCopyDataFromQueue
;;;1313   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0007de  60e7              STR      r7,[r4,#0xc]
;;;1314   
;;;1315   			xReturn = pdPASS;
0007e0  2601              MOVS     r6,#1
0007e2  e000              B        |L1.2022|
                  |L1.2020|
;;;1316   		}
;;;1317   		else
;;;1318   		{
;;;1319   			xReturn = pdFAIL;
0007e4  2600              MOVS     r6,#0
                  |L1.2022|
;;;1320   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1321   		}
;;;1322   	}
;;;1323   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0007e6  4648              MOV      r0,r9
0007e8  f7fffffe          BL       vPortClearInterruptMask
;;;1324   
;;;1325   	return xReturn;
0007ec  4630              MOV      r0,r6
;;;1326   }
0007ee  e8bd87f0          POP      {r4-r10,pc}
;;;1327   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1328   
;;;1329   unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
0007f2  b570              PUSH     {r4-r6,lr}
;;;1330   {
0007f4  4604              MOV      r4,r0
;;;1331   unsigned portBASE_TYPE uxReturn;
;;;1332   
;;;1333   	configASSERT( xQueue );
;;;1334   
;;;1335   	taskENTER_CRITICAL();
0007f6  f7fffffe          BL       vPortEnterCritical
;;;1336   		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
0007fa  6ba5              LDR      r5,[r4,#0x38]
;;;1337   	taskEXIT_CRITICAL();
0007fc  f7fffffe          BL       vPortExitCritical
;;;1338   
;;;1339   	return uxReturn;
000800  4628              MOV      r0,r5
;;;1340   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000802  bd70              POP      {r4-r6,pc}
;;;1341   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1342   
;;;1343   unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
000804  b570              PUSH     {r4-r6,lr}
;;;1344   {
000806  4604              MOV      r4,r0
;;;1345   unsigned portBASE_TYPE uxReturn;
;;;1346   xQUEUE *pxQueue;
;;;1347   
;;;1348   	pxQueue = ( xQUEUE * ) xQueue;
000808  4625              MOV      r5,r4
;;;1349   	configASSERT( pxQueue );
;;;1350   
;;;1351   	taskENTER_CRITICAL();
00080a  f7fffffe          BL       vPortEnterCritical
;;;1352   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00080e  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000812  1a46              SUBS     r6,r0,r1
;;;1353   	taskEXIT_CRITICAL();
000814  f7fffffe          BL       vPortExitCritical
;;;1354   
;;;1355   	return uxReturn;
000818  4630              MOV      r0,r6
;;;1356   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00081a  bd70              POP      {r4-r6,pc}
;;;1357   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1358   
;;;1359   unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
00081c  4601              MOV      r1,r0
;;;1360   {
;;;1361   unsigned portBASE_TYPE uxReturn;
;;;1362   
;;;1363   	configASSERT( xQueue );
;;;1364   
;;;1365   	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
00081e  6b88              LDR      r0,[r1,#0x38]
;;;1366   
;;;1367   	return uxReturn;
;;;1368   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000820  4770              BX       lr
;;;1369   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueUnregisterQueue PROC
;;;1902   
;;;1903   	void vQueueUnregisterQueue( xQueueHandle xQueue )
000822  4601              MOV      r1,r0
;;;1904   	{
;;;1905   	unsigned portBASE_TYPE ux;
;;;1906   
;;;1907   		/* See if the handle of the queue being unregistered in actually in the
;;;1908   		registry. */
;;;1909   		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
000824  2000              MOVS     r0,#0
000826  e00b              B        |L1.2112|
                  |L1.2088|
;;;1910   		{
;;;1911   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000828  4a46              LDR      r2,|L1.2372|
00082a  eb0202c0          ADD      r2,r2,r0,LSL #3
00082e  6852              LDR      r2,[r2,#4]
000830  428a              CMP      r2,r1
000832  d104              BNE      |L1.2110|
;;;1912   			{
;;;1913   				/* Set the name to NULL to show that this slot if free again. */
;;;1914   				xQueueRegistry[ ux ].pcQueueName = NULL;
000834  2200              MOVS     r2,#0
000836  4b43              LDR      r3,|L1.2372|
000838  f8432030          STR      r2,[r3,r0,LSL #3]
;;;1915   				break;
00083c  e002              B        |L1.2116|
                  |L1.2110|
00083e  1c40              ADDS     r0,r0,#1              ;1909
                  |L1.2112|
000840  280a              CMP      r0,#0xa               ;1909
000842  d3f1              BCC      |L1.2088|
                  |L1.2116|
000844  bf00              NOP      
;;;1916   			}
;;;1917   		}
;;;1918   
;;;1919   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000846  4770              BX       lr
;;;1920   
                          ENDP

                  vQueueDelete PROC
;;;1370   
;;;1371   void vQueueDelete( xQueueHandle xQueue )
000848  b570              PUSH     {r4-r6,lr}
;;;1372   {
00084a  4604              MOV      r4,r0
;;;1373   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
00084c  4625              MOV      r5,r4
;;;1374   
;;;1375   	configASSERT( pxQueue );
;;;1376   
;;;1377   	traceQUEUE_DELETE( pxQueue );
;;;1378   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1379   	{
;;;1380   		vQueueUnregisterQueue( pxQueue );
00084e  4628              MOV      r0,r5
000850  f7fffffe          BL       vQueueUnregisterQueue
;;;1381   	}
;;;1382   	#endif
;;;1383   	vPortFree( pxQueue->pcHead );
000854  6828              LDR      r0,[r5,#0]
000856  f7fffffe          BL       vPortFree
;;;1384   	vPortFree( pxQueue );
00085a  4628              MOV      r0,r5
00085c  f7fffffe          BL       vPortFree
;;;1385   }
000860  bd70              POP      {r4-r6,pc}
;;;1386   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;1601   
;;;1602   signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
000862  4601              MOV      r1,r0
;;;1603   {
;;;1604   signed portBASE_TYPE xReturn;
;;;1605   
;;;1606   	configASSERT( xQueue );
;;;1607   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
000864  6b8a              LDR      r2,[r1,#0x38]
000866  b90a              CBNZ     r2,|L1.2156|
;;;1608   	{
;;;1609   		xReturn = pdTRUE;
000868  2001              MOVS     r0,#1
00086a  e000              B        |L1.2158|
                  |L1.2156|
;;;1610   	}
;;;1611   	else
;;;1612   	{
;;;1613   		xReturn = pdFALSE;
00086c  2000              MOVS     r0,#0
                  |L1.2158|
;;;1614   	}
;;;1615   
;;;1616   	return xReturn;
;;;1617   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00086e  4770              BX       lr
;;;1618   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;1640   
;;;1641   signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
000870  4601              MOV      r1,r0
;;;1642   {
;;;1643   signed portBASE_TYPE xReturn;
;;;1644   
;;;1645   	configASSERT( xQueue );
;;;1646   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
000872  6b8a              LDR      r2,[r1,#0x38]
000874  6bcb              LDR      r3,[r1,#0x3c]
000876  429a              CMP      r2,r3
000878  d101              BNE      |L1.2174|
;;;1647   	{
;;;1648   		xReturn = pdTRUE;
00087a  2001              MOVS     r0,#1
00087c  e000              B        |L1.2176|
                  |L1.2174|
;;;1649   	}
;;;1650   	else
;;;1651   	{
;;;1652   		xReturn = pdFALSE;
00087e  2000              MOVS     r0,#0
                  |L1.2176|
;;;1653   	}
;;;1654   
;;;1655   	return xReturn;
;;;1656   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000880  4770              BX       lr
;;;1657   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueAddToRegistry PROC
;;;1879   
;;;1880   	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
000882  4602              MOV      r2,r0
;;;1881   	{
;;;1882   	unsigned portBASE_TYPE ux;
;;;1883   
;;;1884   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;1885   		a free slot. */
;;;1886   		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
000884  2000              MOVS     r0,#0
000886  e00b              B        |L1.2208|
                  |L1.2184|
;;;1887   		{
;;;1888   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000888  4b2e              LDR      r3,|L1.2372|
00088a  f8533030          LDR      r3,[r3,r0,LSL #3]
00088e  b933              CBNZ     r3,|L1.2206|
;;;1889   			{
;;;1890   				/* Store the information on this queue. */
;;;1891   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
000890  4b2c              LDR      r3,|L1.2372|
000892  f8431030          STR      r1,[r3,r0,LSL #3]
;;;1892   				xQueueRegistry[ ux ].xHandle = xQueue;
000896  eb0303c0          ADD      r3,r3,r0,LSL #3
00089a  605a              STR      r2,[r3,#4]
;;;1893   				break;
00089c  e002              B        |L1.2212|
                  |L1.2206|
00089e  1c40              ADDS     r0,r0,#1              ;1886
                  |L1.2208|
0008a0  280a              CMP      r0,#0xa               ;1886
0008a2  d3f1              BCC      |L1.2184|
                  |L1.2212|
0008a4  bf00              NOP      
;;;1894   			}
;;;1895   		}
;;;1896   	}
0008a6  4770              BX       lr
;;;1897   
                          ENDP

                  xQueueCreateSet PROC
;;;1957   
;;;1958   	xQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength )
0008a8  b570              PUSH     {r4-r6,lr}
;;;1959   	{
0008aa  4604              MOV      r4,r0
;;;1960   	xQueueSetHandle pxQueue;
;;;1961   
;;;1962   		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( xQUEUE * ), queueQUEUE_TYPE_SET );
0008ac  2200              MOVS     r2,#0
0008ae  2104              MOVS     r1,#4
0008b0  4620              MOV      r0,r4
0008b2  f7fffffe          BL       xQueueGenericCreate
0008b6  4605              MOV      r5,r0
;;;1963   
;;;1964   		return pxQueue;
0008b8  4628              MOV      r0,r5
;;;1965   	}
0008ba  bd70              POP      {r4-r6,pc}
;;;1966   
                          ENDP

                  xQueueAddToSet PROC
;;;1971   
;;;1972   	portBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
0008bc  b570              PUSH     {r4-r6,lr}
;;;1973   	{
0008be  4604              MOV      r4,r0
0008c0  460e              MOV      r6,r1
;;;1974   	portBASE_TYPE xReturn;
;;;1975   
;;;1976   		if( ( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
0008c2  6ce0              LDR      r0,[r4,#0x4c]
0008c4  b108              CBZ      r0,|L1.2250|
;;;1977   		{
;;;1978   			/* Cannot add a queue/semaphore to more than one queue set. */
;;;1979   			xReturn = pdFAIL;
0008c6  2500              MOVS     r5,#0
0008c8  e009              B        |L1.2270|
                  |L1.2250|
;;;1980   		}
;;;1981   		else if( ( ( xQUEUE * ) xQueueOrSemaphore )->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
0008ca  6ba0              LDR      r0,[r4,#0x38]
0008cc  b108              CBZ      r0,|L1.2258|
;;;1982   		{
;;;1983   			/* Cannot add a queue/semaphore to a queue set if there are already
;;;1984   			items in the queue/semaphore. */
;;;1985   			xReturn = pdFAIL;
0008ce  2500              MOVS     r5,#0
0008d0  e005              B        |L1.2270|
                  |L1.2258|
;;;1986   		}
;;;1987   		else
;;;1988   		{
;;;1989   			taskENTER_CRITICAL();
0008d2  f7fffffe          BL       vPortEnterCritical
;;;1990   			{
;;;1991   				( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
0008d6  64e6              STR      r6,[r4,#0x4c]
;;;1992   			}
;;;1993   			taskEXIT_CRITICAL();
0008d8  f7fffffe          BL       vPortExitCritical
;;;1994   			xReturn = pdPASS;
0008dc  2501              MOVS     r5,#1
                  |L1.2270|
;;;1995   		}
;;;1996   
;;;1997   		return xReturn;
0008de  4628              MOV      r0,r5
;;;1998   	}
0008e0  bd70              POP      {r4-r6,pc}
;;;1999   
                          ENDP

                  xQueueRemoveFromSet PROC
;;;2004   
;;;2005   	portBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
0008e2  e92d41f0          PUSH     {r4-r8,lr}
;;;2006   	{
0008e6  4605              MOV      r5,r0
0008e8  460f              MOV      r7,r1
;;;2007   	portBASE_TYPE xReturn;
;;;2008   	xQUEUE * const pxQueueOrSemaphore = ( xQUEUE * ) xQueueOrSemaphore;
0008ea  462e              MOV      r6,r5
;;;2009   
;;;2010   		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
0008ec  6cf0              LDR      r0,[r6,#0x4c]
0008ee  42b8              CMP      r0,r7
0008f0  d001              BEQ      |L1.2294|
;;;2011   		{
;;;2012   			/* The queue was not a member of the set. */
;;;2013   			xReturn = pdFAIL;
0008f2  2400              MOVS     r4,#0
0008f4  e00a              B        |L1.2316|
                  |L1.2294|
;;;2014   		}
;;;2015   		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( unsigned portBASE_TYPE ) 0 )
0008f6  6bb0              LDR      r0,[r6,#0x38]
0008f8  b108              CBZ      r0,|L1.2302|
;;;2016   		{
;;;2017   			/* It is dangerous to remove a queue from a set when the queue is
;;;2018   			not empty because the queue set will still hold pending events for
;;;2019   			the queue. */
;;;2020   			xReturn = pdFAIL;
0008fa  2400              MOVS     r4,#0
0008fc  e006              B        |L1.2316|
                  |L1.2302|
;;;2021   		}
;;;2022   		else
;;;2023   		{
;;;2024   			taskENTER_CRITICAL();
0008fe  f7fffffe          BL       vPortEnterCritical
;;;2025   			{
;;;2026   				/* The queue is no longer contained in the set. */
;;;2027   				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
000902  2000              MOVS     r0,#0
000904  64f0              STR      r0,[r6,#0x4c]
;;;2028   			}
;;;2029   			taskEXIT_CRITICAL();
000906  f7fffffe          BL       vPortExitCritical
;;;2030   			xReturn = pdPASS;
00090a  2401              MOVS     r4,#1
                  |L1.2316|
;;;2031   		}
;;;2032   
;;;2033   		return xReturn;
00090c  4620              MOV      r0,r4
;;;2034   	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
00090e  e8bd81f0          POP      {r4-r8,pc}
;;;2035   
                          ENDP

                  xQueueSelectFromSet PROC
;;;2040   
;;;2041   	xQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks )
000912  b538              PUSH     {r3-r5,lr}
;;;2042   	{
000914  4605              MOV      r5,r0
000916  460c              MOV      r4,r1
;;;2043   	xQueueSetMemberHandle xReturn = NULL;
000918  2000              MOVS     r0,#0
00091a  9000              STR      r0,[sp,#0]
;;;2044   
;;;2045   		( void ) xQueueGenericReceive( ( xQueueHandle ) xQueueSet, &xReturn, xBlockTimeTicks, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
00091c  2300              MOVS     r3,#0
00091e  4622              MOV      r2,r4
000920  4669              MOV      r1,sp
000922  4628              MOV      r0,r5
000924  f7fffffe          BL       xQueueGenericReceive
;;;2046   		return xReturn;
000928  9800              LDR      r0,[sp,#0]
;;;2047   	}
00092a  bd38              POP      {r3-r5,pc}
;;;2048   
                          ENDP

                  xQueueSelectFromSetFromISR PROC
;;;2053   
;;;2054   	xQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet )
00092c  b538              PUSH     {r3-r5,lr}
;;;2055   	{
00092e  4604              MOV      r4,r0
;;;2056   	xQueueSetMemberHandle xReturn = NULL;
000930  2000              MOVS     r0,#0
000932  9000              STR      r0,[sp,#0]
;;;2057   
;;;2058   		( void ) xQueueReceiveFromISR( ( xQueueHandle ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
000934  2200              MOVS     r2,#0
000936  4669              MOV      r1,sp
000938  4620              MOV      r0,r4
00093a  f7fffffe          BL       xQueueReceiveFromISR
;;;2059   		return xReturn;
00093e  9800              LDR      r0,[sp,#0]
;;;2060   	}
000940  bd38              POP      {r3-r5,pc}
;;;2061   
                          ENDP

000942  0000              DCW      0x0000
                  |L1.2372|
                          DCD      xQueueRegistry

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        80
