; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\port.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\port.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\Driver -I.\web -I.\third_party\lwip-1.4.1\src\include -I.\third_party\fatfs -I.\third_party\lwip-1.4.1\apps\httpserver_raw -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch -I.\third_party\lwip-1.4.1\src\include\ipv4 -I..\MCU -I.\third_party\lwip-1.4.1\apps -I.\third_party -I.\Upnp -I.\Dsp -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C129XNCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DUSE_LWIP -DTM4C129ENCPDT --omf_browse=.\build\port.crf FreeRTOS\portable\port.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;243    
;;;244    static void prvTaskExitError( void )
000000  f7fffffe          BL       ulPortSetInterruptMask
;;;245    {
;;;246    	/* A function that implements a task must not exit or attempt to return to
;;;247    	its caller as there is nothing to return to.  If a task wants to exit it
;;;248    	should instead call vTaskDelete( NULL ).
;;;249    
;;;250    	Artificially force an assert() to be triggered if configASSERT() is
;;;251    	defined, then stop here so application writers can catch the error. */
;;;252    	configASSERT( uxCriticalNesting == ~0UL );
;;;253    	portDISABLE_INTERRUPTS();
;;;254    	for( ;; );
000004  bf00              NOP      
                  |L1.6|
000006  e7fe              B        |L1.6|
;;;255    }
;;;256    /*-----------------------------------------------------------*/
                          ENDP

                  pxPortInitialiseStack PROC
;;;213     */
;;;214    portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
000008  1f00              SUBS     r0,r0,#4
;;;215    {
;;;216    	/* Simulate the stack frame as it would be created by a context switch
;;;217    	interrupt. */
;;;218    
;;;219    	/* Offset added to account for the way the MCU uses the stack on entry/exit
;;;220    	of interrupts, and to ensure alignment. */
;;;221    	pxTopOfStack--;
;;;222    
;;;223    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
00000a  f04f7380          MOV      r3,#0x1000000
00000e  6003              STR      r3,[r0,#0]
;;;224    	pxTopOfStack--;
000010  1f00              SUBS     r0,r0,#4
;;;225    	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
000012  6001              STR      r1,[r0,#0]
;;;226    	pxTopOfStack--;
000014  1f00              SUBS     r0,r0,#4
;;;227    	*pxTopOfStack = ( portSTACK_TYPE ) prvTaskExitError;	/* LR */
000016  4b31              LDR      r3,|L1.220|
000018  6003              STR      r3,[r0,#0]
;;;228    
;;;229    	/* Save code space by skipping register initialisation. */
;;;230    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
00001a  3814              SUBS     r0,r0,#0x14
;;;231    	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
00001c  6002              STR      r2,[r0,#0]
;;;232    
;;;233    	/* A save method is being used that requires each task to maintain its
;;;234    	own exec return value. */
;;;235    	pxTopOfStack--;
00001e  1f00              SUBS     r0,r0,#4
;;;236    	*pxTopOfStack = portINITIAL_EXEC_RETURN;
000020  f06f0302          MVN      r3,#2
000024  6003              STR      r3,[r0,#0]
;;;237    
;;;238    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
000026  3820              SUBS     r0,r0,#0x20
;;;239    
;;;240    	return pxTopOfStack;
;;;241    }
000028  4770              BX       lr
;;;242    /*-----------------------------------------------------------*/
                          ENDP

                  vPortSetupTimerInterrupt PROC
;;;656    
;;;657    	void vPortSetupTimerInterrupt( void )
00002a  482d              LDR      r0,|L1.224|
;;;658    	{
;;;659    		/* Calculate the constants required to configure the tick interrupt. */
;;;660    		#if configUSE_TICKLESS_IDLE == 1
;;;661    		{
;;;662    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;663    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;664    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;665    		}
;;;666    		#endif /* configUSE_TICKLESS_IDLE */
;;;667    
;;;668    		/* Configure SysTick to interrupt at the requested rate. */
;;;669    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
00002c  f04f21e0          MOV      r1,#0xe000e000
000030  6148              STR      r0,[r1,#0x14]
;;;670    		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
000032  2007              MOVS     r0,#7
000034  6108              STR      r0,[r1,#0x10]
;;;671    	}
000036  4770              BX       lr
;;;672    
                          ENDP

                  xPortStartScheduler PROC
;;;311     */
;;;312    portBASE_TYPE xPortStartScheduler( void )
000038  b510              PUSH     {r4,lr}
;;;313    {
;;;314    	#if( configASSERT_DEFINED == 1 )
;;;315    	{
;;;316    		volatile unsigned long ulOriginalPriority;
;;;317    		volatile char * const pcFirstUserPriorityRegister = ( char * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
;;;318    		volatile unsigned char ucMaxPriorityValue;
;;;319    
;;;320    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;321    		functions can be called.  ISR safe functions are those that end in
;;;322    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;323    		ensure interrupt entry is as fast and simple as possible.
;;;324    
;;;325    		Save the interrupt priority value that is about to be clobbered. */
;;;326    		ulOriginalPriority = *pcFirstUserPriorityRegister;
;;;327    
;;;328    		/* Determine the number of priority bits available.  First write to all
;;;329    		possible bits. */
;;;330    		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
;;;331    
;;;332    		/* Read the value back to see how many bits stuck. */
;;;333    		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
;;;334    
;;;335    		/* Use the same mask on the maximum system call priority. */
;;;336    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
;;;337    
;;;338    		/* Calculate the maximum acceptable priority group value for the number
;;;339    		of bits read back. */
;;;340    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
;;;341    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;342    		{
;;;343    			ulMaxPRIGROUPValue--;
;;;344    			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
;;;345    		}
;;;346    
;;;347    		/* Shift the priority group value back to its position within the AIRCR
;;;348    		register. */
;;;349    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
;;;350    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;351    
;;;352    		/* Restore the clobbered interrupt priority register to its original
;;;353    		value. */
;;;354    		*pcFirstUserPriorityRegister = ulOriginalPriority;
;;;355    	}
;;;356    	#endif /* conifgASSERT_DEFINED */
;;;357    
;;;358    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;359    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
00003a  482a              LDR      r0,|L1.228|
00003c  6800              LDR      r0,[r0,#0]
00003e  f440007f          ORR      r0,r0,#0xff0000
000042  4928              LDR      r1,|L1.228|
000044  6008              STR      r0,[r1,#0]
;;;360    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  f040407f          ORR      r0,r0,#0xff000000
00004e  6008              STR      r0,[r1,#0]
;;;361    
;;;362    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;363    	here already. */
;;;364    	vPortSetupTimerInterrupt();
000050  f7fffffe          BL       vPortSetupTimerInterrupt
;;;365    
;;;366    	/* Initialise the critical nesting count ready for the first task. */
;;;367    	uxCriticalNesting = 0;
000054  2000              MOVS     r0,#0
000056  4924              LDR      r1,|L1.232|
000058  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;368    
;;;369    	/* Ensure the VFP is enabled - it should be anyway. */
;;;370    	prvEnableVFP();
00005a  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvEnableVFP
;;;371    
;;;372    	/* Lazy save always. */
;;;373    	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
00005e  4823              LDR      r0,|L1.236|
000060  6800              LDR      r0,[r0,#0]
000062  f0404040          ORR      r0,r0,#0xc0000000
000066  4921              LDR      r1,|L1.236|
000068  6008              STR      r0,[r1,#0]
;;;374    
;;;375    	/* Start the first task. */
;;;376    	prvStartFirstTask();
00006a  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;377    
;;;378    	/* Should not get here! */
;;;379    	return 0;
00006e  2000              MOVS     r0,#0
;;;380    }
000070  bd10              POP      {r4,pc}
;;;381    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEndScheduler PROC
;;;382    
;;;383    void vPortEndScheduler( void )
000072  4770              BX       lr
;;;384    {
;;;385    	/* It is unlikely that the CM4F port will require this function as there
;;;386    	is nothing to return to.  */
;;;387    }
;;;388    /*-----------------------------------------------------------*/
                          ENDP

                  vPortYield PROC
;;;389    
;;;390    void vPortYield( void )
000074  f04f5080          MOV      r0,#0x10000000
;;;391    {
;;;392    	/* Set a PendSV to request a context switch. */
;;;393    	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000078  491a              LDR      r1,|L1.228|
00007a  391c              SUBS     r1,r1,#0x1c
00007c  6008              STR      r0,[r1,#0]
;;;394    
;;;395    	/* Barriers are normally not required but do ensure the code is completely
;;;396    	within the specified behaviour for the architecture. */
;;;397    	__dsb( portSY_FULL_READ_WRITE );
00007e  f3bf8f4f          DSB      
;;;398    	__isb( portSY_FULL_READ_WRITE );
000082  f3bf8f6f          ISB      
;;;399    }
000086  4770              BX       lr
;;;400    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEnterCritical PROC
;;;401    
;;;402    void vPortEnterCritical( void )
000088  b510              PUSH     {r4,lr}
;;;403    {
;;;404    	portDISABLE_INTERRUPTS();
00008a  f7fffffe          BL       ulPortSetInterruptMask
;;;405    	uxCriticalNesting++;
00008e  4816              LDR      r0,|L1.232|
000090  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000092  1c40              ADDS     r0,r0,#1
000094  4914              LDR      r1,|L1.232|
000096  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;406    	__dsb( portSY_FULL_READ_WRITE );
000098  f3bf8f4f          DSB      
;;;407    	__isb( portSY_FULL_READ_WRITE );
00009c  f3bf8f6f          ISB      
;;;408    }
0000a0  bd10              POP      {r4,pc}
;;;409    /*-----------------------------------------------------------*/
                          ENDP

                  vPortExitCritical PROC
;;;410    
;;;411    void vPortExitCritical( void )
0000a2  b510              PUSH     {r4,lr}
;;;412    {
;;;413    	uxCriticalNesting--;
0000a4  4810              LDR      r0,|L1.232|
0000a6  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
0000a8  1e40              SUBS     r0,r0,#1
0000aa  490f              LDR      r1,|L1.232|
0000ac  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;414    	if( uxCriticalNesting == 0 )
0000ae  4608              MOV      r0,r1
0000b0  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
0000b2  b910              CBNZ     r0,|L1.186|
;;;415    	{
;;;416    		portENABLE_INTERRUPTS();
0000b4  2000              MOVS     r0,#0
0000b6  f7fffffe          BL       vPortClearInterruptMask
                  |L1.186|
;;;417    	}
;;;418    }
0000ba  bd10              POP      {r4,pc}
;;;419    /*-----------------------------------------------------------*/
                          ENDP

                  xPortSysTickHandler PROC
;;;478    }
;;;479    void xPortSysTickHandler( void )
0000bc  b510              PUSH     {r4,lr}
;;;480    {
;;;481    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;482    	executes all interrupts must be unmasked.  There is therefore no need to
;;;483    	save and then restore the interrupt mask value as its value is already
;;;484    	known. */
;;;485    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
0000be  f7fffffe          BL       ulPortSetInterruptMask
;;;486    	{
;;;487    		/* Increment the RTOS tick. */
;;;488    		if( xTaskIncrementTick() != pdFALSE )
0000c2  f7fffffe          BL       xTaskIncrementTick
0000c6  b120              CBZ      r0,|L1.210|
;;;489    		{
;;;490    			/* A context switch is required.  Context switching is performed in
;;;491    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;492    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
0000c8  f04f5080          MOV      r0,#0x10000000
0000cc  4905              LDR      r1,|L1.228|
0000ce  391c              SUBS     r1,r1,#0x1c
0000d0  6008              STR      r0,[r1,#0]
                  |L1.210|
;;;493    		}
;;;494    	}
;;;495    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
0000d2  2000              MOVS     r0,#0
0000d4  f7fffffe          BL       vPortClearInterruptMask
;;;496    }
0000d8  bd10              POP      {r4,pc}
;;;497    /*-----------------------------------------------------------*/
                          ENDP

0000da  0000              DCW      0x0000
                  |L1.220|
                          DCD      prvTaskExitError
                  |L1.224|
                          DCD      0x0001d4bf
                  |L1.228|
                          DCD      0xe000ed20
                  |L1.232|
                          DCD      uxCriticalNesting
                  |L1.236|
                          DCD      0xe000ef34

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "FreeRTOS\\portable\\port.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |vPortSVCHandler|
#line 258
|vPortSVCHandler| PROC
#line 259

 PRESERVE8

 
 ldr r3, =pxCurrentTCB
 ldr r1, [r3]
 ldr r0, [r1]
 
 ldmia r0!, {r4-r11, r14}
 msr psp, r0
 mov r0, #0
 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 275
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 276

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
 
 cpsie i
 
 svc 0
 nop
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvEnableVFP|
#line 293
|__asm___6_port_c_39a90d8d__prvEnableVFP| PROC
#line 294

 PRESERVE8

 
 ldr.w r0, =0xE000ED88
 ldr r1, [r0]

 
 orr r1, r1, #( 0xf << 20 )
 str r1, [r0]
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |xPortPendSVHandler|
#line 421
|xPortPendSVHandler| PROC
#line 422

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp

 
 ldr r3, =pxCurrentTCB
 ldr r2, [r3]

 
 tst r14, #0x10
 it eq
 vstmdbeq r0!, {s16-s31}

 
 stmdb r0!, {r4-r11, r14}

 
 str r0, [r2]

 stmdb sp!, {r3}
 mov r0, #(127)
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3}

 
 ldr r1, [r3]
 ldr r0, [r1]

 
 ldmia r0!, {r4-r11, r14}

#line 462
 
 tst r14, #0x10
 it eq
 vldmiaeq r0!, {s16-s31}

 msr psp, r0

 
#line 475

 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 676
|ulPortSetInterruptMask| PROC
#line 677

 PRESERVE8

 mrs r0, basepri
 mov r1, #(127)
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 687
|vPortClearInterruptMask| PROC
#line 688

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |vPortGetIPSR|
#line 696
|vPortGetIPSR| PROC
#line 697

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
