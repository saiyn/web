; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\tasks.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\tasks.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\Driver -I.\web -I.\third_party\lwip-1.4.1\src\include -I.\third_party\fatfs -I.\third_party\lwip-1.4.1\apps\httpserver_raw -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch -I.\third_party\lwip-1.4.1\src\include\ipv4 -I..\MCU -I.\third_party\lwip-1.4.1\apps -I.\third_party -I.\Upnp -I.\Dsp -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C129XNCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DUSE_LWIP -DTM4C129ENCPDT --omf_browse=.\build\tasks.crf FreeRTOS\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;2379   
;;;2380   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;2381   {
;;;2382   unsigned portBASE_TYPE uxPriority;
;;;2383   
;;;2384   	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L1.22|
                  |L1.6|
;;;2385   	{
;;;2386   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4afe              LDR      r2,|L1.1028|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;2384
                  |L1.22|
000016  2c0a              CMP      r4,#0xa               ;2384
000018  d3f5              BCC      |L1.6|
;;;2387   	}
;;;2388   
;;;2389   	vListInitialise( &xDelayedTaskList1 );
00001a  48fb              LDR      r0,|L1.1032|
00001c  f7fffffe          BL       vListInitialise
;;;2390   	vListInitialise( &xDelayedTaskList2 );
000020  48fa              LDR      r0,|L1.1036|
000022  f7fffffe          BL       vListInitialise
;;;2391   	vListInitialise( &xPendingReadyList );
000026  48fa              LDR      r0,|L1.1040|
000028  f7fffffe          BL       vListInitialise
;;;2392   
;;;2393   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2394   	{
;;;2395   		vListInitialise( &xTasksWaitingTermination );
00002c  48f9              LDR      r0,|L1.1044|
00002e  f7fffffe          BL       vListInitialise
;;;2396   	}
;;;2397   	#endif /* INCLUDE_vTaskDelete */
;;;2398   
;;;2399   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2400   	{
;;;2401   		vListInitialise( &xSuspendedTaskList );
000032  48f9              LDR      r0,|L1.1048|
000034  f7fffffe          BL       vListInitialise
;;;2402   	}
;;;2403   	#endif /* INCLUDE_vTaskSuspend */
;;;2404   
;;;2405   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;2406   	using list2. */
;;;2407   	pxDelayedTaskList = &xDelayedTaskList1;
000038  48f3              LDR      r0,|L1.1032|
00003a  49f8              LDR      r1,|L1.1052|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;2408   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  48f3              LDR      r0,|L1.1036|
000040  49f7              LDR      r1,|L1.1056|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;2409   }
000044  bd10              POP      {r4,pc}
;;;2410   /*-----------------------------------------------------------*/
                          ENDP

                  prvInitialiseTCBVariables PROC
;;;2279   
;;;2280   static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
000046  e92d47f0          PUSH     {r4-r10,lr}
;;;2281   {
00004a  4604              MOV      r4,r0
00004c  460f              MOV      r7,r1
00004e  4615              MOV      r5,r2
000050  4699              MOV      r9,r3
000052  f8dd8020          LDR      r8,[sp,#0x20]
;;;2282   unsigned portBASE_TYPE x;
;;;2283   
;;;2284   	/* Store the task name in the TCB. */
;;;2285   	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
000056  2600              MOVS     r6,#0
000058  e007              B        |L1.106|
                  |L1.90|
;;;2286   	{
;;;2287   		pxTCB->pcTaskName[ x ] = pcName[ x ];
00005a  5db9              LDRB     r1,[r7,r6]
00005c  f1040034          ADD      r0,r4,#0x34
000060  5581              STRB     r1,[r0,r6]
;;;2288   
;;;2289   		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;2290   		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;2291   		string is not accessible (extremely unlikely). */
;;;2292   		if( pcName[ x ] == 0x00 )
000062  5db8              LDRB     r0,[r7,r6]
000064  b900              CBNZ     r0,|L1.104|
;;;2293   		{
;;;2294   			break;
000066  e002              B        |L1.110|
                  |L1.104|
000068  1c76              ADDS     r6,r6,#1              ;2285
                  |L1.106|
00006a  2e10              CMP      r6,#0x10              ;2285
00006c  d3f5              BCC      |L1.90|
                  |L1.110|
00006e  bf00              NOP      
;;;2295   		}
;;;2296   	}
;;;2297   
;;;2298   	/* Ensure the name string is terminated in the case that the string length
;;;2299   	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;2300   	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
000070  2100              MOVS     r1,#0
000072  2043              MOVS     r0,#0x43
000074  5501              STRB     r1,[r0,r4]
;;;2301   
;;;2302   	/* This is used as an array index so must ensure it's not too large.  First
;;;2303   	remove the privilege bit if one is present. */
;;;2304   	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
000076  2d0a              CMP      r5,#0xa
000078  d300              BCC      |L1.124|
;;;2305   	{
;;;2306   		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
00007a  2509              MOVS     r5,#9
                  |L1.124|
;;;2307   	}
;;;2308   
;;;2309   	pxTCB->uxPriority = uxPriority;
00007c  62e5              STR      r5,[r4,#0x2c]
;;;2310   	#if ( configUSE_MUTEXES == 1 )
;;;2311   	{
;;;2312   		pxTCB->uxBasePriority = uxPriority;
00007e  64a5              STR      r5,[r4,#0x48]
;;;2313   	}
;;;2314   	#endif /* configUSE_MUTEXES */
;;;2315   
;;;2316   	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
000080  1d20              ADDS     r0,r4,#4
000082  f7fffffe          BL       vListInitialiseItem
;;;2317   	vListInitialiseItem( &( pxTCB->xEventListItem ) );
000086  f1040018          ADD      r0,r4,#0x18
00008a  f7fffffe          BL       vListInitialiseItem
;;;2318   
;;;2319   	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
;;;2320   	back to	the containing TCB from a generic item in a list. */
;;;2321   	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
00008e  6124              STR      r4,[r4,#0x10]
;;;2322   
;;;2323   	/* Event lists are always in priority order. */
;;;2324   	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000090  f1c5000a          RSB      r0,r5,#0xa
000094  61a0              STR      r0,[r4,#0x18]
;;;2325   	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
000096  6264              STR      r4,[r4,#0x24]
;;;2326   
;;;2327   	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;2328   	{
;;;2329   		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
000098  2000              MOVS     r0,#0
00009a  6460              STR      r0,[r4,#0x44]
;;;2330   	}
;;;2331   	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;2332   
;;;2333   	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;2334   	{
;;;2335   		pxTCB->pxTaskTag = NULL;
;;;2336   	}
;;;2337   	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;2338   
;;;2339   	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2340   	{
;;;2341   		pxTCB->ulRunTimeCounter = 0UL;
;;;2342   	}
;;;2343   	#endif /* configGENERATE_RUN_TIME_STATS */
;;;2344   
;;;2345   	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;2346   	{
;;;2347   		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
;;;2348   	}
;;;2349   	#else /* portUSING_MPU_WRAPPERS */
;;;2350   	{
;;;2351   		( void ) xRegions;
;;;2352   		( void ) usStackDepth;
;;;2353   	}
;;;2354   	#endif /* portUSING_MPU_WRAPPERS */
;;;2355   
;;;2356   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2357   	{
;;;2358   		/* Initialise this task's Newlib reent structure. */
;;;2359   		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
;;;2360   	}
;;;2361   	#endif /* configUSE_NEWLIB_REENTRANT */
;;;2362   }
00009c  e8bd87f0          POP      {r4-r10,pc}
;;;2363   /*-----------------------------------------------------------*/
                          ENDP

                  prvAllocateTCBAndStack PROC
;;;2472   
;;;2473   static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
0000a0  b570              PUSH     {r4-r6,lr}
;;;2474   {
0000a2  4605              MOV      r5,r0
0000a4  460e              MOV      r6,r1
;;;2475   tskTCB *pxNewTCB;
;;;2476   
;;;2477   	/* Allocate space for the TCB.  Where the memory comes from depends on
;;;2478   	the implementation of the port malloc function. */
;;;2479   	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
0000a6  204c              MOVS     r0,#0x4c
0000a8  f7fffffe          BL       pvPortMalloc
0000ac  4604              MOV      r4,r0
;;;2480   
;;;2481   	if( pxNewTCB != NULL )
0000ae  b194              CBZ      r4,|L1.214|
;;;2482   	{
;;;2483   		/* Allocate space for the stack used by the task being created.
;;;2484   		The base of the stack memory stored in the TCB so the task can
;;;2485   		be deleted later if required. */
;;;2486   		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000b0  b91e              CBNZ     r6,|L1.186|
0000b2  00a8              LSLS     r0,r5,#2
0000b4  f7fffffe          BL       pvPortMalloc
0000b8  e000              B        |L1.188|
                  |L1.186|
0000ba  4630              MOV      r0,r6
                  |L1.188|
0000bc  6320              STR      r0,[r4,#0x30]
;;;2487   
;;;2488   		if( pxNewTCB->pxStack == NULL )
0000be  6b20              LDR      r0,[r4,#0x30]
0000c0  b920              CBNZ     r0,|L1.204|
;;;2489   		{
;;;2490   			/* Could not allocate the stack.  Delete the allocated TCB. */
;;;2491   			vPortFree( pxNewTCB );
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       vPortFree
;;;2492   			pxNewTCB = NULL;
0000c8  2400              MOVS     r4,#0
0000ca  e004              B        |L1.214|
                  |L1.204|
;;;2493   		}
;;;2494   		else
;;;2495   		{
;;;2496   			/* Just to help debugging. */
;;;2497   			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
0000cc  00a9              LSLS     r1,r5,#2
0000ce  22a5              MOVS     r2,#0xa5
0000d0  6b20              LDR      r0,[r4,#0x30]
0000d2  f7fffffe          BL       __aeabi_memset
                  |L1.214|
;;;2498   		}
;;;2499   	}
;;;2500   
;;;2501   	return pxNewTCB;
0000d6  4620              MOV      r0,r4
;;;2502   }
0000d8  bd70              POP      {r4-r6,pc}
;;;2503   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGenericCreate PROC
;;;486    
;;;487    signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
0000da  e92d4fff          PUSH     {r0-r11,lr}
;;;488    {
0000de  b081              SUB      sp,sp,#4
0000e0  4680              MOV      r8,r0
0000e2  4615              MOV      r5,r2
0000e4  4699              MOV      r9,r3
0000e6  e9dd7a0e          LDRD     r7,r10,[sp,#0x38]
;;;489    signed portBASE_TYPE xReturn;
;;;490    tskTCB * pxNewTCB;
;;;491    
;;;492    	configASSERT( pxTaskCode );
;;;493    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
;;;494    
;;;495    	/* Allocate the memory required by the TCB and stack for the new task,
;;;496    	checking that the allocation was successful. */
;;;497    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
0000ea  4628              MOV      r0,r5
0000ec  9910              LDR      r1,[sp,#0x40]
0000ee  f7fffffe          BL       prvAllocateTCBAndStack
0000f2  4604              MOV      r4,r0
;;;498    
;;;499    	if( pxNewTCB != NULL )
0000f4  2c00              CMP      r4,#0
0000f6  d04f              BEQ      |L1.408|
;;;500    	{
;;;501    		portSTACK_TYPE *pxTopOfStack;
;;;502    
;;;503    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;504    			/* Should the task be created in privileged mode? */
;;;505    			portBASE_TYPE xRunPrivileged;
;;;506    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;507    			{
;;;508    				xRunPrivileged = pdTRUE;
;;;509    			}
;;;510    			else
;;;511    			{
;;;512    				xRunPrivileged = pdFALSE;
;;;513    			}
;;;514    			uxPriority &= ~portPRIVILEGE_BIT;
;;;515    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;516    
;;;517    		/* Calculate the top of stack address.  This depends on whether the
;;;518    		stack grows from high memory to low (as per the 80x86) or visa versa.
;;;519    		portSTACK_GROWTH is used to make the result positive or negative as
;;;520    		required by the port. */
;;;521    		#if( portSTACK_GROWTH < 0 )
;;;522    		{
;;;523    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
0000f8  1e68              SUBS     r0,r5,#1
0000fa  6b21              LDR      r1,[r4,#0x30]
0000fc  eb010b80          ADD      r11,r1,r0,LSL #2
;;;524    			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000100  f02b0b07          BIC      r11,r11,#7
;;;525    
;;;526    			/* Check the alignment of the calculated top of stack is correct. */
;;;527    			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;528    		}
;;;529    		#else /* portSTACK_GROWTH */
;;;530    		{
;;;531    			pxTopOfStack = pxNewTCB->pxStack;
;;;532    
;;;533    			/* Check the alignment of the stack buffer is correct. */
;;;534    			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;535    
;;;536    			/* If we want to use stack checking on architectures that use
;;;537    			a positive stack growth direction then we also need to store the
;;;538    			other extreme of the stack space. */
;;;539    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;540    		}
;;;541    		#endif /* portSTACK_GROWTH */
;;;542    
;;;543    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;544    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
000104  9500              STR      r5,[sp,#0]
000106  463a              MOV      r2,r7
000108  4620              MOV      r0,r4
00010a  9b11              LDR      r3,[sp,#0x44]
00010c  9902              LDR      r1,[sp,#8]
00010e  f7fffffe          BL       prvInitialiseTCBVariables
;;;545    
;;;546    		/* Initialize the TCB stack to look as if the task was already running,
;;;547    		but had been interrupted by the scheduler.  The return address is set
;;;548    		to the start of the task function. Once the stack has been initialised
;;;549    		the	top of stack variable is updated. */
;;;550    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;551    		{
;;;552    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;553    		}
;;;554    		#else /* portUSING_MPU_WRAPPERS */
;;;555    		{
;;;556    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000112  464a              MOV      r2,r9
000114  4641              MOV      r1,r8
000116  4658              MOV      r0,r11
000118  f7fffffe          BL       pxPortInitialiseStack
00011c  6020              STR      r0,[r4,#0]
;;;557    		}
;;;558    		#endif /* portUSING_MPU_WRAPPERS */
;;;559    
;;;560    		if( ( void * ) pxCreatedTask != NULL )
00011e  f1ba0f00          CMP      r10,#0
000122  d001              BEQ      |L1.296|
;;;561    		{
;;;562    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;563    			task can use this as a handle to delete the task later if
;;;564    			required.*/
;;;565    			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
000124  f8ca4000          STR      r4,[r10,#0]
                  |L1.296|
;;;566    		}
;;;567    
;;;568    		/* Ensure interrupts don't access the task lists while they are being
;;;569    		updated. */
;;;570    		taskENTER_CRITICAL();
000128  f7fffffe          BL       vPortEnterCritical
;;;571    		{
;;;572    			uxCurrentNumberOfTasks++;
00012c  48bd              LDR      r0,|L1.1060|
00012e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000130  1c40              ADDS     r0,r0,#1
000132  49bc              LDR      r1,|L1.1060|
000134  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;573    			if( pxCurrentTCB == NULL )
000136  48bc              LDR      r0,|L1.1064|
000138  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00013a  b940              CBNZ     r0,|L1.334|
;;;574    			{
;;;575    				/* There are no other tasks, or all the other tasks are in
;;;576    				the suspended state - make this the current task. */
;;;577    				pxCurrentTCB =  pxNewTCB;
00013c  48ba              LDR      r0,|L1.1064|
00013e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;578    
;;;579    				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
000140  4608              MOV      r0,r1
000142  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000144  2801              CMP      r0,#1
000146  d10c              BNE      |L1.354|
;;;580    				{
;;;581    					/* This is the first task to be created so do the preliminary
;;;582    					initialisation required.  We will not recover if this call
;;;583    					fails, but we will report the failure. */
;;;584    					prvInitialiseTaskLists();
000148  f7fffffe          BL       prvInitialiseTaskLists
00014c  e009              B        |L1.354|
                  |L1.334|
;;;585    				}
;;;586    			}
;;;587    			else
;;;588    			{
;;;589    				/* If the scheduler is not already running, make this task the
;;;590    				current task if it is the highest priority task to be created
;;;591    				so far. */
;;;592    				if( xSchedulerRunning == pdFALSE )
00014e  48b7              LDR      r0,|L1.1068|
000150  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000152  b930              CBNZ     r0,|L1.354|
;;;593    				{
;;;594    					if( pxCurrentTCB->uxPriority <= uxPriority )
000154  48b4              LDR      r0,|L1.1064|
000156  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000158  6ac0              LDR      r0,[r0,#0x2c]
00015a  42b8              CMP      r0,r7
00015c  d801              BHI      |L1.354|
;;;595    					{
;;;596    						pxCurrentTCB = pxNewTCB;
00015e  48b2              LDR      r0,|L1.1064|
000160  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.354|
;;;597    					}
;;;598    				}
;;;599    			}
;;;600    
;;;601    			uxTaskNumber++;
000162  48b3              LDR      r0,|L1.1072|
000164  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000166  1c40              ADDS     r0,r0,#1
000168  49b1              LDR      r1,|L1.1072|
00016a  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;602    
;;;603    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;604    			{
;;;605    				/* Add a counter into the TCB for tracing only. */
;;;606    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;607    			}
;;;608    			#endif /* configUSE_TRACE_FACILITY */
;;;609    			traceTASK_CREATE( pxNewTCB );
;;;610    
;;;611    			prvAddTaskToReadyList( pxNewTCB );
00016c  f894102c          LDRB     r1,[r4,#0x2c]
000170  2001              MOVS     r0,#1
000172  4088              LSLS     r0,r0,r1
000174  49af              LDR      r1,|L1.1076|
000176  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000178  4308              ORRS     r0,r0,r1
00017a  49ae              LDR      r1,|L1.1076|
00017c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00017e  6ae1              LDR      r1,[r4,#0x2c]
000180  eb010181          ADD      r1,r1,r1,LSL #2
000184  4a9f              LDR      r2,|L1.1028|
000186  eb020081          ADD      r0,r2,r1,LSL #2
00018a  1d21              ADDS     r1,r4,#4
00018c  f7fffffe          BL       vListInsertEnd
;;;612    
;;;613    			xReturn = pdPASS;
000190  2601              MOVS     r6,#1
;;;614    			portSETUP_TCB( pxNewTCB );
;;;615    		}
;;;616    		taskEXIT_CRITICAL();
000192  f7fffffe          BL       vPortExitCritical
;;;617    	}
000196  e001              B        |L1.412|
                  |L1.408|
;;;618    	else
;;;619    	{
;;;620    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000198  f04f36ff          MOV      r6,#0xffffffff
                  |L1.412|
;;;621    		traceTASK_CREATE_FAILED();
;;;622    	}
;;;623    
;;;624    	if( xReturn == pdPASS )
00019c  2e01              CMP      r6,#1
00019e  d109              BNE      |L1.436|
;;;625    	{
;;;626    		if( xSchedulerRunning != pdFALSE )
0001a0  48a2              LDR      r0,|L1.1068|
0001a2  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
0001a4  b130              CBZ      r0,|L1.436|
;;;627    		{
;;;628    			/* If the created task is of a higher priority than the current task
;;;629    			then it should run now. */
;;;630    			if( pxCurrentTCB->uxPriority < uxPriority )
0001a6  48a0              LDR      r0,|L1.1064|
0001a8  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001aa  6ac0              LDR      r0,[r0,#0x2c]
0001ac  42b8              CMP      r0,r7
0001ae  d201              BCS      |L1.436|
;;;631    			{
;;;632    				taskYIELD_IF_USING_PREEMPTION();
0001b0  f7fffffe          BL       vPortYield
                  |L1.436|
;;;633    			}
;;;634    		}
;;;635    	}
;;;636    
;;;637    	return xReturn;
0001b4  4630              MOV      r0,r6
;;;638    }
0001b6  b005              ADD      sp,sp,#0x14
0001b8  e8bd8ff0          POP      {r4-r11,pc}
;;;639    /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;642    
;;;643    	void vTaskDelete( xTaskHandle xTaskToDelete )
0001bc  b570              PUSH     {r4-r6,lr}
;;;644    	{
0001be  4605              MOV      r5,r0
;;;645    	tskTCB *pxTCB;
;;;646    
;;;647    		taskENTER_CRITICAL();
0001c0  f7fffffe          BL       vPortEnterCritical
;;;648    		{
;;;649    			/* If null is passed in here then we are deleting ourselves. */
;;;650    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
0001c4  b915              CBNZ     r5,|L1.460|
0001c6  4898              LDR      r0,|L1.1064|
0001c8  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001ca  e000              B        |L1.462|
                  |L1.460|
0001cc  4628              MOV      r0,r5
                  |L1.462|
0001ce  4604              MOV      r4,r0
;;;651    
;;;652    			/* Remove task from the ready list and place in the	termination list.
;;;653    			This will stop the task from be scheduled.  The idle task will check
;;;654    			the termination list and free up any memory allocated by the
;;;655    			scheduler for the TCB and stack. */
;;;656    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0001d0  1d20              ADDS     r0,r4,#4
0001d2  f7fffffe          BL       uxListRemove
0001d6  b978              CBNZ     r0,|L1.504|
;;;657    			{
;;;658    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
0001d8  6ae0              LDR      r0,[r4,#0x2c]
0001da  eb000080          ADD      r0,r0,r0,LSL #2
0001de  4989              LDR      r1,|L1.1028|
0001e0  f8510020          LDR      r0,[r1,r0,LSL #2]
0001e4  b940              CBNZ     r0,|L1.504|
0001e6  f894102c          LDRB     r1,[r4,#0x2c]
0001ea  2001              MOVS     r0,#1
0001ec  4088              LSLS     r0,r0,r1
0001ee  4991              LDR      r1,|L1.1076|
0001f0  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0001f2  4381              BICS     r1,r1,r0
0001f4  488f              LDR      r0,|L1.1076|
0001f6  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.504|
;;;659    			}
;;;660    
;;;661    			/* Is the task waiting on an event also? */
;;;662    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0001f8  6aa0              LDR      r0,[r4,#0x28]
0001fa  b118              CBZ      r0,|L1.516|
;;;663    			{
;;;664    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0001fc  f1040018          ADD      r0,r4,#0x18
000200  f7fffffe          BL       uxListRemove
                  |L1.516|
;;;665    			}
;;;666    
;;;667    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
000204  1d21              ADDS     r1,r4,#4
000206  4883              LDR      r0,|L1.1044|
000208  f7fffffe          BL       vListInsertEnd
;;;668    
;;;669    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;670    			there is a task that has been deleted and that it should therefore
;;;671    			check the xTasksWaitingTermination list. */
;;;672    			++uxTasksDeleted;
00020c  488a              LDR      r0,|L1.1080|
00020e  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
000210  1c40              ADDS     r0,r0,#1
000212  4989              LDR      r1,|L1.1080|
000214  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;673    
;;;674    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;675    			can detect that the task lists need re-generating. */
;;;676    			uxTaskNumber++;
000216  4886              LDR      r0,|L1.1072|
000218  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00021a  1c40              ADDS     r0,r0,#1
00021c  4984              LDR      r1,|L1.1072|
00021e  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;677    
;;;678    			traceTASK_DELETE( pxTCB );
;;;679    		}
;;;680    		taskEXIT_CRITICAL();
000220  f7fffffe          BL       vPortExitCritical
;;;681    
;;;682    		/* Force a reschedule if we have just deleted the current task. */
;;;683    		if( xSchedulerRunning != pdFALSE )
000224  4881              LDR      r0,|L1.1068|
000226  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000228  b128              CBZ      r0,|L1.566|
;;;684    		{
;;;685    			if( pxTCB == pxCurrentTCB )
00022a  487f              LDR      r0,|L1.1064|
00022c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00022e  4284              CMP      r4,r0
000230  d101              BNE      |L1.566|
;;;686    			{
;;;687    				portYIELD_WITHIN_API();
000232  f7fffffe          BL       vPortYield
                  |L1.566|
;;;688    			}
;;;689    		}
;;;690    	}
000236  bd70              POP      {r4-r6,pc}
;;;691    
                          ENDP

                  xTaskIncrementTick PROC
;;;1603   
;;;1604   portBASE_TYPE xTaskIncrementTick( void )
000238  e92d41f0          PUSH     {r4-r8,lr}
;;;1605   {
;;;1606   tskTCB * pxTCB;
;;;1607   portTickType xItemValue;
;;;1608   portBASE_TYPE xSwitchRequired = pdFALSE;
00023c  2700              MOVS     r7,#0
;;;1609   
;;;1610   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1611   	Increments the tick then checks to see if the new tick value will cause any
;;;1612   	tasks to be unblocked. */
;;;1613   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1614   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00023e  487f              LDR      r0,|L1.1084|
000240  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000242  2800              CMP      r0,#0
000244  d176              BNE      |L1.820|
;;;1615   	{
;;;1616   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1617   		delayed lists if it wraps to 0. */
;;;1618   		++xTickCount;
000246  487e              LDR      r0,|L1.1088|
000248  6800              LDR      r0,[r0,#0]  ; xTickCount
00024a  1c40              ADDS     r0,r0,#1
00024c  497c              LDR      r1,|L1.1088|
00024e  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1619   
;;;1620   		{
;;;1621   			/* Minor optimisation.  The tick count cannot change in this
;;;1622   			block. */
;;;1623   			const portTickType xConstTickCount = xTickCount;
000250  4608              MOV      r0,r1
000252  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1624   
;;;1625   			if( xConstTickCount == ( portTickType ) 0U )
000254  bb0e              CBNZ     r6,|L1.666|
;;;1626   			{
;;;1627   				taskSWITCH_DELAYED_LISTS();
000256  4971              LDR      r1,|L1.1052|
000258  6808              LDR      r0,[r1,#0]  ; pxDelayedTaskList
00025a  4971              LDR      r1,|L1.1056|
00025c  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00025e  4a6f              LDR      r2,|L1.1052|
000260  6011              STR      r1,[r2,#0]  ; pxDelayedTaskList
000262  496f              LDR      r1,|L1.1056|
000264  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
000266  4977              LDR      r1,|L1.1092|
000268  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
00026a  1c49              ADDS     r1,r1,#1
00026c  4a75              LDR      r2,|L1.1092|
00026e  6011              STR      r1,[r2,#0]  ; xNumOfOverflows
000270  496a              LDR      r1,|L1.1052|
000272  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000274  6809              LDR      r1,[r1,#0]
000276  b909              CBNZ     r1,|L1.636|
000278  2101              MOVS     r1,#1
00027a  e000              B        |L1.638|
                  |L1.636|
00027c  2100              MOVS     r1,#0
                  |L1.638|
00027e  b121              CBZ      r1,|L1.650|
000280  f04f31ff          MOV      r1,#0xffffffff
000284  4a70              LDR      r2,|L1.1096|
000286  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000288  e006              B        |L1.664|
                  |L1.650|
00028a  4964              LDR      r1,|L1.1052|
00028c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00028e  68c9              LDR      r1,[r1,#0xc]
000290  68cc              LDR      r4,[r1,#0xc]
000292  4a6d              LDR      r2,|L1.1096|
000294  6861              LDR      r1,[r4,#4]
000296  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L1.664|
000298  bf00              NOP      
                  |L1.666|
;;;1628   			}
;;;1629   
;;;1630   			/* See if this tick has made a timeout expire.  Tasks are stored in the
;;;1631   			queue in the order of their wake time - meaning once one tasks has been
;;;1632   			found whose block time has not expired there is no need not look any
;;;1633   			further	down the list. */
;;;1634   			if( xConstTickCount >= xNextTaskUnblockTime )
00029a  486b              LDR      r0,|L1.1096|
00029c  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
00029e  4286              CMP      r6,r0
0002a0  d33b              BCC      |L1.794|
;;;1635   			{
;;;1636   				for( ;; )
0002a2  bf00              NOP      
                  |L1.676|
;;;1637   				{
;;;1638   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0002a4  485d              LDR      r0,|L1.1052|
0002a6  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
0002a8  6800              LDR      r0,[r0,#0]
0002aa  b908              CBNZ     r0,|L1.688|
0002ac  2001              MOVS     r0,#1
0002ae  e000              B        |L1.690|
                  |L1.688|
0002b0  2000              MOVS     r0,#0
                  |L1.690|
0002b2  b120              CBZ      r0,|L1.702|
;;;1639   					{
;;;1640   						/* The delayed list is empty.  Set xNextTaskUnblockTime to
;;;1641   						the	maximum possible value so it is extremely unlikely that
;;;1642   						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1643   						next time through. */
;;;1644   						xNextTaskUnblockTime = portMAX_DELAY;
0002b4  f04f30ff          MOV      r0,#0xffffffff
0002b8  4963              LDR      r1,|L1.1096|
0002ba  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1645   						break;
0002bc  e02c              B        |L1.792|
                  |L1.702|
;;;1646   					}
;;;1647   					else
;;;1648   					{
;;;1649   						/* The delayed list is not empty, get the value of the item
;;;1650   						at the head of the delayed list.  This is the time at which
;;;1651   						the task at the head of the delayed list must be removed
;;;1652   						from the Blocked state. */
;;;1653   						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0002be  4857              LDR      r0,|L1.1052|
0002c0  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
0002c2  68c0              LDR      r0,[r0,#0xc]
0002c4  68c4              LDR      r4,[r0,#0xc]
;;;1654   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
0002c6  6865              LDR      r5,[r4,#4]
;;;1655   
;;;1656   						if( xConstTickCount < xItemValue )
0002c8  42ae              CMP      r6,r5
0002ca  d202              BCS      |L1.722|
;;;1657   						{
;;;1658   							/* It is not time to unblock this item yet, but the item
;;;1659   							value is the time at which the task at the head of the
;;;1660   							blocked list must be removed from the Blocked state -
;;;1661   							so record the item value in xNextTaskUnblockTime. */
;;;1662   							xNextTaskUnblockTime = xItemValue;
0002cc  485e              LDR      r0,|L1.1096|
0002ce  6005              STR      r5,[r0,#0]  ; xNextTaskUnblockTime
;;;1663   							break;
0002d0  e022              B        |L1.792|
                  |L1.722|
;;;1664   						}
;;;1665   
;;;1666   						/* It is time to remove the item from the Blocked state. */
;;;1667   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
0002d2  1d20              ADDS     r0,r4,#4
0002d4  f7fffffe          BL       uxListRemove
;;;1668   
;;;1669   						/* Is the task waiting on an event also?  If so remove it
;;;1670   						from the event list. */
;;;1671   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0002d8  6aa0              LDR      r0,[r4,#0x28]
0002da  b118              CBZ      r0,|L1.740|
;;;1672   						{
;;;1673   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0002dc  f1040018          ADD      r0,r4,#0x18
0002e0  f7fffffe          BL       uxListRemove
                  |L1.740|
;;;1674   						}
;;;1675   
;;;1676   						/* Place the unblocked task into the appropriate ready
;;;1677   						list. */
;;;1678   						prvAddTaskToReadyList( pxTCB );
0002e4  f894102c          LDRB     r1,[r4,#0x2c]
0002e8  2001              MOVS     r0,#1
0002ea  4088              LSLS     r0,r0,r1
0002ec  4951              LDR      r1,|L1.1076|
0002ee  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0002f0  4308              ORRS     r0,r0,r1
0002f2  4950              LDR      r1,|L1.1076|
0002f4  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0002f6  6ae1              LDR      r1,[r4,#0x2c]
0002f8  eb010181          ADD      r1,r1,r1,LSL #2
0002fc  4a41              LDR      r2,|L1.1028|
0002fe  eb020081          ADD      r0,r2,r1,LSL #2
000302  1d21              ADDS     r1,r4,#4
000304  f7fffffe          BL       vListInsertEnd
;;;1679   
;;;1680   						/* A task being unblocked cannot cause an immediate context
;;;1681   						switch if preemption is turned off. */
;;;1682   						#if (  configUSE_PREEMPTION == 1 )
;;;1683   						{
;;;1684   							/* Preemption is on, but a context switch should only
;;;1685   							be performed if the unblocked task has a priority that
;;;1686   							is equal to or higher than the currently executing
;;;1687   							task. */
;;;1688   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000308  4947              LDR      r1,|L1.1064|
00030a  6ae0              LDR      r0,[r4,#0x2c]
00030c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00030e  6ac9              LDR      r1,[r1,#0x2c]
000310  4288              CMP      r0,r1
000312  d3c7              BCC      |L1.676|
;;;1689   							{
;;;1690   								xSwitchRequired = pdTRUE;
000314  2701              MOVS     r7,#1
000316  e7c5              B        |L1.676|
                  |L1.792|
000318  bf00              NOP                            ;1645
                  |L1.794|
;;;1691   							}
;;;1692   						}
;;;1693   						#endif /* configUSE_PREEMPTION */
;;;1694   					}
;;;1695   				}
;;;1696   			}
;;;1697   		}
;;;1698   
;;;1699   		/* Tasks of equal priority to the currently running task will share
;;;1700   		processing time (time slice) if preemption is on, and the application
;;;1701   		writer has not explicitly turned time slicing off. */
;;;1702   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;1703   		{
;;;1704   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
00031a  4843              LDR      r0,|L1.1064|
00031c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00031e  6ac0              LDR      r0,[r0,#0x2c]
000320  eb000080          ADD      r0,r0,r0,LSL #2
000324  4937              LDR      r1,|L1.1028|
000326  f8510020          LDR      r0,[r1,r0,LSL #2]
00032a  2801              CMP      r0,#1
00032c  d907              BLS      |L1.830|
;;;1705   			{
;;;1706   				xSwitchRequired = pdTRUE;
00032e  2701              MOVS     r7,#1
000330  e005              B        |L1.830|
000332  e7ff              B        |L1.820|
                  |L1.820|
;;;1707   			}
;;;1708   		}
;;;1709   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;1710   
;;;1711   		#if ( configUSE_TICK_HOOK == 1 )
;;;1712   		{
;;;1713   			/* Guard against the tick hook being called when the pended tick
;;;1714   			count is being unwound (when the scheduler is being unlocked). */
;;;1715   			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
;;;1716   			{
;;;1717   				vApplicationTickHook();
;;;1718   			}
;;;1719   		}
;;;1720   		#endif /* configUSE_TICK_HOOK */
;;;1721   	}
;;;1722   	else
;;;1723   	{
;;;1724   		++uxPendedTicks;
000334  4845              LDR      r0,|L1.1100|
000336  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000338  1c40              ADDS     r0,r0,#1
00033a  4944              LDR      r1,|L1.1100|
00033c  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L1.830|
;;;1725   
;;;1726   		/* The tick hook gets called at regular intervals, even if the
;;;1727   		scheduler is locked. */
;;;1728   		#if ( configUSE_TICK_HOOK == 1 )
;;;1729   		{
;;;1730   			vApplicationTickHook();
;;;1731   		}
;;;1732   		#endif
;;;1733   	}
;;;1734   
;;;1735   	#if ( configUSE_PREEMPTION == 1 )
;;;1736   	{
;;;1737   		if( xYieldPending != pdFALSE )
00033e  4844              LDR      r0,|L1.1104|
000340  6800              LDR      r0,[r0,#0]  ; xYieldPending
000342  b100              CBZ      r0,|L1.838|
;;;1738   		{
;;;1739   			xSwitchRequired = pdTRUE;
000344  2701              MOVS     r7,#1
                  |L1.838|
;;;1740   		}
;;;1741   	}
;;;1742   	#endif /* configUSE_PREEMPTION */
;;;1743   
;;;1744   	return xSwitchRequired;
000346  4638              MOV      r0,r7
;;;1745   }
000348  e8bd81f0          POP      {r4-r8,pc}
;;;1746   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1362   
;;;1363   signed portBASE_TYPE xTaskResumeAll( void )
00034c  b570              PUSH     {r4-r6,lr}
;;;1364   {
;;;1365   tskTCB *pxTCB;
;;;1366   portBASE_TYPE xAlreadyYielded = pdFALSE;
00034e  2500              MOVS     r5,#0
;;;1367   
;;;1368   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1369   	previous call to vTaskSuspendAll(). */
;;;1370   	configASSERT( uxSchedulerSuspended );
;;;1371   
;;;1372   	/* It is possible that an ISR caused a task to be removed from an event
;;;1373   	list while the scheduler was suspended.  If this was the case then the
;;;1374   	removed task will have been added to the xPendingReadyList.  Once the
;;;1375   	scheduler has been resumed it is safe to move all the pending ready
;;;1376   	tasks from this list into their appropriate ready list. */
;;;1377   	taskENTER_CRITICAL();
000350  f7fffffe          BL       vPortEnterCritical
;;;1378   	{
;;;1379   		--uxSchedulerSuspended;
000354  4839              LDR      r0,|L1.1084|
000356  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000358  1e40              SUBS     r0,r0,#1
00035a  4938              LDR      r1,|L1.1084|
00035c  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1380   
;;;1381   		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00035e  4608              MOV      r0,r1
000360  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000362  2800              CMP      r0,#0
000364  d14b              BNE      |L1.1022|
;;;1382   		{
;;;1383   			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
000366  482f              LDR      r0,|L1.1060|
000368  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00036a  2800              CMP      r0,#0
00036c  d047              BEQ      |L1.1022|
;;;1384   			{
;;;1385   				/* Move any readied tasks from the pending list into the
;;;1386   				appropriate ready list. */
;;;1387   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
00036e  e024              B        |L1.954|
                  |L1.880|
;;;1388   				{
;;;1389   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000370  4827              LDR      r0,|L1.1040|
000372  68c0              LDR      r0,[r0,#0xc]
000374  68c4              LDR      r4,[r0,#0xc]
;;;1390   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000376  f1040018          ADD      r0,r4,#0x18
00037a  f7fffffe          BL       uxListRemove
;;;1391   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
00037e  1d20              ADDS     r0,r4,#4
000380  f7fffffe          BL       uxListRemove
;;;1392   					prvAddTaskToReadyList( pxTCB );
000384  f894102c          LDRB     r1,[r4,#0x2c]
000388  2001              MOVS     r0,#1
00038a  4088              LSLS     r0,r0,r1
00038c  4929              LDR      r1,|L1.1076|
00038e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000390  4308              ORRS     r0,r0,r1
000392  4928              LDR      r1,|L1.1076|
000394  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000396  6ae1              LDR      r1,[r4,#0x2c]
000398  eb010181          ADD      r1,r1,r1,LSL #2
00039c  4a19              LDR      r2,|L1.1028|
00039e  eb020081          ADD      r0,r2,r1,LSL #2
0003a2  1d21              ADDS     r1,r4,#4
0003a4  f7fffffe          BL       vListInsertEnd
;;;1393   
;;;1394   					/* If we have moved a task that has a priority higher than
;;;1395   					the current task then we should yield. */
;;;1396   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0003a8  491f              LDR      r1,|L1.1064|
0003aa  6ae0              LDR      r0,[r4,#0x2c]
0003ac  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0003ae  6ac9              LDR      r1,[r1,#0x2c]
0003b0  4288              CMP      r0,r1
0003b2  d302              BCC      |L1.954|
;;;1397   					{
;;;1398   						xYieldPending = pdTRUE;
0003b4  2001              MOVS     r0,#1
0003b6  4926              LDR      r1,|L1.1104|
0003b8  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.954|
0003ba  4815              LDR      r0,|L1.1040|
0003bc  6800              LDR      r0,[r0,#0]            ;1387  ; xPendingReadyList
0003be  b908              CBNZ     r0,|L1.964|
0003c0  2001              MOVS     r0,#1                 ;1387
0003c2  e000              B        |L1.966|
                  |L1.964|
0003c4  2000              MOVS     r0,#0                 ;1387
                  |L1.966|
0003c6  2800              CMP      r0,#0                 ;1387
0003c8  d0d2              BEQ      |L1.880|
;;;1399   					}
;;;1400   				}
;;;1401   
;;;1402   				/* If any ticks occurred while the scheduler was suspended then
;;;1403   				they should be processed now.  This ensures the tick count does not
;;;1404   				slip, and that any delayed tasks are resumed at the correct time. */
;;;1405   				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
0003ca  4820              LDR      r0,|L1.1100|
0003cc  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003ce  b178              CBZ      r0,|L1.1008|
;;;1406   				{
;;;1407   					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
0003d0  e00a              B        |L1.1000|
                  |L1.978|
;;;1408   					{
;;;1409   						if( xTaskIncrementTick() != pdFALSE )
0003d2  f7fffffe          BL       xTaskIncrementTick
0003d6  b110              CBZ      r0,|L1.990|
;;;1410   						{
;;;1411   							xYieldPending = pdTRUE;
0003d8  2001              MOVS     r0,#1
0003da  491d              LDR      r1,|L1.1104|
0003dc  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.990|
;;;1412   						}
;;;1413   						--uxPendedTicks;
0003de  481b              LDR      r0,|L1.1100|
0003e0  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003e2  1e40              SUBS     r0,r0,#1
0003e4  4919              LDR      r1,|L1.1100|
0003e6  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L1.1000|
0003e8  4818              LDR      r0,|L1.1100|
0003ea  6800              LDR      r0,[r0,#0]            ;1407  ; uxPendedTicks
0003ec  2800              CMP      r0,#0                 ;1407
0003ee  d1f0              BNE      |L1.978|
                  |L1.1008|
;;;1414   					}
;;;1415   				}
;;;1416   
;;;1417   				if( xYieldPending == pdTRUE )
0003f0  4817              LDR      r0,|L1.1104|
0003f2  6800              LDR      r0,[r0,#0]  ; xYieldPending
0003f4  2801              CMP      r0,#1
0003f6  d102              BNE      |L1.1022|
;;;1418   				{
;;;1419   					#if( configUSE_PREEMPTION != 0 )
;;;1420   					{
;;;1421   						xAlreadyYielded = pdTRUE;
0003f8  2501              MOVS     r5,#1
;;;1422   					}
;;;1423   					#endif
;;;1424   					taskYIELD_IF_USING_PREEMPTION();
0003fa  f7fffffe          BL       vPortYield
                  |L1.1022|
;;;1425   				}
;;;1426   			}
;;;1427   		}
;;;1428   	}
;;;1429   	taskEXIT_CRITICAL();
0003fe  f7fffffe          BL       vPortExitCritical
;;;1430   
;;;1431   	return xAlreadyYielded;
000402  e027              B        |L1.1108|
                  |L1.1028|
                          DCD      pxReadyTasksLists
                  |L1.1032|
                          DCD      xDelayedTaskList1
                  |L1.1036|
                          DCD      xDelayedTaskList2
                  |L1.1040|
                          DCD      xPendingReadyList
                  |L1.1044|
                          DCD      xTasksWaitingTermination
                  |L1.1048|
                          DCD      xSuspendedTaskList
                  |L1.1052|
                          DCD      pxDelayedTaskList
                  |L1.1056|
                          DCD      pxOverflowDelayedTaskList
                  |L1.1060|
                          DCD      uxCurrentNumberOfTasks
                  |L1.1064|
                          DCD      pxCurrentTCB
                  |L1.1068|
                          DCD      xSchedulerRunning
                  |L1.1072|
                          DCD      uxTaskNumber
                  |L1.1076|
                          DCD      uxTopReadyPriority
                  |L1.1080|
                          DCD      uxTasksDeleted
                  |L1.1084|
                          DCD      uxSchedulerSuspended
                  |L1.1088|
                          DCD      xTickCount
                  |L1.1092|
                          DCD      xNumOfOverflows
                  |L1.1096|
                          DCD      xNextTaskUnblockTime
                  |L1.1100|
                          DCD      uxPendedTicks
                  |L1.1104|
                          DCD      xYieldPending
                  |L1.1108|
000454  4628              MOV      r0,r5
;;;1432   }
000456  bd70              POP      {r4-r6,pc}
;;;1433   /*-----------------------------------------------------------*/
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;2446   
;;;2447   static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
000458  b510              PUSH     {r4,lr}
;;;2448   {
00045a  4604              MOV      r4,r0
;;;2449   	/* The list item will be inserted in wake time order. */
;;;2450   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
00045c  48fa              LDR      r0,|L1.2120|
00045e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000460  6044              STR      r4,[r0,#4]
;;;2451   
;;;2452   	if( xTimeToWake < xTickCount )
000462  48fa              LDR      r0,|L1.2124|
000464  6800              LDR      r0,[r0,#0]  ; xTickCount
000466  4284              CMP      r4,r0
000468  d207              BCS      |L1.1146|
;;;2453   	{
;;;2454   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2455   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00046a  48f7              LDR      r0,|L1.2120|
00046c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00046e  1d09              ADDS     r1,r1,#4
000470  48f7              LDR      r0,|L1.2128|
000472  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000474  f7fffffe          BL       vListInsert
000478  e00c              B        |L1.1172|
                  |L1.1146|
;;;2456   	}
;;;2457   	else
;;;2458   	{
;;;2459   		/* The wake time has not overflowed, so we can use the current block list. */
;;;2460   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00047a  48f3              LDR      r0,|L1.2120|
00047c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00047e  1d09              ADDS     r1,r1,#4
000480  48f4              LDR      r0,|L1.2132|
000482  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000484  f7fffffe          BL       vListInsert
;;;2461   
;;;2462   		/* If the task entering the blocked state was placed at the head of the
;;;2463   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2464   		too. */
;;;2465   		if( xTimeToWake < xNextTaskUnblockTime )
000488  48f3              LDR      r0,|L1.2136|
00048a  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
00048c  4284              CMP      r4,r0
00048e  d201              BCS      |L1.1172|
;;;2466   		{
;;;2467   			xNextTaskUnblockTime = xTimeToWake;
000490  48f1              LDR      r0,|L1.2136|
000492  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L1.1172|
;;;2468   		}
;;;2469   	}
;;;2470   }
000494  bd10              POP      {r4,pc}
;;;2471   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1326   
;;;1327   void vTaskSuspendAll( void )
000496  48f1              LDR      r0,|L1.2140|
;;;1328   {
;;;1329   	/* A critical section is not required as the variable is of type
;;;1330   	portBASE_TYPE. */
;;;1331   	++uxSchedulerSuspended;
000498  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00049a  1c40              ADDS     r0,r0,#1
00049c  49ef              LDR      r1,|L1.2140|
00049e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1332   }
0004a0  4770              BX       lr
;;;1333   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;696    
;;;697    	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
0004a2  e92d47f0          PUSH     {r4-r10,lr}
;;;698    	{
0004a6  4604              MOV      r4,r0
0004a8  4688              MOV      r8,r1
;;;699    	portTickType xTimeToWake;
;;;700    	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
0004aa  f04f0900          MOV      r9,#0
;;;701    
;;;702    		configASSERT( pxPreviousWakeTime );
;;;703    		configASSERT( ( xTimeIncrement > 0U ) );
;;;704    
;;;705    		vTaskSuspendAll();
0004ae  f7fffffe          BL       vTaskSuspendAll
;;;706    		{
;;;707    			/* Minor optimisation.  The tick count cannot change in this
;;;708    			block. */
;;;709    			const portTickType xConstTickCount = xTickCount;
0004b2  48e6              LDR      r0,|L1.2124|
0004b4  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;710    
;;;711    			/* Generate the tick time at which the task wants to wake. */
;;;712    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
0004b6  6820              LDR      r0,[r4,#0]
0004b8  eb000508          ADD      r5,r0,r8
;;;713    
;;;714    			if( xConstTickCount < *pxPreviousWakeTime )
0004bc  6820              LDR      r0,[r4,#0]
0004be  42b8              CMP      r0,r7
0004c0  d907              BLS      |L1.1234|
;;;715    			{
;;;716    				/* The tick count has overflowed since this function was
;;;717    				lasted called.  In this case the only time we should ever
;;;718    				actually delay is if the wake time has also	overflowed,
;;;719    				and the wake time is greater than the tick time.  When this
;;;720    				is the case it is as if neither time had overflowed. */
;;;721    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0004c2  6820              LDR      r0,[r4,#0]
0004c4  42a8              CMP      r0,r5
0004c6  d90b              BLS      |L1.1248|
0004c8  42bd              CMP      r5,r7
0004ca  d909              BLS      |L1.1248|
;;;722    				{
;;;723    					xShouldDelay = pdTRUE;
0004cc  f04f0901          MOV      r9,#1
0004d0  e006              B        |L1.1248|
                  |L1.1234|
;;;724    				}
;;;725    			}
;;;726    			else
;;;727    			{
;;;728    				/* The tick time has not overflowed.  In this case we will
;;;729    				delay if either the wake time has overflowed, and/or the
;;;730    				tick time is less than the wake time. */
;;;731    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0004d2  6820              LDR      r0,[r4,#0]
0004d4  42a8              CMP      r0,r5
0004d6  d801              BHI      |L1.1244|
0004d8  42bd              CMP      r5,r7
0004da  d901              BLS      |L1.1248|
                  |L1.1244|
;;;732    				{
;;;733    					xShouldDelay = pdTRUE;
0004dc  f04f0901          MOV      r9,#1
                  |L1.1248|
;;;734    				}
;;;735    			}
;;;736    
;;;737    			/* Update the wake time ready for the next call. */
;;;738    			*pxPreviousWakeTime = xTimeToWake;
0004e0  6025              STR      r5,[r4,#0]
;;;739    
;;;740    			if( xShouldDelay != pdFALSE )
0004e2  f1b90f00          CMP      r9,#0
0004e6  d013              BEQ      |L1.1296|
;;;741    			{
;;;742    				traceTASK_DELAY_UNTIL();
;;;743    
;;;744    				/* We must remove ourselves from the ready list before adding
;;;745    				ourselves to the blocked list as the same list item is used for
;;;746    				both lists. */
;;;747    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0004e8  48d7              LDR      r0,|L1.2120|
0004ea  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0004ec  1d00              ADDS     r0,r0,#4
0004ee  f7fffffe          BL       uxListRemove
0004f2  b950              CBNZ     r0,|L1.1290|
;;;748    				{
;;;749    					/* The current task must be in a ready list, so there is
;;;750    					no need to check, and the port reset macro can be called
;;;751    					directly. */
;;;752    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
0004f4  48d4              LDR      r0,|L1.2120|
0004f6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0004f8  f890102c          LDRB     r1,[r0,#0x2c]
0004fc  2001              MOVS     r0,#1
0004fe  4088              LSLS     r0,r0,r1
000500  49d7              LDR      r1,|L1.2144|
000502  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000504  4381              BICS     r1,r1,r0
000506  48d6              LDR      r0,|L1.2144|
000508  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1290|
;;;753    				}
;;;754    
;;;755    				prvAddCurrentTaskToDelayedList( xTimeToWake );
00050a  4628              MOV      r0,r5
00050c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1296|
;;;756    			}
;;;757    		}
;;;758    		xAlreadyYielded = xTaskResumeAll();
000510  f7fffffe          BL       xTaskResumeAll
000514  4606              MOV      r6,r0
;;;759    
;;;760    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;761    		have put ourselves to sleep. */
;;;762    		if( xAlreadyYielded == pdFALSE )
000516  b90e              CBNZ     r6,|L1.1308|
;;;763    		{
;;;764    			portYIELD_WITHIN_API();
000518  f7fffffe          BL       vPortYield
                  |L1.1308|
;;;765    		}
;;;766    	}
00051c  e8bd87f0          POP      {r4-r10,pc}
;;;767    
                          ENDP

                  vTaskDelay PROC
;;;772    
;;;773    	void vTaskDelay( portTickType xTicksToDelay )
000520  b570              PUSH     {r4-r6,lr}
;;;774    	{
000522  4604              MOV      r4,r0
;;;775    	portTickType xTimeToWake;
;;;776    	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
000524  2600              MOVS     r6,#0
;;;777    
;;;778    		/* A delay time of zero just forces a reschedule. */
;;;779    		if( xTicksToDelay > ( portTickType ) 0U )
000526  b1dc              CBZ      r4,|L1.1376|
;;;780    		{
;;;781    			vTaskSuspendAll();
000528  f7fffffe          BL       vTaskSuspendAll
;;;782    			{
;;;783    				traceTASK_DELAY();
;;;784    
;;;785    				/* A task that is removed from the event list while the
;;;786    				scheduler is suspended will not get placed in the ready
;;;787    				list or removed from the blocked list until the scheduler
;;;788    				is resumed.
;;;789    
;;;790    				This task cannot be in an event list as it is the currently
;;;791    				executing task. */
;;;792    
;;;793    				/* Calculate the time to wake - this may overflow but this is
;;;794    				not a problem. */
;;;795    				xTimeToWake = xTickCount + xTicksToDelay;
00052c  48c7              LDR      r0,|L1.2124|
00052e  6800              LDR      r0,[r0,#0]  ; xTickCount
000530  1905              ADDS     r5,r0,r4
;;;796    
;;;797    				/* We must remove ourselves from the ready list before adding
;;;798    				ourselves to the blocked list as the same list item is used for
;;;799    				both lists. */
;;;800    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000532  48c5              LDR      r0,|L1.2120|
000534  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000536  1d00              ADDS     r0,r0,#4
000538  f7fffffe          BL       uxListRemove
00053c  b950              CBNZ     r0,|L1.1364|
;;;801    				{
;;;802    					/* The current task must be in a ready list, so there is
;;;803    					no need to check, and the port reset macro can be called
;;;804    					directly. */
;;;805    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00053e  48c2              LDR      r0,|L1.2120|
000540  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000542  f890102c          LDRB     r1,[r0,#0x2c]
000546  2001              MOVS     r0,#1
000548  4088              LSLS     r0,r0,r1
00054a  49c5              LDR      r1,|L1.2144|
00054c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00054e  4381              BICS     r1,r1,r0
000550  48c3              LDR      r0,|L1.2144|
000552  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1364|
;;;806    				}
;;;807    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000554  4628              MOV      r0,r5
000556  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;808    			}
;;;809    			xAlreadyYielded = xTaskResumeAll();
00055a  f7fffffe          BL       xTaskResumeAll
00055e  4606              MOV      r6,r0
                  |L1.1376|
;;;810    		}
;;;811    
;;;812    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;813    		have put ourselves to sleep. */
;;;814    		if( xAlreadyYielded == pdFALSE )
000560  b90e              CBNZ     r6,|L1.1382|
;;;815    		{
;;;816    			portYIELD_WITHIN_API();
000562  f7fffffe          BL       vPortYield
                  |L1.1382|
;;;817    		}
;;;818    	}
000566  bd70              POP      {r4-r6,pc}
;;;819    
                          ENDP

                  eTaskGetState PROC
;;;824    
;;;825    	eTaskState eTaskGetState( xTaskHandle xTask )
000568  e92d41f0          PUSH     {r4-r8,lr}
;;;826    	{
00056c  4606              MOV      r6,r0
;;;827    	eTaskState eReturn;
;;;828    	xList *pxStateList;
;;;829    	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
00056e  4637              MOV      r7,r6
;;;830    
;;;831    		if( pxTCB == pxCurrentTCB )
000570  48b5              LDR      r0,|L1.2120|
000572  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000574  4287              CMP      r7,r0
000576  d101              BNE      |L1.1404|
;;;832    		{
;;;833    			/* The task calling this function is querying its own state. */
;;;834    			eReturn = eRunning;
000578  2400              MOVS     r4,#0
00057a  e01d              B        |L1.1464|
                  |L1.1404|
;;;835    		}
;;;836    		else
;;;837    		{
;;;838    			taskENTER_CRITICAL();
00057c  f7fffffe          BL       vPortEnterCritical
;;;839    			{
;;;840    				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
000580  697d              LDR      r5,[r7,#0x14]
;;;841    			}
;;;842    			taskEXIT_CRITICAL();
000582  f7fffffe          BL       vPortExitCritical
;;;843    
;;;844    			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
000586  48b3              LDR      r0,|L1.2132|
000588  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00058a  4285              CMP      r5,r0
00058c  d003              BEQ      |L1.1430|
00058e  48b0              LDR      r0,|L1.2128|
000590  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000592  4285              CMP      r5,r0
000594  d101              BNE      |L1.1434|
                  |L1.1430|
;;;845    			{
;;;846    				/* The task being queried is referenced from one of the Blocked
;;;847    				lists. */
;;;848    				eReturn = eBlocked;
000596  2402              MOVS     r4,#2
000598  e00e              B        |L1.1464|
                  |L1.1434|
;;;849    			}
;;;850    
;;;851    			#if ( INCLUDE_vTaskSuspend == 1 )
;;;852    				else if( pxStateList == &xSuspendedTaskList )
00059a  48b2              LDR      r0,|L1.2148|
00059c  4285              CMP      r5,r0
00059e  d105              BNE      |L1.1452|
;;;853    				{
;;;854    					/* The task being queried is referenced from the suspended
;;;855    					list.  Is it genuinely suspended or is it block
;;;856    					indefinitely? */
;;;857    					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
0005a0  6ab8              LDR      r0,[r7,#0x28]
0005a2  b908              CBNZ     r0,|L1.1448|
;;;858    					{
;;;859    						eReturn = eSuspended;
0005a4  2403              MOVS     r4,#3
0005a6  e007              B        |L1.1464|
                  |L1.1448|
;;;860    					}
;;;861    					else
;;;862    					{
;;;863    						eReturn = eBlocked;
0005a8  2402              MOVS     r4,#2
0005aa  e005              B        |L1.1464|
                  |L1.1452|
;;;864    					}
;;;865    				}
;;;866    			#endif
;;;867    
;;;868    			#if ( INCLUDE_vTaskDelete == 1 )
;;;869    				else if( pxStateList == &xTasksWaitingTermination )
0005ac  48ae              LDR      r0,|L1.2152|
0005ae  4285              CMP      r5,r0
0005b0  d101              BNE      |L1.1462|
;;;870    				{
;;;871    					/* The task being queried is referenced from the deleted
;;;872    					tasks list. */
;;;873    					eReturn = eDeleted;
0005b2  2404              MOVS     r4,#4
0005b4  e000              B        |L1.1464|
                  |L1.1462|
;;;874    				}
;;;875    			#endif
;;;876    
;;;877    			else
;;;878    			{
;;;879    				/* If the task is not in any other state, it must be in the
;;;880    				Ready (including pending ready) state. */
;;;881    				eReturn = eReady;
0005b6  2401              MOVS     r4,#1
                  |L1.1464|
;;;882    			}
;;;883    		}
;;;884    
;;;885    		return eReturn;
0005b8  4620              MOV      r0,r4
;;;886    	}
0005ba  e8bd81f0          POP      {r4-r8,pc}
;;;887    
                          ENDP

                  uxTaskPriorityGet PROC
;;;892    
;;;893    	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
0005be  b570              PUSH     {r4-r6,lr}
;;;894    	{
0005c0  4604              MOV      r4,r0
;;;895    	tskTCB *pxTCB;
;;;896    	unsigned portBASE_TYPE uxReturn;
;;;897    
;;;898    		taskENTER_CRITICAL();
0005c2  f7fffffe          BL       vPortEnterCritical
;;;899    		{
;;;900    			/* If null is passed in here then we are changing the
;;;901    			priority of the calling function. */
;;;902    			pxTCB = prvGetTCBFromHandle( xTask );
0005c6  b914              CBNZ     r4,|L1.1486|
0005c8  489f              LDR      r0,|L1.2120|
0005ca  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005cc  e000              B        |L1.1488|
                  |L1.1486|
0005ce  4620              MOV      r0,r4
                  |L1.1488|
0005d0  4606              MOV      r6,r0
;;;903    			uxReturn = pxTCB->uxPriority;
0005d2  6af5              LDR      r5,[r6,#0x2c]
;;;904    		}
;;;905    		taskEXIT_CRITICAL();
0005d4  f7fffffe          BL       vPortExitCritical
;;;906    
;;;907    		return uxReturn;
0005d8  4628              MOV      r0,r5
;;;908    	}
0005da  bd70              POP      {r4-r6,pc}
;;;909    
                          ENDP

                  vTaskPrioritySet PROC
;;;914    
;;;915    	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
0005dc  e92d47f0          PUSH     {r4-r10,lr}
;;;916    	{
0005e0  4680              MOV      r8,r0
0005e2  460d              MOV      r5,r1
;;;917    	tskTCB *pxTCB;
;;;918    	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;919    	portBASE_TYPE xYieldRequired = pdFALSE;
0005e4  f04f0900          MOV      r9,#0
;;;920    
;;;921    		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;922    
;;;923    		/* Ensure the new priority is valid. */
;;;924    		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
0005e8  2d0a              CMP      r5,#0xa
0005ea  d300              BCC      |L1.1518|
;;;925    		{
;;;926    			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
0005ec  2509              MOVS     r5,#9
                  |L1.1518|
;;;927    		}
;;;928    
;;;929    		taskENTER_CRITICAL();
0005ee  f7fffffe          BL       vPortEnterCritical
;;;930    		{
;;;931    			/* If null is passed in here then it is the priority of the calling
;;;932    			task that is being changed. */
;;;933    			pxTCB = prvGetTCBFromHandle( xTask );
0005f2  f1b80f00          CMP      r8,#0
0005f6  d102              BNE      |L1.1534|
0005f8  4893              LDR      r0,|L1.2120|
0005fa  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0005fc  e000              B        |L1.1536|
                  |L1.1534|
0005fe  4640              MOV      r0,r8
                  |L1.1536|
000600  4604              MOV      r4,r0
;;;934    
;;;935    			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;936    
;;;937    			#if ( configUSE_MUTEXES == 1 )
;;;938    			{
;;;939    				uxCurrentBasePriority = pxTCB->uxBasePriority;
000602  6ca6              LDR      r6,[r4,#0x48]
;;;940    			}
;;;941    			#else
;;;942    			{
;;;943    				uxCurrentBasePriority = pxTCB->uxPriority;
;;;944    			}
;;;945    			#endif
;;;946    
;;;947    			if( uxCurrentBasePriority != uxNewPriority )
000604  42ae              CMP      r6,r5
000606  d04c              BEQ      |L1.1698|
;;;948    			{
;;;949    				/* The priority change may have readied a task of higher
;;;950    				priority than the calling task. */
;;;951    				if( uxNewPriority > uxCurrentBasePriority )
000608  42b5              CMP      r5,r6
00060a  d90b              BLS      |L1.1572|
;;;952    				{
;;;953    					if( pxTCB != pxCurrentTCB )
00060c  488e              LDR      r0,|L1.2120|
00060e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000610  4284              CMP      r4,r0
000612  d00d              BEQ      |L1.1584|
;;;954    					{
;;;955    						/* The priority of a task other than the currently
;;;956    						running task is being raised.  Is the priority being
;;;957    						raised above that of the running task? */
;;;958    						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000614  488c              LDR      r0,|L1.2120|
000616  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000618  6ac0              LDR      r0,[r0,#0x2c]
00061a  42a8              CMP      r0,r5
00061c  d808              BHI      |L1.1584|
;;;959    						{
;;;960    							xYieldRequired = pdTRUE;
00061e  f04f0901          MOV      r9,#1
000622  e005              B        |L1.1584|
                  |L1.1572|
;;;961    						}
;;;962    					}
;;;963    					else
;;;964    					{
;;;965    						/* The priority of the running task is being raised,
;;;966    						but the running task must already be the highest
;;;967    						priority task able to run so no yield is required. */
;;;968    					}
;;;969    				}
;;;970    				else if( pxTCB == pxCurrentTCB )
000624  4888              LDR      r0,|L1.2120|
000626  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000628  4284              CMP      r4,r0
00062a  d101              BNE      |L1.1584|
;;;971    				{
;;;972    					/* Setting the priority of the running task down means
;;;973    					there may now be another task of higher priority that
;;;974    					is ready to execute. */
;;;975    					xYieldRequired = pdTRUE;
00062c  f04f0901          MOV      r9,#1
                  |L1.1584|
;;;976    				}
;;;977    				else
;;;978    				{
;;;979    					/* Setting the priority of any other task down does not
;;;980    					require a yield as the running task must be above the
;;;981    					new priority of the task being modified. */
;;;982    				}
;;;983    
;;;984    				/* Remember the ready list the task might be referenced from
;;;985    				before its uxPriority member is changed so the
;;;986    				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;987    				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000630  6ae7              LDR      r7,[r4,#0x2c]
;;;988    
;;;989    				#if ( configUSE_MUTEXES == 1 )
;;;990    				{
;;;991    					/* Only change the priority being used if the task is not
;;;992    					currently using an inherited priority. */
;;;993    					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000632  6ae1              LDR      r1,[r4,#0x2c]
000634  6ca0              LDR      r0,[r4,#0x48]
000636  4288              CMP      r0,r1
000638  d100              BNE      |L1.1596|
;;;994    					{
;;;995    						pxTCB->uxPriority = uxNewPriority;
00063a  62e5              STR      r5,[r4,#0x2c]
                  |L1.1596|
;;;996    					}
;;;997    
;;;998    					/* The base priority gets set whatever. */
;;;999    					pxTCB->uxBasePriority = uxNewPriority;
00063c  64a5              STR      r5,[r4,#0x48]
;;;1000   				}
;;;1001   				#else
;;;1002   				{
;;;1003   					pxTCB->uxPriority = uxNewPriority;
;;;1004   				}
;;;1005   				#endif
;;;1006   
;;;1007   				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00063e  f1c5000a          RSB      r0,r5,#0xa
000642  61a0              STR      r0,[r4,#0x18]
;;;1008   
;;;1009   				/* If the task is in the blocked or suspended list we need do
;;;1010   				nothing more than change it's priority variable. However, if
;;;1011   				the task is in a ready list it needs to be removed and placed
;;;1012   				in the list appropriate to its new priority. */
;;;1013   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000644  eb070187          ADD      r1,r7,r7,LSL #2
000648  4a88              LDR      r2,|L1.2156|
00064a  eb020181          ADD      r1,r2,r1,LSL #2
00064e  6960              LDR      r0,[r4,#0x14]
000650  4288              CMP      r0,r1
000652  d101              BNE      |L1.1624|
000654  2001              MOVS     r0,#1
000656  e000              B        |L1.1626|
                  |L1.1624|
000658  2000              MOVS     r0,#0
                  |L1.1626|
00065a  b1e0              CBZ      r0,|L1.1686|
;;;1014   				{
;;;1015   					/* The task is currently in its ready list - remove before adding
;;;1016   					it to it's new ready list.  As we are in a critical section we
;;;1017   					can do this even if the scheduler is suspended. */
;;;1018   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
00065c  1d20              ADDS     r0,r4,#4
00065e  f7fffffe          BL       uxListRemove
000662  b930              CBNZ     r0,|L1.1650|
;;;1019   					{
;;;1020   						/* It is known that the task is in its ready list so
;;;1021   						there is no need to check again and the port level
;;;1022   						reset macro can be called directly. */
;;;1023   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
000664  2001              MOVS     r0,#1
000666  40b8              LSLS     r0,r0,r7
000668  497d              LDR      r1,|L1.2144|
00066a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00066c  4381              BICS     r1,r1,r0
00066e  487c              LDR      r0,|L1.2144|
000670  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1650|
;;;1024   					}
;;;1025   					prvAddTaskToReadyList( pxTCB );
000672  f894102c          LDRB     r1,[r4,#0x2c]
000676  2001              MOVS     r0,#1
000678  4088              LSLS     r0,r0,r1
00067a  4979              LDR      r1,|L1.2144|
00067c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00067e  4308              ORRS     r0,r0,r1
000680  4977              LDR      r1,|L1.2144|
000682  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000684  6ae1              LDR      r1,[r4,#0x2c]
000686  eb010181          ADD      r1,r1,r1,LSL #2
00068a  4a78              LDR      r2,|L1.2156|
00068c  eb020081          ADD      r0,r2,r1,LSL #2
000690  1d21              ADDS     r1,r4,#4
000692  f7fffffe          BL       vListInsertEnd
                  |L1.1686|
;;;1026   				}
;;;1027   
;;;1028   				if( xYieldRequired == pdTRUE )
000696  f1b90f01          CMP      r9,#1
00069a  d101              BNE      |L1.1696|
;;;1029   				{
;;;1030   					taskYIELD_IF_USING_PREEMPTION();
00069c  f7fffffe          BL       vPortYield
                  |L1.1696|
;;;1031   				}
;;;1032   
;;;1033   				/* Remove compiler warning about unused variables when the port
;;;1034   				optimised task selection is not being used. */
;;;1035   				( void ) uxPriorityUsedOnEntry;
0006a0  bf00              NOP      
                  |L1.1698|
;;;1036   			}
;;;1037   		}
;;;1038   		taskEXIT_CRITICAL();
0006a2  f7fffffe          BL       vPortExitCritical
;;;1039   	}
0006a6  e8bd87f0          POP      {r4-r10,pc}
;;;1040   
                          ENDP

                  vTaskSwitchContext PROC
;;;1834   
;;;1835   void vTaskSwitchContext( void )
0006aa  b510              PUSH     {r4,lr}
;;;1836   {
;;;1837   	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
0006ac  486b              LDR      r0,|L1.2140|
0006ae  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0006b0  b118              CBZ      r0,|L1.1722|
;;;1838   	{
;;;1839   		/* The scheduler is currently suspended - do not allow a context
;;;1840   		switch. */
;;;1841   		xYieldPending = pdTRUE;
0006b2  2001              MOVS     r0,#1
0006b4  496e              LDR      r1,|L1.2160|
0006b6  6008              STR      r0,[r1,#0]  ; xYieldPending
0006b8  e039              B        |L1.1838|
                  |L1.1722|
;;;1842   	}
;;;1843   	else
;;;1844   	{
;;;1845   		xYieldPending = pdFALSE;
0006ba  2000              MOVS     r0,#0
0006bc  496c              LDR      r1,|L1.2160|
0006be  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;1846   		traceTASK_SWITCHED_OUT();
;;;1847   
;;;1848   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;1849   		{
;;;1850   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;1851   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;1852   				#else
;;;1853   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;1854   				#endif
;;;1855   
;;;1856   				/* Add the amount of time the task has been running to the
;;;1857   				accumulated	time so far.  The time the task started running was
;;;1858   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;1859   				protection here	so count values are only valid until the timer
;;;1860   				overflows.  The guard against negative values is to protect
;;;1861   				against suspect run time stat counter implementations - which
;;;1862   				are provided by the application, not the kernel. */
;;;1863   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;1864   				{
;;;1865   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;1866   				}
;;;1867   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;1868   		}
;;;1869   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;1870   
;;;1871   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
0006c0  4861              LDR      r0,|L1.2120|
0006c2  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0006c4  6800              LDR      r0,[r0,#0]
0006c6  4960              LDR      r1,|L1.2120|
0006c8  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0006ca  6b09              LDR      r1,[r1,#0x30]
0006cc  4288              CMP      r0,r1
0006ce  d805              BHI      |L1.1756|
0006d0  485d              LDR      r0,|L1.2120|
0006d2  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0006d4  3134              ADDS     r1,r1,#0x34
0006d6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0006d8  f7fffffe          BL       vApplicationStackOverflowHook
                  |L1.1756|
;;;1872   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
0006dc  495a              LDR      r1,|L1.2120|
0006de  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0006e0  2214              MOVS     r2,#0x14
0006e2  6b08              LDR      r0,[r1,#0x30]
0006e4  4963              LDR      r1,|L1.2164|
0006e6  f7fffffe          BL       memcmp
0006ea  b128              CBZ      r0,|L1.1784|
0006ec  4856              LDR      r0,|L1.2120|
0006ee  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0006f0  3134              ADDS     r1,r1,#0x34
0006f2  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0006f4  f7fffffe          BL       vApplicationStackOverflowHook
                  |L1.1784|
;;;1873   
;;;1874   		taskSELECT_HIGHEST_PRIORITY_TASK();
0006f8  4859              LDR      r0,|L1.2144|
0006fa  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
0006fc  fab0f080          CLZ      r0,r0
000700  f1c0011f          RSB      r1,r0,#0x1f
000704  eb010281          ADD      r2,r1,r1,LSL #2
000708  4b58              LDR      r3,|L1.2156|
00070a  eb030082          ADD      r0,r3,r2,LSL #2
00070e  6842              LDR      r2,[r0,#4]
000710  6852              LDR      r2,[r2,#4]
000712  6042              STR      r2,[r0,#4]
000714  f1000208          ADD      r2,r0,#8
000718  6843              LDR      r3,[r0,#4]
00071a  4293              CMP      r3,r2
00071c  d102              BNE      |L1.1828|
00071e  6842              LDR      r2,[r0,#4]
000720  6852              LDR      r2,[r2,#4]
000722  6042              STR      r2,[r0,#4]
                  |L1.1828|
000724  6842              LDR      r2,[r0,#4]
000726  68d2              LDR      r2,[r2,#0xc]
000728  4b47              LDR      r3,|L1.2120|
00072a  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
00072c  bf00              NOP      
                  |L1.1838|
;;;1875   
;;;1876   		traceTASK_SWITCHED_IN();
;;;1877   
;;;1878   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1879   		{
;;;1880   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1881   			structure specific to this task. */
;;;1882   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1883   		}
;;;1884   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1885   	}
;;;1886   }
00072e  bd10              POP      {r4,pc}
;;;1887   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1045   
;;;1046   	void vTaskSuspend( xTaskHandle xTaskToSuspend )
000730  b570              PUSH     {r4-r6,lr}
;;;1047   	{
000732  4605              MOV      r5,r0
;;;1048   	tskTCB *pxTCB;
;;;1049   
;;;1050   		taskENTER_CRITICAL();
000734  f7fffffe          BL       vPortEnterCritical
;;;1051   		{
;;;1052   			/* If null is passed in here then it is the running task that is
;;;1053   			being suspended. */
;;;1054   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000738  b915              CBNZ     r5,|L1.1856|
00073a  4843              LDR      r0,|L1.2120|
00073c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00073e  e000              B        |L1.1858|
                  |L1.1856|
000740  4628              MOV      r0,r5
                  |L1.1858|
000742  4604              MOV      r4,r0
;;;1055   
;;;1056   			traceTASK_SUSPEND( pxTCB );
;;;1057   
;;;1058   			/* Remove task from the ready/delayed list and place in the	suspended list. */
;;;1059   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000744  1d20              ADDS     r0,r4,#4
000746  f7fffffe          BL       uxListRemove
00074a  b978              CBNZ     r0,|L1.1900|
;;;1060   			{
;;;1061   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00074c  6ae0              LDR      r0,[r4,#0x2c]
00074e  eb000080          ADD      r0,r0,r0,LSL #2
000752  4946              LDR      r1,|L1.2156|
000754  f8510020          LDR      r0,[r1,r0,LSL #2]
000758  b940              CBNZ     r0,|L1.1900|
00075a  f894102c          LDRB     r1,[r4,#0x2c]
00075e  2001              MOVS     r0,#1
000760  4088              LSLS     r0,r0,r1
000762  493f              LDR      r1,|L1.2144|
000764  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000766  4381              BICS     r1,r1,r0
000768  483d              LDR      r0,|L1.2144|
00076a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.1900|
;;;1062   			}
;;;1063   
;;;1064   			/* Is the task waiting on an event also? */
;;;1065   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00076c  6aa0              LDR      r0,[r4,#0x28]
00076e  b118              CBZ      r0,|L1.1912|
;;;1066   			{
;;;1067   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000770  f1040018          ADD      r0,r4,#0x18
000774  f7fffffe          BL       uxListRemove
                  |L1.1912|
;;;1068   			}
;;;1069   
;;;1070   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000778  1d21              ADDS     r1,r4,#4
00077a  483a              LDR      r0,|L1.2148|
00077c  f7fffffe          BL       vListInsertEnd
;;;1071   		}
;;;1072   		taskEXIT_CRITICAL();
000780  f7fffffe          BL       vPortExitCritical
;;;1073   
;;;1074   		if( pxTCB == pxCurrentTCB )
000784  4830              LDR      r0,|L1.2120|
000786  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000788  4284              CMP      r4,r0
00078a  d111              BNE      |L1.1968|
;;;1075   		{
;;;1076   			if( xSchedulerRunning != pdFALSE )
00078c  483a              LDR      r0,|L1.2168|
00078e  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000790  b110              CBZ      r0,|L1.1944|
;;;1077   			{
;;;1078   				/* The current task has just been suspended. */
;;;1079   				portYIELD_WITHIN_API();
000792  f7fffffe          BL       vPortYield
000796  e00b              B        |L1.1968|
                  |L1.1944|
;;;1080   			}
;;;1081   			else
;;;1082   			{
;;;1083   				/* The scheduler is not running, but the task that was pointed
;;;1084   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1085   				must be adjusted to point to a different task. */
;;;1086   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000798  4832              LDR      r0,|L1.2148|
00079a  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
00079c  4937              LDR      r1,|L1.2172|
00079e  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
0007a0  4288              CMP      r0,r1
0007a2  d103              BNE      |L1.1964|
;;;1087   				{
;;;1088   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1089   					NULL so when the next task is created pxCurrentTCB will
;;;1090   					be set to point to it no matter what its relative priority
;;;1091   					is. */
;;;1092   					pxCurrentTCB = NULL;
0007a4  2000              MOVS     r0,#0
0007a6  4928              LDR      r1,|L1.2120|
0007a8  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0007aa  e001              B        |L1.1968|
                  |L1.1964|
;;;1093   				}
;;;1094   				else
;;;1095   				{
;;;1096   					vTaskSwitchContext();
0007ac  f7fffffe          BL       vTaskSwitchContext
                  |L1.1968|
;;;1097   				}
;;;1098   			}
;;;1099   		}
;;;1100   	}
0007b0  bd70              POP      {r4-r6,pc}
;;;1101   
                          ENDP

                  xTaskIsTaskSuspended PROC
;;;1106   
;;;1107   	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
0007b2  b510              PUSH     {r4,lr}
;;;1108   	{
0007b4  4601              MOV      r1,r0
;;;1109   	portBASE_TYPE xReturn = pdFALSE;
0007b6  2000              MOVS     r0,#0
;;;1110   	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
0007b8  460a              MOV      r2,r1
;;;1111   
;;;1112   		/* It does not make sense to check if the calling task is suspended. */
;;;1113   		configASSERT( xTask );
;;;1114   
;;;1115   		/* Is the task we are attempting to resume actually in the
;;;1116   		suspended list? */
;;;1117   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
0007ba  4c2a              LDR      r4,|L1.2148|
0007bc  6953              LDR      r3,[r2,#0x14]
0007be  42a3              CMP      r3,r4
0007c0  d101              BNE      |L1.1990|
0007c2  2301              MOVS     r3,#1
0007c4  e000              B        |L1.1992|
                  |L1.1990|
0007c6  2300              MOVS     r3,#0
                  |L1.1992|
0007c8  b173              CBZ      r3,|L1.2024|
;;;1118   		{
;;;1119   			/* Has the task already been resumed from within an ISR? */
;;;1120   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
0007ca  4c2d              LDR      r4,|L1.2176|
0007cc  6a93              LDR      r3,[r2,#0x28]
0007ce  42a3              CMP      r3,r4
0007d0  d101              BNE      |L1.2006|
0007d2  2301              MOVS     r3,#1
0007d4  e000              B        |L1.2008|
                  |L1.2006|
0007d6  2300              MOVS     r3,#0
                  |L1.2008|
0007d8  b933              CBNZ     r3,|L1.2024|
;;;1121   			{
;;;1122   				/* Is it in the suspended list because it is in the
;;;1123   				Suspended state?  It is possible to be in the suspended
;;;1124   				list because it is blocked on a task with no timeout
;;;1125   				specified. */
;;;1126   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
0007da  6a93              LDR      r3,[r2,#0x28]
0007dc  b90b              CBNZ     r3,|L1.2018|
0007de  2301              MOVS     r3,#1
0007e0  e000              B        |L1.2020|
                  |L1.2018|
0007e2  2300              MOVS     r3,#0
                  |L1.2020|
0007e4  b103              CBZ      r3,|L1.2024|
;;;1127   				{
;;;1128   					xReturn = pdTRUE;
0007e6  2001              MOVS     r0,#1
                  |L1.2024|
;;;1129   				}
;;;1130   			}
;;;1131   		}
;;;1132   
;;;1133   		return xReturn;
;;;1134   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0007e8  bd10              POP      {r4,pc}
;;;1135   
                          ENDP

                  vTaskResume PROC
;;;1140   
;;;1141   	void vTaskResume( xTaskHandle xTaskToResume )
0007ea  b570              PUSH     {r4-r6,lr}
;;;1142   	{
0007ec  4605              MOV      r5,r0
;;;1143   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
0007ee  462c              MOV      r4,r5
;;;1144   
;;;1145   		/* It does not make sense to resume the calling task. */
;;;1146   		configASSERT( xTaskToResume );
;;;1147   
;;;1148   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1149   		currently executing task. */
;;;1150   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
0007f0  b34c              CBZ      r4,|L1.2118|
0007f2  4815              LDR      r0,|L1.2120|
0007f4  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0007f6  4284              CMP      r4,r0
0007f8  d025              BEQ      |L1.2118|
;;;1151   		{
;;;1152   			taskENTER_CRITICAL();
0007fa  f7fffffe          BL       vPortEnterCritical
;;;1153   			{
;;;1154   				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0007fe  4620              MOV      r0,r4
000800  f7fffffe          BL       xTaskIsTaskSuspended
000804  2801              CMP      r0,#1
000806  d11c              BNE      |L1.2114|
;;;1155   				{
;;;1156   					traceTASK_RESUME( pxTCB );
;;;1157   
;;;1158   					/* As we are in a critical section we can access the ready
;;;1159   					lists even if the scheduler is suspended. */
;;;1160   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000808  1d20              ADDS     r0,r4,#4
00080a  f7fffffe          BL       uxListRemove
;;;1161   					prvAddTaskToReadyList( pxTCB );
00080e  f894102c          LDRB     r1,[r4,#0x2c]
000812  2001              MOVS     r0,#1
000814  4088              LSLS     r0,r0,r1
000816  4912              LDR      r1,|L1.2144|
000818  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00081a  4308              ORRS     r0,r0,r1
00081c  4910              LDR      r1,|L1.2144|
00081e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000820  6ae1              LDR      r1,[r4,#0x2c]
000822  eb010181          ADD      r1,r1,r1,LSL #2
000826  4a11              LDR      r2,|L1.2156|
000828  eb020081          ADD      r0,r2,r1,LSL #2
00082c  1d21              ADDS     r1,r4,#4
00082e  f7fffffe          BL       vListInsertEnd
;;;1162   
;;;1163   					/* We may have just resumed a higher priority task. */
;;;1164   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000832  4905              LDR      r1,|L1.2120|
000834  6ae0              LDR      r0,[r4,#0x2c]
000836  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000838  6ac9              LDR      r1,[r1,#0x2c]
00083a  4288              CMP      r0,r1
00083c  d301              BCC      |L1.2114|
;;;1165   					{
;;;1166   						/* This yield may not cause the task just resumed to run,
;;;1167   						but will leave the lists in the correct state for the
;;;1168   						next yield. */
;;;1169   						taskYIELD_IF_USING_PREEMPTION();
00083e  f7fffffe          BL       vPortYield
                  |L1.2114|
;;;1170   					}
;;;1171   				}
;;;1172   			}
;;;1173   			taskEXIT_CRITICAL();
000842  f7fffffe          BL       vPortExitCritical
                  |L1.2118|
;;;1174   		}
;;;1175   	}
000846  bd70              POP      {r4-r6,pc}
                  |L1.2120|
                          DCD      pxCurrentTCB
                  |L1.2124|
                          DCD      xTickCount
                  |L1.2128|
                          DCD      pxOverflowDelayedTaskList
                  |L1.2132|
                          DCD      pxDelayedTaskList
                  |L1.2136|
                          DCD      xNextTaskUnblockTime
                  |L1.2140|
                          DCD      uxSchedulerSuspended
                  |L1.2144|
                          DCD      uxTopReadyPriority
                  |L1.2148|
                          DCD      xSuspendedTaskList
                  |L1.2152|
                          DCD      xTasksWaitingTermination
                  |L1.2156|
                          DCD      pxReadyTasksLists
                  |L1.2160|
                          DCD      xYieldPending
                  |L1.2164|
                          DCD      ucExpectedStackBytes
                  |L1.2168|
                          DCD      xSchedulerRunning
                  |L1.2172|
                          DCD      uxCurrentNumberOfTasks
                  |L1.2176|
                          DCD      xPendingReadyList
                          ENDP

                  xTaskResumeFromISR PROC
;;;1182   
;;;1183   	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
000884  e92d41f0          PUSH     {r4-r8,lr}
;;;1184   	{
000888  4605              MOV      r5,r0
;;;1185   	portBASE_TYPE xYieldRequired = pdFALSE;
00088a  2600              MOVS     r6,#0
;;;1186   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
00088c  462c              MOV      r4,r5
;;;1187   	unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1188   
;;;1189   		configASSERT( xTaskToResume );
;;;1190   
;;;1191   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1192   		maximum	system call (or maximum API call) interrupt priority.
;;;1193   		Interrupts that are	above the maximum system call priority are keep
;;;1194   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1195   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1196   		is defined in FreeRTOSConfig.h then
;;;1197   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1198   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1199   		been assigned a priority above the configured maximum system call
;;;1200   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1201   		from interrupts	that have been assigned a priority at or (logically)
;;;1202   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1203   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1204   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1205   		provided on the following link:
;;;1206   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1207   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1208   
;;;1209   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00088e  f7fffffe          BL       ulPortSetInterruptMask
000892  4607              MOV      r7,r0
;;;1210   		{
;;;1211   			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000894  4620              MOV      r0,r4
000896  f7fffffe          BL       xTaskIsTaskSuspended
00089a  2801              CMP      r0,#1
00089c  d124              BNE      |L1.2280|
;;;1212   			{
;;;1213   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1214   
;;;1215   				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00089e  48fd              LDR      r0,|L1.3220|
0008a0  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0008a2  b9e0              CBNZ     r0,|L1.2270|
;;;1216   				{
;;;1217   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0008a4  49fc              LDR      r1,|L1.3224|
0008a6  6ae0              LDR      r0,[r4,#0x2c]
0008a8  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0008aa  6ac9              LDR      r1,[r1,#0x2c]
0008ac  4288              CMP      r0,r1
0008ae  d300              BCC      |L1.2226|
;;;1218   					{
;;;1219   						xYieldRequired = pdTRUE;
0008b0  2601              MOVS     r6,#1
                  |L1.2226|
;;;1220   					}
;;;1221   
;;;1222   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
0008b2  1d20              ADDS     r0,r4,#4
0008b4  f7fffffe          BL       uxListRemove
;;;1223   					prvAddTaskToReadyList( pxTCB );
0008b8  f894102c          LDRB     r1,[r4,#0x2c]
0008bc  2001              MOVS     r0,#1
0008be  4088              LSLS     r0,r0,r1
0008c0  49f6              LDR      r1,|L1.3228|
0008c2  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0008c4  4308              ORRS     r0,r0,r1
0008c6  49f5              LDR      r1,|L1.3228|
0008c8  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0008ca  6ae1              LDR      r1,[r4,#0x2c]
0008cc  eb010181          ADD      r1,r1,r1,LSL #2
0008d0  4af3              LDR      r2,|L1.3232|
0008d2  eb020081          ADD      r0,r2,r1,LSL #2
0008d6  1d21              ADDS     r1,r4,#4
0008d8  f7fffffe          BL       vListInsertEnd
0008dc  e004              B        |L1.2280|
                  |L1.2270|
;;;1224   				}
;;;1225   				else
;;;1226   				{
;;;1227   					/* We cannot access the delayed or ready lists, so will hold this
;;;1228   					task pending until the scheduler is resumed, at which point a
;;;1229   					yield will be performed if necessary. */
;;;1230   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0008de  f1040118          ADD      r1,r4,#0x18
0008e2  48f0              LDR      r0,|L1.3236|
0008e4  f7fffffe          BL       vListInsertEnd
                  |L1.2280|
;;;1231   				}
;;;1232   			}
;;;1233   		}
;;;1234   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0008e8  4638              MOV      r0,r7
0008ea  f7fffffe          BL       vPortClearInterruptMask
;;;1235   
;;;1236   		return xYieldRequired;
0008ee  4630              MOV      r0,r6
;;;1237   	}
0008f0  e8bd81f0          POP      {r4-r8,pc}
;;;1238   
                          ENDP

                  prvDeleteTCB PROC
;;;2620   
;;;2621   	static void prvDeleteTCB( tskTCB *pxTCB )
0008f4  b510              PUSH     {r4,lr}
;;;2622   	{
0008f6  4604              MOV      r4,r0
;;;2623   		/* This call is required specifically for the TriCore port.  It must be
;;;2624   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;2625   		want to allocate and clean RAM statically. */
;;;2626   		portCLEAN_UP_TCB( pxTCB );
;;;2627   
;;;2628   		/* Free up the memory allocated by the scheduler for the task.  It is up to
;;;2629   		the task to free any memory allocated at the application level. */
;;;2630   		vPortFreeAligned( pxTCB->pxStack );
0008f8  6b20              LDR      r0,[r4,#0x30]
0008fa  f7fffffe          BL       vPortFree
;;;2631   		vPortFree( pxTCB );
0008fe  4620              MOV      r0,r4
000900  f7fffffe          BL       vPortFree
;;;2632   	}
000904  bd10              POP      {r4,pc}
;;;2633   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;2411   
;;;2412   static void prvCheckTasksWaitingTermination( void )
000906  b570              PUSH     {r4-r6,lr}
;;;2413   {
;;;2414   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2415   	{
;;;2416   		portBASE_TYPE xListIsEmpty;
;;;2417   
;;;2418   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2419   		too often in the idle task. */
;;;2420   		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
000908  e023              B        |L1.2386|
                  |L1.2314|
;;;2421   		{
;;;2422   			vTaskSuspendAll();
00090a  f7fffffe          BL       vTaskSuspendAll
;;;2423   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
00090e  48e6              LDR      r0,|L1.3240|
000910  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
000912  b908              CBNZ     r0,|L1.2328|
000914  2001              MOVS     r0,#1
000916  e000              B        |L1.2330|
                  |L1.2328|
000918  2000              MOVS     r0,#0
                  |L1.2330|
00091a  4605              MOV      r5,r0
;;;2424   			( void ) xTaskResumeAll();
00091c  f7fffffe          BL       xTaskResumeAll
;;;2425   
;;;2426   			if( xListIsEmpty == pdFALSE )
000920  b9bd              CBNZ     r5,|L1.2386|
;;;2427   			{
;;;2428   				tskTCB *pxTCB;
;;;2429   
;;;2430   				taskENTER_CRITICAL();
000922  f7fffffe          BL       vPortEnterCritical
;;;2431   				{
;;;2432   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
000926  48e0              LDR      r0,|L1.3240|
000928  68c0              LDR      r0,[r0,#0xc]
00092a  68c4              LDR      r4,[r0,#0xc]
;;;2433   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
00092c  1d20              ADDS     r0,r4,#4
00092e  f7fffffe          BL       uxListRemove
;;;2434   					--uxCurrentNumberOfTasks;
000932  48de              LDR      r0,|L1.3244|
000934  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000936  1e40              SUBS     r0,r0,#1
000938  49dc              LDR      r1,|L1.3244|
00093a  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;2435   					--uxTasksDeleted;
00093c  48dc              LDR      r0,|L1.3248|
00093e  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
000940  1e40              SUBS     r0,r0,#1
000942  49db              LDR      r1,|L1.3248|
000944  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;2436   				}
;;;2437   				taskEXIT_CRITICAL();
000946  f7fffffe          BL       vPortExitCritical
;;;2438   
;;;2439   				prvDeleteTCB( pxTCB );
00094a  4620              MOV      r0,r4
00094c  f7fffffe          BL       prvDeleteTCB
;;;2440   			}
000950  bf00              NOP      
                  |L1.2386|
000952  48d7              LDR      r0,|L1.3248|
000954  6800              LDR      r0,[r0,#0]            ;2420  ; uxTasksDeleted
000956  2800              CMP      r0,#0                 ;2420
000958  d1d7              BNE      |L1.2314|
;;;2441   		}
;;;2442   	}
;;;2443   	#endif /* vTaskDelete */
;;;2444   }
00095a  bd70              POP      {r4-r6,pc}
;;;2445   /*-----------------------------------------------------------*/
                          ENDP

                  prvIdleTask PROC
;;;2148    */
;;;2149   static portTASK_FUNCTION( prvIdleTask, pvParameters )
00095c  bf00              NOP      
                  |L1.2398|
;;;2150   {
;;;2151   	/* Stop warnings. */
;;;2152   	( void ) pvParameters;
;;;2153   
;;;2154   	for( ;; )
;;;2155   	{
;;;2156   		/* See if any tasks have been deleted. */
;;;2157   		prvCheckTasksWaitingTermination();
00095e  f7fffffe          BL       prvCheckTasksWaitingTermination
000962  e7fc              B        |L1.2398|
;;;2158   
;;;2159   		#if ( configUSE_PREEMPTION == 0 )
;;;2160   		{
;;;2161   			/* If we are not using preemption we keep forcing a task switch to
;;;2162   			see if any other task has become available.  If we are using
;;;2163   			preemption we don't need to do this as any task becoming available
;;;2164   			will automatically get the processor anyway. */
;;;2165   			taskYIELD();
;;;2166   		}
;;;2167   		#endif /* configUSE_PREEMPTION */
;;;2168   
;;;2169   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2170   		{
;;;2171   			/* When using preemption tasks of equal priority will be
;;;2172   			timesliced.  If a task that is sharing the idle priority is ready
;;;2173   			to run then the idle task should yield before the end of the
;;;2174   			timeslice.
;;;2175   
;;;2176   			A critical region is not required here as we are just reading from
;;;2177   			the list, and an occasional incorrect value will not matter.  If
;;;2178   			the ready list at the idle priority contains more than one task
;;;2179   			then a task other than the idle task is ready to execute. */
;;;2180   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
;;;2181   			{
;;;2182   				taskYIELD();
;;;2183   			}
;;;2184   		}
;;;2185   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2186   
;;;2187   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2188   		{
;;;2189   			extern void vApplicationIdleHook( void );
;;;2190   
;;;2191   			/* Call the user defined function from within the idle task.  This
;;;2192   			allows the application designer to add background functionality
;;;2193   			without the overhead of a separate task.
;;;2194   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2195   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2196   			vApplicationIdleHook();
;;;2197   		}
;;;2198   		#endif /* configUSE_IDLE_HOOK */
;;;2199   
;;;2200   		/* This conditional compilation should use inequality to 0, not equality
;;;2201   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2202   		user defined low power mode	implementations require
;;;2203   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2204   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2205   		{
;;;2206   		portTickType xExpectedIdleTime;
;;;2207   
;;;2208   			/* It is not desirable to suspend then resume the scheduler on
;;;2209   			each iteration of the idle task.  Therefore, a preliminary
;;;2210   			test of the expected idle time is performed without the
;;;2211   			scheduler suspended.  The result here is not necessarily
;;;2212   			valid. */
;;;2213   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2214   
;;;2215   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2216   			{
;;;2217   				vTaskSuspendAll();
;;;2218   				{
;;;2219   					/* Now the scheduler is suspended, the expected idle
;;;2220   					time can be sampled again, and this time its value can
;;;2221   					be used. */
;;;2222   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2223   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2224   
;;;2225   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2226   					{
;;;2227   						traceLOW_POWER_IDLE_BEGIN();
;;;2228   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2229   						traceLOW_POWER_IDLE_END();
;;;2230   					}
;;;2231   				}
;;;2232   				( void ) xTaskResumeAll();
;;;2233   			}
;;;2234   		}
;;;2235   		#endif /* configUSE_TICKLESS_IDLE */
;;;2236   	}
;;;2237   }
;;;2238   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1241   
;;;1242   void vTaskStartScheduler( void )
000964  b51f              PUSH     {r0-r4,lr}
;;;1243   {
;;;1244   portBASE_TYPE xReturn;
;;;1245   
;;;1246   	/* Add the idle task at the lowest priority. */
;;;1247   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1248   	{
;;;1249   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1250   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1251   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000966  2000              MOVS     r0,#0
000968  4ad2              LDR      r2,|L1.3252|
00096a  e9cd0200          STRD     r0,r2,[sp,#0]
00096e  9002              STR      r0,[sp,#8]
000970  4603              MOV      r3,r0
000972  2280              MOVS     r2,#0x80
000974  a1d0              ADR      r1,|L1.3256|
000976  9003              STR      r0,[sp,#0xc]
000978  48d1              LDR      r0,|L1.3264|
00097a  f7fffffe          BL       xTaskGenericCreate
00097e  4604              MOV      r4,r0
;;;1252   	}
;;;1253   	#else
;;;1254   	{
;;;1255   		/* Create the idle task without storing its handle. */
;;;1256   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1257   	}
;;;1258   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1259   
;;;1260   	#if ( configUSE_TIMERS == 1 )
;;;1261   	{
;;;1262   		if( xReturn == pdPASS )
;;;1263   		{
;;;1264   			xReturn = xTimerCreateTimerTask();
;;;1265   		}
;;;1266   	}
;;;1267   	#endif /* configUSE_TIMERS */
;;;1268   
;;;1269   	if( xReturn == pdPASS )
000980  2c01              CMP      r4,#1
000982  d109              BNE      |L1.2456|
;;;1270   	{
;;;1271   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1272   		before or during the call to xPortStartScheduler().  The stacks of
;;;1273   		the created tasks contain a status word with interrupts switched on
;;;1274   		so interrupts will automatically get re-enabled when the first task
;;;1275   		starts to run. */
;;;1276   		portDISABLE_INTERRUPTS();
000984  f7fffffe          BL       ulPortSetInterruptMask
;;;1277   
;;;1278   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1279   		{
;;;1280   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1281   			structure specific to the task that will run first. */
;;;1282   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1283   		}
;;;1284   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1285   
;;;1286   		xSchedulerRunning = pdTRUE;
000988  2001              MOVS     r0,#1
00098a  49ce              LDR      r1,|L1.3268|
00098c  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1287   		xTickCount = ( portTickType ) 0U;
00098e  2000              MOVS     r0,#0
000990  49cd              LDR      r1,|L1.3272|
000992  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1288   
;;;1289   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1290   		macro must be defined to configure the timer/counter used to generate
;;;1291   		the run time counter time base. */
;;;1292   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1293   
;;;1294   		/* Setting up the timer tick is hardware specific and thus in the
;;;1295   		portable interface. */
;;;1296   		if( xPortStartScheduler() != pdFALSE )
000994  f7fffffe          BL       xPortStartScheduler
                  |L1.2456|
;;;1297   		{
;;;1298   			/* Should not reach here as if the scheduler is running the
;;;1299   			function will not return. */
;;;1300   		}
;;;1301   		else
;;;1302   		{
;;;1303   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1304   		}
;;;1305   	}
;;;1306   	else
;;;1307   	{
;;;1308   		/* This line will only be reached if the kernel could not be started,
;;;1309   		because there was not enough FreeRTOS heap to create the idle task
;;;1310   		or the timer task. */
;;;1311   		configASSERT( xReturn );
;;;1312   	}
;;;1313   }
000998  bd1f              POP      {r0-r4,pc}
;;;1314   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1315   
;;;1316   void vTaskEndScheduler( void )
00099a  b510              PUSH     {r4,lr}
;;;1317   {
;;;1318   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1319   	routine so the original ISRs can be restored if necessary.  The port
;;;1320   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1321   	portDISABLE_INTERRUPTS();
00099c  f7fffffe          BL       ulPortSetInterruptMask
;;;1322   	xSchedulerRunning = pdFALSE;
0009a0  2000              MOVS     r0,#0
0009a2  49c8              LDR      r1,|L1.3268|
0009a4  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1323   	vPortEndScheduler();
0009a6  f7fffffe          BL       vPortEndScheduler
;;;1324   }
0009aa  bd10              POP      {r4,pc}
;;;1325   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1434   
;;;1435   portTickType xTaskGetTickCount( void )
0009ac  b510              PUSH     {r4,lr}
;;;1436   {
;;;1437   portTickType xTicks;
;;;1438   
;;;1439   	/* Critical section required if running on a 16 bit processor. */
;;;1440   	taskENTER_CRITICAL();
0009ae  f7fffffe          BL       vPortEnterCritical
;;;1441   	{
;;;1442   		xTicks = xTickCount;
0009b2  48c5              LDR      r0,|L1.3272|
0009b4  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1443   	}
;;;1444   	taskEXIT_CRITICAL();
0009b6  f7fffffe          BL       vPortExitCritical
;;;1445   
;;;1446   	return xTicks;
0009ba  4620              MOV      r0,r4
;;;1447   }
0009bc  bd10              POP      {r4,pc}
;;;1448   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1449   
;;;1450   portTickType xTaskGetTickCountFromISR( void )
0009be  b570              PUSH     {r4-r6,lr}
;;;1451   {
;;;1452   portTickType xReturn;
;;;1453   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1454   
;;;1455   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1456   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1457   	above the maximum system call priority are keep permanently enabled, even
;;;1458   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1459   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1460   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1461   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1462   	assigned a priority above the configured maximum system call priority.
;;;1463   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1464   	that have been assigned a priority at or (logically) below the maximum
;;;1465   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1466   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1467   	More information (albeit Cortex-M specific) is provided on the following
;;;1468   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1469   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1470   
;;;1471   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0009c0  f7fffffe          BL       ulPortSetInterruptMask
0009c4  4605              MOV      r5,r0
;;;1472   	xReturn = xTickCount;
0009c6  48c0              LDR      r0,|L1.3272|
0009c8  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1473   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0009ca  4628              MOV      r0,r5
0009cc  f7fffffe          BL       vPortClearInterruptMask
;;;1474   
;;;1475   	return xReturn;
0009d0  4620              MOV      r0,r4
;;;1476   }
0009d2  bd70              POP      {r4-r6,pc}
;;;1477   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1478   
;;;1479   unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
0009d4  48b5              LDR      r0,|L1.3244|
;;;1480   {
;;;1481   	/* A critical section is not required because the variables are of type
;;;1482   	portBASE_TYPE. */
;;;1483   	return uxCurrentNumberOfTasks;
0009d6  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;1484   }
0009d8  4770              BX       lr
;;;1485   /*-----------------------------------------------------------*/
                          ENDP

                  pcTaskGetTaskName PROC
;;;1488   
;;;1489   	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
0009da  4601              MOV      r1,r0
;;;1490   	{
;;;1491   	tskTCB *pxTCB;
;;;1492   
;;;1493   		/* If null is passed in here then the name of the calling task is being queried. */
;;;1494   		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
0009dc  b911              CBNZ     r1,|L1.2532|
0009de  48ae              LDR      r0,|L1.3224|
0009e0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0009e2  e000              B        |L1.2534|
                  |L1.2532|
0009e4  4608              MOV      r0,r1
                  |L1.2534|
0009e6  4602              MOV      r2,r0
;;;1495   		configASSERT( pxTCB );
;;;1496   		return &( pxTCB->pcTaskName[ 0 ] );
0009e8  f1020034          ADD      r0,r2,#0x34
;;;1497   	}
0009ec  4770              BX       lr
;;;1498   
                          ENDP

                  xTaskGetIdleTaskHandle PROC
;;;1573   
;;;1574   	xTaskHandle xTaskGetIdleTaskHandle( void )
0009ee  48b1              LDR      r0,|L1.3252|
;;;1575   	{
;;;1576   		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
;;;1577   		started, then xIdleTaskHandle will be NULL. */
;;;1578   		configASSERT( ( xIdleTaskHandle != NULL ) );
;;;1579   		return xIdleTaskHandle;
0009f0  6800              LDR      r0,[r0,#0]  ; xIdleTaskHandle
;;;1580   	}
0009f2  4770              BX       lr
;;;1581   
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;1888   
;;;1889   void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
0009f4  b570              PUSH     {r4-r6,lr}
;;;1890   {
0009f6  4606              MOV      r6,r0
0009f8  460c              MOV      r4,r1
;;;1891   portTickType xTimeToWake;
;;;1892   
;;;1893   	configASSERT( pxEventList );
;;;1894   
;;;1895   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1896   	SCHEDULER SUSPENDED. */
;;;1897   
;;;1898   	/* Place the event list item of the TCB in the appropriate event list.
;;;1899   	This is placed in the list in priority order so the highest priority task
;;;1900   	is the first to be woken by the event. */
;;;1901   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0009fa  48a7              LDR      r0,|L1.3224|
0009fc  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0009fe  3118              ADDS     r1,r1,#0x18
000a00  4630              MOV      r0,r6
000a02  f7fffffe          BL       vListInsert
;;;1902   
;;;1903   	/* We must remove ourselves from the ready list before adding ourselves
;;;1904   	to the blocked list as the same list item is used for both lists.  We have
;;;1905   	exclusive access to the ready lists as the scheduler is locked. */
;;;1906   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000a06  48a4              LDR      r0,|L1.3224|
000a08  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000a0a  1d00              ADDS     r0,r0,#4
000a0c  f7fffffe          BL       uxListRemove
000a10  b950              CBNZ     r0,|L1.2600|
;;;1907   	{
;;;1908   		/* The current task must be in a ready list, so there is no need to
;;;1909   		check, and the port reset macro can be called directly. */
;;;1910   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000a12  48a1              LDR      r0,|L1.3224|
000a14  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000a16  f890102c          LDRB     r1,[r0,#0x2c]
000a1a  2001              MOVS     r0,#1
000a1c  4088              LSLS     r0,r0,r1
000a1e  499f              LDR      r1,|L1.3228|
000a20  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000a22  4381              BICS     r1,r1,r0
000a24  489d              LDR      r0,|L1.3228|
000a26  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.2600|
;;;1911   	}
;;;1912   
;;;1913   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;1914   	{
;;;1915   		if( xTicksToWait == portMAX_DELAY )
000a28  1c60              ADDS     r0,r4,#1
000a2a  d106              BNE      |L1.2618|
;;;1916   		{
;;;1917   			/* Add ourselves to the suspended task list instead of a delayed task
;;;1918   			list to ensure we are not woken by a timing event.  We will block
;;;1919   			indefinitely. */
;;;1920   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000a2c  489a              LDR      r0,|L1.3224|
000a2e  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000a30  1d09              ADDS     r1,r1,#4
000a32  48a6              LDR      r0,|L1.3276|
000a34  f7fffffe          BL       vListInsertEnd
000a38  e005              B        |L1.2630|
                  |L1.2618|
;;;1921   		}
;;;1922   		else
;;;1923   		{
;;;1924   			/* Calculate the time at which the task should be woken if the event does
;;;1925   			not occur.  This may overflow but this doesn't matter. */
;;;1926   			xTimeToWake = xTickCount + xTicksToWait;
000a3a  48a3              LDR      r0,|L1.3272|
000a3c  6800              LDR      r0,[r0,#0]  ; xTickCount
000a3e  1905              ADDS     r5,r0,r4
;;;1927   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000a40  4628              MOV      r0,r5
000a42  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.2630|
;;;1928   		}
;;;1929   	}
;;;1930   	#else /* INCLUDE_vTaskSuspend */
;;;1931   	{
;;;1932   			/* Calculate the time at which the task should be woken if the event does
;;;1933   			not occur.  This may overflow but this doesn't matter. */
;;;1934   			xTimeToWake = xTickCount + xTicksToWait;
;;;1935   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;1936   	}
;;;1937   	#endif /* INCLUDE_vTaskSuspend */
;;;1938   }
000a46  bd70              POP      {r4-r6,pc}
;;;1939   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;1981   
;;;1982   signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
000a48  b570              PUSH     {r4-r6,lr}
;;;1983   {
000a4a  4606              MOV      r6,r0
;;;1984   tskTCB *pxUnblockedTCB;
;;;1985   portBASE_TYPE xReturn;
;;;1986   
;;;1987   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1988   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;1989   
;;;1990   	/* The event list is sorted in priority order, so we can remove the
;;;1991   	first in the list, remove the TCB from the delayed list, and add
;;;1992   	it to the ready list.
;;;1993   
;;;1994   	If an event is for a queue that is locked then this function will never
;;;1995   	get called - the lock count on the queue will get modified instead.  This
;;;1996   	means we can always expect exclusive access to the event list here.
;;;1997   
;;;1998   	This function assumes that a check has already been made to ensure that
;;;1999   	pxEventList is not empty. */
;;;2000   	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000a4c  68f0              LDR      r0,[r6,#0xc]
000a4e  68c4              LDR      r4,[r0,#0xc]
;;;2001   	configASSERT( pxUnblockedTCB );
;;;2002   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000a50  f1040018          ADD      r0,r4,#0x18
000a54  f7fffffe          BL       uxListRemove
;;;2003   
;;;2004   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000a58  488e              LDR      r0,|L1.3220|
000a5a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000a5c  b9a8              CBNZ     r0,|L1.2698|
;;;2005   	{
;;;2006   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000a5e  1d20              ADDS     r0,r4,#4
000a60  f7fffffe          BL       uxListRemove
;;;2007   		prvAddTaskToReadyList( pxUnblockedTCB );
000a64  f894102c          LDRB     r1,[r4,#0x2c]
000a68  2001              MOVS     r0,#1
000a6a  4088              LSLS     r0,r0,r1
000a6c  498b              LDR      r1,|L1.3228|
000a6e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000a70  4308              ORRS     r0,r0,r1
000a72  498a              LDR      r1,|L1.3228|
000a74  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000a76  6ae1              LDR      r1,[r4,#0x2c]
000a78  eb010181          ADD      r1,r1,r1,LSL #2
000a7c  4a88              LDR      r2,|L1.3232|
000a7e  eb020081          ADD      r0,r2,r1,LSL #2
000a82  1d21              ADDS     r1,r4,#4
000a84  f7fffffe          BL       vListInsertEnd
000a88  e004              B        |L1.2708|
                  |L1.2698|
;;;2008   	}
;;;2009   	else
;;;2010   	{
;;;2011   		/* We cannot access the delayed or ready lists, so will hold this
;;;2012   		task pending until the scheduler is resumed. */
;;;2013   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000a8a  f1040118          ADD      r1,r4,#0x18
000a8e  4885              LDR      r0,|L1.3236|
000a90  f7fffffe          BL       vListInsertEnd
                  |L1.2708|
;;;2014   	}
;;;2015   
;;;2016   	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
000a94  4980              LDR      r1,|L1.3224|
000a96  6ae0              LDR      r0,[r4,#0x2c]
000a98  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000a9a  6ac9              LDR      r1,[r1,#0x2c]
000a9c  4288              CMP      r0,r1
000a9e  d304              BCC      |L1.2730|
;;;2017   	{
;;;2018   		/* Return true if the task removed from the event list has
;;;2019   		a higher priority than the calling task.  This allows
;;;2020   		the calling task to know if it should force a context
;;;2021   		switch now. */
;;;2022   		xReturn = pdTRUE;
000aa0  2501              MOVS     r5,#1
;;;2023   
;;;2024   		/* Mark that a yield is pending in case the user is not using the
;;;2025   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2026   		xYieldPending = pdTRUE;
000aa2  2001              MOVS     r0,#1
000aa4  498a              LDR      r1,|L1.3280|
000aa6  6008              STR      r0,[r1,#0]  ; xYieldPending
000aa8  e000              B        |L1.2732|
                  |L1.2730|
;;;2027   	}
;;;2028   	else
;;;2029   	{
;;;2030   		xReturn = pdFALSE;
000aaa  2500              MOVS     r5,#0
                  |L1.2732|
;;;2031   	}
;;;2032   
;;;2033   	return xReturn;
000aac  4628              MOV      r0,r5
;;;2034   }
000aae  bd70              POP      {r4-r6,pc}
;;;2035   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2036   
;;;2037   void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
000ab0  4988              LDR      r1,|L1.3284|
;;;2038   {
;;;2039   	configASSERT( pxTimeOut );
;;;2040   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000ab2  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000ab4  6001              STR      r1,[r0,#0]
;;;2041   	pxTimeOut->xTimeOnEntering = xTickCount;
000ab6  4984              LDR      r1,|L1.3272|
000ab8  6809              LDR      r1,[r1,#0]  ; xTickCount
000aba  6041              STR      r1,[r0,#4]
;;;2042   }
000abc  4770              BX       lr
;;;2043   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2044   
;;;2045   portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
000abe  b570              PUSH     {r4-r6,lr}
;;;2046   {
000ac0  4604              MOV      r4,r0
000ac2  460d              MOV      r5,r1
;;;2047   portBASE_TYPE xReturn;
;;;2048   
;;;2049   	configASSERT( pxTimeOut );
;;;2050   	configASSERT( pxTicksToWait );
;;;2051   
;;;2052   	taskENTER_CRITICAL();
000ac4  f7fffffe          BL       vPortEnterCritical
;;;2053   	{
;;;2054   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2055   		const portTickType xConstTickCount = xTickCount;
000ac8  487f              LDR      r0,|L1.3272|
000aca  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;2056   
;;;2057   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2058   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2059   			the maximum block time then the task should block indefinitely, and
;;;2060   			therefore never time out. */
;;;2061   			if( *pxTicksToWait == portMAX_DELAY )
000acc  6828              LDR      r0,[r5,#0]
000ace  1c40              ADDS     r0,r0,#1
000ad0  d101              BNE      |L1.2774|
;;;2062   			{
;;;2063   				xReturn = pdFALSE;
000ad2  2600              MOVS     r6,#0
000ad4  e019              B        |L1.2826|
                  |L1.2774|
;;;2064   			}
;;;2065   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2066   		#endif
;;;2067   
;;;2068   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000ad6  497f              LDR      r1,|L1.3284|
000ad8  6820              LDR      r0,[r4,#0]
000ada  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000adc  4288              CMP      r0,r1
000ade  d004              BEQ      |L1.2794|
000ae0  6860              LDR      r0,[r4,#4]
000ae2  4290              CMP      r0,r2
000ae4  d801              BHI      |L1.2794|
;;;2069   		{
;;;2070   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2071   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2072   			It must have wrapped all the way around and gone past us again. This
;;;2073   			passed since vTaskSetTimeout() was called. */
;;;2074   			xReturn = pdTRUE;
000ae6  2601              MOVS     r6,#1
000ae8  e00f              B        |L1.2826|
                  |L1.2794|
;;;2075   		}
;;;2076   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000aea  6860              LDR      r0,[r4,#4]
000aec  1a10              SUBS     r0,r2,r0
000aee  6829              LDR      r1,[r5,#0]
000af0  4288              CMP      r0,r1
000af2  d209              BCS      |L1.2824|
;;;2077   		{
;;;2078   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2079   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
000af4  6828              LDR      r0,[r5,#0]
000af6  6861              LDR      r1,[r4,#4]
000af8  1a51              SUBS     r1,r2,r1
000afa  1a40              SUBS     r0,r0,r1
000afc  6028              STR      r0,[r5,#0]
;;;2080   			vTaskSetTimeOutState( pxTimeOut );
000afe  4620              MOV      r0,r4
000b00  f7fffffe          BL       vTaskSetTimeOutState
;;;2081   			xReturn = pdFALSE;
000b04  2600              MOVS     r6,#0
000b06  e000              B        |L1.2826|
                  |L1.2824|
;;;2082   		}
;;;2083   		else
;;;2084   		{
;;;2085   			xReturn = pdTRUE;
000b08  2601              MOVS     r6,#1
                  |L1.2826|
;;;2086   		}
;;;2087   	}
;;;2088   	taskEXIT_CRITICAL();
000b0a  f7fffffe          BL       vPortExitCritical
;;;2089   
;;;2090   	return xReturn;
000b0e  4630              MOV      r0,r6
;;;2091   }
000b10  bd70              POP      {r4-r6,pc}
;;;2092   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2093   
;;;2094   void vTaskMissedYield( void )
000b12  2001              MOVS     r0,#1
;;;2095   {
;;;2096   	xYieldPending = pdTRUE;
000b14  496e              LDR      r1,|L1.3280|
000b16  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2097   }
000b18  4770              BX       lr
;;;2098   /*-----------------------------------------------------------*/
                          ENDP

                  prvTaskCheckFreeStackSpace PROC
;;;2572   
;;;2573   	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
000b1a  4601              MOV      r1,r0
;;;2574   	{
;;;2575   	unsigned short usCount = 0U;
000b1c  2000              MOVS     r0,#0
;;;2576   
;;;2577   		while( *pucStackByte == tskSTACK_FILL_BYTE )
000b1e  e002              B        |L1.2854|
                  |L1.2848|
;;;2578   		{
;;;2579   			pucStackByte -= portSTACK_GROWTH;
000b20  1c49              ADDS     r1,r1,#1
;;;2580   			usCount++;
000b22  1c42              ADDS     r2,r0,#1
000b24  b290              UXTH     r0,r2
                  |L1.2854|
000b26  780a              LDRB     r2,[r1,#0]            ;2577
000b28  2aa5              CMP      r2,#0xa5              ;2577
000b2a  d0f9              BEQ      |L1.2848|
;;;2581   		}
;;;2582   
;;;2583   		usCount /= sizeof( portSTACK_TYPE );
000b2c  0880              LSRS     r0,r0,#2
;;;2584   
;;;2585   		return usCount;
;;;2586   	}
000b2e  4770              BX       lr
;;;2587   
                          ENDP

                  uxTaskGetStackHighWaterMark PROC
;;;2592   
;;;2593   	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
000b30  e92d41f0          PUSH     {r4-r8,lr}
;;;2594   	{
000b34  4604              MOV      r4,r0
;;;2595   	tskTCB *pxTCB;
;;;2596   	unsigned char *pcEndOfStack;
;;;2597   	unsigned portBASE_TYPE uxReturn;
;;;2598   
;;;2599   		pxTCB = prvGetTCBFromHandle( xTask );
000b36  b914              CBNZ     r4,|L1.2878|
000b38  4857              LDR      r0,|L1.3224|
000b3a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000b3c  e000              B        |L1.2880|
                  |L1.2878|
000b3e  4620              MOV      r0,r4
                  |L1.2880|
000b40  4607              MOV      r7,r0
;;;2600   
;;;2601   		#if portSTACK_GROWTH < 0
;;;2602   		{
;;;2603   			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
000b42  6b3d              LDR      r5,[r7,#0x30]
;;;2604   		}
;;;2605   		#else
;;;2606   		{
;;;2607   			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
;;;2608   		}
;;;2609   		#endif
;;;2610   
;;;2611   		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
000b44  4628              MOV      r0,r5
000b46  f7fffffe          BL       prvTaskCheckFreeStackSpace
000b4a  4606              MOV      r6,r0
;;;2612   
;;;2613   		return uxReturn;
000b4c  4630              MOV      r0,r6
;;;2614   	}
000b4e  e8bd81f0          POP      {r4-r8,pc}
;;;2615   
                          ENDP

                  xTaskGetCurrentTaskHandle PROC
;;;2638   
;;;2639   	xTaskHandle xTaskGetCurrentTaskHandle( void )
000b52  4951              LDR      r1,|L1.3224|
;;;2640   	{
;;;2641   	xTaskHandle xReturn;
;;;2642   
;;;2643   		/* A critical section is not required as this is not called from
;;;2644   		an interrupt and the current TCB will always be the same for any
;;;2645   		individual execution thread. */
;;;2646   		xReturn = pxCurrentTCB;
000b54  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;2647   
;;;2648   		return xReturn;
;;;2649   	}
000b56  4770              BX       lr
;;;2650   
                          ENDP

                  xTaskGetSchedulerState PROC
;;;2655   
;;;2656   	portBASE_TYPE xTaskGetSchedulerState( void )
000b58  495a              LDR      r1,|L1.3268|
;;;2657   	{
;;;2658   	portBASE_TYPE xReturn;
;;;2659   
;;;2660   		if( xSchedulerRunning == pdFALSE )
000b5a  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000b5c  b909              CBNZ     r1,|L1.2914|
;;;2661   		{
;;;2662   			xReturn = taskSCHEDULER_NOT_STARTED;
000b5e  2000              MOVS     r0,#0
000b60  e005              B        |L1.2926|
                  |L1.2914|
;;;2663   		}
;;;2664   		else
;;;2665   		{
;;;2666   			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000b62  494c              LDR      r1,|L1.3220|
000b64  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
000b66  b909              CBNZ     r1,|L1.2924|
;;;2667   			{
;;;2668   				xReturn = taskSCHEDULER_RUNNING;
000b68  2001              MOVS     r0,#1
000b6a  e000              B        |L1.2926|
                  |L1.2924|
;;;2669   			}
;;;2670   			else
;;;2671   			{
;;;2672   				xReturn = taskSCHEDULER_SUSPENDED;
000b6c  2002              MOVS     r0,#2
                  |L1.2926|
;;;2673   			}
;;;2674   		}
;;;2675   
;;;2676   		return xReturn;
;;;2677   	}
000b6e  4770              BX       lr
;;;2678   
                          ENDP

                  vTaskPriorityInherit PROC
;;;2683   
;;;2684   	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
000b70  b570              PUSH     {r4-r6,lr}
;;;2685   	{
000b72  4605              MOV      r5,r0
;;;2686   	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
000b74  462c              MOV      r4,r5
;;;2687   
;;;2688   		/* If the mutex was given back by an interrupt while the queue was
;;;2689   		locked then the mutex holder might now be NULL. */
;;;2690   		if( pxMutexHolder != NULL )
000b76  2d00              CMP      r5,#0
000b78  d047              BEQ      |L1.3082|
;;;2691   		{
;;;2692   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
000b7a  4947              LDR      r1,|L1.3224|
000b7c  6ae0              LDR      r0,[r4,#0x2c]
000b7e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000b80  6ac9              LDR      r1,[r1,#0x2c]
000b82  4288              CMP      r0,r1
000b84  d241              BCS      |L1.3082|
;;;2693   			{
;;;2694   				/* Adjust the mutex holder state to account for its new priority. */
;;;2695   				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000b86  4844              LDR      r0,|L1.3224|
000b88  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000b8a  6ac0              LDR      r0,[r0,#0x2c]
000b8c  f1c0000a          RSB      r0,r0,#0xa
000b90  61a0              STR      r0,[r4,#0x18]
;;;2696   
;;;2697   				/* If the task being modified is in the ready state it will need to
;;;2698   				be moved into a new list. */
;;;2699   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000b92  6ae1              LDR      r1,[r4,#0x2c]
000b94  eb010181          ADD      r1,r1,r1,LSL #2
000b98  4a41              LDR      r2,|L1.3232|
000b9a  eb020181          ADD      r1,r2,r1,LSL #2
000b9e  6960              LDR      r0,[r4,#0x14]
000ba0  4288              CMP      r0,r1
000ba2  d101              BNE      |L1.2984|
000ba4  2001              MOVS     r0,#1
000ba6  e000              B        |L1.2986|
                  |L1.2984|
000ba8  2000              MOVS     r0,#0
                  |L1.2986|
000baa  b350              CBZ      r0,|L1.3074|
;;;2700   				{
;;;2701   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000bac  1d20              ADDS     r0,r4,#4
000bae  f7fffffe          BL       uxListRemove
000bb2  b978              CBNZ     r0,|L1.3028|
;;;2702   					{
;;;2703   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000bb4  6ae0              LDR      r0,[r4,#0x2c]
000bb6  eb000080          ADD      r0,r0,r0,LSL #2
000bba  4939              LDR      r1,|L1.3232|
000bbc  f8510020          LDR      r0,[r1,r0,LSL #2]
000bc0  b940              CBNZ     r0,|L1.3028|
000bc2  f894102c          LDRB     r1,[r4,#0x2c]
000bc6  2001              MOVS     r0,#1
000bc8  4088              LSLS     r0,r0,r1
000bca  4934              LDR      r1,|L1.3228|
000bcc  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000bce  4381              BICS     r1,r1,r0
000bd0  4832              LDR      r0,|L1.3228|
000bd2  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.3028|
;;;2704   					}
;;;2705   
;;;2706   					/* Inherit the priority before being moved into the new list. */
;;;2707   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000bd4  4830              LDR      r0,|L1.3224|
000bd6  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000bd8  6ac0              LDR      r0,[r0,#0x2c]
000bda  62e0              STR      r0,[r4,#0x2c]
;;;2708   					prvAddTaskToReadyList( pxTCB );
000bdc  f894102c          LDRB     r1,[r4,#0x2c]
000be0  2001              MOVS     r0,#1
000be2  4088              LSLS     r0,r0,r1
000be4  492d              LDR      r1,|L1.3228|
000be6  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000be8  4308              ORRS     r0,r0,r1
000bea  492c              LDR      r1,|L1.3228|
000bec  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000bee  6ae1              LDR      r1,[r4,#0x2c]
000bf0  eb010181          ADD      r1,r1,r1,LSL #2
000bf4  4a2a              LDR      r2,|L1.3232|
000bf6  eb020081          ADD      r0,r2,r1,LSL #2
000bfa  1d21              ADDS     r1,r4,#4
000bfc  f7fffffe          BL       vListInsertEnd
000c00  e003              B        |L1.3082|
                  |L1.3074|
;;;2709   				}
;;;2710   				else
;;;2711   				{
;;;2712   					/* Just inherit the priority. */
;;;2713   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000c02  4825              LDR      r0,|L1.3224|
000c04  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000c06  6ac0              LDR      r0,[r0,#0x2c]
000c08  62e0              STR      r0,[r4,#0x2c]
                  |L1.3082|
;;;2714   				}
;;;2715   
;;;2716   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;2717   			}
;;;2718   		}
;;;2719   	}
000c0a  bd70              POP      {r4-r6,pc}
;;;2720   
                          ENDP

                  vTaskPriorityDisinherit PROC
;;;2725   
;;;2726   	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
000c0c  b570              PUSH     {r4-r6,lr}
;;;2727   	{
000c0e  4605              MOV      r5,r0
;;;2728   	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
000c10  462c              MOV      r4,r5
;;;2729   
;;;2730   		if( pxMutexHolder != NULL )
000c12  b37d              CBZ      r5,|L1.3188|
;;;2731   		{
;;;2732   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000c14  6ca1              LDR      r1,[r4,#0x48]
000c16  6ae0              LDR      r0,[r4,#0x2c]
000c18  4288              CMP      r0,r1
000c1a  d02b              BEQ      |L1.3188|
;;;2733   			{
;;;2734   				/* We must be the running task to be able to give the mutex back.
;;;2735   				Remove ourselves from the ready list we currently appear in. */
;;;2736   				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000c1c  1d20              ADDS     r0,r4,#4
000c1e  f7fffffe          BL       uxListRemove
000c22  b978              CBNZ     r0,|L1.3140|
;;;2737   				{
;;;2738   					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000c24  6ae0              LDR      r0,[r4,#0x2c]
000c26  eb000080          ADD      r0,r0,r0,LSL #2
000c2a  491d              LDR      r1,|L1.3232|
000c2c  f8510020          LDR      r0,[r1,r0,LSL #2]
000c30  b940              CBNZ     r0,|L1.3140|
000c32  f894102c          LDRB     r1,[r4,#0x2c]
000c36  2001              MOVS     r0,#1
000c38  4088              LSLS     r0,r0,r1
000c3a  4918              LDR      r1,|L1.3228|
000c3c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000c3e  4381              BICS     r1,r1,r0
000c40  4816              LDR      r0,|L1.3228|
000c42  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L1.3140|
;;;2739   				}
;;;2740   
;;;2741   				/* Disinherit the priority before adding the task into the new
;;;2742   				ready list. */
;;;2743   				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;2744   				pxTCB->uxPriority = pxTCB->uxBasePriority;
000c44  6ca0              LDR      r0,[r4,#0x48]
000c46  62e0              STR      r0,[r4,#0x2c]
;;;2745   				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000c48  6ae0              LDR      r0,[r4,#0x2c]
000c4a  f1c0000a          RSB      r0,r0,#0xa
000c4e  61a0              STR      r0,[r4,#0x18]
;;;2746   				prvAddTaskToReadyList( pxTCB );
000c50  f894102c          LDRB     r1,[r4,#0x2c]
000c54  2001              MOVS     r0,#1
000c56  4088              LSLS     r0,r0,r1
000c58  4910              LDR      r1,|L1.3228|
000c5a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000c5c  4308              ORRS     r0,r0,r1
000c5e  490f              LDR      r1,|L1.3228|
000c60  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000c62  6ae1              LDR      r1,[r4,#0x2c]
000c64  eb010181          ADD      r1,r1,r1,LSL #2
000c68  4a0d              LDR      r2,|L1.3232|
000c6a  eb020081          ADD      r0,r2,r1,LSL #2
000c6e  1d21              ADDS     r1,r4,#4
000c70  f7fffffe          BL       vListInsertEnd
                  |L1.3188|
;;;2747   			}
;;;2748   		}
;;;2749   	}
000c74  bd70              POP      {r4-r6,pc}
;;;2750   
                          ENDP

                  vTaskEnterCritical PROC
;;;2755   
;;;2756   	void vTaskEnterCritical( void )
000c76  b510              PUSH     {r4,lr}
;;;2757   	{
;;;2758   		portDISABLE_INTERRUPTS();
000c78  f7fffffe          BL       ulPortSetInterruptMask
;;;2759   
;;;2760   		if( xSchedulerRunning != pdFALSE )
000c7c  4811              LDR      r0,|L1.3268|
000c7e  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000c80  b130              CBZ      r0,|L1.3216|
;;;2761   		{
;;;2762   			( pxCurrentTCB->uxCriticalNesting )++;
000c82  4905              LDR      r1,|L1.3224|
000c84  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000c86  f1010044          ADD      r0,r1,#0x44
000c8a  6c49              LDR      r1,[r1,#0x44]
000c8c  1c49              ADDS     r1,r1,#1
000c8e  6001              STR      r1,[r0,#0]
                  |L1.3216|
;;;2763   		}
;;;2764   	}
000c90  bd10              POP      {r4,pc}
000c92  0000              DCW      0x0000
                  |L1.3220|
                          DCD      uxSchedulerSuspended
                  |L1.3224|
                          DCD      pxCurrentTCB
                  |L1.3228|
                          DCD      uxTopReadyPriority
                  |L1.3232|
                          DCD      pxReadyTasksLists
                  |L1.3236|
                          DCD      xPendingReadyList
                  |L1.3240|
                          DCD      xTasksWaitingTermination
                  |L1.3244|
                          DCD      uxCurrentNumberOfTasks
                  |L1.3248|
                          DCD      uxTasksDeleted
                  |L1.3252|
                          DCD      xIdleTaskHandle
                  |L1.3256|
000cb8  49444c45          DCB      "IDLE",0
000cbc  00      
000cbd  00                DCB      0
000cbe  00                DCB      0
000cbf  00                DCB      0
                  |L1.3264|
                          DCD      prvIdleTask
                  |L1.3268|
                          DCD      xSchedulerRunning
                  |L1.3272|
                          DCD      xTickCount
                  |L1.3276|
                          DCD      xSuspendedTaskList
                  |L1.3280|
                          DCD      xYieldPending
                  |L1.3284|
                          DCD      xNumOfOverflows
                          ENDP

                  vTaskExitCritical PROC
;;;2770   
;;;2771   	void vTaskExitCritical( void )
000cd8  b510              PUSH     {r4,lr}
;;;2772   	{
;;;2773   		if( xSchedulerRunning != pdFALSE )
000cda  480b              LDR      r0,|L1.3336|
000cdc  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000cde  b188              CBZ      r0,|L1.3332|
;;;2774   		{
;;;2775   			if( pxCurrentTCB->uxCriticalNesting > 0U )
000ce0  480a              LDR      r0,|L1.3340|
000ce2  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000ce4  6c40              LDR      r0,[r0,#0x44]
000ce6  b168              CBZ      r0,|L1.3332|
;;;2776   			{
;;;2777   				( pxCurrentTCB->uxCriticalNesting )--;
000ce8  4908              LDR      r1,|L1.3340|
000cea  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000cec  f1010044          ADD      r0,r1,#0x44
000cf0  6c49              LDR      r1,[r1,#0x44]
000cf2  1e49              SUBS     r1,r1,#1
000cf4  6001              STR      r1,[r0,#0]
;;;2778   
;;;2779   				if( pxCurrentTCB->uxCriticalNesting == 0U )
000cf6  4805              LDR      r0,|L1.3340|
000cf8  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000cfa  6c40              LDR      r0,[r0,#0x44]
000cfc  b910              CBNZ     r0,|L1.3332|
;;;2780   				{
;;;2781   					portENABLE_INTERRUPTS();
000cfe  2000              MOVS     r0,#0
000d00  f7fffffe          BL       vPortClearInterruptMask
                  |L1.3332|
;;;2782   				}
;;;2783   			}
;;;2784   		}
;;;2785   	}
000d04  bd10              POP      {r4,pc}
;;;2786   
                          ENDP

000d06  0000              DCW      0x0000
                  |L1.3336|
                          DCD      xSchedulerRunning
                  |L1.3340|
                          DCD      pxCurrentTCB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        200
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ucExpectedStackBytes
000000  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000004  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000008  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
00000c  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5
000010  a5a5a5a5          DCB      0xa5,0xa5,0xa5,0xa5

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
