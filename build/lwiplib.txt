; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\lwiplib.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\lwiplib.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\Driver -I.\web -I.\third_party\lwip-1.4.1\src\include -I.\third_party\fatfs -I.\third_party\lwip-1.4.1\apps\httpserver_raw -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch -I.\third_party\lwip-1.4.1\src\include\ipv4 -I..\MCU -I.\third_party\lwip-1.4.1\apps -I.\third_party -I.\Upnp -I.\Dsp -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C129XNCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DUSE_LWIP -DTM4C129ENCPDT --omf_browse=.\build\lwiplib.crf web\lwiplib.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sys_arch_unprotect PROC
;;;674    void
;;;675    sys_arch_unprotect(sys_prot_t val)
000000  b510              PUSH     {r4,lr}
;;;676    {
000002  4604              MOV      r4,r0
;;;677    #if RTOS_FREERTOS
;;;678      taskEXIT_CRITICAL();
000004  f7fffffe          BL       vPortExitCritical
;;;679    #endif
;;;680    }
000008  bd10              POP      {r4,pc}
;;;681    
                          ENDP

                  sys_arch_protect PROC
;;;659    sys_prot_t
;;;660    sys_arch_protect(void)
00000a  b510              PUSH     {r4,lr}
;;;661    {
;;;662    #if RTOS_FREERTOS
;;;663      taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;664    #endif
;;;665    
;;;666      return 1;
000010  2001              MOVS     r0,#1
;;;667    }
000012  bd10              POP      {r4,pc}
;;;668    
                          ENDP

                  memp_free PROC
;;;434    void
;;;435    memp_free(memp_t type, void *mem)
000014  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000018  4604              MOV      r4,r0
00001a  460d              MOV      r5,r1
;;;437      struct memp *memp;
;;;438      SYS_ARCH_DECL_PROTECT(old_level);
;;;439    
;;;440      if (mem == NULL) {
00001c  b90d              CBNZ     r5,|L1.34|
                  |L1.30|
;;;441        return;
;;;442      }
;;;443      LWIP_ASSERT("memp_free: mem properly aligned",
;;;444                    ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
;;;445    
;;;446      memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
;;;447    
;;;448      SYS_ARCH_PROTECT(old_level);
;;;449    #if MEMP_OVERFLOW_CHECK
;;;450    #if MEMP_OVERFLOW_CHECK >= 2
;;;451      memp_overflow_check_all();
;;;452    #else
;;;453      memp_overflow_check_element_overflow(memp, type);
;;;454      memp_overflow_check_element_underflow(memp, type);
;;;455    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;456    #endif /* MEMP_OVERFLOW_CHECK */
;;;457    
;;;458      MEMP_STATS_DEC(used, type); 
;;;459      
;;;460      memp->next = memp_tab[type]; 
;;;461      memp_tab[type] = memp;
;;;462    
;;;463    #if MEMP_SANITY_CHECK
;;;464      LWIP_ASSERT("memp sanity", memp_sanity());
;;;465    #endif /* MEMP_SANITY_CHECK */
;;;466    
;;;467      SYS_ARCH_UNPROTECT(old_level);
;;;468    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.34|
000022  bf00              NOP                            ;443
000024  bf00              NOP                            ;443
000026  462e              MOV      r6,r5                 ;446
000028  f7fffffe          BL       sys_arch_protect
00002c  4607              MOV      r7,r0                 ;448
00002e  eb040184          ADD      r1,r4,r4,LSL #2       ;458
000032  48f9              LDR      r0,|L1.1048|
000034  eb000081          ADD      r0,r0,r1,LSL #2       ;458
000038  6880              LDR      r0,[r0,#8]            ;458
00003a  1e40              SUBS     r0,r0,#1              ;458
00003c  eb040284          ADD      r2,r4,r4,LSL #2       ;458
000040  49f5              LDR      r1,|L1.1048|
000042  eb010182          ADD      r1,r1,r2,LSL #2       ;458
000046  6088              STR      r0,[r1,#8]            ;458
000048  48f4              LDR      r0,|L1.1052|
00004a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;460
00004e  6030              STR      r0,[r6,#0]            ;460
000050  48f2              LDR      r0,|L1.1052|
000052  f8406024          STR      r6,[r0,r4,LSL #2]     ;461
000056  4638              MOV      r0,r7                 ;467
000058  f7fffffe          BL       sys_arch_unprotect
00005c  bf00              NOP      
00005e  e7de              B        |L1.30|
;;;469    
                          ENDP

                  sys_mbox_free PROC
;;;517    void
;;;518    sys_mbox_free(sys_mbox_t *mbox)
000060  b570              PUSH     {r4-r6,lr}
;;;519    {
000062  4604              MOV      r4,r0
;;;520    	unsigned char i;
;;;521    	
;;;522      /* There should not be any messages waiting (if there are it is a bug).  If
;;;523         any are waiting, increment the mailbox error count. */
;;;524    #if RTOS_FREERTOS
;;;525      if(uxQueueMessagesWaiting(mbox->queue) != 0) {
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       uxQueueMessagesWaiting
00006a  b148              CBZ      r0,|L1.128|
;;;526    #endif /* RTOS_FREERTOS */
;;;527    
;;;528    #if SYS_STATS
;;;529        STATS_INC(sys.mbox.err);
00006c  48ea              LDR      r0,|L1.1048|
00006e  38c0              SUBS     r0,r0,#0xc0
000070  f8b001d4          LDRH     r0,[r0,#0x1d4]
000074  1c40              ADDS     r0,r0,#1
000076  b281              UXTH     r1,r0
000078  48e7              LDR      r0,|L1.1048|
00007a  38c0              SUBS     r0,r0,#0xc0
00007c  f8a011d4          STRH     r1,[r0,#0x1d4]
                  |L1.128|
;;;530    #endif /* SYS_STATS */
;;;531      }
;;;532    
;;;533    	vQueueDelete(mbox->queue);
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       vQueueDelete
;;;534    	
;;;535    	for(i = 0; i < SYS_MBOX_MAX; i++){
000086  2500              MOVS     r5,#0
000088  e010              B        |L1.172|
                  |L1.138|
;;;536    		if(mboxes[i].queue == mbox->queue){
00008a  eb051005          ADD      r0,r5,r5,LSL #4
00008e  49e4              LDR      r1,|L1.1056|
000090  f8510030          LDR      r0,[r1,r0,LSL #3]
000094  6821              LDR      r1,[r4,#0]
000096  4288              CMP      r0,r1
000098  d106              BNE      |L1.168|
;;;537    			mboxes[i].queue = 0;
00009a  2000              MOVS     r0,#0
00009c  eb051105          ADD      r1,r5,r5,LSL #4
0000a0  4adf              LDR      r2,|L1.1056|
0000a2  f8420031          STR      r0,[r2,r1,LSL #3]
;;;538    			break;
0000a6  e003              B        |L1.176|
                  |L1.168|
0000a8  1c68              ADDS     r0,r5,#1              ;535
0000aa  b2c5              UXTB     r5,r0                 ;535
                  |L1.172|
0000ac  2d10              CMP      r5,#0x10              ;535
0000ae  dbec              BLT      |L1.138|
                  |L1.176|
0000b0  bf00              NOP      
;;;539    		}
;;;540    	}
;;;541    	
;;;542      /* Clear the queue handle. */
;;;543      mbox->queue = 0;
0000b2  2000              MOVS     r0,#0
0000b4  6020              STR      r0,[r4,#0]
;;;544    
;;;545      /* Update the mailbox statistics. */
;;;546    #if SYS_STATS
;;;547       STATS_DEC(sys.mbox.used);
0000b6  48d8              LDR      r0,|L1.1048|
0000b8  38c0              SUBS     r0,r0,#0xc0
0000ba  f8b001d0          LDRH     r0,[r0,#0x1d0]
0000be  1e40              SUBS     r0,r0,#1
0000c0  b281              UXTH     r1,r0
0000c2  48d5              LDR      r0,|L1.1048|
0000c4  38c0              SUBS     r0,r0,#0xc0
0000c6  f8a011d0          STRH     r1,[r0,#0x1d0]
;;;548    #endif /* SYS_STATS */
;;;549    }
0000ca  bd70              POP      {r4-r6,pc}
;;;550    
                          ENDP

                  sys_sem_free PROC
;;;311    void
;;;312    sys_sem_free(sys_sem_t *sem)
0000cc  b570              PUSH     {r4-r6,lr}
;;;313    {
0000ce  4604              MOV      r4,r0
;;;314    	unsigned char index;
;;;315    	
;;;316    	vQueueDelete(sem->queue);
0000d0  6820              LDR      r0,[r4,#0]
0000d2  f7fffffe          BL       vQueueDelete
;;;317    	
;;;318    	for(index = 0; index < SYS_SEM_MAX; index++){
0000d6  2500              MOVS     r5,#0
0000d8  e010              B        |L1.252|
                  |L1.218|
;;;319    		if(sems[index].queue == sem->queue){
0000da  eb050045          ADD      r0,r5,r5,LSL #1
0000de  49d1              LDR      r1,|L1.1060|
0000e0  f8510020          LDR      r0,[r1,r0,LSL #2]
0000e4  6821              LDR      r1,[r4,#0]
0000e6  4288              CMP      r0,r1
0000e8  d106              BNE      |L1.248|
;;;320    			sems[index].queue = 0;
0000ea  2000              MOVS     r0,#0
0000ec  eb050145          ADD      r1,r5,r5,LSL #1
0000f0  4acc              LDR      r2,|L1.1060|
0000f2  f8420021          STR      r0,[r2,r1,LSL #2]
;;;321    			break;
0000f6  e003              B        |L1.256|
                  |L1.248|
0000f8  1c68              ADDS     r0,r5,#1              ;318
0000fa  b2c5              UXTB     r5,r0                 ;318
                  |L1.252|
0000fc  2d10              CMP      r5,#0x10              ;318
0000fe  dbec              BLT      |L1.218|
                  |L1.256|
000100  bf00              NOP      
;;;322    		}
;;;323    	}
;;;324    	
;;;325      /* Clear the queue handle. */
;;;326      sem->queue = 0;
000102  2000              MOVS     r0,#0
000104  6020              STR      r0,[r4,#0]
;;;327    
;;;328      /* Update the semaphore statistics. */
;;;329    #if SYS_STATS
;;;330      STATS_DEC(sys.sem.used);
000106  48c4              LDR      r0,|L1.1048|
000108  38c0              SUBS     r0,r0,#0xc0
00010a  f8b001c4          LDRH     r0,[r0,#0x1c4]  ; lwip_stats
00010e  1e40              SUBS     r0,r0,#1
000110  49c1              LDR      r1,|L1.1048|
000112  39c0              SUBS     r1,r1,#0xc0
000114  f8a101c4          STRH     r0,[r1,#0x1c4]
;;;331    #endif /* SYS_STATS */
;;;332    }
000118  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

                  sys_mbox_valid PROC
;;;556    int
;;;557    sys_mbox_valid(sys_mbox_t *mbox)
00011a  4601              MOV      r1,r0
;;;558    {
;;;559      /*Check if a mailbox has been created*/
;;;560      if(mbox->queue == SYS_MBOX_NULL){
00011c  6808              LDR      r0,[r1,#0]
00011e  b908              CBNZ     r0,|L1.292|
;;;561          return 0;
000120  2000              MOVS     r0,#0
                  |L1.290|
;;;562      }
;;;563      else{
;;;564          return 1;
;;;565      }
;;;566    }
000122  4770              BX       lr
                  |L1.292|
000124  2001              MOVS     r0,#1                 ;564
000126  e7fc              B        |L1.290|
;;;567    
                          ENDP

                  sys_sem_valid PROC
;;;238    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
;;;239    int sys_sem_valid(sys_sem_t *sem)
000128  4601              MOV      r1,r0
;;;240    {
;;;241      /*Check if a mailbox has been created*/
;;;242      if(sem->queue == SYS_SEM_NULL){
00012a  6808              LDR      r0,[r1,#0]
00012c  b908              CBNZ     r0,|L1.306|
;;;243          return 0;
00012e  2000              MOVS     r0,#0
                  |L1.304|
;;;244      }
;;;245      else{
;;;246          return 1;
;;;247      }	
;;;248    }
000130  4770              BX       lr
                  |L1.306|
000132  2001              MOVS     r0,#1                 ;246
000134  e7fc              B        |L1.304|
;;;249    
                          ENDP

                  sys_arch_sem_wait PROC
;;;277    u32_t
;;;278    sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
000136  b5f8              PUSH     {r3-r7,lr}
;;;279    {
000138  4604              MOV      r4,r0
00013a  460d              MOV      r5,r1
;;;280      portTickType starttime;
;;;281      void *msg = 0;
00013c  2000              MOVS     r0,#0
00013e  9000              STR      r0,[sp,#0]
;;;282    
;;;283      /* Get the starting time. */
;;;284      starttime = xTaskGetTickCount();
000140  f7fffffe          BL       xTaskGetTickCount
000144  4606              MOV      r6,r0
;;;285    
;;;286      /* See if there is a timeout. */
;;;287      if(timeout != 0) {
000146  b175              CBZ      r5,|L1.358|
;;;288        /* Send a message to the queue. */
;;;289        if(xQueueSend(sem->queue, &msg, timeout / portTICK_RATE_MS) == pdPASS) {
000148  2300              MOVS     r3,#0
00014a  462a              MOV      r2,r5
00014c  4669              MOV      r1,sp
00014e  6820              LDR      r0,[r4,#0]
000150  f7fffffe          BL       xQueueGenericSend
000154  2801              CMP      r0,#1
000156  d103              BNE      |L1.352|
;;;290          /* Return the amount of time it took for the semaphore to be
;;;291             signalled. */
;;;292          return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
000158  f7fffffe          BL       xTaskGetTickCount
00015c  1b80              SUBS     r0,r0,r6
                  |L1.350|
;;;293        } else {
;;;294          /* The semaphore failed to signal in the allotted time. */
;;;295          return SYS_ARCH_TIMEOUT;
;;;296        }
;;;297      } else {
;;;298        /* Try to send a message to the queue until it succeeds. */
;;;299        while(xQueueSend(sem->queue, &msg, portMAX_DELAY) != pdPASS);
;;;300    
;;;301        /* Return the amount of time it took for the semaphore to be signalled. */
;;;302        return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
;;;303      }
;;;304    }
00015e  bdf8              POP      {r3-r7,pc}
                  |L1.352|
000160  f04f30ff          MOV      r0,#0xffffffff        ;295
000164  e7fb              B        |L1.350|
                  |L1.358|
000166  bf00              NOP                            ;299
                  |L1.360|
000168  2300              MOVS     r3,#0                 ;299
00016a  1e5a              SUBS     r2,r3,#1              ;299
00016c  4669              MOV      r1,sp                 ;299
00016e  6820              LDR      r0,[r4,#0]            ;299
000170  f7fffffe          BL       xQueueGenericSend
000174  2801              CMP      r0,#1                 ;299
000176  d1f7              BNE      |L1.360|
000178  f7fffffe          BL       xTaskGetTickCount
00017c  1b80              SUBS     r0,r0,r6              ;302
00017e  e7ee              B        |L1.350|
;;;305    
                          ENDP

                  sys_mbox_post PROC
;;;406    void
;;;407    sys_mbox_post(sys_mbox_t *mbox, void *msg)
000180  b513              PUSH     {r0,r1,r4,lr}
;;;408    {
000182  4604              MOV      r4,r0
;;;409      /* Send this message to the queue. */
;;;410      while(xQueueSend(mbox->queue, &msg, portMAX_DELAY) != pdPASS);
000184  bf00              NOP      
                  |L1.390|
000186  2300              MOVS     r3,#0
000188  1e5a              SUBS     r2,r3,#1
00018a  a901              ADD      r1,sp,#4
00018c  6820              LDR      r0,[r4,#0]
00018e  f7fffffe          BL       xQueueGenericSend
000192  2801              CMP      r0,#1
000194  d1f7              BNE      |L1.390|
;;;411    }
000196  bd1c              POP      {r2-r4,pc}
;;;412    
                          ENDP

                  tcpip_apimsg PROC
;;;306    err_t
;;;307    tcpip_apimsg(struct api_msg *apimsg)
000198  b510              PUSH     {r4,lr}
;;;308    {
00019a  b086              SUB      sp,sp,#0x18
00019c  4604              MOV      r4,r0
;;;309      struct tcpip_msg msg;
;;;310    #ifdef LWIP_DEBUG
;;;311      /* catch functions that don't set err */
;;;312      apimsg->msg.err = ERR_VAL;
00019e  21fa              MOVS     r1,#0xfa
0001a0  7221              STRB     r1,[r4,#8]
;;;313    #endif
;;;314      
;;;315      if (sys_mbox_valid(&mbox)) {
0001a2  48a1              LDR      r0,|L1.1064|
0001a4  f7fffffe          BL       sys_mbox_valid
0001a8  b188              CBZ      r0,|L1.462|
;;;316        msg.type = TCPIP_MSG_API;
0001aa  2000              MOVS     r0,#0
0001ac  f88d0004          STRB     r0,[sp,#4]
;;;317        msg.msg.apimsg = apimsg;
0001b0  9403              STR      r4,[sp,#0xc]
;;;318        sys_mbox_post(&mbox, &msg);
0001b2  a901              ADD      r1,sp,#4
0001b4  489c              LDR      r0,|L1.1064|
0001b6  f7fffffe          BL       sys_mbox_post
;;;319        sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
0001ba  6861              LDR      r1,[r4,#4]
0001bc  f101000c          ADD      r0,r1,#0xc
0001c0  2100              MOVS     r1,#0
0001c2  f7fffffe          BL       sys_arch_sem_wait
;;;320        return apimsg->msg.err;
0001c6  f9940008          LDRSB    r0,[r4,#8]
                  |L1.458|
;;;321      }
;;;322      return ERR_VAL;
;;;323    }
0001ca  b006              ADD      sp,sp,#0x18
0001cc  bd10              POP      {r4,pc}
                  |L1.462|
0001ce  f06f0005          MVN      r0,#5                 ;322
0001d2  e7fa              B        |L1.458|
;;;324    
                          ENDP

                  sys_sem_signal PROC
;;;259    void
;;;260    sys_sem_signal(sys_sem_t *sem)
0001d4  b538              PUSH     {r3-r5,lr}
;;;261    {
0001d6  4604              MOV      r4,r0
;;;262      void *msg;
;;;263    
;;;264      /* Receive a message from the semaphore's queue. */
;;;265      xQueueReceive(sem->queue, &msg, 0);
0001d8  2300              MOVS     r3,#0
0001da  461a              MOV      r2,r3
0001dc  4669              MOV      r1,sp
0001de  6820              LDR      r0,[r4,#0]
0001e0  f7fffffe          BL       xQueueGenericReceive
;;;266    }
0001e4  bd38              POP      {r3-r5,pc}
;;;267    
                          ENDP

                  sys_mbox_trypost PROC
;;;421    err_t
;;;422    sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
0001e6  b513              PUSH     {r0,r1,r4,lr}
;;;423    {
0001e8  4604              MOV      r4,r0
;;;424      /* Send this message to the queue. */
;;;425      if(xQueueSend(mbox->queue, &msg, 0) == pdPASS) {
0001ea  2300              MOVS     r3,#0
0001ec  461a              MOV      r2,r3
0001ee  a901              ADD      r1,sp,#4
0001f0  6820              LDR      r0,[r4,#0]
0001f2  f7fffffe          BL       xQueueGenericSend
0001f6  2801              CMP      r0,#1
0001f8  d101              BNE      |L1.510|
;;;426        return ERR_OK;
0001fa  2000              MOVS     r0,#0
                  |L1.508|
;;;427      }
;;;428    
;;;429      /* Update the mailbox statistics. */
;;;430    #if SYS_STATS
;;;431      STATS_INC(sys.mbox.err);
;;;432    #endif /* SYS_STATS */
;;;433    
;;;434      /* The message could not be sent. */
;;;435      return ERR_MEM;
;;;436    }
0001fc  bd1c              POP      {r2-r4,pc}
                  |L1.510|
0001fe  4886              LDR      r0,|L1.1048|
000200  38c0              SUBS     r0,r0,#0xc0           ;431
000202  f8b001d4          LDRH     r0,[r0,#0x1d4]        ;431
000206  1c40              ADDS     r0,r0,#1              ;431
000208  b281              UXTH     r1,r0                 ;431
00020a  4883              LDR      r0,|L1.1048|
00020c  38c0              SUBS     r0,r0,#0xc0           ;431
00020e  f8a011d4          STRH     r1,[r0,#0x1d4]        ;431
000212  f04f30ff          MOV      r0,#0xffffffff        ;435
000216  e7f1              B        |L1.508|
;;;437    
                          ENDP

                  err_tcp PROC
;;;347    static void
;;;348    err_tcp(void *arg, err_t err)
000218  e92d47f0          PUSH     {r4-r10,lr}
;;;349    {
00021c  4607              MOV      r7,r0
00021e  460e              MOV      r6,r1
;;;350      struct netconn *conn;
;;;351      enum netconn_state old_state;
;;;352      SYS_ARCH_DECL_PROTECT(lev);
;;;353    
;;;354      conn = (struct netconn *)arg;
000220  463c              MOV      r4,r7
;;;355      LWIP_ASSERT("conn != NULL", (conn != NULL));
000222  bf00              NOP      
000224  bf00              NOP      
;;;356    
;;;357      conn->pcb.tcp = NULL;
000226  2000              MOVS     r0,#0
000228  6060              STR      r0,[r4,#4]
;;;358    
;;;359      /* no check since this is always fatal! */
;;;360      SYS_ARCH_PROTECT(lev);
00022a  f7fffffe          BL       sys_arch_protect
00022e  4681              MOV      r9,r0
;;;361      conn->last_err = err;
000230  7226              STRB     r6,[r4,#8]
;;;362      SYS_ARCH_UNPROTECT(lev);
000232  4648              MOV      r0,r9
000234  f7fffffe          BL       sys_arch_unprotect
;;;363    
;;;364      /* reset conn->state now before waking up other threads */
;;;365      old_state = conn->state;
000238  7865              LDRB     r5,[r4,#1]
;;;366      conn->state = NETCONN_NONE;
00023a  2000              MOVS     r0,#0
00023c  7060              STRB     r0,[r4,#1]
;;;367    
;;;368      /* Notify the user layer about a connection error. Used to signal
;;;369         select. */
;;;370      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
00023e  f8d40138          LDR      r0,[r4,#0x138]
000242  b128              CBZ      r0,|L1.592|
000244  2200              MOVS     r2,#0
000246  2104              MOVS     r1,#4
000248  4620              MOV      r0,r4
00024a  f8d43138          LDR      r3,[r4,#0x138]
00024e  4798              BLX      r3
                  |L1.592|
;;;371      /* Try to release selects pending on 'read' or 'write', too.
;;;372         They will get an error if they actually try to read or write. */
;;;373      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
000250  f8d40138          LDR      r0,[r4,#0x138]
000254  b128              CBZ      r0,|L1.610|
000256  2200              MOVS     r2,#0
000258  4611              MOV      r1,r2
00025a  4620              MOV      r0,r4
00025c  f8d43138          LDR      r3,[r4,#0x138]
000260  4798              BLX      r3
                  |L1.610|
;;;374      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
000262  f8d40138          LDR      r0,[r4,#0x138]
000266  b128              CBZ      r0,|L1.628|
000268  2200              MOVS     r2,#0
00026a  2102              MOVS     r1,#2
00026c  4620              MOV      r0,r4
00026e  f8d43138          LDR      r3,[r4,#0x138]
000272  4798              BLX      r3
                  |L1.628|
;;;375    
;;;376      /* pass NULL-message to recvmbox to wake up pending recv */
;;;377      if (sys_mbox_valid(&conn->recvmbox)) {
000274  f1040018          ADD      r0,r4,#0x18
000278  f7fffffe          BL       sys_mbox_valid
00027c  b120              CBZ      r0,|L1.648|
;;;378        /* use trypost to prevent deadlock */
;;;379        sys_mbox_trypost(&conn->recvmbox, NULL);
00027e  2100              MOVS     r1,#0
000280  f1040018          ADD      r0,r4,#0x18
000284  f7fffffe          BL       sys_mbox_trypost
                  |L1.648|
;;;380      }
;;;381      /* pass NULL-message to acceptmbox to wake up pending accept */
;;;382      if (sys_mbox_valid(&conn->acceptmbox)) {
000288  f10400a0          ADD      r0,r4,#0xa0
00028c  f7fffffe          BL       sys_mbox_valid
000290  b120              CBZ      r0,|L1.668|
;;;383        /* use trypost to preven deadlock */
;;;384        sys_mbox_trypost(&conn->acceptmbox, NULL);
000292  2100              MOVS     r1,#0
000294  f10400a0          ADD      r0,r4,#0xa0
000298  f7fffffe          BL       sys_mbox_trypost
                  |L1.668|
;;;385      }
;;;386    
;;;387      if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
00029c  2d01              CMP      r5,#1
00029e  d003              BEQ      |L1.680|
0002a0  2d04              CMP      r5,#4
0002a2  d001              BEQ      |L1.680|
;;;388          (old_state == NETCONN_CONNECT)) {
0002a4  2d03              CMP      r5,#3
0002a6  d11b              BNE      |L1.736|
                  |L1.680|
;;;389        /* calling do_writemore/do_close_internal is not necessary
;;;390           since the pcb has already been deleted! */
;;;391        int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
0002a8  f894012c          LDRB     r0,[r4,#0x12c]
0002ac  f3c00880          UBFX     r8,r0,#2,#1
;;;392        SET_NONBLOCKING_CONNECT(conn, 0);
0002b0  bf00              NOP      
0002b2  f894012c          LDRB     r0,[r4,#0x12c]
0002b6  f0200004          BIC      r0,r0,#4
0002ba  f884012c          STRB     r0,[r4,#0x12c]
0002be  bf00              NOP      
;;;393    
;;;394        if (!was_nonblocking_connect) {
0002c0  f1b80f00          CMP      r8,#0
0002c4  d10b              BNE      |L1.734|
;;;395          /* set error return code */
;;;396          LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
0002c6  bf00              NOP      
0002c8  bf00              NOP      
;;;397          conn->current_msg->err = err;
0002ca  f8d40134          LDR      r0,[r4,#0x134]
0002ce  7106              STRB     r6,[r0,#4]
;;;398          conn->current_msg = NULL;
0002d0  2000              MOVS     r0,#0
0002d2  f8c40134          STR      r0,[r4,#0x134]
;;;399          /* wake up the waiting task */
;;;400          sys_sem_signal(&conn->op_completed);
0002d6  f104000c          ADD      r0,r4,#0xc
0002da  f7fffffe          BL       sys_sem_signal
                  |L1.734|
;;;401        }
;;;402      } else {
0002de  e001              B        |L1.740|
                  |L1.736|
;;;403        LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
0002e0  bf00              NOP      
0002e2  bf00              NOP      
                  |L1.740|
;;;404      }
;;;405    }
0002e4  e8bd87f0          POP      {r4-r10,pc}
;;;406    
                          ENDP

                  tcp_err PROC
;;;1422   void
;;;1423   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
0002e8  bf00              NOP      
;;;1424   {
;;;1425     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
0002ea  bf00              NOP      
;;;1426     pcb->errf = err;
0002ec  f8c0108c          STR      r1,[r0,#0x8c]
;;;1427   }
0002f0  4770              BX       lr
;;;1428   
                          ENDP

                  tcp_arg PROC
;;;1377   void
;;;1378   tcp_arg(struct tcp_pcb *pcb, void *arg)
0002f2  6101              STR      r1,[r0,#0x10]
;;;1379   {
;;;1380     /* This function is allowed to be called for both listen pcbs and
;;;1381        connection pcbs. */
;;;1382     pcb->callback_arg = arg;
;;;1383   }
0002f4  4770              BX       lr
;;;1384   #if LWIP_CALLBACK_API
                          ENDP

                  tcp_poll PROC
;;;1453   void
;;;1454   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
0002f6  bf00              NOP      
;;;1455   {
;;;1456     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
0002f8  bf00              NOP      
;;;1457   #if LWIP_CALLBACK_API
;;;1458     pcb->poll = poll;
0002fa  f8c01088          STR      r1,[r0,#0x88]
;;;1459   #else /* LWIP_CALLBACK_API */  
;;;1460     LWIP_UNUSED_ARG(poll);
;;;1461   #endif /* LWIP_CALLBACK_API */  
;;;1462     pcb->pollinterval = interval;
0002fe  f8802020          STRB     r2,[r0,#0x20]
;;;1463   }
000302  4770              BX       lr
;;;1464   
                          ENDP

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000304  b530              PUSH     {r4,r5,lr}
;;;237    {
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000306  bf00              NOP      
000308  bf00              NOP      
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
00030a  bf00              NOP      
00030c  bf00              NOP      
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00030e  bf00              NOP      
000310  bf00              NOP      
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
000312  bf00              NOP      
000314  bf00              NOP      
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
000316  4c45              LDR      r4,|L1.1068|
000318  6803              LDR      r3,[r0,#0]
00031a  6824              LDR      r4,[r4,#0]  ; ram
00031c  1919              ADDS     r1,r3,r4
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
00031e  4288              CMP      r0,r1
000320  d015              BEQ      |L1.846|
000322  7a0b              LDRB     r3,[r1,#8]
000324  b99b              CBNZ     r3,|L1.846|
000326  4b42              LDR      r3,|L1.1072|
000328  681b              LDR      r3,[r3,#0]  ; ram_end
00032a  4299              CMP      r1,r3
00032c  d00f              BEQ      |L1.846|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
00032e  4b41              LDR      r3,|L1.1076|
000330  681b              LDR      r3,[r3,#0]  ; lfree
000332  428b              CMP      r3,r1
000334  d101              BNE      |L1.826|
;;;252          lfree = mem;
000336  4b3f              LDR      r3,|L1.1076|
000338  6018              STR      r0,[r3,#0]  ; lfree
                  |L1.826|
;;;253        }
;;;254        mem->next = nmem->next;
00033a  680b              LDR      r3,[r1,#0]
00033c  6003              STR      r3,[r0,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
00033e  4b3b              LDR      r3,|L1.1068|
000340  681b              LDR      r3,[r3,#0]  ; ram
000342  1ac3              SUBS     r3,r0,r3
000344  4d39              LDR      r5,|L1.1068|
000346  680c              LDR      r4,[r1,#0]
000348  682d              LDR      r5,[r5,#0]  ; ram
00034a  442c              ADD      r4,r4,r5
00034c  6063              STR      r3,[r4,#4]
                  |L1.846|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
00034e  4c37              LDR      r4,|L1.1068|
000350  6843              LDR      r3,[r0,#4]
000352  6824              LDR      r4,[r4,#0]  ; ram
000354  191a              ADDS     r2,r3,r4
;;;260      if (pmem != mem && pmem->used == 0) {
000356  4282              CMP      r2,r0
000358  d011              BEQ      |L1.894|
00035a  7a13              LDRB     r3,[r2,#8]
00035c  b97b              CBNZ     r3,|L1.894|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
00035e  4b35              LDR      r3,|L1.1076|
000360  681b              LDR      r3,[r3,#0]  ; lfree
000362  4283              CMP      r3,r0
000364  d101              BNE      |L1.874|
;;;263          lfree = pmem;
000366  4b33              LDR      r3,|L1.1076|
000368  601a              STR      r2,[r3,#0]  ; lfree
                  |L1.874|
;;;264        }
;;;265        pmem->next = mem->next;
00036a  6803              LDR      r3,[r0,#0]
00036c  6013              STR      r3,[r2,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
00036e  4b2f              LDR      r3,|L1.1068|
000370  681b              LDR      r3,[r3,#0]  ; ram
000372  1ad3              SUBS     r3,r2,r3
000374  4d2d              LDR      r5,|L1.1068|
000376  6804              LDR      r4,[r0,#0]
000378  682d              LDR      r5,[r5,#0]  ; ram
00037a  442c              ADD      r4,r4,r5
00037c  6063              STR      r3,[r4,#4]
                  |L1.894|
;;;267      }
;;;268    }
00037e  bd30              POP      {r4,r5,pc}
;;;269    
                          ENDP

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000380  b570              PUSH     {r4-r6,lr}
;;;312    {
000382  4605              MOV      r5,r0
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
000384  b915              CBNZ     r5,|L1.908|
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
000386  bf00              NOP      
000388  bf00              NOP      
                  |L1.906|
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
;;;342    
;;;343      if (mem < lfree) {
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
00038a  bd70              POP      {r4-r6,pc}
                  |L1.908|
00038c  bf00              NOP                            ;320
00038e  bf00              NOP                            ;320
000390  bf00              NOP                            ;322
000392  bf00              NOP                            ;322
000394  4825              LDR      r0,|L1.1068|
000396  6800              LDR      r0,[r0,#0]            ;325  ; ram
000398  4285              CMP      r5,r0                 ;325
00039a  d303              BCC      |L1.932|
00039c  4824              LDR      r0,|L1.1072|
00039e  6800              LDR      r0,[r0,#0]            ;325  ; ram_end
0003a0  4285              CMP      r5,r0                 ;325
0003a2  d312              BCC      |L1.970|
                  |L1.932|
0003a4  bf00              NOP                            ;327
0003a6  bf00              NOP                            ;327
0003a8  f7fffffe          BL       sys_arch_protect
0003ac  4606              MOV      r6,r0                 ;329
0003ae  481a              LDR      r0,|L1.1048|
0003b0  38c0              SUBS     r0,r0,#0xc0           ;330
0003b2  f8b000be          LDRH     r0,[r0,#0xbe]         ;330
0003b6  1c40              ADDS     r0,r0,#1              ;330
0003b8  b281              UXTH     r1,r0                 ;330
0003ba  4817              LDR      r0,|L1.1048|
0003bc  38c0              SUBS     r0,r0,#0xc0           ;330
0003be  f8a010be          STRH     r1,[r0,#0xbe]         ;330
0003c2  4630              MOV      r0,r6                 ;331
0003c4  f7fffffe          BL       sys_arch_unprotect
0003c8  e7df              B        |L1.906|
                  |L1.970|
0003ca  2100              MOVS     r1,#0                 ;335
0003cc  481a              LDR      r0,|L1.1080|
0003ce  f7fffffe          BL       sys_arch_sem_wait
0003d2  f1a5040c          SUB      r4,r5,#0xc            ;337
0003d6  bf00              NOP                            ;339
0003d8  bf00              NOP                            ;339
0003da  2000              MOVS     r0,#0                 ;341
0003dc  7220              STRB     r0,[r4,#8]            ;341
0003de  4815              LDR      r0,|L1.1076|
0003e0  6800              LDR      r0,[r0,#0]            ;343  ; lfree
0003e2  4284              CMP      r4,r0                 ;343
0003e4  d201              BCS      |L1.1002|
0003e6  4813              LDR      r0,|L1.1076|
0003e8  6004              STR      r4,[r0,#0]            ;345  ; lfree
                  |L1.1002|
0003ea  4910              LDR      r1,|L1.1068|
0003ec  6820              LDR      r0,[r4,#0]            ;348
0003ee  6809              LDR      r1,[r1,#0]            ;348  ; ram
0003f0  1a61              SUBS     r1,r4,r1              ;348
0003f2  1a41              SUBS     r1,r0,r1              ;348
0003f4  4808              LDR      r0,|L1.1048|
0003f6  38c0              SUBS     r0,r0,#0xc0           ;348
0003f8  f8d000b4          LDR      r0,[r0,#0xb4]         ;348
0003fc  1a41              SUBS     r1,r0,r1              ;348
0003fe  4806              LDR      r0,|L1.1048|
000400  38c0              SUBS     r0,r0,#0xc0           ;348
000402  f8c010b4          STR      r1,[r0,#0xb4]         ;348
000406  4620              MOV      r0,r4                 ;351
000408  f7fffffe          BL       plug_holes
00040c  480a              LDR      r0,|L1.1080|
00040e  f7fffffe          BL       sys_sem_signal
000412  bf00              NOP      
000414  e7b9              B        |L1.906|
000416  0000              DCW      0x0000
                  |L1.1048|
                          DCD      lwip_stats+0xc0
                  |L1.1052|
                          DCD      memp_tab
                  |L1.1056|
                          DCD      mboxes
                  |L1.1060|
                          DCD      sems
                  |L1.1064|
                          DCD      mbox
                  |L1.1068|
                          DCD      ||ram||
                  |L1.1072|
                          DCD      ram_end
                  |L1.1076|
                          DCD      lfree
                  |L1.1080|
                          DCD      mem_mutex
                          ENDP

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
00043c  e92d47f0          PUSH     {r4-r10,lr}
;;;619    {
000440  4604              MOV      r4,r0
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
000442  b934              CBNZ     r4,|L1.1106|
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
000444  bf00              NOP      
000446  bf00              NOP      
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
000448  bf00              NOP      
00044a  bf00              NOP      
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
00044c  2000              MOVS     r0,#0
                  |L1.1102|
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
00044e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1106|
000452  bf00              NOP                            ;631
000454  bf00              NOP                            ;631
000456  bf00              NOP                            ;635
000458  bf00              NOP                            ;635
00045a  2600              MOVS     r6,#0                 ;639
00045c  e02f              B        |L1.1214|
                  |L1.1118|
00045e  f7fffffe          BL       sys_arch_protect
000462  4681              MOV      r9,r0                 ;648
000464  bf00              NOP                            ;650
000466  bf00              NOP                            ;650
000468  89e0              LDRH     r0,[r4,#0xe]          ;652
00046a  1e40              SUBS     r0,r0,#1              ;652
00046c  fa1ff880          UXTH     r8,r0                 ;652
000470  f8a4800e          STRH     r8,[r4,#0xe]          ;652
000474  4648              MOV      r0,r9                 ;653
000476  f7fffffe          BL       sys_arch_unprotect
00047a  f1b80f00          CMP      r8,#0                 ;655
00047e  d11a              BNE      |L1.1206|
000480  6827              LDR      r7,[r4,#0]            ;657
000482  bf00              NOP                            ;658
000484  bf00              NOP                            ;658
000486  7b25              LDRB     r5,[r4,#0xc]          ;659
000488  2d03              CMP      r5,#3                 ;670
00048a  d104              BNE      |L1.1174|
00048c  4621              MOV      r1,r4                 ;671
00048e  200c              MOVS     r0,#0xc               ;671
000490  f7fffffe          BL       memp_free
000494  e00b              B        |L1.1198|
                  |L1.1174|
000496  2d01              CMP      r5,#1                 ;673
000498  d001              BEQ      |L1.1182|
00049a  2d02              CMP      r5,#2                 ;673
00049c  d104              BNE      |L1.1192|
                  |L1.1182|
00049e  4621              MOV      r1,r4                 ;674
0004a0  200b              MOVS     r0,#0xb               ;674
0004a2  f7fffffe          BL       memp_free
0004a6  e002              B        |L1.1198|
                  |L1.1192|
0004a8  4620              MOV      r0,r4                 ;677
0004aa  f7fffffe          BL       mem_free
                  |L1.1198|
0004ae  1c70              ADDS     r0,r6,#1              ;680
0004b0  b2c6              UXTB     r6,r0                 ;680
0004b2  463c              MOV      r4,r7                 ;682
0004b4  e002              B        |L1.1212|
                  |L1.1206|
0004b6  bf00              NOP                            ;686
0004b8  bf00              NOP                            ;686
0004ba  2400              MOVS     r4,#0                 ;688
                  |L1.1212|
0004bc  bf00              NOP                            ;690
                  |L1.1214|
0004be  2c00              CMP      r4,#0                 ;642
0004c0  d1cd              BNE      |L1.1118|
0004c2  4630              MOV      r0,r6                 ;693
0004c4  e7c3              B        |L1.1102|
;;;695    
                          ENDP

                  tcp_seg_free PROC
;;;1144   void
;;;1145   tcp_seg_free(struct tcp_seg *seg)
0004c6  b510              PUSH     {r4,lr}
;;;1146   {
0004c8  4604              MOV      r4,r0
;;;1147     if (seg != NULL) {
0004ca  b144              CBZ      r4,|L1.1246|
;;;1148       if (seg->p != NULL) {
0004cc  6860              LDR      r0,[r4,#4]
0004ce  b110              CBZ      r0,|L1.1238|
;;;1149         pbuf_free(seg->p);
0004d0  6860              LDR      r0,[r4,#4]
0004d2  f7fffffe          BL       pbuf_free
                  |L1.1238|
;;;1150   #if TCP_DEBUG
;;;1151         seg->p = NULL;
;;;1152   #endif /* TCP_DEBUG */
;;;1153       }
;;;1154       memp_free(MEMP_TCP_SEG, seg);
0004d6  4621              MOV      r1,r4
0004d8  2004              MOVS     r0,#4
0004da  f7fffffe          BL       memp_free
                  |L1.1246|
;;;1155     }
;;;1156   }
0004de  bd10              POP      {r4,pc}
;;;1157   
                          ENDP

                  lwip_htonl PROC
;;;87     u32_t
;;;88     lwip_htonl(u32_t n)
0004e0  4601              MOV      r1,r0
;;;89     {
;;;90       return ((n & 0xff) << 24) |
0004e2  0608              LSLS     r0,r1,#24
0004e4  f401427f          AND      r2,r1,#0xff00
0004e8  ea402002          ORR      r0,r0,r2,LSL #8
0004ec  f401027f          AND      r2,r1,#0xff0000
0004f0  ea402012          ORR      r0,r0,r2,LSR #8
0004f4  ea406011          ORR      r0,r0,r1,LSR #24
;;;91         ((n & 0xff00) << 8) |
;;;92         ((n & 0xff0000UL) >> 8) |
;;;93         ((n & 0xff000000UL) >> 24);
;;;94     }
0004f8  4770              BX       lr
;;;95     
                          ENDP

                  lwip_ntohl PROC
;;;102    u32_t
;;;103    lwip_ntohl(u32_t n)
0004fa  b500              PUSH     {lr}
;;;104    {
0004fc  4603              MOV      r3,r0
;;;105      return lwip_htonl(n);
0004fe  4618              MOV      r0,r3
000500  f7fffffe          BL       lwip_htonl
;;;106    }
000504  bd00              POP      {pc}
;;;107    
                          ENDP

                  lwip_htons PROC
;;;63     u16_t
;;;64     lwip_htons(u16_t n)
000506  4601              MOV      r1,r0
;;;65     {
;;;66       return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
000508  0608              LSLS     r0,r1,#24
00050a  0c00              LSRS     r0,r0,#16
00050c  ea402011          ORR      r0,r0,r1,LSR #8
;;;67     }
000510  4770              BX       lr
;;;68     
                          ENDP

                  lwip_ntohs PROC
;;;75     u16_t
;;;76     lwip_ntohs(u16_t n)
000512  b500              PUSH     {lr}
;;;77     {
000514  4602              MOV      r2,r0
;;;78       return lwip_htons(n);
000516  4610              MOV      r0,r2
000518  f7fffffe          BL       lwip_htons
;;;79     }
00051c  bd00              POP      {pc}
;;;80     
                          ENDP

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
00051e  b570              PUSH     {r4-r6,lr}
;;;512    {
000520  4602              MOV      r2,r0
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
000522  bf00              NOP      
000524  bf00              NOP      
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000526  b101              CBZ      r1,|L1.1322|
000528  b90a              CBNZ     r2,|L1.1326|
                  |L1.1322|
;;;519        return 0;
00052a  2000              MOVS     r0,#0
                  |L1.1324|
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
00052c  bd70              POP      {r4-r6,pc}
                  |L1.1326|
00052e  2900              CMP      r1,#0                 ;522
000530  da08              BGE      |L1.1348|
000532  4248              RSBS     r0,r1,#0              ;523
000534  b284              UXTH     r4,r0                 ;523
000536  bf00              NOP                            ;525
000538  8950              LDRH     r0,[r2,#0xa]          ;525
00053a  42a0              CMP      r0,r4                 ;525
00053c  da01              BGE      |L1.1346|
00053e  2001              MOVS     r0,#1                 ;525
000540  e7f4              B        |L1.1324|
                  |L1.1346|
000542  e000              B        |L1.1350|
                  |L1.1348|
000544  b28c              UXTH     r4,r1                 ;527
                  |L1.1350|
000546  7b13              LDRB     r3,[r2,#0xc]          ;540
000548  6855              LDR      r5,[r2,#4]            ;542
00054a  b10b              CBZ      r3,|L1.1360|
00054c  2b03              CMP      r3,#3                 ;545
00054e  d10c              BNE      |L1.1386|
                  |L1.1360|
000550  6850              LDR      r0,[r2,#4]            ;547
000552  1a40              SUBS     r0,r0,r1              ;547
000554  6050              STR      r0,[r2,#4]            ;547
000556  f1020010          ADD      r0,r2,#0x10           ;549
00055a  6856              LDR      r6,[r2,#4]            ;549
00055c  4286              CMP      r6,r0                 ;549
00055e  d217              BCS      |L1.1424|
000560  bf00              NOP                            ;550
000562  bf00              NOP                            ;550
000564  6055              STR      r5,[r2,#4]            ;554
000566  2001              MOVS     r0,#1                 ;556
000568  e7e0              B        |L1.1324|
                  |L1.1386|
00056a  2b02              CMP      r3,#2                 ;559
00056c  d001              BEQ      |L1.1394|
00056e  2b01              CMP      r3,#1                 ;559
000570  d10a              BNE      |L1.1416|
                  |L1.1394|
000572  2900              CMP      r1,#0                 ;561
000574  da06              BGE      |L1.1412|
000576  8950              LDRH     r0,[r2,#0xa]          ;561
000578  42a0              CMP      r0,r4                 ;561
00057a  db03              BLT      |L1.1412|
00057c  6850              LDR      r0,[r2,#4]            ;563
00057e  1a40              SUBS     r0,r0,r1              ;563
000580  6050              STR      r0,[r2,#4]            ;563
000582  e005              B        |L1.1424|
                  |L1.1412|
000584  2001              MOVS     r0,#1                 ;567
000586  e7d1              B        |L1.1324|
                  |L1.1416|
000588  bf00              NOP                            ;571
00058a  bf00              NOP                            ;571
00058c  2001              MOVS     r0,#1                 ;572
00058e  e7cd              B        |L1.1324|
                  |L1.1424|
000590  8950              LDRH     r0,[r2,#0xa]          ;575
000592  4408              ADD      r0,r0,r1              ;575
000594  8150              STRH     r0,[r2,#0xa]          ;575
000596  8910              LDRH     r0,[r2,#8]            ;576
000598  4408              ADD      r0,r0,r1              ;576
00059a  8110              STRH     r0,[r2,#8]            ;576
00059c  bf00              NOP                            ;578
00059e  bf00              NOP                            ;578
0005a0  2000              MOVS     r0,#0                 ;581
0005a2  e7c3              B        |L1.1324|
;;;583    
                          ENDP

                  ip_output_if_opt PROC
;;;654     */
;;;655    err_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
0005a4  e92d4fff          PUSH     {r0-r11,lr}
;;;656           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;657           u16_t optlen)
;;;658    {
0005a8  b081              SUB      sp,sp,#4
0005aa  4605              MOV      r5,r0
0005ac  460f              MOV      r7,r1
0005ae  4692              MOV      r10,r2
0005b0  f8ddb040          LDR      r11,[sp,#0x40]
0005b4  9e12              LDR      r6,[sp,#0x48]
;;;659    #endif /* IP_OPTIONS_SEND */
;;;660      struct ip_hdr *iphdr;
;;;661      ip_addr_t dest_addr;
;;;662    #if CHECKSUM_GEN_IP_INLINE
;;;663      u32_t chk_sum = 0;
;;;664    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;665    
;;;666      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;667         gets altered as the packet is passed down the stack */
;;;668      LWIP_ASSERT("p->ref == 1", p->ref == 1);
0005b6  bf00              NOP      
0005b8  bf00              NOP      
;;;669    
;;;670      snmp_inc_ipoutrequests();
;;;671    
;;;672      /* Should the IP header be generated or is it already included in p? */
;;;673      if (dest != IP_HDRINCL) {
0005ba  f1ba0f00          CMP      r10,#0
0005be  d074              BEQ      |L1.1706|
;;;674        u16_t ip_hlen = IP_HLEN;
0005c0  f04f0814          MOV      r8,#0x14
;;;675    #if IP_OPTIONS_SEND
;;;676        u16_t optlen_aligned = 0;
0005c4  f04f0900          MOV      r9,#0
;;;677        if (optlen != 0) {
0005c8  b356              CBZ      r6,|L1.1568|
;;;678    #if CHECKSUM_GEN_IP_INLINE
;;;679          int i;
;;;680    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;681          /* round up to a multiple of 4 */
;;;682          optlen_aligned = ((optlen + 3) & ~3);
0005ca  1cf0              ADDS     r0,r6,#3
0005cc  f0200003          BIC      r0,r0,#3
0005d0  fa1ff980          UXTH     r9,r0
;;;683          ip_hlen += optlen_aligned;
0005d4  eb080009          ADD      r0,r8,r9
0005d8  fa1ff880          UXTH     r8,r0
;;;684          /* First write in the IP options */
;;;685          if (pbuf_header(p, optlen_aligned)) {
0005dc  fa0ff189          SXTH     r1,r9
0005e0  4628              MOV      r0,r5
0005e2  f7fffffe          BL       pbuf_header
0005e6  b170              CBZ      r0,|L1.1542|
;;;686            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
0005e8  bf00              NOP      
0005ea  bf00              NOP      
;;;687            IP_STATS_INC(ip.err);
0005ec  48fe              LDR      r0,|L1.2536|
0005ee  f8b00044          LDRH     r0,[r0,#0x44]
0005f2  1c40              ADDS     r0,r0,#1
0005f4  b281              UXTH     r1,r0
0005f6  48fc              LDR      r0,|L1.2536|
0005f8  f8a01044          STRH     r1,[r0,#0x44]
;;;688            snmp_inc_ipoutdiscards();
;;;689            return ERR_BUF;
0005fc  f06f0001          MVN      r0,#1
                  |L1.1536|
;;;690          }
;;;691          MEMCPY(p->payload, ip_options, optlen);
;;;692          if (optlen < optlen_aligned) {
;;;693            /* zero the remaining bytes */
;;;694            memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
;;;695          }
;;;696    #if CHECKSUM_GEN_IP_INLINE
;;;697          for (i = 0; i < optlen_aligned/2; i++) {
;;;698            chk_sum += ((u16_t*)p->payload)[i];
;;;699          }
;;;700    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;701        }
;;;702    #endif /* IP_OPTIONS_SEND */
;;;703        /* generate IP header */
;;;704        if (pbuf_header(p, IP_HLEN)) {
;;;705          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));
;;;706    
;;;707          IP_STATS_INC(ip.err);
;;;708          snmp_inc_ipoutdiscards();
;;;709          return ERR_BUF;
;;;710        }
;;;711    
;;;712        iphdr = (struct ip_hdr *)p->payload;
;;;713        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
;;;714                   (p->len >= sizeof(struct ip_hdr)));
;;;715    
;;;716        IPH_TTL_SET(iphdr, ttl);
;;;717        IPH_PROTO_SET(iphdr, proto);
;;;718    #if CHECKSUM_GEN_IP_INLINE
;;;719        chk_sum += LWIP_MAKE_U16(proto, ttl);
;;;720    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;721    
;;;722        /* dest cannot be NULL here */
;;;723        ip_addr_copy(iphdr->dest, *dest);
;;;724    #if CHECKSUM_GEN_IP_INLINE
;;;725        chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
;;;726        chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
;;;727    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;728    
;;;729        IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
;;;730        IPH_TOS_SET(iphdr, tos);
;;;731    #if CHECKSUM_GEN_IP_INLINE
;;;732        chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
;;;733    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;734        IPH_LEN_SET(iphdr, htons(p->tot_len));
;;;735    #if CHECKSUM_GEN_IP_INLINE
;;;736        chk_sum += iphdr->_len;
;;;737    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;738        IPH_OFFSET_SET(iphdr, 0);
;;;739        IPH_ID_SET(iphdr, htons(ip_id));
;;;740    #if CHECKSUM_GEN_IP_INLINE
;;;741        chk_sum += iphdr->_id;
;;;742    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;743        ++ip_id;
;;;744    
;;;745        if (ip_addr_isany(src)) {
;;;746          ip_addr_copy(iphdr->src, netif->ip_addr);
;;;747        } else {
;;;748          /* src cannot be NULL here */
;;;749          ip_addr_copy(iphdr->src, *src);
;;;750        }
;;;751    
;;;752    #if CHECKSUM_GEN_IP_INLINE
;;;753        chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
;;;754        chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
;;;755        chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
;;;756        chk_sum = (chk_sum >> 16) + chk_sum;
;;;757        chk_sum = ~chk_sum;
;;;758        iphdr->_chksum = chk_sum; /* network order */
;;;759    #else /* CHECKSUM_GEN_IP_INLINE */
;;;760        IPH_CHKSUM_SET(iphdr, 0);
;;;761    #if CHECKSUM_GEN_IP
;;;762        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;763    #endif
;;;764    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;765      } else {
;;;766        /* IP header already included in p */
;;;767        iphdr = (struct ip_hdr *)p->payload;
;;;768        ip_addr_copy(dest_addr, iphdr->dest);
;;;769        dest = &dest_addr;
;;;770      }
;;;771    
;;;772      IP_STATS_INC(ip.xmit);
;;;773    
;;;774      LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
;;;775      ip_debug_print(p);
;;;776    
;;;777    #if ENABLE_LOOPBACK
;;;778      if (ip_addr_cmp(dest, &netif->ip_addr)) {
;;;779        /* Packet to self, enqueue it for loopback */
;;;780        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;781        return netif_loop_output(netif, p, dest);
;;;782      }
;;;783    #if LWIP_IGMP
;;;784      if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
;;;785        netif_loop_output(netif, p, dest);
;;;786      }
;;;787    #endif /* LWIP_IGMP */
;;;788    #endif /* ENABLE_LOOPBACK */
;;;789    #if IP_FRAG
;;;790      /* don't fragment if interface has mtu set to 0 [loopif] */
;;;791      if (netif->mtu && (p->tot_len > netif->mtu)) {
;;;792        return ip_frag(p, netif, dest);
;;;793      }
;;;794    #endif /* IP_FRAG */
;;;795    
;;;796      LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
;;;797      return netif->output(netif, p, dest);
;;;798    }
000600  b005              ADD      sp,sp,#0x14
000602  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1542|
000606  4632              MOV      r2,r6                 ;691
000608  6868              LDR      r0,[r5,#4]            ;691
00060a  9911              LDR      r1,[sp,#0x44]         ;691
00060c  f7fffffe          BL       __aeabi_memcpy
000610  454e              CMP      r6,r9                 ;692
000612  da05              BGE      |L1.1568|
000614  eba90106          SUB      r1,r9,r6              ;694
000618  686a              LDR      r2,[r5,#4]            ;694
00061a  1990              ADDS     r0,r2,r6              ;694
00061c  f7fffffe          BL       __aeabi_memclr
                  |L1.1568|
000620  2114              MOVS     r1,#0x14              ;704
000622  4628              MOV      r0,r5                 ;704
000624  f7fffffe          BL       pbuf_header
000628  b160              CBZ      r0,|L1.1604|
00062a  bf00              NOP                            ;705
00062c  bf00              NOP                            ;705
00062e  48ee              LDR      r0,|L1.2536|
000630  f8b00044          LDRH     r0,[r0,#0x44]         ;707
000634  1c40              ADDS     r0,r0,#1              ;707
000636  b281              UXTH     r1,r0                 ;707
000638  48eb              LDR      r0,|L1.2536|
00063a  f8a01044          STRH     r1,[r0,#0x44]         ;707
00063e  f06f0001          MVN      r0,#1                 ;709
000642  e7dd              B        |L1.1536|
                  |L1.1604|
000644  686c              LDR      r4,[r5,#4]            ;712
000646  bf00              NOP                            ;713
000648  bf00              NOP                            ;713
00064a  9804              LDR      r0,[sp,#0x10]         ;716
00064c  7220              STRB     r0,[r4,#8]            ;716
00064e  980f              LDR      r0,[sp,#0x3c]         ;717
000650  7260              STRB     r0,[r4,#9]            ;717
000652  f8da0000          LDR      r0,[r10,#0]           ;723
000656  6120              STR      r0,[r4,#0x10]         ;723
000658  4640              MOV      r0,r8                 ;729
00065a  ea4f71e8          ASR      r1,r8,#31             ;729
00065e  eb087191          ADD      r1,r8,r1,LSR #30      ;729
000662  f3c10187          UBFX     r1,r1,#2,#8           ;729
000666  f0410140          ORR      r1,r1,#0x40           ;729
00066a  7021              STRB     r1,[r4,#0]            ;729
00066c  980e              LDR      r0,[sp,#0x38]         ;730
00066e  7060              STRB     r0,[r4,#1]            ;730
000670  8928              LDRH     r0,[r5,#8]            ;734
000672  f7fffffe          BL       lwip_htons
000676  8060              STRH     r0,[r4,#2]            ;734
000678  2000              MOVS     r0,#0                 ;738
00067a  80e0              STRH     r0,[r4,#6]            ;738
00067c  48db              LDR      r0,|L1.2540|
00067e  8800              LDRH     r0,[r0,#0]            ;739  ; ip_id
000680  f7fffffe          BL       lwip_htons
000684  80a0              STRH     r0,[r4,#4]            ;739
000686  48d9              LDR      r0,|L1.2540|
000688  8800              LDRH     r0,[r0,#0]            ;743  ; ip_id
00068a  1c40              ADDS     r0,r0,#1              ;743
00068c  49d7              LDR      r1,|L1.2540|
00068e  8008              STRH     r0,[r1,#0]            ;743
000690  b10f              CBZ      r7,|L1.1686|
000692  6838              LDR      r0,[r7,#0]            ;745
000694  b920              CBNZ     r0,|L1.1696|
                  |L1.1686|
000696  f8db0004          LDR      r0,[r11,#4]           ;746
00069a  60e0              STR      r0,[r4,#0xc]          ;746
00069c  e002              B        |L1.1700|
00069e  e004              B        |L1.1706|
                  |L1.1696|
0006a0  6838              LDR      r0,[r7,#0]            ;749
0006a2  60e0              STR      r0,[r4,#0xc]          ;749
                  |L1.1700|
0006a4  2000              MOVS     r0,#0                 ;760
0006a6  8160              STRH     r0,[r4,#0xa]          ;760
0006a8  e003              B        |L1.1714|
                  |L1.1706|
0006aa  686c              LDR      r4,[r5,#4]            ;767
0006ac  6920              LDR      r0,[r4,#0x10]         ;768
0006ae  9000              STR      r0,[sp,#0]            ;768
0006b0  46ea              MOV      r10,sp                ;769
                  |L1.1714|
0006b2  48cd              LDR      r0,|L1.2536|
0006b4  8e00              LDRH     r0,[r0,#0x30]         ;772  ; lwip_stats
0006b6  1c40              ADDS     r0,r0,#1              ;772
0006b8  49cb              LDR      r1,|L1.2536|
0006ba  8608              STRH     r0,[r1,#0x30]         ;772
0006bc  bf00              NOP                            ;774
0006be  bf00              NOP                            ;774
0006c0  bf00              NOP                            ;796
0006c2  bf00              NOP                            ;796
0006c4  4652              MOV      r2,r10                ;797
0006c6  4629              MOV      r1,r5                 ;797
0006c8  4658              MOV      r0,r11                ;797
0006ca  f8db3014          LDR      r3,[r11,#0x14]        ;797
0006ce  4798              BLX      r3                    ;797
0006d0  e796              B        |L1.1536|
;;;799    
                          ENDP

                  ip_output_if PROC
;;;640    err_t
;;;641    ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
0006d2  e92d47f0          PUSH     {r4-r10,lr}
;;;642                 u8_t ttl, u8_t tos,
;;;643                 u8_t proto, struct netif *netif)
;;;644    {
0006d6  b086              SUB      sp,sp,#0x18
0006d8  4604              MOV      r4,r0
0006da  460d              MOV      r5,r1
0006dc  4616              MOV      r6,r2
0006de  461f              MOV      r7,r3
0006e0  e9dd9a0f          LDRD     r9,r10,[sp,#0x3c]
0006e4  f8dd8038          LDR      r8,[sp,#0x38]
;;;645    #if IP_OPTIONS_SEND
;;;646      return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
0006e8  2000              MOVS     r0,#0
0006ea  e9cda002          STRD     r10,r0,[sp,#8]
0006ee  463b              MOV      r3,r7
0006f0  4632              MOV      r2,r6
0006f2  4629              MOV      r1,r5
0006f4  e9cd8900          STRD     r8,r9,[sp,#0]
0006f8  9004              STR      r0,[sp,#0x10]
0006fa  4620              MOV      r0,r4
0006fc  f7fffffe          BL       ip_output_if_opt
;;;647    }
000700  b006              ADD      sp,sp,#0x18
000702  e8bd87f0          POP      {r4-r10,pc}
;;;648    
                          ENDP

                  ip_route PROC
;;;123    struct netif *
;;;124    ip_route(ip_addr_t *dest)
000706  b510              PUSH     {r4,lr}
;;;125    {
000708  4602              MOV      r2,r0
;;;126      struct netif *netif;
;;;127    
;;;128    #ifdef LWIP_HOOK_IP4_ROUTE
;;;129      netif = LWIP_HOOK_IP4_ROUTE(dest);
;;;130      if (netif != NULL) {
;;;131        return netif;
;;;132      }
;;;133    #endif
;;;134    
;;;135      /* iterate through netifs */
;;;136      for (netif = netif_list; netif != NULL; netif = netif->next) {
00070a  48b9              LDR      r0,|L1.2544|
00070c  6801              LDR      r1,[r0,#0]  ; netif_list
00070e  e00f              B        |L1.1840|
                  |L1.1808|
;;;137        /* network mask matches? */
;;;138        if (netif_is_up(netif)) {
000710  f8910031          LDRB     r0,[r1,#0x31]
000714  f0100f01          TST      r0,#1
000718  d009              BEQ      |L1.1838|
;;;139          if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
00071a  6810              LDR      r0,[r2,#0]
00071c  688b              LDR      r3,[r1,#8]
00071e  4018              ANDS     r0,r0,r3
000720  e9d13401          LDRD     r3,r4,[r1,#4]
000724  4023              ANDS     r3,r3,r4
000726  4298              CMP      r0,r3
000728  d101              BNE      |L1.1838|
;;;140            /* return netif on which to forward IP packet */
;;;141            return netif;
00072a  4608              MOV      r0,r1
                  |L1.1836|
;;;142          }
;;;143        }
;;;144      }
;;;145      if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
;;;146        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;147          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;148        IP_STATS_INC(ip.rterr);
;;;149        snmp_inc_ipoutnoroutes();
;;;150        return NULL;
;;;151      }
;;;152      /* no matching netif found, use default netif */
;;;153      return netif_default;
;;;154    }
00072c  bd10              POP      {r4,pc}
                  |L1.1838|
00072e  6809              LDR      r1,[r1,#0]            ;136
                  |L1.1840|
000730  2900              CMP      r1,#0                 ;136
000732  d1ed              BNE      |L1.1808|
000734  48af              LDR      r0,|L1.2548|
000736  6800              LDR      r0,[r0,#0]            ;145  ; netif_default
000738  b130              CBZ      r0,|L1.1864|
00073a  48ae              LDR      r0,|L1.2548|
00073c  6800              LDR      r0,[r0,#0]            ;145  ; netif_default
00073e  f8900031          LDRB     r0,[r0,#0x31]         ;145
000742  f0100f01          TST      r0,#1                 ;145
000746  d109              BNE      |L1.1884|
                  |L1.1864|
000748  bf00              NOP                            ;146
00074a  bf00              NOP                            ;146
00074c  48a6              LDR      r0,|L1.2536|
00074e  8fc0              LDRH     r0,[r0,#0x3e]         ;148
000750  1c40              ADDS     r0,r0,#1              ;148
000752  b283              UXTH     r3,r0                 ;148
000754  48a4              LDR      r0,|L1.2536|
000756  87c3              STRH     r3,[r0,#0x3e]         ;148
000758  2000              MOVS     r0,#0                 ;150
00075a  e7e7              B        |L1.1836|
                  |L1.1884|
00075c  48a5              LDR      r0,|L1.2548|
00075e  6800              LDR      r0,[r0,#0]            ;153  ; netif_default
000760  e7e4              B        |L1.1836|
;;;155    
                          ENDP

                  ip_output PROC
;;;817    err_t
;;;818    ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
000762  e92d4ffe          PUSH     {r1-r11,lr}
;;;819              u8_t ttl, u8_t tos, u8_t proto)
;;;820    {
000766  4606              MOV      r6,r0
000768  460f              MOV      r7,r1
00076a  4615              MOV      r5,r2
00076c  4698              MOV      r8,r3
00076e  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;821      struct netif *netif;
;;;822    
;;;823      /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
;;;824         gets altered as the packet is passed down the stack */
;;;825      LWIP_ASSERT("p->ref == 1", p->ref == 1);
000772  bf00              NOP      
000774  bf00              NOP      
;;;826    
;;;827      if ((netif = ip_route(dest)) == NULL) {
000776  4628              MOV      r0,r5
000778  f7fffffe          BL       ip_route
00077c  0004              MOVS     r4,r0
00077e  d10a              BNE      |L1.1942|
;;;828        LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
000780  bf00              NOP      
000782  bf00              NOP      
;;;829          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;830        IP_STATS_INC(ip.rterr);
000784  4898              LDR      r0,|L1.2536|
000786  8fc0              LDRH     r0,[r0,#0x3e]
000788  1c40              ADDS     r0,r0,#1
00078a  b281              UXTH     r1,r0
00078c  4896              LDR      r0,|L1.2536|
00078e  87c1              STRH     r1,[r0,#0x3e]
;;;831        return ERR_RTE;
000790  1f20              SUBS     r0,r4,#4
                  |L1.1938|
;;;832      }
;;;833    
;;;834      return ip_output_if(p, src, dest, ttl, tos, proto, netif);
;;;835    }
000792  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.1942|
000796  4643              MOV      r3,r8                 ;834
000798  462a              MOV      r2,r5                 ;834
00079a  4639              MOV      r1,r7                 ;834
00079c  4630              MOV      r0,r6                 ;834
00079e  e9cd9a00          STRD     r9,r10,[sp,#0]        ;834
0007a2  9402              STR      r4,[sp,#8]            ;834
0007a4  f7fffffe          BL       ip_output_if
0007a8  e7f3              B        |L1.1938|
;;;836    
                          ENDP

                  tcp_eff_send_mss PROC
;;;1587   u16_t
;;;1588   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
0007aa  b5f0              PUSH     {r4-r7,lr}
;;;1589   {
0007ac  4605              MOV      r5,r0
0007ae  460e              MOV      r6,r1
;;;1590     u16_t mss_s;
;;;1591     struct netif *outif;
;;;1592   
;;;1593     outif = ip_route(addr);
0007b0  4630              MOV      r0,r6
0007b2  f7fffffe          BL       ip_route
0007b6  4604              MOV      r4,r0
;;;1594     if ((outif != NULL) && (outif->mtu != 0)) {
0007b8  b154              CBZ      r4,|L1.2000|
0007ba  8d20              LDRH     r0,[r4,#0x28]
0007bc  b140              CBZ      r0,|L1.2000|
;;;1595       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
0007be  8d20              LDRH     r0,[r4,#0x28]
0007c0  3828              SUBS     r0,r0,#0x28
0007c2  b287              UXTH     r7,r0
;;;1596       /* RFC 1122, chap 4.2.2.6:
;;;1597        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1598        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1599        */
;;;1600       sendmss = LWIP_MIN(sendmss, mss_s);
0007c4  42bd              CMP      r5,r7
0007c6  da01              BGE      |L1.1996|
0007c8  4628              MOV      r0,r5
0007ca  e000              B        |L1.1998|
                  |L1.1996|
0007cc  4638              MOV      r0,r7
                  |L1.1998|
0007ce  4605              MOV      r5,r0
                  |L1.2000|
;;;1601     }
;;;1602     return sendmss;
0007d0  4628              MOV      r0,r5
;;;1603   }
0007d2  bdf0              POP      {r4-r7,pc}
;;;1604   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
0007d4  e92d47fc          PUSH     {r2-r10,lr}
;;;1050   {
0007d8  4605              MOV      r5,r0
0007da  460c              MOV      r4,r1
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
0007dc  6aa0              LDR      r0,[r4,#0x28]
0007de  f7fffffe          BL       lwip_htonl
0007e2  6929              LDR      r1,[r5,#0x10]
0007e4  6088              STR      r0,[r1,#8]
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
0007e6  8de0              LDRH     r0,[r4,#0x2e]
0007e8  f7fffffe          BL       lwip_htons
0007ec  6929              LDR      r1,[r5,#0x10]
0007ee  81c8              STRH     r0,[r1,#0xe]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
0007f0  8de1              LDRH     r1,[r4,#0x2e]
0007f2  6aa0              LDR      r0,[r4,#0x28]
0007f4  4408              ADD      r0,r0,r1
0007f6  6320              STR      r0,[r4,#0x30]
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
0007f8  6928              LDR      r0,[r5,#0x10]
0007fa  f1000814          ADD      r8,r0,#0x14
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
0007fe  7b28              LDRB     r0,[r5,#0xc]
000800  f0100f01          TST      r0,#1
000804  d00e              BEQ      |L1.2084|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
000806  1d21              ADDS     r1,r4,#4
000808  f24050dc          MOV      r0,#0x5dc
00080c  f7fffffe          BL       tcp_eff_send_mss
000810  4681              MOV      r9,r0
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
000812  f0497001          ORR      r0,r9,#0x2040000
000816  f7fffffe          BL       lwip_htonl
00081a  f8c80000          STR      r0,[r8,#0]
;;;1078       opts += 1;
00081e  f1080804          ADD      r8,r8,#4
;;;1079     }
000822  bf00              NOP      
                  |L1.2084|
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
000824  f9b40034          LDRSH    r0,[r4,#0x34]
000828  1c40              ADDS     r0,r0,#1
00082a  d100              BNE      |L1.2094|
;;;1092       pcb->rtime = 0;
00082c  86a0              STRH     r0,[r4,#0x34]
                  |L1.2094|
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
00082e  b10c              CBZ      r4,|L1.2100|
000830  6820              LDR      r0,[r4,#0]
000832  b940              CBNZ     r0,|L1.2118|
                  |L1.2100|
;;;1098       netif = ip_route(&(pcb->remote_ip));
000834  1d20              ADDS     r0,r4,#4
000836  f7fffffe          BL       ip_route
00083a  4606              MOV      r6,r0
;;;1099       if (netif == NULL) {
00083c  b90e              CBNZ     r6,|L1.2114|
                  |L1.2110|
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
;;;1106       pcb->rttest = tcp_ticks;
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
00083e  e8bd87fc          POP      {r2-r10,pc}
                  |L1.2114|
000842  6870              LDR      r0,[r6,#4]            ;1102
000844  6020              STR      r0,[r4,#0]            ;1102
                  |L1.2118|
000846  6ba0              LDR      r0,[r4,#0x38]         ;1105
000848  b948              CBNZ     r0,|L1.2142|
00084a  486b              LDR      r0,|L1.2552|
00084c  6800              LDR      r0,[r0,#0]            ;1106  ; tcp_ticks
00084e  63a0              STR      r0,[r4,#0x38]         ;1106
000850  6929              LDR      r1,[r5,#0x10]         ;1107
000852  6848              LDR      r0,[r1,#4]            ;1107
000854  f7fffffe          BL       lwip_ntohl
000858  63e0              STR      r0,[r4,#0x3c]         ;1107
00085a  bf00              NOP                            ;1109
00085c  bf00              NOP                            ;1109
                  |L1.2142|
00085e  bf00              NOP                            ;1111
000860  bf00              NOP                            ;1111
000862  8a28              LDRH     r0,[r5,#0x10]         ;1115
000864  6869              LDR      r1,[r5,#4]            ;1115
000866  8889              LDRH     r1,[r1,#4]            ;1115
000868  1a40              SUBS     r0,r0,r1              ;1115
00086a  b287              UXTH     r7,r0                 ;1115
00086c  6868              LDR      r0,[r5,#4]            ;1117
00086e  8940              LDRH     r0,[r0,#0xa]          ;1117
000870  1bc0              SUBS     r0,r0,r7              ;1117
000872  6869              LDR      r1,[r5,#4]            ;1117
000874  8148              STRH     r0,[r1,#0xa]          ;1117
000876  6868              LDR      r0,[r5,#4]            ;1118
000878  8900              LDRH     r0,[r0,#8]            ;1118
00087a  1bc0              SUBS     r0,r0,r7              ;1118
00087c  6869              LDR      r1,[r5,#4]            ;1118
00087e  8108              STRH     r0,[r1,#8]            ;1118
000880  6869              LDR      r1,[r5,#4]            ;1120
000882  6928              LDR      r0,[r5,#0x10]         ;1120
000884  6048              STR      r0,[r1,#4]            ;1120
000886  2000              MOVS     r0,#0                 ;1122
000888  6929              LDR      r1,[r5,#0x10]         ;1122
00088a  8208              STRH     r0,[r1,#0x10]         ;1122
00088c  4856              LDR      r0,|L1.2536|
00088e  f8b00094          LDRH     r0,[r0,#0x94]         ;1163  ; lwip_stats
000892  1c40              ADDS     r0,r0,#1              ;1163
000894  4954              LDR      r1,|L1.2536|
000896  f8a10094          STRH     r0,[r1,#0x94]         ;1163
00089a  2106              MOVS     r1,#6                 ;1169
00089c  7a60              LDRB     r0,[r4,#9]            ;1169
00089e  e9cd0100          STRD     r0,r1,[sp,#0]         ;1169
0008a2  7aa3              LDRB     r3,[r4,#0xa]          ;1169
0008a4  1d22              ADDS     r2,r4,#4              ;1169
0008a6  4621              MOV      r1,r4                 ;1169
0008a8  6868              LDR      r0,[r5,#4]            ;1169
0008aa  f7fffffe          BL       ip_output
0008ae  bf00              NOP      
0008b0  e7c5              B        |L1.2110|
;;;1173   
                          ENDP

                  memp_malloc PROC
;;;389    #if !MEMP_OVERFLOW_CHECK
;;;390    memp_malloc(memp_t type)
0008b2  b570              PUSH     {r4-r6,lr}
;;;391    #else
;;;392    memp_malloc_fn(memp_t type, const char* file, const int line)
;;;393    #endif
;;;394    {
0008b4  4604              MOV      r4,r0
;;;395      struct memp *memp;
;;;396      SYS_ARCH_DECL_PROTECT(old_level);
;;;397     
;;;398      LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
0008b6  bf00              NOP      
0008b8  2c0d              CMP      r4,#0xd
0008ba  db01              BLT      |L1.2240|
0008bc  2000              MOVS     r0,#0
                  |L1.2238|
;;;399    
;;;400      SYS_ARCH_PROTECT(old_level);
;;;401    #if MEMP_OVERFLOW_CHECK >= 2
;;;402      memp_overflow_check_all();
;;;403    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;404    
;;;405      memp = memp_tab[type];
;;;406      
;;;407      if (memp != NULL) {
;;;408        memp_tab[type] = memp->next;
;;;409    #if MEMP_OVERFLOW_CHECK
;;;410        memp->next = NULL;
;;;411        memp->file = file;
;;;412        memp->line = line;
;;;413    #endif /* MEMP_OVERFLOW_CHECK */
;;;414        MEMP_STATS_INC_USED(used, type);
;;;415        LWIP_ASSERT("memp_malloc: memp properly aligned",
;;;416                    ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
;;;417        memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
;;;418      } else {
;;;419        LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
;;;420        MEMP_STATS_INC(err, type);
;;;421      }
;;;422    
;;;423      SYS_ARCH_UNPROTECT(old_level);
;;;424    
;;;425      return memp;
;;;426    }
0008be  bd70              POP      {r4-r6,pc}
                  |L1.2240|
0008c0  bf00              NOP                            ;398
0008c2  f7fffffe          BL       sys_arch_protect
0008c6  4606              MOV      r6,r0                 ;400
0008c8  484c              LDR      r0,|L1.2556|
0008ca  f8505024          LDR      r5,[r0,r4,LSL #2]     ;405
0008ce  b3ad              CBZ      r5,|L1.2364|
0008d0  494a              LDR      r1,|L1.2556|
0008d2  6828              LDR      r0,[r5,#0]            ;408
0008d4  f8410024          STR      r0,[r1,r4,LSL #2]     ;408
0008d8  bf00              NOP                            ;414
0008da  eb040184          ADD      r1,r4,r4,LSL #2       ;414
0008de  4842              LDR      r0,|L1.2536|
0008e0  30c0              ADDS     r0,r0,#0xc0           ;414
0008e2  eb000081          ADD      r0,r0,r1,LSL #2       ;414
0008e6  6880              LDR      r0,[r0,#8]            ;414
0008e8  1c40              ADDS     r0,r0,#1              ;414
0008ea  eb040284          ADD      r2,r4,r4,LSL #2       ;414
0008ee  493e              LDR      r1,|L1.2536|
0008f0  31c0              ADDS     r1,r1,#0xc0           ;414
0008f2  eb010182          ADD      r1,r1,r2,LSL #2       ;414
0008f6  6088              STR      r0,[r1,#8]            ;414
0008f8  eb040184          ADD      r1,r4,r4,LSL #2       ;414
0008fc  483a              LDR      r0,|L1.2536|
0008fe  30c0              ADDS     r0,r0,#0xc0           ;414
000900  eb000081          ADD      r0,r0,r1,LSL #2       ;414
000904  eb040284          ADD      r2,r4,r4,LSL #2       ;414
000908  68c1              LDR      r1,[r0,#0xc]          ;414
00090a  4837              LDR      r0,|L1.2536|
00090c  30c0              ADDS     r0,r0,#0xc0           ;414
00090e  eb000082          ADD      r0,r0,r2,LSL #2       ;414
000912  6880              LDR      r0,[r0,#8]            ;414
000914  4281              CMP      r1,r0                 ;414
000916  d20d              BCS      |L1.2356|
000918  eb040184          ADD      r1,r4,r4,LSL #2       ;414
00091c  4832              LDR      r0,|L1.2536|
00091e  30c0              ADDS     r0,r0,#0xc0           ;414
000920  eb000081          ADD      r0,r0,r1,LSL #2       ;414
000924  eb040284          ADD      r2,r4,r4,LSL #2       ;414
000928  6881              LDR      r1,[r0,#8]            ;414
00092a  482f              LDR      r0,|L1.2536|
00092c  30c0              ADDS     r0,r0,#0xc0           ;414
00092e  eb000082          ADD      r0,r0,r2,LSL #2       ;414
000932  60c1              STR      r1,[r0,#0xc]          ;414
                  |L1.2356|
000934  bf00              NOP                            ;414
000936  bf00              NOP                            ;415
000938  bf00              NOP                            ;415
00093a  e012              B        |L1.2402|
                  |L1.2364|
00093c  e7ff              B        |L1.2366|
                  |L1.2366|
00093e  bf00              NOP                            ;419
000940  bf00              NOP                            ;419
000942  eb040184          ADD      r1,r4,r4,LSL #2       ;420
000946  4828              LDR      r0,|L1.2536|
000948  30c0              ADDS     r0,r0,#0xc0           ;420
00094a  eb000081          ADD      r0,r0,r1,LSL #2       ;420
00094e  8a00              LDRH     r0,[r0,#0x10]         ;420
000950  1c40              ADDS     r0,r0,#1              ;420
000952  b281              UXTH     r1,r0                 ;420
000954  eb040284          ADD      r2,r4,r4,LSL #2       ;420
000958  4823              LDR      r0,|L1.2536|
00095a  30c0              ADDS     r0,r0,#0xc0           ;420
00095c  eb000082          ADD      r0,r0,r2,LSL #2       ;420
000960  8201              STRH     r1,[r0,#0x10]         ;420
                  |L1.2402|
000962  4630              MOV      r0,r6                 ;423
000964  f7fffffe          BL       sys_arch_unprotect
000968  4628              MOV      r0,r5                 ;425
00096a  e7a8              B        |L1.2238|
;;;427    
                          ENDP

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
00096c  e92d41f0          PUSH     {r4-r8,lr}
;;;495    {
000970  4605              MOV      r5,r0
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
000972  b915              CBNZ     r5,|L1.2426|
;;;504        return NULL;
000974  2000              MOVS     r0,#0
                  |L1.2422|
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
000976  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2426|
00097a  1ce8              ADDS     r0,r5,#3              ;509
00097c  f0200503          BIC      r5,r0,#3              ;509
000980  2d0c              CMP      r5,#0xc               ;511
000982  d200              BCS      |L1.2438|
000984  250c              MOVS     r5,#0xc               ;513
                  |L1.2438|
000986  f5b53f80          CMP      r5,#0x10000           ;516
00098a  d901              BLS      |L1.2448|
00098c  2000              MOVS     r0,#0                 ;517
00098e  e7f2              B        |L1.2422|
                  |L1.2448|
000990  2100              MOVS     r1,#0                 ;521
000992  481b              LDR      r0,|L1.2560|
000994  f7fffffe          BL       sys_arch_sem_wait
000998  481a              LDR      r0,|L1.2564|
00099a  6800              LDR      r0,[r0,#0]            ;532  ; lfree
00099c  491a              LDR      r1,|L1.2568|
00099e  6809              LDR      r1,[r1,#0]            ;532  ; ram
0009a0  1a46              SUBS     r6,r0,r1              ;532
0009a2  e098              B        |L1.2774|
                  |L1.2468|
0009a4  4818              LDR      r0,|L1.2568|
0009a6  6800              LDR      r0,[r0,#0]            ;534  ; ram
0009a8  1984              ADDS     r4,r0,r6              ;534
0009aa  7a20              LDRB     r0,[r4,#8]            ;548
0009ac  2800              CMP      r0,#0                 ;548
0009ae  d173              BNE      |L1.2712|
0009b0  f106000c          ADD      r0,r6,#0xc            ;549
0009b4  6821              LDR      r1,[r4,#0]            ;549
0009b6  1a08              SUBS     r0,r1,r0              ;549
0009b8  42a8              CMP      r0,r5                 ;549
0009ba  d36d              BCC      |L1.2712|
0009bc  f106000c          ADD      r0,r6,#0xc            ;553
0009c0  6821              LDR      r1,[r4,#0]            ;553
0009c2  1a09              SUBS     r1,r1,r0              ;553
0009c4  f1050018          ADD      r0,r5,#0x18           ;553
0009c8  4281              CMP      r1,r0                 ;553
0009ca  d343              BCC      |L1.2644|
0009cc  f106000c          ADD      r0,r6,#0xc            ;564
0009d0  eb000805          ADD      r8,r0,r5              ;564
0009d4  480c              LDR      r0,|L1.2568|
0009d6  6800              LDR      r0,[r0,#0]            ;566  ; ram
0009d8  eb000708          ADD      r7,r0,r8              ;566
0009dc  2000              MOVS     r0,#0                 ;567
0009de  7238              STRB     r0,[r7,#8]            ;567
0009e0  6820              LDR      r0,[r4,#0]            ;568
0009e2  6038              STR      r0,[r7,#0]            ;568
0009e4  607e              STR      r6,[r7,#4]            ;569
0009e6  e011              B        |L1.2572|
                  |L1.2536|
                          DCD      lwip_stats
                  |L1.2540|
                          DCD      ip_id
                  |L1.2544|
                          DCD      netif_list
                  |L1.2548|
                          DCD      netif_default
                  |L1.2552|
                          DCD      tcp_ticks
                  |L1.2556|
                          DCD      memp_tab
                  |L1.2560|
                          DCD      mem_mutex
                  |L1.2564|
                          DCD      lfree
                  |L1.2568|
                          DCD      ||ram||
                  |L1.2572|
000a0c  f8c48000          STR      r8,[r4,#0]            ;571
000a10  2001              MOVS     r0,#1                 ;572
000a12  7220              STRB     r0,[r4,#8]            ;572
000a14  6838              LDR      r0,[r7,#0]            ;574
000a16  f5b03f80          CMP      r0,#0x10000           ;574
000a1a  d005              BEQ      |L1.2600|
000a1c  49fc              LDR      r1,|L1.3600|
000a1e  6838              LDR      r0,[r7,#0]            ;575
000a20  6809              LDR      r1,[r1,#0]            ;575  ; ram
000a22  4408              ADD      r0,r0,r1              ;575
000a24  f8c08004          STR      r8,[r0,#4]            ;575
                  |L1.2600|
000a28  bf00              NOP                            ;577
000a2a  48fa              LDR      r0,|L1.3604|
000a2c  f8d010b4          LDR      r1,[r0,#0xb4]         ;577
000a30  f105000c          ADD      r0,r5,#0xc            ;577
000a34  4401              ADD      r1,r1,r0              ;577
000a36  48f7              LDR      r0,|L1.3604|
000a38  f8c010b4          STR      r1,[r0,#0xb4]         ;577
000a3c  f8d010b8          LDR      r1,[r0,#0xb8]         ;577
000a40  f8d000b4          LDR      r0,[r0,#0xb4]         ;577
000a44  4281              CMP      r1,r0                 ;577
000a46  d204              BCS      |L1.2642|
000a48  48f2              LDR      r0,|L1.3604|
000a4a  f8d010b4          LDR      r1,[r0,#0xb4]         ;577
000a4e  f8c010b8          STR      r1,[r0,#0xb8]         ;577
                  |L1.2642|
000a52  e01a              B        |L1.2698|
                  |L1.2644|
000a54  2001              MOVS     r0,#1                 ;586
000a56  7220              STRB     r0,[r4,#8]            ;586
000a58  bf00              NOP                            ;587
000a5a  49ed              LDR      r1,|L1.3600|
000a5c  6820              LDR      r0,[r4,#0]            ;587
000a5e  6809              LDR      r1,[r1,#0]            ;587  ; ram
000a60  1a61              SUBS     r1,r4,r1              ;587
000a62  1a41              SUBS     r1,r0,r1              ;587
000a64  48eb              LDR      r0,|L1.3604|
000a66  f8d000b4          LDR      r0,[r0,#0xb4]         ;587
000a6a  4401              ADD      r1,r1,r0              ;587
000a6c  48e9              LDR      r0,|L1.3604|
000a6e  f8c010b4          STR      r1,[r0,#0xb4]         ;587
000a72  f8d010b8          LDR      r1,[r0,#0xb8]         ;587
000a76  f8d000b4          LDR      r0,[r0,#0xb4]         ;587
000a7a  4281              CMP      r1,r0                 ;587
000a7c  d204              BCS      |L1.2696|
000a7e  48e5              LDR      r0,|L1.3604|
000a80  f8d010b4          LDR      r1,[r0,#0xb4]         ;587
000a84  f8c010b8          STR      r1,[r0,#0xb8]         ;587
                  |L1.2696|
000a88  bf00              NOP                            ;587
                  |L1.2698|
000a8a  48e3              LDR      r0,|L1.3608|
000a8c  6800              LDR      r0,[r0,#0]            ;592  ; lfree
000a8e  4284              CMP      r4,r0                 ;592
000a90  d112              BNE      |L1.2744|
000a92  49e1              LDR      r1,|L1.3608|
000a94  6808              LDR      r0,[r1,#0]            ;593  ; lfree
000a96  e004              B        |L1.2722|
                  |L1.2712|
000a98  e01a              B        |L1.2768|
                  |L1.2714|
000a9a  4add              LDR      r2,|L1.3600|
000a9c  6801              LDR      r1,[r0,#0]            ;607
000a9e  6812              LDR      r2,[r2,#0]            ;607  ; ram
000aa0  1888              ADDS     r0,r1,r2              ;607
                  |L1.2722|
000aa2  7a01              LDRB     r1,[r0,#8]            ;595
000aa4  b119              CBZ      r1,|L1.2734|
000aa6  49dd              LDR      r1,|L1.3612|
000aa8  6809              LDR      r1,[r1,#0]            ;595  ; ram_end
000aaa  4288              CMP      r0,r1                 ;595
000aac  d1f5              BNE      |L1.2714|
                  |L1.2734|
000aae  49da              LDR      r1,|L1.3608|
000ab0  6008              STR      r0,[r1,#0]            ;609  ; lfree
000ab2  bf00              NOP                            ;610
000ab4  bf00              NOP                            ;610
000ab6  bf00              NOP                            ;611
                  |L1.2744|
000ab8  48d9              LDR      r0,|L1.3616|
000aba  f7fffffe          BL       sys_sem_signal
000abe  bf00              NOP                            ;614
000ac0  bf00              NOP                            ;614
000ac2  bf00              NOP                            ;616
000ac4  bf00              NOP                            ;616
000ac6  bf00              NOP                            ;618
000ac8  bf00              NOP                            ;618
000aca  f104000c          ADD      r0,r4,#0xc            ;621
000ace  e752              B        |L1.2422|
                  |L1.2768|
000ad0  48cf              LDR      r0,|L1.3600|
000ad2  6800              LDR      r0,[r0,#0]            ;533  ; ram
000ad4  5986              LDR      r6,[r0,r6]            ;533
                  |L1.2774|
000ad6  f5c53080          RSB      r0,r5,#0x10000        ;532
000ada  42b0              CMP      r0,r6                 ;532
000adc  f63faf62          BHI      |L1.2468|
000ae0  bf00              NOP                            ;628
000ae2  bf00              NOP                            ;628
000ae4  48cb              LDR      r0,|L1.3604|
000ae6  f8b000bc          LDRH     r0,[r0,#0xbc]         ;629
000aea  1c40              ADDS     r0,r0,#1              ;629
000aec  b281              UXTH     r1,r0                 ;629
000aee  48c9              LDR      r0,|L1.3604|
000af0  f8a010bc          STRH     r1,[r0,#0xbc]         ;629
000af4  48ca              LDR      r0,|L1.3616|
000af6  f7fffffe          BL       sys_sem_signal
000afa  2000              MOVS     r0,#0                 ;632
000afc  e73b              B        |L1.2422|
;;;634    
                          ENDP

                  tcp_segs_free PROC
;;;1129   void
;;;1130   tcp_segs_free(struct tcp_seg *seg)
000afe  b570              PUSH     {r4-r6,lr}
;;;1131   {
000b00  4604              MOV      r4,r0
;;;1132     while (seg != NULL) {
000b02  e005              B        |L1.2832|
                  |L1.2820|
;;;1133       struct tcp_seg *next = seg->next;
000b04  6825              LDR      r5,[r4,#0]
;;;1134       tcp_seg_free(seg);
000b06  4620              MOV      r0,r4
000b08  f7fffffe          BL       tcp_seg_free
;;;1135       seg = next;
000b0c  462c              MOV      r4,r5
;;;1136     }
000b0e  bf00              NOP      
                  |L1.2832|
000b10  2c00              CMP      r4,#0                 ;1132
000b12  d1f7              BNE      |L1.2820|
;;;1137   }
000b14  bd70              POP      {r4-r6,pc}
;;;1138   
                          ENDP

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000b16  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
000b18  f7fffffe          BL       sys_arch_protect
000b1c  4605              MOV      r5,r0
;;;124      pbuf_free_ooseq_pending = 0;
000b1e  2000              MOVS     r0,#0
000b20  49c0              LDR      r1,|L1.3620|
000b22  7008              STRB     r0,[r1,#0]
;;;125      SYS_ARCH_UNPROTECT(old_level);
000b24  4628              MOV      r0,r5
000b26  f7fffffe          BL       sys_arch_unprotect
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000b2a  48bf              LDR      r0,|L1.3624|
000b2c  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000b2e  e00a              B        |L1.2886|
                  |L1.2864|
;;;128        if (NULL != pcb->ooseq) {
000b30  6f60              LDR      r0,[r4,#0x74]
000b32  b138              CBZ      r0,|L1.2884|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
000b34  bf00              NOP      
000b36  bf00              NOP      
;;;131          tcp_segs_free(pcb->ooseq);
000b38  6f60              LDR      r0,[r4,#0x74]
000b3a  f7fffffe          BL       tcp_segs_free
;;;132          pcb->ooseq = NULL;
000b3e  2000              MOVS     r0,#0
000b40  6760              STR      r0,[r4,#0x74]
                  |L1.2882|
;;;133          return;
;;;134        }
;;;135      }
;;;136    }
000b42  bd70              POP      {r4-r6,pc}
                  |L1.2884|
000b44  68e4              LDR      r4,[r4,#0xc]          ;127
                  |L1.2886|
000b46  2c00              CMP      r4,#0                 ;127
000b48  d1f2              BNE      |L1.2864|
000b4a  bf00              NOP      
000b4c  e7f9              B        |L1.2882|
;;;137    
                          ENDP

                  pbuf_free_ooseq_callback PROC
;;;142    static void
;;;143    pbuf_free_ooseq_callback(void *arg)
000b4e  b510              PUSH     {r4,lr}
;;;144    {
000b50  4604              MOV      r4,r0
;;;145      LWIP_UNUSED_ARG(arg);
;;;146      pbuf_free_ooseq();
000b52  f7fffffe          BL       pbuf_free_ooseq
;;;147    }
000b56  bd10              POP      {r4,pc}
;;;148    #endif /* !NO_SYS */
                          ENDP

                  tcpip_callback_with_block PROC
;;;211    err_t
;;;212    tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
000b58  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
000b5c  4605              MOV      r5,r0
000b5e  460e              MOV      r6,r1
000b60  4617              MOV      r7,r2
;;;214      struct tcpip_msg *msg;
;;;215    
;;;216      if (sys_mbox_valid(&mbox)) {
000b62  48b2              LDR      r0,|L1.3628|
000b64  f7fffffe          BL       sys_mbox_valid
000b68  b300              CBZ      r0,|L1.2988|
;;;217        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000b6a  2007              MOVS     r0,#7
000b6c  f7fffffe          BL       memp_malloc
000b70  4604              MOV      r4,r0
;;;218        if (msg == NULL) {
000b72  b91c              CBNZ     r4,|L1.2940|
;;;219          return ERR_MEM;
000b74  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2936|
;;;220        }
;;;221    
;;;222        msg->type = TCPIP_MSG_CALLBACK;
;;;223        msg->msg.cb.function = function;
;;;224        msg->msg.cb.ctx = ctx;
;;;225        if (block) {
;;;226          sys_mbox_post(&mbox, msg);
;;;227        } else {
;;;228          if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;229            memp_free(MEMP_TCPIP_MSG_API, msg);
;;;230            return ERR_MEM;
;;;231          }
;;;232        }
;;;233        return ERR_OK;
;;;234      }
;;;235      return ERR_VAL;
;;;236    }
000b78  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2940|
000b7c  2004              MOVS     r0,#4                 ;222
000b7e  7020              STRB     r0,[r4,#0]            ;222
000b80  60a5              STR      r5,[r4,#8]            ;223
000b82  60e6              STR      r6,[r4,#0xc]          ;224
000b84  b127              CBZ      r7,|L1.2960|
000b86  4621              MOV      r1,r4                 ;226
000b88  48a8              LDR      r0,|L1.3628|
000b8a  f7fffffe          BL       sys_mbox_post
000b8e  e00b              B        |L1.2984|
                  |L1.2960|
000b90  4621              MOV      r1,r4                 ;228
000b92  48a6              LDR      r0,|L1.3628|
000b94  f7fffffe          BL       sys_mbox_trypost
000b98  b130              CBZ      r0,|L1.2984|
000b9a  4621              MOV      r1,r4                 ;229
000b9c  2007              MOVS     r0,#7                 ;229
000b9e  f7fffffe          BL       memp_free
000ba2  f04f30ff          MOV      r0,#0xffffffff        ;230
000ba6  e7e7              B        |L1.2936|
                  |L1.2984|
000ba8  2000              MOVS     r0,#0                 ;233
000baa  e7e5              B        |L1.2936|
                  |L1.2988|
000bac  f06f0005          MVN      r0,#5                 ;235
000bb0  e7e2              B        |L1.2936|
;;;237    
                          ENDP

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
000bb2  b570              PUSH     {r4-r6,lr}
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
;;;157      pbuf_free_ooseq_pending = 1;
;;;158      SYS_ARCH_UNPROTECT(old_level);
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
000bb4  f7fffffe          BL       sys_arch_protect
000bb8  4605              MOV      r5,r0
;;;163      queued = pbuf_free_ooseq_pending;
000bba  489a              LDR      r0,|L1.3620|
000bbc  7804              LDRB     r4,[r0,#0]  ; pbuf_free_ooseq_pending
;;;164      pbuf_free_ooseq_pending = 1;
000bbe  2001              MOVS     r0,#1
000bc0  4998              LDR      r1,|L1.3620|
000bc2  7008              STRB     r0,[r1,#0]
;;;165      SYS_ARCH_UNPROTECT(old_level);
000bc4  4628              MOV      r0,r5
000bc6  f7fffffe          BL       sys_arch_unprotect
;;;166    
;;;167      if(!queued) {
000bca  b984              CBNZ     r4,|L1.3054|
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
000bcc  bf00              NOP      
000bce  2200              MOVS     r2,#0
000bd0  4611              MOV      r1,r2
000bd2  4897              LDR      r0,|L1.3632|
000bd4  f7fffffe          BL       tcpip_callback_with_block
000bd8  b140              CBZ      r0,|L1.3052|
000bda  f7fffffe          BL       sys_arch_protect
000bde  4605              MOV      r5,r0
000be0  2000              MOVS     r0,#0
000be2  4990              LDR      r1,|L1.3620|
000be4  7008              STRB     r0,[r1,#0]
000be6  4628              MOV      r0,r5
000be8  f7fffffe          BL       sys_arch_unprotect
                  |L1.3052|
000bec  bf00              NOP      
                  |L1.3054|
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
000bee  bd70              POP      {r4-r6,pc}
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000bf0  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
000bf4  4683              MOV      r11,r0
000bf6  460f              MOV      r7,r1
000bf8  4690              MOV      r8,r2
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
000bfa  bf00              NOP      
000bfc  bf00              NOP      
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
000bfe  f1bb0f00          CMP      r11,#0
000c02  d009              BEQ      |L1.3096|
000c04  f1bb0f01          CMP      r11,#1
000c08  d008              BEQ      |L1.3100|
000c0a  f1bb0f02          CMP      r11,#2
000c0e  d007              BEQ      |L1.3104|
000c10  f1bb0f03          CMP      r11,#3
000c14  d108              BNE      |L1.3112|
000c16  e005              B        |L1.3108|
                  |L1.3096|
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000c18  2638              MOVS     r6,#0x38
;;;219        break;
000c1a  e00a              B        |L1.3122|
                  |L1.3100|
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
000c1c  2624              MOVS     r6,#0x24
;;;223        break;
000c1e  e008              B        |L1.3122|
                  |L1.3104|
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
000c20  2610              MOVS     r6,#0x10
;;;227        break;
000c22  e006              B        |L1.3122|
                  |L1.3108|
;;;228      case PBUF_RAW:
;;;229        offset = 0;
000c24  2600              MOVS     r6,#0
;;;230        break;
000c26  e004              B        |L1.3122|
                  |L1.3112|
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000c28  bf00              NOP      
000c2a  bf00              NOP      
;;;233        return NULL;
000c2c  2000              MOVS     r0,#0
                  |L1.3118|
;;;234      }
;;;235    
;;;236      switch (type) {
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
000c2e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.3122|
000c32  bf00              NOP                            ;219
000c34  f1b80f00          CMP      r8,#0                 ;236
000c38  d06e              BEQ      |L1.3352|
000c3a  f1b80f01          CMP      r8,#1                 ;236
000c3e  d079              BEQ      |L1.3380|
000c40  f1b80f02          CMP      r8,#2                 ;236
000c44  d077              BEQ      |L1.3382|
000c46  f1b80f03          CMP      r8,#3                 ;236
000c4a  d175              BNE      |L1.3384|
000c4c  200c              MOVS     r0,#0xc               ;239
000c4e  f7fffffe          BL       memp_malloc
000c52  4604              MOV      r4,r0                 ;239
000c54  bf00              NOP                            ;240
000c56  bf00              NOP                            ;240
000c58  b91c              CBNZ     r4,|L1.3170|
000c5a  f7fffffe          BL       pbuf_pool_is_empty
000c5e  2000              MOVS     r0,#0                 ;243
000c60  e7e5              B        |L1.3118|
                  |L1.3170|
000c62  f884800c          STRB     r8,[r4,#0xc]          ;245
000c66  2000              MOVS     r0,#0                 ;246
000c68  6020              STR      r0,[r4,#0]            ;246
000c6a  f1060010          ADD      r0,r6,#0x10           ;249
000c6e  4420              ADD      r0,r0,r4              ;249
000c70  1cc0              ADDS     r0,r0,#3              ;249
000c72  f0200003          BIC      r0,r0,#3              ;249
000c76  6060              STR      r0,[r4,#4]            ;249
000c78  bf00              NOP                            ;250
000c7a  bf00              NOP                            ;250
000c7c  8127              STRH     r7,[r4,#8]            ;253
000c7e  1cf0              ADDS     r0,r6,#3              ;255
000c80  f0200003          BIC      r0,r0,#3              ;255
000c84  f5c07000          RSB      r0,r0,#0x200          ;255
000c88  42b8              CMP      r0,r7                 ;255
000c8a  dd01              BLE      |L1.3216|
000c8c  4638              MOV      r0,r7                 ;255
000c8e  e004              B        |L1.3226|
                  |L1.3216|
000c90  1cf0              ADDS     r0,r6,#3              ;255
000c92  f0200003          BIC      r0,r0,#3              ;255
000c96  f5c07000          RSB      r0,r0,#0x200          ;255
                  |L1.3226|
000c9a  8160              STRH     r0,[r4,#0xa]          ;255
000c9c  bf00              NOP                            ;256
000c9e  bf00              NOP                            ;256
000ca0  bf00              NOP                            ;259
000ca2  bf00              NOP                            ;259
000ca4  2001              MOVS     r0,#1                 ;262
000ca6  81e0              STRH     r0,[r4,#0xe]          ;262
000ca8  46a2              MOV      r10,r4                ;267
000caa  8960              LDRH     r0,[r4,#0xa]          ;269
000cac  eba70900          SUB      r9,r7,r0              ;269
000cb0  e02e              B        |L1.3344|
                  |L1.3250|
000cb2  200c              MOVS     r0,#0xc               ;272
000cb4  f7fffffe          BL       memp_malloc
000cb8  4605              MOV      r5,r0                 ;272
000cba  b935              CBNZ     r5,|L1.3274|
000cbc  f7fffffe          BL       pbuf_pool_is_empty
000cc0  4620              MOV      r0,r4                 ;276
000cc2  f7fffffe          BL       pbuf_free
000cc6  2000              MOVS     r0,#0                 ;278
000cc8  e7b1              B        |L1.3118|
                  |L1.3274|
000cca  f885800c          STRB     r8,[r5,#0xc]          ;280
000cce  2000              MOVS     r0,#0                 ;281
000cd0  7368              STRB     r0,[r5,#0xd]          ;281
000cd2  6028              STR      r0,[r5,#0]            ;282
000cd4  f8ca5000          STR      r5,[r10,#0]           ;284
000cd8  bf00              NOP                            ;286
000cda  bf00              NOP                            ;286
000cdc  f8a59008          STRH     r9,[r5,#8]            ;287
000ce0  fa1ff089          UXTH     r0,r9                 ;289
000ce4  f5b07f00          CMP      r0,#0x200             ;289
000ce8  da02              BGE      |L1.3312|
000cea  fa1ff089          UXTH     r0,r9                 ;289
000cee  e001              B        |L1.3316|
                  |L1.3312|
000cf0  f44f7000          MOV      r0,#0x200             ;289
                  |L1.3316|
000cf4  8168              STRH     r0,[r5,#0xa]          ;289
000cf6  f1050010          ADD      r0,r5,#0x10           ;290
000cfa  6068              STR      r0,[r5,#4]            ;290
000cfc  bf00              NOP                            ;291
000cfe  bf00              NOP                            ;291
000d00  bf00              NOP                            ;293
000d02  bf00              NOP                            ;293
000d04  2001              MOVS     r0,#1                 ;296
000d06  81e8              STRH     r0,[r5,#0xe]          ;296
000d08  8968              LDRH     r0,[r5,#0xa]          ;298
000d0a  eba90900          SUB      r9,r9,r0              ;298
000d0e  46aa              MOV      r10,r5                ;300
                  |L1.3344|
000d10  f1b90f00          CMP      r9,#0                 ;271
000d14  dccd              BGT      |L1.3250|
000d16  e036              B        |L1.3462|
                  |L1.3352|
000d18  f1060113          ADD      r1,r6,#0x13           ;308
000d1c  f0210203          BIC      r2,r1,#3              ;308
000d20  1cf9              ADDS     r1,r7,#3              ;308
000d22  f0210103          BIC      r1,r1,#3              ;308
000d26  1850              ADDS     r0,r2,r1              ;308
000d28  f7fffffe          BL       mem_malloc
000d2c  4604              MOV      r4,r0                 ;308
000d2e  b924              CBNZ     r4,|L1.3386|
000d30  2000              MOVS     r0,#0                 ;310
000d32  e77c              B        |L1.3118|
                  |L1.3380|
000d34  e011              B        |L1.3418|
                  |L1.3382|
000d36  e011              B        |L1.3420|
                  |L1.3384|
000d38  e021              B        |L1.3454|
                  |L1.3386|
000d3a  f1040010          ADD      r0,r4,#0x10           ;313
000d3e  4430              ADD      r0,r0,r6              ;313
000d40  1cc0              ADDS     r0,r0,#3              ;313
000d42  f0200003          BIC      r0,r0,#3              ;313
000d46  6060              STR      r0,[r4,#4]            ;313
000d48  8127              STRH     r7,[r4,#8]            ;314
000d4a  8167              STRH     r7,[r4,#0xa]          ;314
000d4c  2000              MOVS     r0,#0                 ;315
000d4e  6020              STR      r0,[r4,#0]            ;315
000d50  f884800c          STRB     r8,[r4,#0xc]          ;316
000d54  bf00              NOP                            ;318
000d56  bf00              NOP                            ;318
000d58  e015              B        |L1.3462|
                  |L1.3418|
000d5a  bf00              NOP                            ;324
                  |L1.3420|
000d5c  200b              MOVS     r0,#0xb               ;326
000d5e  f7fffffe          BL       memp_malloc
000d62  4604              MOV      r4,r0                 ;326
000d64  b91c              CBNZ     r4,|L1.3438|
000d66  bf00              NOP                            ;328
000d68  bf00              NOP                            ;328
000d6a  2000              MOVS     r0,#0                 ;331
000d6c  e75f              B        |L1.3118|
                  |L1.3438|
000d6e  2000              MOVS     r0,#0                 ;334
000d70  6060              STR      r0,[r4,#4]            ;334
000d72  8127              STRH     r7,[r4,#8]            ;335
000d74  8167              STRH     r7,[r4,#0xa]          ;335
000d76  6020              STR      r0,[r4,#0]            ;336
000d78  f884800c          STRB     r8,[r4,#0xc]          ;337
000d7c  e003              B        |L1.3462|
                  |L1.3454|
000d7e  bf00              NOP                            ;340
000d80  bf00              NOP                            ;340
000d82  2000              MOVS     r0,#0                 ;341
000d84  e753              B        |L1.3118|
                  |L1.3462|
000d86  bf00              NOP                            ;305
000d88  2001              MOVS     r0,#1                 ;344
000d8a  81e0              STRH     r0,[r4,#0xe]          ;344
000d8c  2000              MOVS     r0,#0                 ;346
000d8e  7360              STRB     r0,[r4,#0xd]          ;346
000d90  bf00              NOP                            ;347
000d92  bf00              NOP                            ;347
000d94  4620              MOV      r0,r4                 ;348
000d96  e74a              B        |L1.3118|
;;;350    
                          ENDP

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000d98  e92d47f0          PUSH     {r4-r10,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000d9c  4605              MOV      r5,r0
000d9e  460e              MOV      r6,r1
000da0  4690              MOV      r8,r2
000da2  4699              MOV      r9,r3
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000da4  f1060014          ADD      r0,r6,#0x14
000da8  4440              ADD      r0,r0,r8
000daa  b281              UXTH     r1,r0
000dac  2200              MOVS     r2,#0
000dae  2001              MOVS     r0,#1
000db0  f7fffffe          BL       pbuf_alloc
000db4  4607              MOV      r7,r0
;;;99       if (p != NULL) {
000db6  b347              CBZ      r7,|L1.3594|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000db8  bf00              NOP      
000dba  bf00              NOP      
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
000dbc  687c              LDR      r4,[r7,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
000dbe  8b68              LDRH     r0,[r5,#0x1a]
000dc0  f7fffffe          BL       lwip_htons
000dc4  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
000dc6  8ba8              LDRH     r0,[r5,#0x1c]
000dc8  f7fffffe          BL       lwip_htons
000dcc  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
000dce  f8c49004          STR      r9,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
000dd2  6aa8              LDR      r0,[r5,#0x28]
000dd4  f7fffffe          BL       lwip_htonl
000dd8  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
000dda  4632              MOV      r2,r6
000ddc  17f1              ASRS     r1,r6,#31
000dde  eb067191          ADD      r1,r6,r1,LSR #30
000de2  1089              ASRS     r1,r1,#2
000de4  1d49              ADDS     r1,r1,#5
000de6  2310              MOVS     r3,#0x10
000de8  ea433101          ORR      r1,r3,r1,LSL #12
000dec  b288              UXTH     r0,r1
000dee  f7fffffe          BL       lwip_htons
000df2  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000df4  8de8              LDRH     r0,[r5,#0x2e]
000df6  f7fffffe          BL       lwip_htons
000dfa  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
000dfc  2000              MOVS     r0,#0
000dfe  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
000e00  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000e02  8de9              LDRH     r1,[r5,#0x2e]
000e04  6aa8              LDR      r0,[r5,#0x28]
000e06  4408              ADD      r0,r0,r1
000e08  6328              STR      r0,[r5,#0x30]
                  |L1.3594|
;;;114      }
;;;115      return p;
000e0a  4638              MOV      r0,r7
;;;116    }
000e0c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3600|
                          DCD      ||ram||
                  |L1.3604|
                          DCD      lwip_stats
                  |L1.3608|
                          DCD      lfree
                  |L1.3612|
                          DCD      ram_end
                  |L1.3616|
                          DCD      mem_mutex
                  |L1.3620|
                          DCD      pbuf_free_ooseq_pending
                  |L1.3624|
                          DCD      tcp_active_pcbs
                  |L1.3628|
                          DCD      mbox
                  |L1.3632|
                          DCD      pbuf_free_ooseq_callback
                          ENDP

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000e34  e92d41fc          PUSH     {r2-r8,lr}
;;;843    {
000e38  4604              MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
000e3a  2700              MOVS     r7,#0
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000e3c  6d20              LDR      r0,[r4,#0x50]
000e3e  f7fffffe          BL       lwip_htonl
000e42  4680              MOV      r8,r0
000e44  4643              MOV      r3,r8
000e46  2200              MOVS     r2,#0
000e48  4639              MOV      r1,r7
000e4a  4620              MOV      r0,r4
000e4c  f7fffffe          BL       tcp_output_alloc_header
000e50  4605              MOV      r5,r0
;;;855      if (p == NULL) {
000e52  b925              CBNZ     r5,|L1.3678|
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
000e54  bf00              NOP      
000e56  bf00              NOP      
;;;857        return ERR_BUF;
000e58  1eb8              SUBS     r0,r7,#2
                  |L1.3674|
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
;;;886    
;;;887      return ERR_OK;
;;;888    }
000e5a  e8bd81fc          POP      {r2-r8,pc}
                  |L1.3678|
000e5e  686e              LDR      r6,[r5,#4]            ;859
000e60  bf00              NOP                            ;860
000e62  bf00              NOP                            ;860
000e64  7fa0              LDRB     r0,[r4,#0x1e]         ;863
000e66  f0200003          BIC      r0,r0,#3              ;863
000e6a  77a0              STRB     r0,[r4,#0x1e]         ;863
000e6c  2106              MOVS     r1,#6                 ;882
000e6e  7a60              LDRB     r0,[r4,#9]            ;882
000e70  e9cd0100          STRD     r0,r1,[sp,#0]         ;882
000e74  7aa3              LDRB     r3,[r4,#0xa]          ;882
000e76  1d22              ADDS     r2,r4,#4              ;882
000e78  4621              MOV      r1,r4                 ;882
000e7a  4628              MOV      r0,r5                 ;882
000e7c  f7fffffe          BL       ip_output
000e80  4628              MOV      r0,r5                 ;885
000e82  f7fffffe          BL       pbuf_free
000e86  2000              MOVS     r0,#0                 ;887
000e88  e7e7              B        |L1.3674|
;;;889    
                          ENDP

                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
000e8a  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
000e8e  4604              MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000e90  bf00              NOP      
000e92  bf00              NOP      
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
000e94  48fe              LDR      r0,|L1.4752|
000e96  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000e98  42a0              CMP      r0,r4
000e9a  d102              BNE      |L1.3746|
;;;915        return ERR_OK;
000e9c  2000              MOVS     r0,#0
                  |L1.3742|
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
000e9e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3746|
000ea2  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000ea6  f8b4104c          LDRH     r1,[r4,#0x4c]         ;918
000eaa  4288              CMP      r0,r1                 ;918
000eac  da02              BGE      |L1.3764|
000eae  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000eb2  e001              B        |L1.3768|
                  |L1.3764|
000eb4  f8b4004c          LDRH     r0,[r4,#0x4c]         ;918
                  |L1.3768|
000eb8  4681              MOV      r9,r0                 ;918
000eba  6ee5              LDR      r5,[r4,#0x6c]         ;920
000ebc  7fa0              LDRB     r0,[r4,#0x1e]         ;928
000ebe  f0100f02          TST      r0,#2                 ;928
000ec2  d00e              BEQ      |L1.3810|
000ec4  b14d              CBZ      r5,|L1.3802|
000ec6  6929              LDR      r1,[r5,#0x10]         ;930
000ec8  6848              LDR      r0,[r1,#4]            ;930
000eca  f7fffffe          BL       lwip_ntohl
000ece  6ca1              LDR      r1,[r4,#0x48]         ;930
000ed0  1a40              SUBS     r0,r0,r1              ;930
000ed2  8929              LDRH     r1,[r5,#8]            ;930
000ed4  4408              ADD      r0,r0,r1              ;930
000ed6  4548              CMP      r0,r9                 ;930
000ed8  d903              BLS      |L1.3810|
                  |L1.3802|
000eda  4620              MOV      r0,r4                 ;931
000edc  f7fffffe          BL       tcp_send_empty_ack
000ee0  e7dd              B        |L1.3742|
                  |L1.3810|
000ee2  6f26              LDR      r6,[r4,#0x70]         ;935
000ee4  b126              CBZ      r6,|L1.3824|
000ee6  e000              B        |L1.3818|
                  |L1.3816|
000ee8  6836              LDR      r6,[r6,#0]            ;937
                  |L1.3818|
000eea  6830              LDR      r0,[r6,#0]            ;937
000eec  2800              CMP      r0,#0                 ;937
000eee  d1fb              BNE      |L1.3816|
                  |L1.3824|
000ef0  e091              B        |L1.4118|
                  |L1.3826|
000ef2  bf00              NOP                            ;964
000ef4  6929              LDR      r1,[r5,#0x10]         ;964
000ef6  8988              LDRH     r0,[r1,#0xc]          ;964
000ef8  f7fffffe          BL       lwip_ntohs
000efc  bf00              NOP                            ;964
000efe  6f20              LDR      r0,[r4,#0x70]         ;973
000f00  b1a0              CBZ      r0,|L1.3884|
000f02  7fa0              LDRB     r0,[r4,#0x1e]         ;973
000f04  f0100f44          TST      r0,#0x44              ;973
000f08  d110              BNE      |L1.3884|
000f0a  6ee0              LDR      r0,[r4,#0x6c]         ;973
000f0c  b138              CBZ      r0,|L1.3870|
000f0e  6ee0              LDR      r0,[r4,#0x6c]         ;973
000f10  6800              LDR      r0,[r0,#0]            ;973
000f12  b958              CBNZ     r0,|L1.3884|
000f14  6ee0              LDR      r0,[r4,#0x6c]         ;973
000f16  8900              LDRH     r0,[r0,#8]            ;973
000f18  8ee1              LDRH     r1,[r4,#0x36]         ;973
000f1a  4288              CMP      r0,r1                 ;973
000f1c  da06              BGE      |L1.3884|
                  |L1.3870|
000f1e  f8b40066          LDRH     r0,[r4,#0x66]         ;973
000f22  b118              CBZ      r0,|L1.3884|
000f24  f8b40068          LDRH     r0,[r4,#0x68]         ;973
000f28  2820              CMP      r0,#0x20              ;973
000f2a  db01              BLT      |L1.3888|
                  |L1.3884|
000f2c  2001              MOVS     r0,#1                 ;973
000f2e  e000              B        |L1.3890|
                  |L1.3888|
000f30  2000              MOVS     r0,#0                 ;973
                  |L1.3890|
000f32  b920              CBNZ     r0,|L1.3902|
000f34  7fa0              LDRB     r0,[r4,#0x1e]         ;974
000f36  f0100fa0          TST      r0,#0xa0              ;974
000f3a  d100              BNE      |L1.3902|
000f3c  e077              B        |L1.4142|
                  |L1.3902|
000f3e  6828              LDR      r0,[r5,#0]            ;986
000f40  66e0              STR      r0,[r4,#0x6c]         ;986
000f42  7e20              LDRB     r0,[r4,#0x18]         ;988
000f44  2802              CMP      r0,#2                 ;988
000f46  d00b              BEQ      |L1.3936|
000f48  2010              MOVS     r0,#0x10              ;989
000f4a  f7fffffe          BL       lwip_htons
000f4e  6929              LDR      r1,[r5,#0x10]         ;989
000f50  8989              LDRH     r1,[r1,#0xc]          ;989
000f52  4308              ORRS     r0,r0,r1              ;989
000f54  6929              LDR      r1,[r5,#0x10]         ;989
000f56  8188              STRH     r0,[r1,#0xc]          ;989
000f58  7fa0              LDRB     r0,[r4,#0x1e]         ;990
000f5a  f0200003          BIC      r0,r0,#3              ;990
000f5e  77a0              STRB     r0,[r4,#0x1e]         ;990
                  |L1.3936|
000f60  4621              MOV      r1,r4                 ;993
000f62  4628              MOV      r0,r5                 ;993
000f64  f7fffffe          BL       tcp_output_segment
000f68  6929              LDR      r1,[r5,#0x10]         ;994
000f6a  6848              LDR      r0,[r1,#4]            ;994
000f6c  f7fffffe          BL       lwip_ntohl
000f70  4603              MOV      r3,r0                 ;994
000f72  6929              LDR      r1,[r5,#0x10]         ;994
000f74  8988              LDRH     r0,[r1,#0xc]          ;994
000f76  f7fffffe          BL       lwip_ntohs
000f7a  f0100f03          TST      r0,#3                 ;994
000f7e  d001              BEQ      |L1.3972|
000f80  2001              MOVS     r0,#1                 ;994
000f82  e000              B        |L1.3974|
                  |L1.3972|
000f84  2000              MOVS     r0,#0                 ;994
                  |L1.3974|
000f86  8929              LDRH     r1,[r5,#8]            ;994
000f88  4408              ADD      r0,r0,r1              ;994
000f8a  eb030800          ADD      r8,r3,r0              ;994
000f8e  6d20              LDR      r0,[r4,#0x50]         ;995
000f90  ebb00008          SUBS     r0,r0,r8              ;995
000f94  d501              BPL      |L1.3994|
000f96  f8c48050          STR      r8,[r4,#0x50]         ;996
                  |L1.3994|
000f9a  6929              LDR      r1,[r5,#0x10]         ;999
000f9c  8988              LDRH     r0,[r1,#0xc]          ;999
000f9e  f7fffffe          BL       lwip_ntohs
000fa2  f0100f03          TST      r0,#3                 ;999
000fa6  d001              BEQ      |L1.4012|
000fa8  2001              MOVS     r0,#1                 ;999
000faa  e000              B        |L1.4014|
                  |L1.4012|
000fac  2000              MOVS     r0,#0                 ;999
                  |L1.4014|
000fae  8929              LDRH     r1,[r5,#8]            ;999
000fb0  4408              ADD      r0,r0,r1              ;999
000fb2  2800              CMP      r0,#0                 ;999
000fb4  dd2b              BLE      |L1.4110|
000fb6  2000              MOVS     r0,#0                 ;1000
000fb8  6028              STR      r0,[r5,#0]            ;1000
000fba  6f20              LDR      r0,[r4,#0x70]         ;1002
000fbc  b910              CBNZ     r0,|L1.4036|
000fbe  6725              STR      r5,[r4,#0x70]         ;1003
000fc0  462e              MOV      r6,r5                 ;1004
000fc2  e027              B        |L1.4116|
                  |L1.4036|
000fc4  6929              LDR      r1,[r5,#0x10]         ;1010
000fc6  6848              LDR      r0,[r1,#4]            ;1010
000fc8  f7fffffe          BL       lwip_ntohl
000fcc  4607              MOV      r7,r0                 ;1010
000fce  6931              LDR      r1,[r6,#0x10]         ;1010
000fd0  6848              LDR      r0,[r1,#4]            ;1010
000fd2  f7fffffe          BL       lwip_ntohl
000fd6  1a38              SUBS     r0,r7,r0              ;1010
000fd8  d516              BPL      |L1.4104|
000fda  f1040770          ADD      r7,r4,#0x70           ;1012
000fde  e000              B        |L1.4066|
                  |L1.4064|
000fe0  683f              LDR      r7,[r7,#0]            ;1015
                  |L1.4066|
000fe2  6838              LDR      r0,[r7,#0]            ;1013
000fe4  b160              CBZ      r0,|L1.4096|
000fe6  6839              LDR      r1,[r7,#0]            ;1014
000fe8  6909              LDR      r1,[r1,#0x10]         ;1014
000fea  6848              LDR      r0,[r1,#4]            ;1014
000fec  f7fffffe          BL       lwip_ntohl
000ff0  4682              MOV      r10,r0                ;1014
000ff2  6929              LDR      r1,[r5,#0x10]         ;1014
000ff4  6848              LDR      r0,[r1,#4]            ;1014
000ff6  f7fffffe          BL       lwip_ntohl
000ffa  ebba0000          SUBS     r0,r10,r0             ;1014
000ffe  d4ef              BMI      |L1.4064|
                  |L1.4096|
001000  6838              LDR      r0,[r7,#0]            ;1017
001002  6028              STR      r0,[r5,#0]            ;1017
001004  603d              STR      r5,[r7,#0]            ;1018
001006  e005              B        |L1.4116|
                  |L1.4104|
001008  6035              STR      r5,[r6,#0]            ;1021
00100a  6836              LDR      r6,[r6,#0]            ;1022
00100c  e002              B        |L1.4116|
                  |L1.4110|
00100e  4628              MOV      r0,r5                 ;1027
001010  f7fffffe          BL       tcp_seg_free
                  |L1.4116|
001014  6ee5              LDR      r5,[r4,#0x6c]         ;1029
                  |L1.4118|
001016  b155              CBZ      r5,|L1.4142|
001018  6929              LDR      r1,[r5,#0x10]         ;963
00101a  6848              LDR      r0,[r1,#4]            ;963
00101c  f7fffffe          BL       lwip_ntohl
001020  6ca1              LDR      r1,[r4,#0x48]         ;963
001022  1a40              SUBS     r0,r0,r1              ;963
001024  8929              LDRH     r1,[r5,#8]            ;963
001026  4408              ADD      r0,r0,r1              ;963
001028  4548              CMP      r0,r9                 ;963
00102a  f67faf62          BLS      |L1.3826|
                  |L1.4142|
00102e  bf00              NOP                            ;975
001030  6ee0              LDR      r0,[r4,#0x6c]         ;1032
001032  b910              CBNZ     r0,|L1.4154|
001034  2000              MOVS     r0,#0                 ;1034
001036  f8a4006a          STRH     r0,[r4,#0x6a]         ;1034
                  |L1.4154|
00103a  7fa0              LDRB     r0,[r4,#0x1e]         ;1038
00103c  f0200080          BIC      r0,r0,#0x80           ;1038
001040  77a0              STRB     r0,[r4,#0x1e]         ;1038
001042  2000              MOVS     r0,#0                 ;1039
001044  e72b              B        |L1.3742|
;;;1041   
                          ENDP

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
001046  b510              PUSH     {r4,lr}
;;;746    {
001048  4602              MOV      r2,r0
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
00104a  bf00              NOP      
00104c  b102              CBZ      r2,|L1.4176|
00104e  b901              CBNZ     r1,|L1.4178|
                  |L1.4176|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
001050  bd10              POP      {r4,pc}
                  |L1.4178|
001052  bf00              NOP                            ;749
001054  4610              MOV      r0,r2                 ;753
001056  e004              B        |L1.4194|
                  |L1.4184|
001058  8903              LDRH     r3,[r0,#8]            ;755
00105a  890c              LDRH     r4,[r1,#8]            ;755
00105c  4423              ADD      r3,r3,r4              ;755
00105e  8103              STRH     r3,[r0,#8]            ;755
001060  6800              LDR      r0,[r0,#0]            ;753
                  |L1.4194|
001062  6803              LDR      r3,[r0,#0]            ;753
001064  2b00              CMP      r3,#0                 ;753
001066  d1f7              BNE      |L1.4184|
001068  bf00              NOP                            ;758
00106a  bf00              NOP                            ;758
00106c  bf00              NOP                            ;759
00106e  bf00              NOP                            ;759
001070  8903              LDRH     r3,[r0,#8]            ;761
001072  890c              LDRH     r4,[r1,#8]            ;761
001074  4423              ADD      r3,r3,r4              ;761
001076  8103              STRH     r3,[r0,#8]            ;761
001078  6001              STR      r1,[r0,#0]            ;763
00107a  bf00              NOP      
00107c  e7e8              B        |L1.4176|
;;;768    
                          ENDP

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
00107e  e92d47f0          PUSH     {r4-r10,lr}
;;;160    {
001082  4607              MOV      r7,r0
001084  460e              MOV      r6,r1
001086  4691              MOV      r9,r2
001088  469a              MOV      r10,r3
00108a  f8dd8020          LDR      r8,[sp,#0x20]
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
00108e  f0180f01          TST      r8,#1
001092  d001              BEQ      |L1.4248|
001094  2004              MOVS     r0,#4
001096  e000              B        |L1.4250|
                  |L1.4248|
001098  2000              MOVS     r0,#0
                  |L1.4250|
00109a  f0180f02          TST      r8,#2
00109e  d001              BEQ      |L1.4260|
0010a0  210c              MOVS     r1,#0xc
0010a2  e000              B        |L1.4262|
                  |L1.4260|
0010a4  2100              MOVS     r1,#0
                  |L1.4262|
0010a6  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
0010a8  2004              MOVS     r0,#4
0010aa  f7fffffe          BL       memp_malloc
0010ae  0004              MOVS     r4,r0
0010b0  d107              BNE      |L1.4290|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
0010b2  bf00              NOP      
0010b4  bf00              NOP      
;;;166        pbuf_free(p);
0010b6  4630              MOV      r0,r6
0010b8  f7fffffe          BL       pbuf_free
;;;167        return NULL;
0010bc  2000              MOVS     r0,#0
                  |L1.4286|
;;;168      }
;;;169      seg->flags = optflags;
;;;170      seg->next = NULL;
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
;;;189        return NULL;
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
0010be  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4290|
0010c2  f884800c          STRB     r8,[r4,#0xc]          ;169
0010c6  2000              MOVS     r0,#0                 ;170
0010c8  6020              STR      r0,[r4,#0]            ;170
0010ca  6066              STR      r6,[r4,#4]            ;171
0010cc  8930              LDRH     r0,[r6,#8]            ;172
0010ce  1b40              SUBS     r0,r0,r5              ;172
0010d0  8120              STRH     r0,[r4,#8]            ;172
0010d2  2000              MOVS     r0,#0                 ;174
0010d4  8160              STRH     r0,[r4,#0xa]          ;174
0010d6  2114              MOVS     r1,#0x14              ;185
0010d8  4630              MOV      r0,r6                 ;185
0010da  f7fffffe          BL       pbuf_header
0010de  b170              CBZ      r0,|L1.4350|
0010e0  bf00              NOP                            ;186
0010e2  bf00              NOP                            ;186
0010e4  486b              LDR      r0,|L1.4756|
0010e6  f8b000a8          LDRH     r0,[r0,#0xa8]         ;187
0010ea  1c40              ADDS     r0,r0,#1              ;187
0010ec  b281              UXTH     r1,r0                 ;187
0010ee  4869              LDR      r0,|L1.4756|
0010f0  f8a010a8          STRH     r1,[r0,#0xa8]         ;187
0010f4  4620              MOV      r0,r4                 ;188
0010f6  f7fffffe          BL       tcp_seg_free
0010fa  2000              MOVS     r0,#0                 ;189
0010fc  e7df              B        |L1.4286|
                  |L1.4350|
0010fe  6860              LDR      r0,[r4,#4]            ;191
001100  6840              LDR      r0,[r0,#4]            ;191
001102  6120              STR      r0,[r4,#0x10]         ;191
001104  8b78              LDRH     r0,[r7,#0x1a]         ;192
001106  f7fffffe          BL       lwip_htons
00110a  6921              LDR      r1,[r4,#0x10]         ;192
00110c  8008              STRH     r0,[r1,#0]            ;192
00110e  8bb8              LDRH     r0,[r7,#0x1c]         ;193
001110  f7fffffe          BL       lwip_htons
001114  6921              LDR      r1,[r4,#0x10]         ;193
001116  8048              STRH     r0,[r1,#2]            ;193
001118  4650              MOV      r0,r10                ;194
00111a  f7fffffe          BL       lwip_htonl
00111e  6921              LDR      r1,[r4,#0x10]         ;194
001120  6048              STR      r0,[r1,#4]            ;194
001122  462a              MOV      r2,r5                 ;196
001124  17e9              ASRS     r1,r5,#31             ;196
001126  eb057191          ADD      r1,r5,r1,LSR #30      ;196
00112a  1089              ASRS     r1,r1,#2              ;196
00112c  1d49              ADDS     r1,r1,#5              ;196
00112e  ea493101          ORR      r1,r9,r1,LSL #12      ;196
001132  b288              UXTH     r0,r1                 ;196
001134  f7fffffe          BL       lwip_htons
001138  6921              LDR      r1,[r4,#0x10]         ;196
00113a  8188              STRH     r0,[r1,#0xc]          ;196
00113c  2000              MOVS     r0,#0                 ;198
00113e  6921              LDR      r1,[r4,#0x10]         ;198
001140  8248              STRH     r0,[r1,#0x12]         ;198
001142  4620              MOV      r0,r4                 ;199
001144  e7bb              B        |L1.4286|
;;;201    
                          ENDP

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
001146  4601              MOV      r1,r0
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
001148  2000              MOVS     r0,#0
;;;709      while (p != NULL) {
00114a  e002              B        |L1.4434|
                  |L1.4428|
;;;710        ++len;
00114c  1c42              ADDS     r2,r0,#1
00114e  b2d0              UXTB     r0,r2
;;;711        p = p->next;
001150  6809              LDR      r1,[r1,#0]
                  |L1.4434|
001152  2900              CMP      r1,#0                 ;709
001154  d1fa              BNE      |L1.4428|
;;;712      }
;;;713      return len;
;;;714    }
001156  4770              BX       lr
;;;715    
                          ENDP

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
001158  e92d5fff          PUSH     {r0-r12,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
00115c  460c              MOV      r4,r1
00115e  4616              MOV      r6,r2
001160  4698              MOV      r8,r3
001162  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
001166  9f0e              LDR      r7,[sp,#0x38]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
001168  46a1              MOV      r9,r4
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
00116a  42b4              CMP      r4,r6
00116c  da1b              BGE      |L1.4518|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
00116e  f01a0f02          TST      r10,#2
001172  d10a              BNE      |L1.4490|
;;;247            (!(pcb->flags & TF_NODELAY) &&
001174  7fb8              LDRB     r0,[r7,#0x1e]
001176  f0100f40          TST      r0,#0x40
00117a  d114              BNE      |L1.4518|
;;;248             (!first_seg ||
00117c  f1bb0f00          CMP      r11,#0
001180  d003              BEQ      |L1.4490|
;;;249              pcb->unsent != NULL ||
001182  6ef8              LDR      r0,[r7,#0x6c]
001184  b908              CBNZ     r0,|L1.4490|
;;;250              pcb->unacked != NULL))) {
001186  6f38              LDR      r0,[r7,#0x70]
001188  b168              CBZ      r0,|L1.4518|
                  |L1.4490|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
00118a  f20450df          ADD      r0,r4,#0x5df
00118e  f0200003          BIC      r0,r0,#3
001192  42b0              CMP      r0,r6
001194  dd01              BLE      |L1.4506|
001196  4630              MOV      r0,r6
001198  e003              B        |L1.4514|
                  |L1.4506|
00119a  f20450df          ADD      r0,r4,#0x5df
00119e  f0200003          BIC      r0,r0,#3
                  |L1.4514|
0011a2  fa1ff980          UXTH     r9,r0
                  |L1.4518|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
0011a6  2200              MOVS     r2,#0
0011a8  4649              MOV      r1,r9
0011aa  9800              LDR      r0,[sp,#0]
0011ac  f7fffffe          BL       pbuf_alloc
0011b0  4605              MOV      r5,r0
;;;256      if (p == NULL) {
0011b2  b91d              CBNZ     r5,|L1.4540|
;;;257        return NULL;
0011b4  2000              MOVS     r0,#0
                  |L1.4534|
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
0011b6  b004              ADD      sp,sp,#0x10
0011b8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.4540|
0011bc  bf00              NOP                            ;259
0011be  bf00              NOP                            ;259
0011c0  8968              LDRH     r0,[r5,#0xa]          ;260
0011c2  1b00              SUBS     r0,r0,r4              ;260
0011c4  f8a80000          STRH     r0,[r8,#0]            ;260
0011c8  812c              STRH     r4,[r5,#8]            ;262
0011ca  816c              STRH     r4,[r5,#0xa]          ;262
0011cc  4628              MOV      r0,r5                 ;263
0011ce  e7f2              B        |L1.4534|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
0011d0  4602              MOV      r2,r0
;;;295    {
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
0011d2  7e10              LDRB     r0,[r2,#0x18]
0011d4  2804              CMP      r0,#4
0011d6  d00d              BEQ      |L1.4596|
;;;298          (pcb->state != CLOSE_WAIT) &&
0011d8  7e10              LDRB     r0,[r2,#0x18]
0011da  2807              CMP      r0,#7
0011dc  d00a              BEQ      |L1.4596|
;;;299          (pcb->state != SYN_SENT) &&
0011de  7e10              LDRB     r0,[r2,#0x18]
0011e0  2802              CMP      r0,#2
0011e2  d007              BEQ      |L1.4596|
;;;300          (pcb->state != SYN_RCVD)) {
0011e4  7e10              LDRB     r0,[r2,#0x18]
0011e6  2803              CMP      r0,#3
0011e8  d004              BEQ      |L1.4596|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
0011ea  bf00              NOP      
0011ec  bf00              NOP      
;;;302        return ERR_CONN;
0011ee  f06f000c          MVN      r0,#0xc
                  |L1.4594|
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
0011f2  4770              BX       lr
                  |L1.4596|
0011f4  b909              CBNZ     r1,|L1.4602|
0011f6  2000              MOVS     r0,#0                 ;304
0011f8  e7fb              B        |L1.4594|
                  |L1.4602|
0011fa  f8b20066          LDRH     r0,[r2,#0x66]         ;308
0011fe  4288              CMP      r0,r1                 ;308
001200  da08              BGE      |L1.4628|
001202  bf00              NOP                            ;309
001204  bf00              NOP                            ;309
001206  7f90              LDRB     r0,[r2,#0x1e]         ;311
001208  f0400080          ORR      r0,r0,#0x80           ;311
00120c  7790              STRB     r0,[r2,#0x1e]         ;311
00120e  f04f30ff          MOV      r0,#0xffffffff        ;312
001212  e7ee              B        |L1.4594|
                  |L1.4628|
001214  bf00              NOP                            ;315
001216  bf00              NOP                            ;315
001218  f8b20068          LDRH     r0,[r2,#0x68]         ;320
00121c  2820              CMP      r0,#0x20              ;320
00121e  da05              BGE      |L1.4652|
001220  f8b20068          LDRH     r0,[r2,#0x68]         ;320
001224  f64f73fc          MOV      r3,#0xfffc            ;320
001228  4298              CMP      r0,r3                 ;320
00122a  d910              BLS      |L1.4686|
                  |L1.4652|
00122c  bf00              NOP                            ;321
00122e  bf00              NOP                            ;321
001230  4818              LDR      r0,|L1.4756|
001232  f8b000a0          LDRH     r0,[r0,#0xa0]         ;323
001236  1c40              ADDS     r0,r0,#1              ;323
001238  b283              UXTH     r3,r0                 ;323
00123a  4816              LDR      r0,|L1.4756|
00123c  f8a030a0          STRH     r3,[r0,#0xa0]         ;323
001240  7f90              LDRB     r0,[r2,#0x1e]         ;324
001242  f0400080          ORR      r0,r0,#0x80           ;324
001246  7790              STRB     r0,[r2,#0x1e]         ;324
001248  f04f30ff          MOV      r0,#0xffffffff        ;325
00124c  e7d1              B        |L1.4594|
                  |L1.4686|
00124e  f8b20068          LDRH     r0,[r2,#0x68]         ;327
001252  b108              CBZ      r0,|L1.4696|
001254  bf00              NOP                            ;328
001256  e001              B        |L1.4700|
                  |L1.4696|
001258  bf00              NOP                            ;331
00125a  bf00              NOP                            ;331
                  |L1.4700|
00125c  2000              MOVS     r0,#0                 ;334
00125e  e7c8              B        |L1.4594|
;;;336    
                          ENDP

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
001260  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
001264  b08f              SUB      sp,sp,#0x3c
001266  4604              MOV      r4,r0
001268  4617              MOV      r7,r2
;;;356      struct pbuf *concat_p = NULL;
00126a  f04f0b00          MOV      r11,#0
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00126e  2500              MOVS     r5,#0
001270  46aa              MOV      r10,r5
001272  2000              MOVS     r0,#0
001274  900e              STR      r0,[sp,#0x38]
001276  900d              STR      r0,[sp,#0x34]
;;;358      u16_t pos = 0; /* position in 'arg' data */
001278  2600              MOVS     r6,#0
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
00127a  900b              STR      r0,[sp,#0x2c]
;;;361      u8_t optflags = 0;
00127c  900a              STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
00127e  9009              STR      r0,[sp,#0x24]
;;;364      u16_t oversize_used = 0;
001280  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
001282  f8b41062          LDRH     r1,[r4,#0x62]
001286  eb0172d1          ADD      r2,r1,r1,LSR #31
00128a  1052              ASRS     r2,r2,#1
00128c  8ee3              LDRH     r3,[r4,#0x36]
00128e  e003              B        |L1.4760|
                  |L1.4752|
                          DCD      tcp_input_pcb
                  |L1.4756|
                          DCD      lwip_stats
                  |L1.4760|
001298  429a              CMP      r2,r3
00129a  dd01              BLE      |L1.4768|
00129c  8ee2              LDRH     r2,[r4,#0x36]
00129e  e004              B        |L1.4778|
                  |L1.4768|
0012a0  f8b40062          LDRH     r0,[r4,#0x62]
0012a4  eb0072d0          ADD      r2,r0,r0,LSR #31
0012a8  1052              ASRS     r2,r2,#1
                  |L1.4778|
0012aa  b292              UXTH     r2,r2
0012ac  9207              STR      r2,[sp,#0x1c]
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
0012ae  bf00              NOP      
0012b0  bf00              NOP      
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
0012b2  bf00              NOP      
0012b4  9810              LDR      r0,[sp,#0x40]
0012b6  b920              CBNZ     r0,|L1.4802|
0012b8  f06f000d          MVN      r0,#0xd
                  |L1.4796|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
;;;386      if (err != ERR_OK) {
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
0012bc  b013              ADD      sp,sp,#0x4c
0012be  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4802|
0012c2  bf00              NOP                            ;382
0012c4  4639              MOV      r1,r7                 ;385
0012c6  4620              MOV      r0,r4                 ;385
0012c8  f7fffffe          BL       tcp_write_checks
0012cc  9008              STR      r0,[sp,#0x20]         ;385
0012ce  9808              LDR      r0,[sp,#0x20]         ;386
0012d0  b108              CBZ      r0,|L1.4822|
0012d2  9808              LDR      r0,[sp,#0x20]         ;387
0012d4  e7f2              B        |L1.4796|
                  |L1.4822|
0012d6  f8b40068          LDRH     r0,[r4,#0x68]         ;389
0012da  900c              STR      r0,[sp,#0x30]         ;389
0012dc  6ee0              LDR      r0,[r4,#0x6c]         ;422
0012de  2800              CMP      r0,#0                 ;422
0012e0  d073              BEQ      |L1.5066|
0012e2  6ee5              LDR      r5,[r4,#0x6c]         ;427
0012e4  e000              B        |L1.4840|
                  |L1.4838|
0012e6  682d              LDR      r5,[r5,#0]            ;428
                  |L1.4840|
0012e8  6828              LDR      r0,[r5,#0]            ;427
0012ea  2800              CMP      r0,#0                 ;427
0012ec  d1fb              BNE      |L1.4838|
0012ee  7b28              LDRB     r0,[r5,#0xc]          ;431
0012f0  f0100f01          TST      r0,#1                 ;431
0012f4  d001              BEQ      |L1.4858|
0012f6  2004              MOVS     r0,#4                 ;431
0012f8  e000              B        |L1.4860|
                  |L1.4858|
0012fa  2000              MOVS     r0,#0                 ;431
                  |L1.4860|
0012fc  7b29              LDRB     r1,[r5,#0xc]          ;431
0012fe  f0110f02          TST      r1,#2                 ;431
001302  d001              BEQ      |L1.4872|
001304  210c              MOVS     r1,#0xc               ;431
001306  e000              B        |L1.4874|
                  |L1.4872|
001308  2100              MOVS     r1,#0                 ;431
                  |L1.4874|
00130a  4408              ADD      r0,r0,r1              ;431
00130c  9006              STR      r0,[sp,#0x18]         ;431
00130e  8929              LDRH     r1,[r5,#8]            ;432
001310  9806              LDR      r0,[sp,#0x18]         ;432
001312  4401              ADD      r1,r1,r0              ;432
001314  9807              LDR      r0,[sp,#0x1c]         ;432
001316  1a40              SUBS     r0,r0,r1              ;432
001318  fa1ff980          UXTH     r9,r0                 ;432
00131c  bf00              NOP                            ;444
00131e  bf00              NOP                            ;444
001320  f8b4006a          LDRH     r0,[r4,#0x6a]         ;447
001324  9009              STR      r0,[sp,#0x24]         ;447
001326  f8bd0024          LDRH     r0,[sp,#0x24]         ;448
00132a  2800              CMP      r0,#0                 ;448
00132c  dd18              BLE      |L1.4960|
00132e  bf00              NOP                            ;449
001330  bf00              NOP                            ;449
001332  46aa              MOV      r10,r5                ;450
001334  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
001338  42b8              CMP      r0,r7                 ;451
00133a  da02              BGE      |L1.4930|
00133c  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
001340  e000              B        |L1.4932|
                  |L1.4930|
001342  4638              MOV      r0,r7                 ;451
                  |L1.4932|
001344  4680              MOV      r8,r0                 ;451
001346  eb060008          ADD      r0,r6,r8              ;452
00134a  b286              UXTH     r6,r0                 ;452
00134c  f8bd0024          LDRH     r0,[sp,#0x24]         ;453
001350  eba00008          SUB      r0,r0,r8              ;453
001354  b280              UXTH     r0,r0                 ;453
001356  9009              STR      r0,[sp,#0x24]         ;453
001358  eba90008          SUB      r0,r9,r8              ;454
00135c  fa1ff980          UXTH     r9,r0                 ;454
                  |L1.4960|
001360  bf00              NOP                            ;457
001362  bf00              NOP                            ;457
001364  42be              CMP      r6,r7                 ;467
001366  da4b              BGE      |L1.5120|
001368  f1b90f00          CMP      r9,#0                 ;467
00136c  dd48              BLE      |L1.5120|
00136e  8928              LDRH     r0,[r5,#8]            ;467
001370  2800              CMP      r0,#0                 ;467
001372  dd45              BLE      |L1.5120|
001374  1bb8              SUBS     r0,r7,r6              ;468
001376  4548              CMP      r0,r9                 ;468
001378  dd01              BLE      |L1.4990|
00137a  4648              MOV      r0,r9                 ;468
00137c  e000              B        |L1.4992|
                  |L1.4990|
00137e  1bb8              SUBS     r0,r7,r6              ;468
                  |L1.4992|
001380  b280              UXTH     r0,r0                 ;468
001382  9005              STR      r0,[sp,#0x14]         ;468
001384  46aa              MOV      r10,r5                ;469
001386  9812              LDR      r0,[sp,#0x48]         ;474
001388  f0100f01          TST      r0,#1                 ;474
00138c  d01e              BEQ      |L1.5068|
00138e  2101              MOVS     r1,#1                 ;476
001390  9812              LDR      r0,[sp,#0x48]         ;476
001392  ab09              ADD      r3,sp,#0x24           ;476
001394  464a              MOV      r2,r9                 ;476
001396  e9cd4000          STRD     r4,r0,[sp,#0]         ;476
00139a  9102              STR      r1,[sp,#8]            ;476
00139c  2003              MOVS     r0,#3                 ;476
00139e  9905              LDR      r1,[sp,#0x14]         ;476
0013a0  f7fffffe          BL       tcp_pbuf_prealloc
0013a4  ea5f0b00          MOVS     r11,r0                ;476
0013a8  d102              BNE      |L1.5040|
0013aa  bf00              NOP                            ;477
0013ac  bf00              NOP                            ;477
0013ae  e12c              B        |L1.5642|
                  |L1.5040|
0013b0  8968              LDRH     r0,[r5,#0xa]          ;483
0013b2  f8bd1024          LDRH     r1,[sp,#0x24]         ;483
0013b6  4408              ADD      r0,r0,r1              ;483
0013b8  8168              STRH     r0,[r5,#0xa]          ;483
0013ba  9a10              LDR      r2,[sp,#0x40]         ;485
0013bc  1991              ADDS     r1,r2,r6              ;485
0013be  f8db0004          LDR      r0,[r11,#4]           ;485
0013c2  9a05              LDR      r2,[sp,#0x14]         ;485
0013c4  f7fffffe          BL       __aeabi_memcpy
0013c8  e00f              B        |L1.5098|
                  |L1.5066|
0013ca  e01a              B        |L1.5122|
                  |L1.5068|
0013cc  2201              MOVS     r2,#1                 ;491
0013ce  2003              MOVS     r0,#3                 ;491
0013d0  9905              LDR      r1,[sp,#0x14]         ;491
0013d2  f7fffffe          BL       pbuf_alloc
0013d6  ea5f0b00          MOVS     r11,r0                ;491
0013da  d102              BNE      |L1.5090|
0013dc  bf00              NOP                            ;492
0013de  bf00              NOP                            ;492
0013e0  e113              B        |L1.5642|
                  |L1.5090|
0013e2  9810              LDR      r0,[sp,#0x40]         ;503
0013e4  4430              ADD      r0,r0,r6              ;503
0013e6  f8cb0004          STR      r0,[r11,#4]           ;503
                  |L1.5098|
0013ea  9805              LDR      r0,[sp,#0x14]         ;506
0013ec  4430              ADD      r0,r0,r6              ;506
0013ee  b286              UXTH     r6,r0                 ;506
0013f0  4658              MOV      r0,r11                ;507
0013f2  f7fffffe          BL       pbuf_clen
0013f6  990c              LDR      r1,[sp,#0x30]         ;507
0013f8  4408              ADD      r0,r0,r1              ;507
0013fa  b280              UXTH     r0,r0                 ;507
0013fc  900c              STR      r0,[sp,#0x30]         ;507
0013fe  bf00              NOP                            ;508
                  |L1.5120|
001400  e001              B        |L1.5126|
                  |L1.5122|
001402  bf00              NOP                            ;511
001404  bf00              NOP                            ;511
                  |L1.5126|
001406  e092              B        |L1.5422|
                  |L1.5128|
001408  1bb8              SUBS     r0,r7,r6              ;524
00140a  b280              UXTH     r0,r0                 ;524
00140c  9006              STR      r0,[sp,#0x18]         ;524
00140e  990b              LDR      r1,[sp,#0x2c]         ;525
001410  9807              LDR      r0,[sp,#0x1c]         ;525
001412  1a40              SUBS     r0,r0,r1              ;525
001414  b280              UXTH     r0,r0                 ;525
001416  9005              STR      r0,[sp,#0x14]         ;525
001418  e9dd1005          LDRD     r1,r0,[sp,#0x14]      ;526
00141c  4288              CMP      r0,r1                 ;526
00141e  dd01              BLE      |L1.5156|
001420  9805              LDR      r0,[sp,#0x14]         ;526
001422  e000              B        |L1.5158|
                  |L1.5156|
001424  9806              LDR      r0,[sp,#0x18]         ;526
                  |L1.5158|
001426  9004              STR      r0,[sp,#0x10]         ;526
001428  9812              LDR      r0,[sp,#0x48]         ;532
00142a  f0100f01          TST      r0,#1                 ;532
00142e  d023              BEQ      |L1.5240|
001430  980d              LDR      r0,[sp,#0x34]         ;535
001432  b908              CBNZ     r0,|L1.5176|
001434  2101              MOVS     r1,#1                 ;535
001436  e000              B        |L1.5178|
                  |L1.5176|
001438  2100              MOVS     r1,#0                 ;535
                  |L1.5178|
00143a  9812              LDR      r0,[sp,#0x48]         ;535
00143c  e9cd4000          STRD     r4,r0,[sp,#0]         ;535
001440  9102              STR      r1,[sp,#8]            ;535
001442  9a0b              LDR      r2,[sp,#0x2c]         ;535
001444  9804              LDR      r0,[sp,#0x10]         ;535
001446  4410              ADD      r0,r0,r2              ;535
001448  b281              UXTH     r1,r0                 ;535
00144a  ab09              ADD      r3,sp,#0x24           ;535
00144c  2000              MOVS     r0,#0                 ;535
00144e  9a07              LDR      r2,[sp,#0x1c]         ;535
001450  f7fffffe          BL       tcp_pbuf_prealloc
001454  ea5f0900          MOVS     r9,r0                 ;535
001458  d102              BNE      |L1.5216|
00145a  bf00              NOP                            ;536
00145c  bf00              NOP                            ;536
00145e  e0d4              B        |L1.5642|
                  |L1.5216|
001460  bf00              NOP                            ;539
001462  bf00              NOP                            ;539
001464  9a10              LDR      r2,[sp,#0x40]         ;541
001466  1991              ADDS     r1,r2,r6              ;541
001468  f8d93004          LDR      r3,[r9,#4]            ;541
00146c  9a0b              LDR      r2,[sp,#0x2c]         ;541
00146e  1898              ADDS     r0,r3,r2              ;541
001470  9a04              LDR      r2,[sp,#0x10]         ;541
001472  f7fffffe          BL       __aeabi_memcpy
001476  e022              B        |L1.5310|
                  |L1.5240|
001478  bf00              NOP                            ;550
00147a  bf00              NOP                            ;550
00147c  2201              MOVS     r2,#1                 ;552
00147e  2000              MOVS     r0,#0                 ;552
001480  9904              LDR      r1,[sp,#0x10]         ;552
001482  f7fffffe          BL       pbuf_alloc
001486  9003              STR      r0,[sp,#0xc]          ;552
001488  b910              CBNZ     r0,|L1.5264|
00148a  bf00              NOP                            ;553
00148c  bf00              NOP                            ;553
00148e  e0bc              B        |L1.5642|
                  |L1.5264|
001490  9810              LDR      r0,[sp,#0x40]         ;561
001492  1981              ADDS     r1,r0,r6              ;561
001494  9803              LDR      r0,[sp,#0xc]          ;561
001496  6041              STR      r1,[r0,#4]            ;561
001498  2200              MOVS     r2,#0                 ;564
00149a  4610              MOV      r0,r2                 ;564
00149c  990b              LDR      r1,[sp,#0x2c]         ;564
00149e  f7fffffe          BL       pbuf_alloc
0014a2  ea5f0900          MOVS     r9,r0                 ;564
0014a6  d105              BNE      |L1.5300|
0014a8  9803              LDR      r0,[sp,#0xc]          ;567
0014aa  f7fffffe          BL       pbuf_free
0014ae  bf00              NOP                            ;568
0014b0  bf00              NOP                            ;568
0014b2  e0aa              B        |L1.5642|
                  |L1.5300|
0014b4  4648              MOV      r0,r9                 ;572
0014b6  9903              LDR      r1,[sp,#0xc]          ;572
0014b8  f7fffffe          BL       pbuf_cat
0014bc  bf00              NOP                            ;573
                  |L1.5310|
0014be  4648              MOV      r0,r9                 ;575
0014c0  f7fffffe          BL       pbuf_clen
0014c4  990c              LDR      r1,[sp,#0x30]         ;575
0014c6  4408              ADD      r0,r0,r1              ;575
0014c8  b280              UXTH     r0,r0                 ;575
0014ca  900c              STR      r0,[sp,#0x30]         ;575
0014cc  980c              LDR      r0,[sp,#0x30]         ;580
0014ce  2820              CMP      r0,#0x20              ;580
0014d0  dc04              BGT      |L1.5340|
0014d2  f64f71fc          MOV      r1,#0xfffc            ;580
0014d6  980c              LDR      r0,[sp,#0x30]         ;580
0014d8  4288              CMP      r0,r1                 ;580
0014da  d905              BLS      |L1.5352|
                  |L1.5340|
0014dc  bf00              NOP                            ;581
0014de  bf00              NOP                            ;581
0014e0  4648              MOV      r0,r9                 ;582
0014e2  f7fffffe          BL       pbuf_free
0014e6  e090              B        |L1.5642|
                  |L1.5352|
0014e8  980a              LDR      r0,[sp,#0x28]         ;586
0014ea  9000              STR      r0,[sp,#0]            ;586
0014ec  6de0              LDR      r0,[r4,#0x5c]         ;586
0014ee  1983              ADDS     r3,r0,r6              ;586
0014f0  2200              MOVS     r2,#0                 ;586
0014f2  4649              MOV      r1,r9                 ;586
0014f4  4620              MOV      r0,r4                 ;586
0014f6  f7fffffe          BL       tcp_create_segment
0014fa  ea5f0a00          MOVS     r10,r0                ;586
0014fe  d100              BNE      |L1.5378|
001500  e083              B        |L1.5642|
                  |L1.5378|
001502  f8bd0024          LDRH     r0,[sp,#0x24]         ;590
001506  f8aa000a          STRH     r0,[r10,#0xa]         ;590
00150a  980d              LDR      r0,[sp,#0x34]         ;599
00150c  b910              CBNZ     r0,|L1.5396|
00150e  f8cda034          STR      r10,[sp,#0x34]        ;600
001512  e004              B        |L1.5406|
                  |L1.5396|
001514  bf00              NOP                            ;603
001516  bf00              NOP                            ;603
001518  980e              LDR      r0,[sp,#0x38]         ;604
00151a  f8c0a000          STR      r10,[r0,#0]           ;604
                  |L1.5406|
00151e  f8cda038          STR      r10,[sp,#0x38]        ;607
001522  bf00              NOP                            ;609
001524  bf00              NOP                            ;609
001526  9804              LDR      r0,[sp,#0x10]         ;613
001528  4430              ADD      r0,r0,r6              ;613
00152a  b286              UXTH     r6,r0                 ;613
00152c  bf00              NOP                            ;614
                  |L1.5422|
00152e  42be              CMP      r6,r7                 ;522
001530  f6ffaf6a          BLT      |L1.5128|
001534  f1b80f00          CMP      r8,#0                 ;626
001538  dd27              BLE      |L1.5514|
00153a  f8d59004          LDR      r9,[r5,#4]            ;629
00153e  e017              B        |L1.5488|
                  |L1.5440|
001540  f8b90008          LDRH     r0,[r9,#8]            ;630
001544  4440              ADD      r0,r0,r8              ;630
001546  f8a90008          STRH     r0,[r9,#8]            ;630
00154a  f8d90000          LDR      r0,[r9,#0]            ;631
00154e  b968              CBNZ     r0,|L1.5484|
001550  f8b9200a          LDRH     r2,[r9,#0xa]          ;632
001554  f8d91004          LDR      r1,[r9,#4]            ;632
001558  1888              ADDS     r0,r1,r2              ;632
00155a  4642              MOV      r2,r8                 ;632
00155c  9910              LDR      r1,[sp,#0x40]         ;632
00155e  f7fffffe          BL       __aeabi_memcpy
001562  f8b9000a          LDRH     r0,[r9,#0xa]          ;633
001566  4440              ADD      r0,r0,r8              ;633
001568  f8a9000a          STRH     r0,[r9,#0xa]          ;633
                  |L1.5484|
00156c  f8d99000          LDR      r9,[r9,#0]            ;629
                  |L1.5488|
001570  f1b90f00          CMP      r9,#0                 ;629
001574  d1e4              BNE      |L1.5440|
001576  8928              LDRH     r0,[r5,#8]            ;636
001578  4440              ADD      r0,r0,r8              ;636
00157a  8128              STRH     r0,[r5,#8]            ;636
00157c  bf00              NOP                            ;638
00157e  bf00              NOP                            ;638
001580  8968              LDRH     r0,[r5,#0xa]          ;640
001582  eba00008          SUB      r0,r0,r8              ;640
001586  8168              STRH     r0,[r5,#0xa]          ;640
001588  bf00              NOP                            ;642
                  |L1.5514|
00158a  f8bd0024          LDRH     r0,[sp,#0x24]         ;643
00158e  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
001592  f1bb0f00          CMP      r11,#0                ;649
001596  d00a              BEQ      |L1.5550|
001598  bf00              NOP                            ;650
00159a  bf00              NOP                            ;650
00159c  4659              MOV      r1,r11                ;652
00159e  6868              LDR      r0,[r5,#4]            ;652
0015a0  f7fffffe          BL       pbuf_cat
0015a4  8928              LDRH     r0,[r5,#8]            ;653
0015a6  f8bb1008          LDRH     r1,[r11,#8]           ;653
0015aa  4408              ADD      r0,r0,r1              ;653
0015ac  8128              STRH     r0,[r5,#8]            ;653
                  |L1.5550|
0015ae  b915              CBNZ     r5,|L1.5558|
0015b0  980d              LDR      r0,[sp,#0x34]         ;668
0015b2  66e0              STR      r0,[r4,#0x6c]         ;668
0015b4  e001              B        |L1.5562|
                  |L1.5558|
0015b6  980d              LDR      r0,[sp,#0x34]         ;670
0015b8  6028              STR      r0,[r5,#0]            ;670
                  |L1.5562|
0015ba  f8540f5c          LDR      r0,[r4,#0x5c]!        ;676
0015be  4438              ADD      r0,r0,r7              ;676
0015c0  6020              STR      r0,[r4,#0]            ;676
0015c2  8960              LDRH     r0,[r4,#0xa]          ;677
0015c4  1bc0              SUBS     r0,r0,r7              ;677
0015c6  8160              STRH     r0,[r4,#0xa]          ;677
0015c8  980c              LDR      r0,[sp,#0x30]         ;678
0015ca  81a0              STRH     r0,[r4,#0xc]          ;678
0015cc  f1a4045c          SUB      r4,r4,#0x5c           ;678
0015d0  bf00              NOP                            ;680
0015d2  bf00              NOP                            ;680
0015d4  f8b40068          LDRH     r0,[r4,#0x68]         ;682
0015d8  b108              CBZ      r0,|L1.5598|
0015da  bf00              NOP                            ;683
0015dc  bf00              NOP                            ;683
                  |L1.5598|
0015de  f1ba0f00          CMP      r10,#0                ;688
0015e2  d010              BEQ      |L1.5638|
0015e4  f8da0010          LDR      r0,[r10,#0x10]        ;688
0015e8  b168              CBZ      r0,|L1.5638|
0015ea  9812              LDR      r0,[sp,#0x48]         ;688
0015ec  f0100f02          TST      r0,#2                 ;688
0015f0  d109              BNE      |L1.5638|
0015f2  2008              MOVS     r0,#8                 ;689
0015f4  f7fffffe          BL       lwip_htons
0015f8  f8da1010          LDR      r1,[r10,#0x10]        ;689
0015fc  8989              LDRH     r1,[r1,#0xc]          ;689
0015fe  4308              ORRS     r0,r0,r1              ;689
001600  f8da1010          LDR      r1,[r10,#0x10]        ;689
001604  8188              STRH     r0,[r1,#0xc]          ;689
                  |L1.5638|
001606  2000              MOVS     r0,#0                 ;692
001608  e658              B        |L1.4796|
                  |L1.5642|
00160a  7fa0              LDRB     r0,[r4,#0x1e]         ;694
00160c  f0400080          ORR      r0,r0,#0x80           ;694
001610  77a0              STRB     r0,[r4,#0x1e]         ;694
001612  48fe              LDR      r0,|L1.6668|
001614  f8b000a0          LDRH     r0,[r0,#0xa0]         ;695
001618  1c40              ADDS     r0,r0,#1              ;695
00161a  b281              UXTH     r1,r0                 ;695
00161c  48fb              LDR      r0,|L1.6668|
00161e  f8a010a0          STRH     r1,[r0,#0xa0]         ;695
001622  f1bb0f00          CMP      r11,#0                ;697
001626  d002              BEQ      |L1.5678|
001628  4658              MOV      r0,r11                ;698
00162a  f7fffffe          BL       pbuf_free
                  |L1.5678|
00162e  980d              LDR      r0,[sp,#0x34]         ;700
001630  b110              CBZ      r0,|L1.5688|
001632  980d              LDR      r0,[sp,#0x34]         ;701
001634  f7fffffe          BL       tcp_segs_free
                  |L1.5688|
001638  f8b40068          LDRH     r0,[r4,#0x68]         ;703
00163c  b108              CBZ      r0,|L1.5698|
00163e  bf00              NOP                            ;704
001640  bf00              NOP                            ;704
                  |L1.5698|
001642  bf00              NOP                            ;707
001644  bf00              NOP                            ;707
001646  f04f30ff          MOV      r0,#0xffffffff        ;708
00164a  e637              B        |L1.4796|
;;;710    
                          ENDP

                  do_writemore PROC
;;;1210   static err_t
;;;1211   do_writemore(struct netconn *conn)
00164c  e92d4ff8          PUSH     {r3-r11,lr}
;;;1212   {
001650  4604              MOV      r4,r0
;;;1213     err_t err;
;;;1214     void *dataptr;
;;;1215     u16_t len, available;
;;;1216     u8_t write_finished = 0;
001652  2000              MOVS     r0,#0
001654  9000              STR      r0,[sp,#0]
;;;1217     size_t diff;
;;;1218     u8_t dontblock = netconn_is_nonblocking(conn) ||
001656  f894012c          LDRB     r0,[r4,#0x12c]
00165a  f0100f02          TST      r0,#2
00165e  d105              BNE      |L1.5740|
;;;1219          (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
001660  f8d40134          LDR      r0,[r4,#0x134]
001664  7c00              LDRB     r0,[r0,#0x10]
001666  f0100f04          TST      r0,#4
00166a  d001              BEQ      |L1.5744|
                  |L1.5740|
00166c  2001              MOVS     r0,#1
00166e  e000              B        |L1.5746|
                  |L1.5744|
001670  2000              MOVS     r0,#0
                  |L1.5746|
001672  4607              MOV      r7,r0
;;;1220     u8_t apiflags = conn->current_msg->msg.w.apiflags;
001674  f8d40134          LDR      r0,[r4,#0x134]
001678  f8908010          LDRB     r8,[r0,#0x10]
;;;1221   
;;;1222     LWIP_ASSERT("conn != NULL", conn != NULL);
00167c  bf00              NOP      
00167e  bf00              NOP      
;;;1223     LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
001680  bf00              NOP      
001682  bf00              NOP      
;;;1224     LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
001684  bf00              NOP      
001686  bf00              NOP      
;;;1225     LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
001688  bf00              NOP      
00168a  bf00              NOP      
;;;1226     LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
00168c  bf00              NOP      
00168e  bf00              NOP      
;;;1227       conn->write_offset < conn->current_msg->msg.w.len);
;;;1228   
;;;1229   #if LWIP_SO_SNDTIMEO
;;;1230     if ((conn->send_timeout != 0) &&
;;;1231         ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
;;;1232       write_finished = 1;
;;;1233       if (conn->write_offset == 0) {
;;;1234         /* nothing has been written */
;;;1235         err = ERR_WOULDBLOCK;
;;;1236         conn->current_msg->msg.w.len = 0;
;;;1237       } else {
;;;1238         /* partial write */
;;;1239         err = ERR_OK;
;;;1240         conn->current_msg->msg.w.len = conn->write_offset;
;;;1241       }
;;;1242     } else
;;;1243   #endif /* LWIP_SO_SNDTIMEO */
;;;1244     {
;;;1245       dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
001690  f8d40134          LDR      r0,[r4,#0x134]
001694  6880              LDR      r0,[r0,#8]
001696  f8d41130          LDR      r1,[r4,#0x130]
00169a  eb000b01          ADD      r11,r0,r1
;;;1246       diff = conn->current_msg->msg.w.len - conn->write_offset;
00169e  f8d40134          LDR      r0,[r4,#0x134]
0016a2  68c0              LDR      r0,[r0,#0xc]
0016a4  f8d41130          LDR      r1,[r4,#0x130]
0016a8  eba00a01          SUB      r10,r0,r1
;;;1247       if (diff > 0xffffUL) { /* max_u16_t */
0016ac  f5ba3f80          CMP      r10,#0x10000
0016b0  d304              BCC      |L1.5820|
;;;1248         len = 0xffff;
0016b2  f64f76ff          MOV      r6,#0xffff
;;;1249   #if LWIP_TCPIP_CORE_LOCKING
;;;1250         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1251   #endif
;;;1252         apiflags |= TCP_WRITE_FLAG_MORE;
0016b6  f0480802          ORR      r8,r8,#2
0016ba  e001              B        |L1.5824|
                  |L1.5820|
;;;1253       } else {
;;;1254         len = (u16_t)diff;
0016bc  fa1ff68a          UXTH     r6,r10
                  |L1.5824|
;;;1255       }
;;;1256       available = tcp_sndbuf(conn->pcb.tcp);
0016c0  6860              LDR      r0,[r4,#4]
0016c2  f8b09066          LDRH     r9,[r0,#0x66]
;;;1257       if (available < len) {
0016c6  45b1              CMP      r9,r6
0016c8  da07              BGE      |L1.5850|
;;;1258         /* don't try to write more than sendbuf */
;;;1259         len = available;
0016ca  464e              MOV      r6,r9
;;;1260         if (dontblock){ 
0016cc  b11f              CBZ      r7,|L1.5846|
;;;1261           if (!len) {
0016ce  b926              CBNZ     r6,|L1.5850|
;;;1262             err = ERR_WOULDBLOCK;
0016d0  f06f0506          MVN      r5,#6
;;;1263             goto err_mem;
0016d4  e00e              B        |L1.5876|
                  |L1.5846|
;;;1264           }
;;;1265         } else {
;;;1266   #if LWIP_TCPIP_CORE_LOCKING
;;;1267           conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1268   #endif
;;;1269           apiflags |= TCP_WRITE_FLAG_MORE;
0016d6  f0480802          ORR      r8,r8,#2
                  |L1.5850|
;;;1270         }
;;;1271       }
;;;1272       LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
0016da  bf00              NOP      
0016dc  bf00              NOP      
;;;1273       err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
0016de  4643              MOV      r3,r8
0016e0  4632              MOV      r2,r6
0016e2  4659              MOV      r1,r11
0016e4  6860              LDR      r0,[r4,#4]
0016e6  f7fffffe          BL       tcp_write
0016ea  4605              MOV      r5,r0
;;;1274       /* if OK or memory error, check available space */
;;;1275       if ((err == ERR_OK) || (err == ERR_MEM)) {
0016ec  b10d              CBZ      r5,|L1.5874|
0016ee  1c68              ADDS     r0,r5,#1
0016f0  d12b              BNE      |L1.5962|
                  |L1.5874|
;;;1276   err_mem:
0016f2  bf00              NOP      
                  |L1.5876|
;;;1277         if (dontblock && (len < conn->current_msg->msg.w.len)) {
0016f4  b1a7              CBZ      r7,|L1.5920|
0016f6  f8d40134          LDR      r0,[r4,#0x134]
0016fa  68c0              LDR      r0,[r0,#0xc]
0016fc  42b0              CMP      r0,r6
0016fe  d90f              BLS      |L1.5920|
;;;1278           /* non-blocking write did not write everything: mark the pcb non-writable
;;;1279              and let poll_tcp check writable space to mark the pcb writable again */
;;;1280           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
001700  f8d40138          LDR      r0,[r4,#0x138]
001704  b128              CBZ      r0,|L1.5906|
001706  4632              MOV      r2,r6
001708  2103              MOVS     r1,#3
00170a  4620              MOV      r0,r4
00170c  f8d43138          LDR      r3,[r4,#0x138]
001710  4798              BLX      r3
                  |L1.5906|
;;;1281           conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
001712  f894012c          LDRB     r0,[r4,#0x12c]
001716  f0400010          ORR      r0,r0,#0x10
00171a  f884012c          STRB     r0,[r4,#0x12c]
00171e  e014              B        |L1.5962|
                  |L1.5920|
;;;1282         } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
001720  6860              LDR      r0,[r4,#4]
001722  f8b00066          LDRH     r0,[r0,#0x66]
001726  f2417170          MOV      r1,#0x1770
00172a  4288              CMP      r0,r1
00172c  dd04              BLE      |L1.5944|
;;;1283                    (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
00172e  6860              LDR      r0,[r4,#4]
001730  f8b00068          LDRH     r0,[r0,#0x68]
001734  2810              CMP      r0,#0x10
001736  db08              BLT      |L1.5962|
                  |L1.5944|
;;;1284           /* The queued byte- or pbuf-count exceeds the configured low-water limit,
;;;1285              let select mark this pcb as non-writable. */
;;;1286           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
001738  f8d40138          LDR      r0,[r4,#0x138]
00173c  b128              CBZ      r0,|L1.5962|
00173e  4632              MOV      r2,r6
001740  2103              MOVS     r1,#3
001742  4620              MOV      r0,r4
001744  f8d43138          LDR      r3,[r4,#0x138]
001748  4798              BLX      r3
                  |L1.5962|
;;;1287         }
;;;1288       }
;;;1289   
;;;1290       if (err == ERR_OK) {
00174a  b9d5              CBNZ     r5,|L1.6018|
;;;1291         conn->write_offset += len;
00174c  f8d40130          LDR      r0,[r4,#0x130]
001750  4430              ADD      r0,r0,r6
001752  f8c40130          STR      r0,[r4,#0x130]
;;;1292         if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
001756  f8d41130          LDR      r1,[r4,#0x130]
00175a  f8d40134          LDR      r0,[r4,#0x134]
00175e  68c0              LDR      r0,[r0,#0xc]
001760  4281              CMP      r1,r0
001762  d000              BEQ      |L1.5990|
001764  b14f              CBZ      r7,|L1.6010|
                  |L1.5990|
;;;1293           /* return sent length */
;;;1294           conn->current_msg->msg.w.len = conn->write_offset;
001766  f8d41130          LDR      r1,[r4,#0x130]
00176a  f8d40134          LDR      r0,[r4,#0x134]
00176e  60c1              STR      r1,[r0,#0xc]
;;;1295           /* everything was written */
;;;1296           write_finished = 1;
001770  2001              MOVS     r0,#1
001772  9000              STR      r0,[sp,#0]
;;;1297           conn->write_offset = 0;
001774  2000              MOVS     r0,#0
001776  f8c40130          STR      r0,[r4,#0x130]
                  |L1.6010|
;;;1298         }
;;;1299         tcp_output(conn->pcb.tcp);
00177a  6860              LDR      r0,[r4,#4]
00177c  f7fffffe          BL       tcp_output
001780  e00c              B        |L1.6044|
                  |L1.6018|
;;;1300       } else if ((err == ERR_MEM) && !dontblock) {
001782  1c68              ADDS     r0,r5,#1
001784  d104              BNE      |L1.6032|
001786  b91f              CBNZ     r7,|L1.6032|
;;;1301         /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
;;;1302            we do NOT return to the application thread, since ERR_MEM is
;;;1303            only a temporary error! */
;;;1304   
;;;1305         /* tcp_write returned ERR_MEM, try tcp_output anyway */
;;;1306         tcp_output(conn->pcb.tcp);
001788  6860              LDR      r0,[r4,#4]
00178a  f7fffffe          BL       tcp_output
00178e  e005              B        |L1.6044|
                  |L1.6032|
;;;1307   
;;;1308   #if LWIP_TCPIP_CORE_LOCKING
;;;1309         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1310   #endif
;;;1311       } else {
;;;1312         /* On errors != ERR_MEM, we don't try writing any more but return
;;;1313            the error to the application thread. */
;;;1314         write_finished = 1;
001790  2001              MOVS     r0,#1
001792  9000              STR      r0,[sp,#0]
;;;1315         conn->current_msg->msg.w.len = 0;
001794  2100              MOVS     r1,#0
001796  f8d40134          LDR      r0,[r4,#0x134]
00179a  60c1              STR      r1,[r0,#0xc]
                  |L1.6044|
;;;1316       }
;;;1317     }
;;;1318     if (write_finished) {
00179c  9800              LDR      r0,[sp,#0]
00179e  b150              CBZ      r0,|L1.6070|
;;;1319       /* everything was written: set back connection state
;;;1320          and back to application task */
;;;1321       conn->current_msg->err = err;
0017a0  f8d40134          LDR      r0,[r4,#0x134]
0017a4  7105              STRB     r5,[r0,#4]
;;;1322       conn->current_msg = NULL;
0017a6  2000              MOVS     r0,#0
0017a8  f8c40134          STR      r0,[r4,#0x134]
;;;1323       conn->state = NETCONN_NONE;
0017ac  7060              STRB     r0,[r4,#1]
;;;1324   #if LWIP_TCPIP_CORE_LOCKING
;;;1325       if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
;;;1326   #endif
;;;1327       {
;;;1328         sys_sem_signal(&conn->op_completed);
0017ae  f104000c          ADD      r0,r4,#0xc
0017b2  f7fffffe          BL       sys_sem_signal
                  |L1.6070|
;;;1329       }
;;;1330     }
;;;1331   #if LWIP_TCPIP_CORE_LOCKING
;;;1332     else
;;;1333       return ERR_MEM;
;;;1334   #endif
;;;1335     return ERR_OK;
0017b6  2000              MOVS     r0,#0
;;;1336   }
0017b8  e8bd8ff8          POP      {r3-r11,pc}
;;;1337   #endif /* LWIP_TCP */
                          ENDP

                  sent_tcp PROC
;;;313    static err_t
;;;314    sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
0017bc  e92d41f0          PUSH     {r4-r8,lr}
;;;315    {
0017c0  4605              MOV      r5,r0
0017c2  460f              MOV      r7,r1
0017c4  4616              MOV      r6,r2
;;;316      struct netconn *conn = (struct netconn *)arg;
0017c6  462c              MOV      r4,r5
;;;317    
;;;318      LWIP_UNUSED_ARG(pcb);
;;;319      LWIP_ASSERT("conn != NULL", (conn != NULL));
0017c8  bf00              NOP      
0017ca  bf00              NOP      
;;;320    
;;;321      if (conn->state == NETCONN_WRITE) {
0017cc  7860              LDRB     r0,[r4,#1]
0017ce  2801              CMP      r0,#1
0017d0  d103              BNE      |L1.6106|
;;;322        do_writemore(conn);
0017d2  4620              MOV      r0,r4
0017d4  f7fffffe          BL       do_writemore
0017d8  e005              B        |L1.6118|
                  |L1.6106|
;;;323      } else if (conn->state == NETCONN_CLOSE) {
0017da  7860              LDRB     r0,[r4,#1]
0017dc  2804              CMP      r0,#4
0017de  d102              BNE      |L1.6118|
;;;324        do_close_internal(conn);
0017e0  4620              MOV      r0,r4
0017e2  f7fffffe          BL       do_close_internal
                  |L1.6118|
;;;325      }
;;;326    
;;;327      if (conn) {
0017e6  b1e4              CBZ      r4,|L1.6178|
;;;328        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;329           let select mark this pcb as writable again. */
;;;330        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
0017e8  6860              LDR      r0,[r4,#4]
0017ea  b1d0              CBZ      r0,|L1.6178|
0017ec  6860              LDR      r0,[r4,#4]
0017ee  f8b00066          LDRH     r0,[r0,#0x66]
0017f2  f2417170          MOV      r1,#0x1770
0017f6  4288              CMP      r0,r1
0017f8  dd13              BLE      |L1.6178|
;;;331          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
0017fa  6860              LDR      r0,[r4,#4]
0017fc  f8b00068          LDRH     r0,[r0,#0x68]
001800  2810              CMP      r0,#0x10
001802  da0e              BGE      |L1.6178|
;;;332          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
001804  f894012c          LDRB     r0,[r4,#0x12c]
001808  f0200010          BIC      r0,r0,#0x10
00180c  f884012c          STRB     r0,[r4,#0x12c]
;;;333          API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
001810  f8d40138          LDR      r0,[r4,#0x138]
001814  b128              CBZ      r0,|L1.6178|
001816  4632              MOV      r2,r6
001818  2102              MOVS     r1,#2
00181a  4620              MOV      r0,r4
00181c  f8d43138          LDR      r3,[r4,#0x138]
001820  4798              BLX      r3
                  |L1.6178|
;;;334        }
;;;335      }
;;;336      
;;;337      return ERR_OK;
001822  2000              MOVS     r0,#0
;;;338    }
001824  e8bd81f0          POP      {r4-r8,pc}
;;;339    
                          ENDP

                  tcp_sent PROC
;;;1407   void
;;;1408   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
001828  bf00              NOP      
;;;1409   {
;;;1410     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
00182a  bf00              NOP      
;;;1411     pcb->sent = sent;
00182c  67c1              STR      r1,[r0,#0x7c]
;;;1412   }
00182e  4770              BX       lr
;;;1413   
                          ENDP

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
001830  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
001834  4604              MOV      r4,r0
001836  460d              MOV      r5,r1
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
001838  2700              MOVS     r7,#0
;;;727      u8_t optlen = 0;
00183a  46b8              MOV      r8,r7
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
00183c  bf00              NOP      
00183e  bf00              NOP      
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
001840  bf00              NOP      
001842  bf00              NOP      
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
001844  f8b40068          LDRH     r0,[r4,#0x68]
001848  2820              CMP      r0,#0x20
00184a  da05              BGE      |L1.6232|
00184c  f8b40068          LDRH     r0,[r4,#0x68]
001850  f64f71fc          MOV      r1,#0xfffc
001854  4288              CMP      r0,r1
001856  d911              BLS      |L1.6268|
                  |L1.6232|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
001858  bf00              NOP      
00185a  bf00              NOP      
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
00185c  486b              LDR      r0,|L1.6668|
00185e  f8b000a0          LDRH     r0,[r0,#0xa0]
001862  1c40              ADDS     r0,r0,#1
001864  b281              UXTH     r1,r0
001866  4869              LDR      r0,|L1.6668|
001868  f8a010a0          STRH     r1,[r0,#0xa0]
;;;739        pcb->flags |= TF_NAGLEMEMERR;
00186c  7fa0              LDRB     r0,[r4,#0x1e]
00186e  f0400080          ORR      r0,r0,#0x80
001872  77a0              STRB     r0,[r4,#0x1e]
;;;740        return ERR_MEM;
001874  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6264|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
001878  e8bd83f8          POP      {r3-r9,pc}
                  |L1.6268|
00187c  f0150f02          TST      r5,#2                 ;743
001880  d000              BEQ      |L1.6276|
001882  2701              MOVS     r7,#1                 ;744
                  |L1.6276|
001884  f0170f01          TST      r7,#1                 ;751
001888  d001              BEQ      |L1.6286|
00188a  2004              MOVS     r0,#4                 ;751
00188c  e000              B        |L1.6288|
                  |L1.6286|
00188e  2000              MOVS     r0,#0                 ;751
                  |L1.6288|
001890  f0170f02          TST      r7,#2                 ;751
001894  d001              BEQ      |L1.6298|
001896  210c              MOVS     r1,#0xc               ;751
001898  e000              B        |L1.6300|
                  |L1.6298|
00189a  2100              MOVS     r1,#0                 ;751
                  |L1.6300|
00189c  eb000801          ADD      r8,r0,r1              ;751
0018a0  f8b40066          LDRH     r0,[r4,#0x66]         ;757
0018a4  b960              CBNZ     r0,|L1.6336|
0018a6  bf00              NOP                            ;758
0018a8  bf00              NOP                            ;758
0018aa  4858              LDR      r0,|L1.6668|
0018ac  f8b000a0          LDRH     r0,[r0,#0xa0]         ;759
0018b0  1c40              ADDS     r0,r0,#1              ;759
0018b2  b281              UXTH     r1,r0                 ;759
0018b4  4855              LDR      r0,|L1.6668|
0018b6  f8a010a0          STRH     r1,[r0,#0xa0]         ;759
0018ba  f04f30ff          MOV      r0,#0xffffffff        ;760
0018be  e7db              B        |L1.6264|
                  |L1.6336|
0018c0  2200              MOVS     r2,#0                 ;764
0018c2  4641              MOV      r1,r8                 ;764
0018c4  4610              MOV      r0,r2                 ;764
0018c6  f7fffffe          BL       pbuf_alloc
0018ca  ea5f0900          MOVS     r9,r0                 ;764
0018ce  d10e              BNE      |L1.6382|
0018d0  7fa0              LDRB     r0,[r4,#0x1e]         ;765
0018d2  f0400080          ORR      r0,r0,#0x80           ;765
0018d6  77a0              STRB     r0,[r4,#0x1e]         ;765
0018d8  484c              LDR      r0,|L1.6668|
0018da  f8b000a0          LDRH     r0,[r0,#0xa0]         ;766
0018de  1c40              ADDS     r0,r0,#1              ;766
0018e0  b281              UXTH     r1,r0                 ;766
0018e2  484a              LDR      r0,|L1.6668|
0018e4  f8a010a0          STRH     r1,[r0,#0xa0]         ;766
0018e8  f04f30ff          MOV      r0,#0xffffffff        ;767
0018ec  e7c4              B        |L1.6264|
                  |L1.6382|
0018ee  bf00              NOP                            ;769
0018f0  bf00              NOP                            ;769
0018f2  9700              STR      r7,[sp,#0]            ;773
0018f4  462a              MOV      r2,r5                 ;773
0018f6  4649              MOV      r1,r9                 ;773
0018f8  4620              MOV      r0,r4                 ;773
0018fa  6de3              LDR      r3,[r4,#0x5c]         ;773
0018fc  f7fffffe          BL       tcp_create_segment
001900  0006              MOVS     r6,r0                 ;773
001902  d10d              BNE      |L1.6432|
001904  7fa0              LDRB     r0,[r4,#0x1e]         ;774
001906  f0400080          ORR      r0,r0,#0x80           ;774
00190a  77a0              STRB     r0,[r4,#0x1e]         ;774
00190c  483f              LDR      r0,|L1.6668|
00190e  f8b000a0          LDRH     r0,[r0,#0xa0]         ;775
001912  1c40              ADDS     r0,r0,#1              ;775
001914  b281              UXTH     r1,r0                 ;775
001916  483d              LDR      r0,|L1.6668|
001918  f8a010a0          STRH     r1,[r0,#0xa0]         ;775
00191c  1e70              SUBS     r0,r6,#1              ;776
00191e  e7ab              B        |L1.6264|
                  |L1.6432|
001920  bf00              NOP                            ;778
001922  bf00              NOP                            ;778
001924  bf00              NOP                            ;779
001926  bf00              NOP                            ;779
001928  bf00              NOP                            ;781
00192a  bf00              NOP                            ;781
00192c  6ee0              LDR      r0,[r4,#0x6c]         ;788
00192e  b908              CBNZ     r0,|L1.6452|
001930  66e6              STR      r6,[r4,#0x6c]         ;789
001932  e007              B        |L1.6468|
                  |L1.6452|
001934  6ee0              LDR      r0,[r4,#0x6c]         ;792
001936  e000              B        |L1.6458|
                  |L1.6456|
001938  6800              LDR      r0,[r0,#0]            ;792
                  |L1.6458|
00193a  6801              LDR      r1,[r0,#0]            ;792
00193c  2900              CMP      r1,#0                 ;792
00193e  d1fb              BNE      |L1.6456|
001940  6006              STR      r6,[r0,#0]            ;793
001942  bf00              NOP                            ;794
                  |L1.6468|
001944  2000              MOVS     r0,#0                 ;797
001946  f8a4006a          STRH     r0,[r4,#0x6a]         ;797
00194a  f0150f02          TST      r5,#2                 ;801
00194e  d102              BNE      |L1.6486|
001950  f0150f01          TST      r5,#1                 ;801
001954  d007              BEQ      |L1.6502|
                  |L1.6486|
001956  6de0              LDR      r0,[r4,#0x5c]         ;802
001958  1c40              ADDS     r0,r0,#1              ;802
00195a  65e0              STR      r0,[r4,#0x5c]         ;802
00195c  f8b40066          LDRH     r0,[r4,#0x66]         ;804
001960  1e40              SUBS     r0,r0,#1              ;804
001962  f8a40066          STRH     r0,[r4,#0x66]         ;804
                  |L1.6502|
001966  f0150f01          TST      r5,#1                 ;806
00196a  d003              BEQ      |L1.6516|
00196c  7fa0              LDRB     r0,[r4,#0x1e]         ;807
00196e  f0400020          ORR      r0,r0,#0x20           ;807
001972  77a0              STRB     r0,[r4,#0x1e]         ;807
                  |L1.6516|
001974  6870              LDR      r0,[r6,#4]            ;811
001976  f7fffffe          BL       pbuf_clen
00197a  f8b41068          LDRH     r1,[r4,#0x68]         ;811
00197e  4408              ADD      r0,r0,r1              ;811
001980  f8a40068          STRH     r0,[r4,#0x68]         ;811
001984  bf00              NOP                            ;812
001986  bf00              NOP                            ;812
001988  f8b40068          LDRH     r0,[r4,#0x68]         ;813
00198c  b108              CBZ      r0,|L1.6546|
00198e  bf00              NOP                            ;814
001990  bf00              NOP                            ;814
                  |L1.6546|
001992  2000              MOVS     r0,#0                 ;818
001994  e770              B        |L1.6264|
;;;820    
                          ENDP

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
001996  b510              PUSH     {r4,lr}
;;;126    {
001998  4604              MOV      r4,r0
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
00199a  6ee0              LDR      r0,[r4,#0x6c]
00199c  b1d8              CBZ      r0,|L1.6614|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
00199e  6ee3              LDR      r3,[r4,#0x6c]
0019a0  e000              B        |L1.6564|
                  |L1.6562|
;;;131             last_unsent = last_unsent->next);
0019a2  681b              LDR      r3,[r3,#0]
                  |L1.6564|
0019a4  6818              LDR      r0,[r3,#0]            ;130
0019a6  2800              CMP      r0,#0                 ;130
0019a8  d1fb              BNE      |L1.6562|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
0019aa  6919              LDR      r1,[r3,#0x10]
0019ac  8988              LDRH     r0,[r1,#0xc]
0019ae  f7fffffe          BL       lwip_ntohs
0019b2  f0100f07          TST      r0,#7
0019b6  d10d              BNE      |L1.6612|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
0019b8  2001              MOVS     r0,#1
0019ba  f7fffffe          BL       lwip_htons
0019be  6919              LDR      r1,[r3,#0x10]
0019c0  8989              LDRH     r1,[r1,#0xc]
0019c2  4308              ORRS     r0,r0,r1
0019c4  6919              LDR      r1,[r3,#0x10]
0019c6  8188              STRH     r0,[r1,#0xc]
;;;136          pcb->flags |= TF_FIN;
0019c8  7fa0              LDRB     r0,[r4,#0x1e]
0019ca  f0400020          ORR      r0,r0,#0x20
0019ce  77a0              STRB     r0,[r4,#0x1e]
;;;137          return ERR_OK;
0019d0  2000              MOVS     r0,#0
                  |L1.6610|
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
;;;142    }
0019d2  bd10              POP      {r4,pc}
                  |L1.6612|
0019d4  bf00              NOP                            ;139
                  |L1.6614|
0019d6  2101              MOVS     r1,#1                 ;141
0019d8  4620              MOV      r0,r4                 ;141
0019da  f7fffffe          BL       tcp_enqueue_flags
0019de  e7f8              B        |L1.6610|
;;;143    
                          ENDP

                  tcp_pcb_purge PROC
;;;1471   void
;;;1472   tcp_pcb_purge(struct tcp_pcb *pcb)
0019e0  b510              PUSH     {r4,lr}
;;;1473   {
0019e2  4604              MOV      r4,r0
;;;1474     if (pcb->state != CLOSED &&
0019e4  7e20              LDRB     r0,[r4,#0x18]
0019e6  2800              CMP      r0,#0
0019e8  d051              BEQ      |L1.6798|
;;;1475        pcb->state != TIME_WAIT &&
0019ea  7e20              LDRB     r0,[r4,#0x18]
0019ec  280a              CMP      r0,#0xa
0019ee  d04e              BEQ      |L1.6798|
;;;1476        pcb->state != LISTEN) {
0019f0  7e20              LDRB     r0,[r4,#0x18]
0019f2  2801              CMP      r0,#1
0019f4  d04b              BEQ      |L1.6798|
;;;1477   
;;;1478       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
0019f6  bf00              NOP      
0019f8  bf00              NOP      
;;;1479   
;;;1480   #if TCP_LISTEN_BACKLOG
;;;1481       if (pcb->state == SYN_RCVD) {
0019fa  7e20              LDRB     r0,[r4,#0x18]
0019fc  2803              CMP      r0,#3
0019fe  d11f              BNE      |L1.6720|
;;;1482         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1483         struct tcp_pcb_listen *lpcb;
;;;1484         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
001a00  bf00              NOP      
001a02  bf00              NOP      
;;;1485           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1486         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
001a04  4902              LDR      r1,|L1.6672|
001a06  6808              LDR      r0,[r1,#0]  ; tcp_listen_pcbs
001a08  e016              B        |L1.6712|
001a0a  0000              DCW      0x0000
                  |L1.6668|
                          DCD      lwip_stats
                  |L1.6672|
                          DCD      tcp_listen_pcbs
                  |L1.6676|
;;;1487           if ((lpcb->local_port == pcb->local_port) &&
001a14  8b41              LDRH     r1,[r0,#0x1a]
001a16  8b62              LDRH     r2,[r4,#0x1a]
001a18  4291              CMP      r1,r2
001a1a  d10c              BNE      |L1.6710|
;;;1488               (ip_addr_isany(&lpcb->local_ip) ||
001a1c  b128              CBZ      r0,|L1.6698|
001a1e  6801              LDR      r1,[r0,#0]
001a20  b119              CBZ      r1,|L1.6698|
;;;1489                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
001a22  6821              LDR      r1,[r4,#0]
001a24  6802              LDR      r2,[r0,#0]
001a26  4291              CMP      r1,r2
001a28  d105              BNE      |L1.6710|
                  |L1.6698|
;;;1490               /* port and address of the listen pcb match the timed-out pcb */
;;;1491               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
001a2a  bf00              NOP      
001a2c  bf00              NOP      
;;;1492                 lpcb->accepts_pending > 0);
;;;1493               lpcb->accepts_pending--;
001a2e  7f41              LDRB     r1,[r0,#0x1d]
001a30  1e49              SUBS     r1,r1,#1
001a32  7741              STRB     r1,[r0,#0x1d]
;;;1494               break;
001a34  e002              B        |L1.6716|
                  |L1.6710|
001a36  68c0              LDR      r0,[r0,#0xc]          ;1486
                  |L1.6712|
001a38  2800              CMP      r0,#0                 ;1486
001a3a  d1eb              BNE      |L1.6676|
                  |L1.6716|
001a3c  bf00              NOP      
;;;1495             }
;;;1496         }
;;;1497       }
001a3e  bf00              NOP      
                  |L1.6720|
;;;1498   #endif /* TCP_LISTEN_BACKLOG */
;;;1499   
;;;1500   
;;;1501       if (pcb->refused_data != NULL) {
001a40  6fa0              LDR      r0,[r4,#0x78]
001a42  b130              CBZ      r0,|L1.6738|
;;;1502         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
001a44  bf00              NOP      
001a46  bf00              NOP      
;;;1503         pbuf_free(pcb->refused_data);
001a48  6fa0              LDR      r0,[r4,#0x78]
001a4a  f7fffffe          BL       pbuf_free
;;;1504         pcb->refused_data = NULL;
001a4e  2000              MOVS     r0,#0
001a50  67a0              STR      r0,[r4,#0x78]
                  |L1.6738|
;;;1505       }
;;;1506       if (pcb->unsent != NULL) {
001a52  6ee0              LDR      r0,[r4,#0x6c]
001a54  b108              CBZ      r0,|L1.6746|
;;;1507         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
001a56  bf00              NOP      
001a58  bf00              NOP      
                  |L1.6746|
;;;1508       }
;;;1509       if (pcb->unacked != NULL) {
001a5a  6f20              LDR      r0,[r4,#0x70]
001a5c  b108              CBZ      r0,|L1.6754|
;;;1510         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
001a5e  bf00              NOP      
001a60  bf00              NOP      
                  |L1.6754|
;;;1511       }
;;;1512   #if TCP_QUEUE_OOSEQ
;;;1513       if (pcb->ooseq != NULL) {
001a62  6f60              LDR      r0,[r4,#0x74]
001a64  b108              CBZ      r0,|L1.6762|
;;;1514         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
001a66  bf00              NOP      
001a68  bf00              NOP      
                  |L1.6762|
;;;1515       }
;;;1516       tcp_segs_free(pcb->ooseq);
001a6a  6f60              LDR      r0,[r4,#0x74]
001a6c  f7fffffe          BL       tcp_segs_free
;;;1517       pcb->ooseq = NULL;
001a70  2000              MOVS     r0,#0
001a72  6760              STR      r0,[r4,#0x74]
;;;1518   #endif /* TCP_QUEUE_OOSEQ */
;;;1519   
;;;1520       /* Stop the retransmission timer as it will expect data on unacked
;;;1521          queue if it fires */
;;;1522       pcb->rtime = -1;
001a74  1e40              SUBS     r0,r0,#1
001a76  86a0              STRH     r0,[r4,#0x34]
;;;1523   
;;;1524       tcp_segs_free(pcb->unsent);
001a78  6ee0              LDR      r0,[r4,#0x6c]
001a7a  f7fffffe          BL       tcp_segs_free
;;;1525       tcp_segs_free(pcb->unacked);
001a7e  6f20              LDR      r0,[r4,#0x70]
001a80  f7fffffe          BL       tcp_segs_free
;;;1526       pcb->unacked = pcb->unsent = NULL;
001a84  2000              MOVS     r0,#0
001a86  66e0              STR      r0,[r4,#0x6c]
001a88  6720              STR      r0,[r4,#0x70]
;;;1527   #if TCP_OVERSIZE
;;;1528       pcb->unsent_oversize = 0;
001a8a  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L1.6798|
;;;1529   #endif /* TCP_OVERSIZE */
;;;1530     }
;;;1531   }
001a8e  bd10              POP      {r4,pc}
;;;1532   
                          ENDP

                  tcp_pcb_remove PROC
;;;1539   void
;;;1540   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
001a90  b570              PUSH     {r4-r6,lr}
;;;1541   {
001a92  4605              MOV      r5,r0
001a94  460c              MOV      r4,r1
;;;1542     TCP_RMV(pcblist, pcb);
001a96  bf00              NOP      
001a98  6828              LDR      r0,[r5,#0]
001a9a  42a0              CMP      r0,r4
001a9c  d103              BNE      |L1.6822|
001a9e  6828              LDR      r0,[r5,#0]
001aa0  68c0              LDR      r0,[r0,#0xc]
001aa2  6028              STR      r0,[r5,#0]
001aa4  e017              B        |L1.6870|
                  |L1.6822|
001aa6  49f7              LDR      r1,|L1.7812|
001aa8  6828              LDR      r0,[r5,#0]
001aaa  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
001aac  e00e              B        |L1.6860|
                  |L1.6830|
001aae  48f5              LDR      r0,|L1.7812|
001ab0  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
001ab2  68c0              LDR      r0,[r0,#0xc]
001ab4  42a0              CMP      r0,r4
001ab6  d104              BNE      |L1.6850|
001ab8  49f2              LDR      r1,|L1.7812|
001aba  68e0              LDR      r0,[r4,#0xc]
001abc  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
001abe  60c8              STR      r0,[r1,#0xc]
001ac0  e008              B        |L1.6868|
                  |L1.6850|
001ac2  48f0              LDR      r0,|L1.7812|
001ac4  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
001ac6  68c0              LDR      r0,[r0,#0xc]
001ac8  49ee              LDR      r1,|L1.7812|
001aca  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L1.6860|
001acc  48ed              LDR      r0,|L1.7812|
001ace  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
001ad0  2800              CMP      r0,#0
001ad2  d1ec              BNE      |L1.6830|
                  |L1.6868|
001ad4  bf00              NOP      
                  |L1.6870|
001ad6  2000              MOVS     r0,#0
001ad8  60e0              STR      r0,[r4,#0xc]
001ada  bf00              NOP      
;;;1543   
;;;1544     tcp_pcb_purge(pcb);
001adc  4620              MOV      r0,r4
001ade  f7fffffe          BL       tcp_pcb_purge
;;;1545     
;;;1546     /* if there is an outstanding delayed ACKs, send it */
;;;1547     if (pcb->state != TIME_WAIT &&
001ae2  7e20              LDRB     r0,[r4,#0x18]
001ae4  280a              CMP      r0,#0xa
001ae6  d00d              BEQ      |L1.6916|
;;;1548        pcb->state != LISTEN &&
001ae8  7e20              LDRB     r0,[r4,#0x18]
001aea  2801              CMP      r0,#1
001aec  d00a              BEQ      |L1.6916|
;;;1549        pcb->flags & TF_ACK_DELAY) {
001aee  7fa0              LDRB     r0,[r4,#0x1e]
001af0  f0100f01          TST      r0,#1
001af4  d006              BEQ      |L1.6916|
;;;1550       pcb->flags |= TF_ACK_NOW;
001af6  7fa0              LDRB     r0,[r4,#0x1e]
001af8  f0400002          ORR      r0,r0,#2
001afc  77a0              STRB     r0,[r4,#0x1e]
;;;1551       tcp_output(pcb);
001afe  4620              MOV      r0,r4
001b00  f7fffffe          BL       tcp_output
                  |L1.6916|
;;;1552     }
;;;1553   
;;;1554     if (pcb->state != LISTEN) {
001b04  7e20              LDRB     r0,[r4,#0x18]
001b06  2801              CMP      r0,#1
001b08  d005              BEQ      |L1.6934|
;;;1555       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
001b0a  bf00              NOP      
001b0c  bf00              NOP      
;;;1556       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
001b0e  bf00              NOP      
001b10  bf00              NOP      
;;;1557   #if TCP_QUEUE_OOSEQ
;;;1558       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
001b12  bf00              NOP      
001b14  bf00              NOP      
                  |L1.6934|
;;;1559   #endif /* TCP_QUEUE_OOSEQ */
;;;1560     }
;;;1561   
;;;1562     pcb->state = CLOSED;
001b16  2000              MOVS     r0,#0
001b18  7620              STRB     r0,[r4,#0x18]
;;;1563   
;;;1564     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
001b1a  bf00              NOP      
001b1c  bf00              NOP      
;;;1565   }
001b1e  bd70              POP      {r4-r6,pc}
;;;1566   
                          ENDP

                  sys_timeout PROC
;;;265    void
;;;266    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
001b20  e92d41f0          PUSH     {r4-r8,lr}
;;;267    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;268    {
001b24  4606              MOV      r6,r0
001b26  460f              MOV      r7,r1
001b28  4690              MOV      r8,r2
;;;269      struct sys_timeo *timeout, *t;
;;;270    
;;;271      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
001b2a  200a              MOVS     r0,#0xa
001b2c  f7fffffe          BL       memp_malloc
001b30  4604              MOV      r4,r0
;;;272      if (timeout == NULL) {
001b32  b91c              CBNZ     r4,|L1.6972|
;;;273        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
001b34  bf00              NOP      
001b36  bf00              NOP      
                  |L1.6968|
;;;274        return;
;;;275      }
;;;276      timeout->next = NULL;
;;;277      timeout->h = handler;
;;;278      timeout->arg = arg;
;;;279      timeout->time = msecs;
;;;280    #if LWIP_DEBUG_TIMERNAMES
;;;281      timeout->handler_name = handler_name;
;;;282      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;283        (void *)timeout, msecs, handler_name, (void *)arg));
;;;284    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;285    
;;;286      if (next_timeout == NULL) {
;;;287        next_timeout = timeout;
;;;288        return;
;;;289      }
;;;290    
;;;291      if (next_timeout->time > msecs) {
;;;292        next_timeout->time -= msecs;
;;;293        timeout->next = next_timeout;
;;;294        next_timeout = timeout;
;;;295      } else {  
;;;296        for(t = next_timeout; t != NULL; t = t->next) {
;;;297          timeout->time -= t->time;
;;;298          if (t->next == NULL || t->next->time > timeout->time) {
;;;299            if (t->next != NULL) {
;;;300              t->next->time -= timeout->time;
;;;301            }
;;;302            timeout->next = t->next;
;;;303            t->next = timeout;
;;;304            break;
;;;305          }
;;;306        }
;;;307      }
;;;308    }
001b38  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6972|
001b3c  2000              MOVS     r0,#0                 ;276
001b3e  6020              STR      r0,[r4,#0]            ;276
001b40  60a7              STR      r7,[r4,#8]            ;277
001b42  f8c4800c          STR      r8,[r4,#0xc]          ;278
001b46  6066              STR      r6,[r4,#4]            ;279
001b48  48cf              LDR      r0,|L1.7816|
001b4a  6800              LDR      r0,[r0,#0]            ;286  ; next_timeout
001b4c  b910              CBNZ     r0,|L1.6996|
001b4e  48ce              LDR      r0,|L1.7816|
001b50  6004              STR      r4,[r0,#0]            ;287  ; next_timeout
001b52  e7f1              B        |L1.6968|
                  |L1.6996|
001b54  48cc              LDR      r0,|L1.7816|
001b56  6800              LDR      r0,[r0,#0]            ;291  ; next_timeout
001b58  6840              LDR      r0,[r0,#4]            ;291
001b5a  42b0              CMP      r0,r6                 ;291
001b5c  d90c              BLS      |L1.7032|
001b5e  48ca              LDR      r0,|L1.7816|
001b60  6800              LDR      r0,[r0,#0]            ;292  ; next_timeout
001b62  6840              LDR      r0,[r0,#4]            ;292
001b64  1b80              SUBS     r0,r0,r6              ;292
001b66  49c8              LDR      r1,|L1.7816|
001b68  6809              LDR      r1,[r1,#0]            ;292  ; next_timeout
001b6a  6048              STR      r0,[r1,#4]            ;292
001b6c  48c6              LDR      r0,|L1.7816|
001b6e  6800              LDR      r0,[r0,#0]            ;293  ; next_timeout
001b70  6020              STR      r0,[r4,#0]            ;293
001b72  48c5              LDR      r0,|L1.7816|
001b74  6004              STR      r4,[r0,#0]            ;294  ; next_timeout
001b76  e01d              B        |L1.7092|
                  |L1.7032|
001b78  48c3              LDR      r0,|L1.7816|
001b7a  6805              LDR      r5,[r0,#0]            ;296  ; next_timeout
001b7c  e017              B        |L1.7086|
                  |L1.7038|
001b7e  6860              LDR      r0,[r4,#4]            ;297
001b80  6869              LDR      r1,[r5,#4]            ;297
001b82  1a40              SUBS     r0,r0,r1              ;297
001b84  6060              STR      r0,[r4,#4]            ;297
001b86  6828              LDR      r0,[r5,#0]            ;298
001b88  b120              CBZ      r0,|L1.7060|
001b8a  6828              LDR      r0,[r5,#0]            ;298
001b8c  6840              LDR      r0,[r0,#4]            ;298
001b8e  6861              LDR      r1,[r4,#4]            ;298
001b90  4288              CMP      r0,r1                 ;298
001b92  d90b              BLS      |L1.7084|
                  |L1.7060|
001b94  6828              LDR      r0,[r5,#0]            ;299
001b96  b128              CBZ      r0,|L1.7076|
001b98  6828              LDR      r0,[r5,#0]            ;300
001b9a  6840              LDR      r0,[r0,#4]            ;300
001b9c  6861              LDR      r1,[r4,#4]            ;300
001b9e  1a40              SUBS     r0,r0,r1              ;300
001ba0  6829              LDR      r1,[r5,#0]            ;300
001ba2  6048              STR      r0,[r1,#4]            ;300
                  |L1.7076|
001ba4  6828              LDR      r0,[r5,#0]            ;302
001ba6  6020              STR      r0,[r4,#0]            ;302
001ba8  602c              STR      r4,[r5,#0]            ;303
001baa  e002              B        |L1.7090|
                  |L1.7084|
001bac  682d              LDR      r5,[r5,#0]            ;296
                  |L1.7086|
001bae  2d00              CMP      r5,#0                 ;296
001bb0  d1e5              BNE      |L1.7038|
                  |L1.7090|
001bb2  bf00              NOP                            ;304
                  |L1.7092|
001bb4  bf00              NOP      
001bb6  e7bf              B        |L1.6968|
;;;309    
                          ENDP

                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
001bb8  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
001bbc  4681              MOV      r9,r0
001bbe  460e              MOV      r6,r1
001bc0  4617              MOV      r7,r2
001bc2  4698              MOV      r8,r3
001bc4  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
001bc8  2200              MOVS     r2,#0
001bca  2114              MOVS     r1,#0x14
001bcc  2001              MOVS     r0,#1
001bce  f7fffffe          BL       pbuf_alloc
001bd2  4605              MOV      r5,r0
;;;1202     if (p == NULL) {
001bd4  b91d              CBNZ     r5,|L1.7134|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
001bd6  bf00              NOP      
001bd8  bf00              NOP      
                  |L1.7130|
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
;;;1211     tcphdr->dest = htons(remote_port);
;;;1212     tcphdr->seqno = htonl(seqno);
;;;1213     tcphdr->ackno = htonl(ackno);
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
;;;1216     tcphdr->chksum = 0;
;;;1217     tcphdr->urgp = 0;
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
;;;1227     pbuf_free(p);
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
001bda  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.7134|
001bde  bf00              NOP                            ;1206
001be0  bf00              NOP                            ;1206
001be2  686c              LDR      r4,[r5,#4]            ;1209
001be4  4650              MOV      r0,r10                ;1210
001be6  f7fffffe          BL       lwip_htons
001bea  8020              STRH     r0,[r4,#0]            ;1210
001bec  4658              MOV      r0,r11                ;1211
001bee  f7fffffe          BL       lwip_htons
001bf2  8060              STRH     r0,[r4,#2]            ;1211
001bf4  4648              MOV      r0,r9                 ;1212
001bf6  f7fffffe          BL       lwip_htonl
001bfa  6060              STR      r0,[r4,#4]            ;1212
001bfc  4630              MOV      r0,r6                 ;1213
001bfe  f7fffffe          BL       lwip_htonl
001c02  60a0              STR      r0,[r4,#8]            ;1213
001c04  f2450014          MOV      r0,#0x5014            ;1214
001c08  f7fffffe          BL       lwip_htons
001c0c  81a0              STRH     r0,[r4,#0xc]          ;1214
001c0e  2010              MOVS     r0,#0x10              ;1215
001c10  81e0              STRH     r0,[r4,#0xe]          ;1215
001c12  2000              MOVS     r0,#0                 ;1216
001c14  8220              STRH     r0,[r4,#0x10]         ;1216
001c16  8260              STRH     r0,[r4,#0x12]         ;1217
001c18  489c              LDR      r0,|L1.7820|
001c1a  f8b00094          LDRH     r0,[r0,#0x94]         ;1223  ; lwip_stats
001c1e  1c40              ADDS     r0,r0,#1              ;1223
001c20  499a              LDR      r1,|L1.7820|
001c22  f8a10094          STRH     r0,[r1,#0x94]         ;1223
001c26  2006              MOVS     r0,#6                 ;1226
001c28  2100              MOVS     r1,#0                 ;1226
001c2a  23ff              MOVS     r3,#0xff              ;1226
001c2c  4642              MOV      r2,r8                 ;1226
001c2e  e9cd1000          STRD     r1,r0,[sp,#0]         ;1226
001c32  4639              MOV      r1,r7                 ;1226
001c34  4628              MOV      r0,r5                 ;1226
001c36  f7fffffe          BL       ip_output
001c3a  4628              MOV      r0,r5                 ;1227
001c3c  f7fffffe          BL       pbuf_free
001c40  bf00              NOP                            ;1228
001c42  bf00              NOP                            ;1228
001c44  bf00              NOP      
001c46  e7c8              B        |L1.7130|
;;;1230   
                          ENDP

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
001c48  e92d41fc          PUSH     {r2-r8,lr}
;;;1365   {
001c4c  4604              MOV      r4,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
001c4e  bf00              NOP      
001c50  bf00              NOP      
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
001c52  bf00              NOP      
001c54  bf00              NOP      
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
001c56  6d21              LDR      r1,[r4,#0x50]
001c58  1e48              SUBS     r0,r1,#1
001c5a  f7fffffe          BL       lwip_htonl
001c5e  4607              MOV      r7,r0
001c60  463b              MOV      r3,r7
001c62  2200              MOVS     r2,#0
001c64  4611              MOV      r1,r2
001c66  4620              MOV      r0,r4
001c68  f7fffffe          BL       tcp_output_alloc_header
001c6c  4605              MOV      r5,r0
;;;1377     if(p == NULL) {
001c6e  b91d              CBNZ     r5,|L1.7288|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
001c70  bf00              NOP      
001c72  bf00              NOP      
                  |L1.7284|
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
001c74  e8bd81fc          POP      {r2-r8,pc}
                  |L1.7288|
001c78  686e              LDR      r6,[r5,#4]            ;1382
001c7a  4884              LDR      r0,|L1.7820|
001c7c  f8b00094          LDRH     r0,[r0,#0x94]         ;1388  ; lwip_stats
001c80  1c40              ADDS     r0,r0,#1              ;1388
001c82  4982              LDR      r1,|L1.7820|
001c84  f8a10094          STRH     r0,[r1,#0x94]         ;1388
001c88  2006              MOVS     r0,#6                 ;1395
001c8a  2100              MOVS     r1,#0                 ;1395
001c8c  e9cd1000          STRD     r1,r0,[sp,#0]         ;1395
001c90  7aa3              LDRB     r3,[r4,#0xa]          ;1395
001c92  1d22              ADDS     r2,r4,#4              ;1395
001c94  4621              MOV      r1,r4                 ;1395
001c96  4628              MOV      r0,r5                 ;1395
001c98  f7fffffe          BL       ip_output
001c9c  4628              MOV      r0,r5                 ;1398
001c9e  f7fffffe          BL       pbuf_free
001ca2  bf00              NOP                            ;1400
001ca4  bf00              NOP                            ;1400
001ca6  bf00              NOP      
001ca8  e7e4              B        |L1.7284|
;;;1403   
                          ENDP

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
001caa  b570              PUSH     {r4-r6,lr}
;;;1240   {
001cac  4604              MOV      r4,r0
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
001cae  6f20              LDR      r0,[r4,#0x70]
001cb0  b900              CBNZ     r0,|L1.7348|
                  |L1.7346|
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
;;;1265   }
001cb2  bd70              POP      {r4-r6,pc}
                  |L1.7348|
001cb4  6f25              LDR      r5,[r4,#0x70]         ;1248
001cb6  e000              B        |L1.7354|
                  |L1.7352|
001cb8  682d              LDR      r5,[r5,#0]            ;1248
                  |L1.7354|
001cba  6828              LDR      r0,[r5,#0]            ;1248
001cbc  2800              CMP      r0,#0                 ;1248
001cbe  d1fb              BNE      |L1.7352|
001cc0  6ee0              LDR      r0,[r4,#0x6c]         ;1250
001cc2  6028              STR      r0,[r5,#0]            ;1250
001cc4  6f20              LDR      r0,[r4,#0x70]         ;1252
001cc6  66e0              STR      r0,[r4,#0x6c]         ;1252
001cc8  2000              MOVS     r0,#0                 ;1254
001cca  6720              STR      r0,[r4,#0x70]         ;1254
001ccc  f8940046          LDRB     r0,[r4,#0x46]         ;1258
001cd0  1c40              ADDS     r0,r0,#1              ;1258
001cd2  f8840046          STRB     r0,[r4,#0x46]         ;1258
001cd6  2000              MOVS     r0,#0                 ;1261
001cd8  63a0              STR      r0,[r4,#0x38]         ;1261
001cda  4620              MOV      r0,r4                 ;1264
001cdc  f7fffffe          BL       tcp_output
001ce0  bf00              NOP      
001ce2  e7e6              B        |L1.7346|
;;;1266   
                          ENDP

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
001ce4  e92d5ff0          PUSH     {r4-r12,lr}
;;;919    {
001ce8  4680              MOV      r8,r0
001cea  4689              MOV      r9,r1
001cec  4616              MOV      r6,r2
001cee  461d              MOV      r5,r3
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
001cf0  f04f0b00          MOV      r11,#0
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
001cf4  bf00              NOP      
001cf6  f1b80f00          CMP      r8,#0
001cfa  d102              BNE      |L1.7426|
001cfc  2000              MOVS     r0,#0
                  |L1.7422|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;927    
;;;928      left = 0;
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
001cfe  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.7426|
001d02  bf00              NOP                            ;925
001d04  bf00              NOP                            ;926
001d06  f1b90f00          CMP      r9,#0                 ;926
001d0a  d101              BNE      |L1.7440|
001d0c  2000              MOVS     r0,#0                 ;926
001d0e  e7f6              B        |L1.7422|
                  |L1.7440|
001d10  bf00              NOP                            ;926
001d12  f04f0a00          MOV      r10,#0                ;928
001d16  f1b80f00          CMP      r8,#0                 ;930
001d1a  d002              BEQ      |L1.7458|
001d1c  f1b90f00          CMP      r9,#0                 ;930
001d20  d101              BNE      |L1.7462|
                  |L1.7458|
001d22  2000              MOVS     r0,#0                 ;931
001d24  e7eb              B        |L1.7422|
                  |L1.7462|
001d26  4644              MOV      r4,r8                 ;935
001d28  e020              B        |L1.7532|
                  |L1.7466|
001d2a  b135              CBZ      r5,|L1.7482|
001d2c  8960              LDRH     r0,[r4,#0xa]          ;936
001d2e  42a8              CMP      r0,r5                 ;936
001d30  dc03              BGT      |L1.7482|
001d32  8960              LDRH     r0,[r4,#0xa]          ;938
001d34  1a28              SUBS     r0,r5,r0              ;938
001d36  b285              UXTH     r5,r0                 ;938
001d38  e017              B        |L1.7530|
                  |L1.7482|
001d3a  8960              LDRH     r0,[r4,#0xa]          ;941
001d3c  1b40              SUBS     r0,r0,r5              ;941
001d3e  b287              UXTH     r7,r0                 ;941
001d40  42b7              CMP      r7,r6                 ;942
001d42  dd00              BLE      |L1.7494|
001d44  4637              MOV      r7,r6                 ;943
                  |L1.7494|
001d46  6862              LDR      r2,[r4,#4]            ;945
001d48  1951              ADDS     r1,r2,r5              ;945
001d4a  eb09000a          ADD      r0,r9,r10             ;945
001d4e  463a              MOV      r2,r7                 ;945
001d50  f7fffffe          BL       __aeabi_memcpy
001d54  eb0b0007          ADD      r0,r11,r7             ;946
001d58  fa1ffb80          UXTH     r11,r0                ;946
001d5c  eb0a0007          ADD      r0,r10,r7             ;947
001d60  fa1ffa80          UXTH     r10,r0                ;947
001d64  1bf0              SUBS     r0,r6,r7              ;948
001d66  b286              UXTH     r6,r0                 ;948
001d68  2500              MOVS     r5,#0                 ;949
                  |L1.7530|
001d6a  6824              LDR      r4,[r4,#0]            ;935
                  |L1.7532|
001d6c  b10e              CBZ      r6,|L1.7538|
001d6e  2c00              CMP      r4,#0                 ;935
001d70  d1db              BNE      |L1.7466|
                  |L1.7538|
001d72  4658              MOV      r0,r11                ;952
001d74  e7c3              B        |L1.7422|
;;;954    
                          ENDP

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
001d76  e92d47fc          PUSH     {r2-r10,lr}
;;;1415   {
001d7a  4605              MOV      r5,r0
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
001d7c  bf00              NOP      
001d7e  bf00              NOP      
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
001d80  bf00              NOP      
001d82  bf00              NOP      
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
001d84  6f2c              LDR      r4,[r5,#0x70]
;;;1434   
;;;1435     if(seg == NULL) {
001d86  b904              CBNZ     r4,|L1.7562|
;;;1436       seg = pcb->unsent;
001d88  6eec              LDR      r4,[r5,#0x6c]
                  |L1.7562|
;;;1437     }
;;;1438     if(seg == NULL) {
001d8a  b90c              CBNZ     r4,|L1.7568|
                  |L1.7564|
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
;;;1447     if(p == NULL) {
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
001d8c  e8bd87fc          POP      {r2-r10,pc}
                  |L1.7568|
001d90  6921              LDR      r1,[r4,#0x10]         ;1442
001d92  8988              LDRH     r0,[r1,#0xc]          ;1442
001d94  f7fffffe          BL       lwip_ntohs
001d98  f0100f01          TST      r0,#1                 ;1442
001d9c  d003              BEQ      |L1.7590|
001d9e  8920              LDRH     r0,[r4,#8]            ;1442
001da0  b908              CBNZ     r0,|L1.7590|
001da2  2001              MOVS     r0,#1                 ;1442
001da4  e000              B        |L1.7592|
                  |L1.7590|
001da6  2000              MOVS     r0,#0                 ;1442
                  |L1.7592|
001da8  4680              MOV      r8,r0                 ;1442
001daa  f1b80f00          CMP      r8,#0                 ;1444
001dae  d101              BNE      |L1.7604|
001db0  2001              MOVS     r0,#1                 ;1444
001db2  e000              B        |L1.7606|
                  |L1.7604|
001db4  2000              MOVS     r0,#0                 ;1444
                  |L1.7606|
001db6  4681              MOV      r9,r0                 ;1444
001db8  6920              LDR      r0,[r4,#0x10]         ;1446
001dba  6843              LDR      r3,[r0,#4]            ;1446
001dbc  464a              MOV      r2,r9                 ;1446
001dbe  2100              MOVS     r1,#0                 ;1446
001dc0  4628              MOV      r0,r5                 ;1446
001dc2  f7fffffe          BL       tcp_output_alloc_header
001dc6  4606              MOV      r6,r0                 ;1446
001dc8  b916              CBNZ     r6,|L1.7632|
001dca  bf00              NOP                            ;1448
001dcc  bf00              NOP                            ;1448
001dce  e7dd              B        |L1.7564|
                  |L1.7632|
001dd0  6877              LDR      r7,[r6,#4]            ;1451
001dd2  f1b80f00          CMP      r8,#0                 ;1453
001dd6  d009              BEQ      |L1.7660|
001dd8  2011              MOVS     r0,#0x11              ;1455
001dda  f7fffffe          BL       lwip_htons
001dde  89b9              LDRH     r1,[r7,#0xc]          ;1455
001de0  f24c02ff          MOV      r2,#0xc0ff            ;1455
001de4  4011              ANDS     r1,r1,r2              ;1455
001de6  4308              ORRS     r0,r0,r1              ;1455
001de8  81b8              STRH     r0,[r7,#0xc]          ;1455
001dea  e00d              B        |L1.7688|
                  |L1.7660|
001dec  6870              LDR      r0,[r6,#4]            ;1458
001dee  f1000a14          ADD      r10,r0,#0x14          ;1458
001df2  6861              LDR      r1,[r4,#4]            ;1462
001df4  8909              LDRH     r1,[r1,#8]            ;1462
001df6  8922              LDRH     r2,[r4,#8]            ;1462
001df8  1a89              SUBS     r1,r1,r2              ;1462
001dfa  b28b              UXTH     r3,r1                 ;1462
001dfc  2201              MOVS     r2,#1                 ;1462
001dfe  4651              MOV      r1,r10                ;1462
001e00  6860              LDR      r0,[r4,#4]            ;1462
001e02  f7fffffe          BL       pbuf_copy_partial
001e06  bf00              NOP                            ;1463
                  |L1.7688|
001e08  4820              LDR      r0,|L1.7820|
001e0a  f8b00094          LDRH     r0,[r0,#0x94]         ;1469  ; lwip_stats
001e0e  1c40              ADDS     r0,r0,#1              ;1469
001e10  491e              LDR      r1,|L1.7820|
001e12  f8a10094          STRH     r0,[r1,#0x94]         ;1469
001e16  2006              MOVS     r0,#6                 ;1476
001e18  2100              MOVS     r1,#0                 ;1476
001e1a  e9cd1000          STRD     r1,r0,[sp,#0]         ;1476
001e1e  7aab              LDRB     r3,[r5,#0xa]          ;1476
001e20  1d2a              ADDS     r2,r5,#4              ;1476
001e22  4629              MOV      r1,r5                 ;1476
001e24  4630              MOV      r0,r6                 ;1476
001e26  f7fffffe          BL       ip_output
001e2a  4630              MOV      r0,r6                 ;1479
001e2c  f7fffffe          BL       pbuf_free
001e30  bf00              NOP                            ;1481
001e32  bf00              NOP                            ;1481
001e34  bf00              NOP      
001e36  e7a9              B        |L1.7564|
;;;1485   #endif /* LWIP_TCP */
                          ENDP

                  tcp_slowtmr PROC
;;;789    void
;;;790    tcp_slowtmr(void)
001e38  e92d4ffe          PUSH     {r1-r11,lr}
;;;791    {
;;;792      struct tcp_pcb *pcb, *prev;
;;;793      u16_t eff_wnd;
;;;794      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;795      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;796      err_t err;
;;;797    
;;;798      err = ERR_OK;
001e3c  2000              MOVS     r0,#0
001e3e  9002              STR      r0,[sp,#8]
;;;799    
;;;800      ++tcp_ticks;
001e40  4813              LDR      r0,|L1.7824|
001e42  6800              LDR      r0,[r0,#0]  ; tcp_ticks
001e44  1c40              ADDS     r0,r0,#1
001e46  4912              LDR      r1,|L1.7824|
001e48  6008              STR      r0,[r1,#0]  ; tcp_ticks
;;;801      ++tcp_timer_ctr;
001e4a  4812              LDR      r0,|L1.7828|
001e4c  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
001e4e  1c40              ADDS     r0,r0,#1
001e50  4910              LDR      r1,|L1.7828|
001e52  7008              STRB     r0,[r1,#0]
;;;802    
;;;803    tcp_slowtmr_start:
001e54  bf00              NOP      
                  |L1.7766|
;;;804      /* Steps through all of the active PCBs. */
;;;805      prev = NULL;
001e56  2500              MOVS     r5,#0
;;;806      pcb = tcp_active_pcbs;
001e58  480f              LDR      r0,|L1.7832|
001e5a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;807      if (pcb == NULL) {
001e5c  b90c              CBNZ     r4,|L1.7778|
;;;808        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
001e5e  bf00              NOP      
001e60  bf00              NOP      
                  |L1.7778|
;;;809      }
;;;810      while (pcb != NULL) {
001e62  e181              B        |L1.8552|
                  |L1.7780|
;;;811        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
001e64  bf00              NOP      
001e66  bf00              NOP      
;;;812        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
001e68  bf00              NOP      
001e6a  bf00              NOP      
;;;813        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
001e6c  bf00              NOP      
001e6e  bf00              NOP      
;;;814        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
001e70  bf00              NOP      
001e72  bf00              NOP      
;;;815        if (pcb->last_timer == tcp_timer_ctr) {
001e74  f8940021          LDRB     r0,[r4,#0x21]
001e78  4906              LDR      r1,|L1.7828|
001e7a  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
001e7c  4288              CMP      r0,r1
001e7e  d10d              BNE      |L1.7836|
;;;816          /* skip this pcb, we have already processed it */
;;;817          pcb = pcb->next;
001e80  68e4              LDR      r4,[r4,#0xc]
;;;818          continue;
001e82  e171              B        |L1.8552|
                  |L1.7812|
                          DCD      tcp_tmp_pcb
                  |L1.7816|
                          DCD      next_timeout
                  |L1.7820|
                          DCD      lwip_stats
                  |L1.7824|
                          DCD      tcp_ticks
                  |L1.7828|
                          DCD      tcp_timer_ctr
                  |L1.7832|
                          DCD      tcp_active_pcbs
                  |L1.7836|
;;;819        }
;;;820        pcb->last_timer = tcp_timer_ctr;
001e9c  48fd              LDR      r0,|L1.8852|
001e9e  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
001ea0  f8840021          STRB     r0,[r4,#0x21]
;;;821    
;;;822        pcb_remove = 0;
001ea4  2600              MOVS     r6,#0
;;;823        pcb_reset = 0;
001ea6  46b1              MOV      r9,r6
;;;824    
;;;825        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
001ea8  7e20              LDRB     r0,[r4,#0x18]
001eaa  2802              CMP      r0,#2
001eac  d107              BNE      |L1.7870|
001eae  f8940046          LDRB     r0,[r4,#0x46]
001eb2  2806              CMP      r0,#6
001eb4  d103              BNE      |L1.7870|
;;;826          ++pcb_remove;
001eb6  1c70              ADDS     r0,r6,#1
001eb8  b2c6              UXTB     r6,r0
;;;827          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
001eba  bf00              NOP      
001ebc  e078              B        |L1.8112|
                  |L1.7870|
;;;828        }
;;;829        else if (pcb->nrtx == TCP_MAXRTX) {
001ebe  f8940046          LDRB     r0,[r4,#0x46]
001ec2  280c              CMP      r0,#0xc
001ec4  d103              BNE      |L1.7886|
;;;830          ++pcb_remove;
001ec6  1c70              ADDS     r0,r6,#1
001ec8  b2c6              UXTB     r6,r0
;;;831          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
001eca  bf00              NOP      
001ecc  e070              B        |L1.8112|
                  |L1.7886|
;;;832        } else {
;;;833          if (pcb->persist_backoff > 0) {
001ece  f8940095          LDRB     r0,[r4,#0x95]
001ed2  2800              CMP      r0,#0
001ed4  dd1d              BLE      |L1.7954|
;;;834            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;835             * instead of using the standard retransmission mechanism. */
;;;836            pcb->persist_cnt++;
001ed6  f8140f94          LDRB     r0,[r4,#0x94]!
001eda  1c40              ADDS     r0,r0,#1
001edc  7020              STRB     r0,[r4,#0]
;;;837            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
001ede  7821              LDRB     r1,[r4,#0]
001ee0  7860              LDRB     r0,[r4,#1]
001ee2  f1a40494          SUB      r4,r4,#0x94
001ee6  f1a00001          SUB      r0,r0,#1
001eea  4aeb              LDR      r2,|L1.8856|
001eec  5c10              LDRB     r0,[r2,r0]
001eee  4281              CMP      r1,r0
001ef0  db5e              BLT      |L1.8112|
;;;838              pcb->persist_cnt = 0;
001ef2  2000              MOVS     r0,#0
001ef4  f8840094          STRB     r0,[r4,#0x94]
;;;839              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
001ef8  f8940095          LDRB     r0,[r4,#0x95]
001efc  2807              CMP      r0,#7
001efe  d204              BCS      |L1.7946|
;;;840                pcb->persist_backoff++;
001f00  f8940095          LDRB     r0,[r4,#0x95]
001f04  1c40              ADDS     r0,r0,#1
001f06  f8840095          STRB     r0,[r4,#0x95]
                  |L1.7946|
;;;841              }
;;;842              tcp_zero_window_probe(pcb);
001f0a  4620              MOV      r0,r4
001f0c  f7fffffe          BL       tcp_zero_window_probe
001f10  e04e              B        |L1.8112|
                  |L1.7954|
;;;843            }
;;;844          } else {
;;;845            /* Increase the retransmission timer if it is running */
;;;846            if(pcb->rtime >= 0) {
001f12  f9b40034          LDRSH    r0,[r4,#0x34]
001f16  2800              CMP      r0,#0
001f18  db03              BLT      |L1.7970|
;;;847              ++pcb->rtime;
001f1a  8ea0              LDRH     r0,[r4,#0x34]
001f1c  1c40              ADDS     r0,r0,#1
001f1e  b200              SXTH     r0,r0
001f20  86a0              STRH     r0,[r4,#0x34]
                  |L1.7970|
;;;848            }
;;;849    
;;;850            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
001f22  6f20              LDR      r0,[r4,#0x70]
001f24  b3f0              CBZ      r0,|L1.8100|
001f26  f9b40034          LDRSH    r0,[r4,#0x34]
001f2a  f9b41044          LDRSH    r1,[r4,#0x44]
001f2e  4288              CMP      r0,r1
001f30  db3e              BLT      |L1.8112|
;;;851              /* Time for a retransmission. */
;;;852              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
001f32  bf00              NOP      
001f34  bf00              NOP      
;;;853                                          " pcb->rto %"S16_F"\n",
;;;854                                          pcb->rtime, pcb->rto));
;;;855    
;;;856              /* Double retransmission time-out unless we are trying to
;;;857               * connect to somebody (i.e., we are in SYN_SENT). */
;;;858              if (pcb->state != SYN_SENT) {
001f36  7e20              LDRB     r0,[r4,#0x18]
001f38  2802              CMP      r0,#2
001f3a  d00f              BEQ      |L1.8028|
;;;859                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
001f3c  f1040440          ADD      r4,r4,#0x40
001f40  8860              LDRH     r0,[r4,#2]
001f42  f9b41000          LDRSH    r1,[r4,#0]
001f46  eb0000e1          ADD      r0,r0,r1,ASR #3
001f4a  79a1              LDRB     r1,[r4,#6]
001f4c  4ad3              LDR      r2,|L1.8860|
001f4e  5c51              LDRB     r1,[r2,r1]
001f50  fa00f001          LSL      r0,r0,r1
001f54  b200              SXTH     r0,r0
001f56  80a0              STRH     r0,[r4,#4]
001f58  f1a40440          SUB      r4,r4,#0x40
                  |L1.8028|
;;;860              }
;;;861    
;;;862              /* Reset the retransmission timer. */
;;;863              pcb->rtime = 0;
001f5c  f04f0000          MOV      r0,#0
001f60  86a0              STRH     r0,[r4,#0x34]
;;;864    
;;;865              /* Reduce congestion window and ssthresh. */
;;;866              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
001f62  f8b4004c          LDRH     r0,[r4,#0x4c]
001f66  f8b41060          LDRH     r1,[r4,#0x60]
001f6a  4288              CMP      r0,r1
001f6c  da02              BGE      |L1.8052|
001f6e  f8b4004c          LDRH     r0,[r4,#0x4c]
001f72  e001              B        |L1.8056|
                  |L1.8052|
001f74  f8b40060          LDRH     r0,[r4,#0x60]
                  |L1.8056|
001f78  4682              MOV      r10,r0
;;;867              pcb->ssthresh = eff_wnd >> 1;
001f7a  ea4f006a          ASR      r0,r10,#1
001f7e  f8a4004e          STRH     r0,[r4,#0x4e]
;;;868              if (pcb->ssthresh < (pcb->mss << 1)) {
001f82  f8b4004e          LDRH     r0,[r4,#0x4e]
001f86  8ee1              LDRH     r1,[r4,#0x36]
001f88  ebb00f41          CMP      r0,r1,LSL #1
001f8c  da06              BGE      |L1.8092|
;;;869                pcb->ssthresh = (pcb->mss << 1);
001f8e  8ee0              LDRH     r0,[r4,#0x36]
001f90  f64f71ff          MOV      r1,#0xffff
001f94  ea010040          AND      r0,r1,r0,LSL #1
001f98  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L1.8092|
;;;870              }
;;;871              pcb->cwnd = pcb->mss;
001f9c  8ee0              LDRH     r0,[r4,#0x36]
001f9e  f8a4004c          STRH     r0,[r4,#0x4c]
;;;872              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
001fa2  e000              B        |L1.8102|
                  |L1.8100|
001fa4  e004              B        |L1.8112|
                  |L1.8102|
001fa6  bf00              NOP      
001fa8  bf00              NOP      
;;;873                                           " ssthresh %"U16_F"\n",
;;;874                                           pcb->cwnd, pcb->ssthresh));
;;;875     
;;;876              /* The following needs to be called AFTER cwnd is set to one
;;;877                 mss - STJ */
;;;878              tcp_rexmit_rto(pcb);
001faa  4620              MOV      r0,r4
001fac  f7fffffe          BL       tcp_rexmit_rto
                  |L1.8112|
;;;879            }
;;;880          }
;;;881        }
;;;882        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;883        if (pcb->state == FIN_WAIT_2) {
001fb0  7e20              LDRB     r0,[r4,#0x18]
001fb2  2806              CMP      r0,#6
001fb4  d10d              BNE      |L1.8146|
;;;884          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;885          if (pcb->flags & TF_RXCLOSED) {
001fb6  7fa0              LDRB     r0,[r4,#0x1e]
001fb8  f0100f10          TST      r0,#0x10
001fbc  d009              BEQ      |L1.8146|
;;;886            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;887               normal FIN-WAIT timeout handling. */
;;;888            if ((u32_t)(tcp_ticks - pcb->tmr) >
001fbe  49b8              LDR      r1,|L1.8864|
001fc0  6a60              LDR      r0,[r4,#0x24]
001fc2  6809              LDR      r1,[r1,#0]  ; tcp_ticks
001fc4  1a08              SUBS     r0,r1,r0
001fc6  2828              CMP      r0,#0x28
001fc8  d903              BLS      |L1.8146|
;;;889                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;890              ++pcb_remove;
001fca  1c70              ADDS     r0,r6,#1
001fcc  b2c6              UXTB     r6,r0
;;;891              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
001fce  bf00              NOP      
001fd0  bf00              NOP      
                  |L1.8146|
;;;892            }
;;;893          }
;;;894        }
;;;895    
;;;896        /* Check if KEEPALIVE should be sent */
;;;897        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
001fd2  7a20              LDRB     r0,[r4,#8]
001fd4  f0100f08          TST      r0,#8
001fd8  d038              BEQ      |L1.8268|
;;;898           ((pcb->state == ESTABLISHED) ||
001fda  7e20              LDRB     r0,[r4,#0x18]
001fdc  2804              CMP      r0,#4
001fde  d002              BEQ      |L1.8166|
;;;899            (pcb->state == CLOSE_WAIT))) {
001fe0  7e20              LDRB     r0,[r4,#0x18]
001fe2  2807              CMP      r0,#7
001fe4  d132              BNE      |L1.8268|
                  |L1.8166|
;;;900          if((u32_t)(tcp_ticks - pcb->tmr) >
001fe6  49af              LDR      r1,|L1.8868|
001fe8  f8d40090          LDR      r0,[r4,#0x90]
001fec  4408              ADD      r0,r0,r1
001fee  f44f71fa          MOV      r1,#0x1f4
001ff2  fbb0f0f1          UDIV     r0,r0,r1
001ff6  4aaa              LDR      r2,|L1.8864|
001ff8  6a61              LDR      r1,[r4,#0x24]
001ffa  6812              LDR      r2,[r2,#0]  ; tcp_ticks
001ffc  1a51              SUBS     r1,r2,r1
001ffe  4288              CMP      r0,r1
002000  d208              BCS      |L1.8212|
;;;901             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;902          {
;;;903            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
002002  bf00              NOP      
002004  bf00              NOP      
;;;904                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;905                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;906            
;;;907            ++pcb_remove;
002006  1c70              ADDS     r0,r6,#1
002008  b2c6              UXTB     r6,r0
;;;908            ++pcb_reset;
00200a  f1090001          ADD      r0,r9,#1
00200e  f00009ff          AND      r9,r0,#0xff
002012  e01b              B        |L1.8268|
                  |L1.8212|
;;;909          }
;;;910          else if((u32_t)(tcp_ticks - pcb->tmr) > 
002014  f8941096          LDRB     r1,[r4,#0x96]
002018  f242429f          MOV      r2,#0x249f
00201c  fb11f102          SMULBB   r1,r1,r2
002020  f8d40090          LDR      r0,[r4,#0x90]
002024  eb0000c1          ADD      r0,r0,r1,LSL #3
002028  f44f71fa          MOV      r1,#0x1f4
00202c  fbb0f1f1          UDIV     r1,r0,r1
002030  4a9b              LDR      r2,|L1.8864|
002032  6a60              LDR      r0,[r4,#0x24]
002034  6812              LDR      r2,[r2,#0]  ; tcp_ticks
002036  1a10              SUBS     r0,r2,r0
002038  4281              CMP      r1,r0
00203a  d207              BCS      |L1.8268|
;;;911                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;912                  / TCP_SLOW_INTERVAL)
;;;913          {
;;;914            tcp_keepalive(pcb);
00203c  4620              MOV      r0,r4
00203e  f7fffffe          BL       tcp_keepalive
;;;915            pcb->keep_cnt_sent++;
002042  f8940096          LDRB     r0,[r4,#0x96]
002046  1c40              ADDS     r0,r0,#1
002048  f8840096          STRB     r0,[r4,#0x96]
                  |L1.8268|
;;;916          }
;;;917        }
;;;918    
;;;919        /* If this PCB has queued out of sequence data, but has been
;;;920           inactive for too long, will drop the data (it will eventually
;;;921           be retransmitted). */
;;;922    #if TCP_QUEUE_OOSEQ
;;;923        if (pcb->ooseq != NULL &&
00204c  6f60              LDR      r0,[r4,#0x74]
00204e  b188              CBZ      r0,|L1.8308|
;;;924            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
002050  4993              LDR      r1,|L1.8864|
002052  6a60              LDR      r0,[r4,#0x24]
002054  6809              LDR      r1,[r1,#0]  ; tcp_ticks
002056  1a08              SUBS     r0,r1,r0
002058  f9b41044          LDRSH    r1,[r4,#0x44]
00205c  eb010141          ADD      r1,r1,r1,LSL #1
002060  ebb00f41          CMP      r0,r1,LSL #1
002064  d306              BCC      |L1.8308|
;;;925          tcp_segs_free(pcb->ooseq);
002066  6f60              LDR      r0,[r4,#0x74]
002068  f7fffffe          BL       tcp_segs_free
;;;926          pcb->ooseq = NULL;
00206c  2000              MOVS     r0,#0
00206e  6760              STR      r0,[r4,#0x74]
;;;927          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
002070  bf00              NOP      
002072  bf00              NOP      
                  |L1.8308|
;;;928        }
;;;929    #endif /* TCP_QUEUE_OOSEQ */
;;;930    
;;;931        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;932        if (pcb->state == SYN_RCVD) {
002074  7e20              LDRB     r0,[r4,#0x18]
002076  2803              CMP      r0,#3
002078  d109              BNE      |L1.8334|
;;;933          if ((u32_t)(tcp_ticks - pcb->tmr) >
00207a  4989              LDR      r1,|L1.8864|
00207c  6a60              LDR      r0,[r4,#0x24]
00207e  6809              LDR      r1,[r1,#0]  ; tcp_ticks
002080  1a08              SUBS     r0,r1,r0
002082  2828              CMP      r0,#0x28
002084  d903              BLS      |L1.8334|
;;;934              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;935            ++pcb_remove;
002086  1c70              ADDS     r0,r6,#1
002088  b2c6              UXTB     r6,r0
;;;936            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
00208a  bf00              NOP      
00208c  bf00              NOP      
                  |L1.8334|
;;;937          }
;;;938        }
;;;939    
;;;940        /* Check if this PCB has stayed too long in LAST-ACK */
;;;941        if (pcb->state == LAST_ACK) {
00208e  7e20              LDRB     r0,[r4,#0x18]
002090  2809              CMP      r0,#9
002092  d109              BNE      |L1.8360|
;;;942          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
002094  4982              LDR      r1,|L1.8864|
002096  6a60              LDR      r0,[r4,#0x24]
002098  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00209a  1a08              SUBS     r0,r1,r0
00209c  28f0              CMP      r0,#0xf0
00209e  d903              BLS      |L1.8360|
;;;943            ++pcb_remove;
0020a0  1c70              ADDS     r0,r6,#1
0020a2  b2c6              UXTB     r6,r0
;;;944            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
0020a4  bf00              NOP      
0020a6  bf00              NOP      
                  |L1.8360|
;;;945          }
;;;946        }
;;;947    
;;;948        /* If the PCB should be removed, do it. */
;;;949        if (pcb_remove) {
0020a8  b3a6              CBZ      r6,|L1.8468|
;;;950          struct tcp_pcb *pcb2;
;;;951          tcp_err_fn err_fn;
;;;952          void *err_arg;
;;;953          tcp_pcb_purge(pcb);
0020aa  4620              MOV      r0,r4
0020ac  f7fffffe          BL       tcp_pcb_purge
;;;954          /* Remove PCB from tcp_active_pcbs list. */
;;;955          if (prev != NULL) {
0020b0  b125              CBZ      r5,|L1.8380|
;;;956            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
0020b2  bf00              NOP      
0020b4  bf00              NOP      
;;;957            prev->next = pcb->next;
0020b6  68e0              LDR      r0,[r4,#0xc]
0020b8  60e8              STR      r0,[r5,#0xc]
0020ba  e004              B        |L1.8390|
                  |L1.8380|
;;;958          } else {
;;;959            /* This PCB was the first. */
;;;960            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0020bc  bf00              NOP      
0020be  bf00              NOP      
;;;961            tcp_active_pcbs = pcb->next;
0020c0  4979              LDR      r1,|L1.8872|
0020c2  68e0              LDR      r0,[r4,#0xc]
0020c4  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L1.8390|
;;;962          }
;;;963    
;;;964          if (pcb_reset) {
0020c6  f1b90f00          CMP      r9,#0
0020ca  d009              BEQ      |L1.8416|
;;;965            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0020cc  8ba0              LDRH     r0,[r4,#0x1c]
0020ce  8b61              LDRH     r1,[r4,#0x1a]
0020d0  e9cd1000          STRD     r1,r0,[sp,#0]
0020d4  1d23              ADDS     r3,r4,#4
0020d6  4622              MOV      r2,r4
0020d8  6aa1              LDR      r1,[r4,#0x28]
0020da  6d20              LDR      r0,[r4,#0x50]
0020dc  f7fffffe          BL       tcp_rst
                  |L1.8416|
;;;966              pcb->local_port, pcb->remote_port);
;;;967          }
;;;968    
;;;969          err_fn = pcb->errf;
0020e0  f8d4808c          LDR      r8,[r4,#0x8c]
;;;970          err_arg = pcb->callback_arg;
0020e4  f8d4b010          LDR      r11,[r4,#0x10]
;;;971          pcb2 = pcb;
0020e8  4627              MOV      r7,r4
;;;972          pcb = pcb->next;
0020ea  68e4              LDR      r4,[r4,#0xc]
;;;973          memp_free(MEMP_TCP_PCB, pcb2);
0020ec  4639              MOV      r1,r7
0020ee  2002              MOVS     r0,#2
0020f0  f7fffffe          BL       memp_free
;;;974    
;;;975          tcp_active_pcbs_changed = 0;
0020f4  2000              MOVS     r0,#0
0020f6  496d              LDR      r1,|L1.8876|
0020f8  7008              STRB     r0,[r1,#0]
;;;976          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
0020fa  bf00              NOP      
0020fc  f1b80f00          CMP      r8,#0
002100  d003              BEQ      |L1.8458|
002102  f06f0109          MVN      r1,#9
002106  4658              MOV      r0,r11
002108  47c0              BLX      r8
                  |L1.8458|
00210a  bf00              NOP      
;;;977          if (tcp_active_pcbs_changed) {
00210c  4867              LDR      r0,|L1.8876|
00210e  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
002110  b108              CBZ      r0,|L1.8470|
;;;978            goto tcp_slowtmr_start;
002112  e6a0              B        |L1.7766|
                  |L1.8468|
002114  e000              B        |L1.8472|
                  |L1.8470|
;;;979          }
;;;980        } else {
002116  e026              B        |L1.8550|
                  |L1.8472|
;;;981          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;982          prev = pcb;
002118  4625              MOV      r5,r4
;;;983          pcb = pcb->next;
00211a  68e4              LDR      r4,[r4,#0xc]
;;;984    
;;;985          /* We check if we should poll the connection. */
;;;986          ++prev->polltmr;
00211c  7fe8              LDRB     r0,[r5,#0x1f]
00211e  1c40              ADDS     r0,r0,#1
002120  77e8              STRB     r0,[r5,#0x1f]
;;;987          if (prev->polltmr >= prev->pollinterval) {
002122  7fe8              LDRB     r0,[r5,#0x1f]
002124  f8951020          LDRB     r1,[r5,#0x20]
002128  4288              CMP      r0,r1
00212a  db1c              BLT      |L1.8550|
;;;988            prev->polltmr = 0;
00212c  2000              MOVS     r0,#0
00212e  77e8              STRB     r0,[r5,#0x1f]
;;;989            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
002130  bf00              NOP      
002132  bf00              NOP      
;;;990            tcp_active_pcbs_changed = 0;
002134  495d              LDR      r1,|L1.8876|
002136  7008              STRB     r0,[r1,#0]
;;;991            TCP_EVENT_POLL(prev, err);
002138  bf00              NOP      
00213a  f8d50088          LDR      r0,[r5,#0x88]
00213e  b130              CBZ      r0,|L1.8526|
002140  4629              MOV      r1,r5
002142  f8d52088          LDR      r2,[r5,#0x88]
002146  6928              LDR      r0,[r5,#0x10]
002148  4790              BLX      r2
00214a  9002              STR      r0,[sp,#8]
00214c  e001              B        |L1.8530|
                  |L1.8526|
00214e  2000              MOVS     r0,#0
002150  9002              STR      r0,[sp,#8]
                  |L1.8530|
002152  bf00              NOP      
;;;992            if (tcp_active_pcbs_changed) {
002154  4855              LDR      r0,|L1.8876|
002156  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
002158  b100              CBZ      r0,|L1.8540|
;;;993              goto tcp_slowtmr_start;
00215a  e67c              B        |L1.7766|
                  |L1.8540|
;;;994            }
;;;995            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;996            if (err == ERR_OK) {
00215c  9802              LDR      r0,[sp,#8]
00215e  b910              CBNZ     r0,|L1.8550|
;;;997              tcp_output(prev);
002160  4628              MOV      r0,r5
002162  f7fffffe          BL       tcp_output
                  |L1.8550|
002166  bf00              NOP                            ;818
                  |L1.8552|
002168  2c00              CMP      r4,#0                 ;810
00216a  f47fae7b          BNE      |L1.7780|
;;;998            }
;;;999          }
;;;1000       }
;;;1001     }
;;;1002   
;;;1003     
;;;1004     /* Steps through all of the TIME-WAIT PCBs. */
;;;1005     prev = NULL;
00216e  2500              MOVS     r5,#0
;;;1006     pcb = tcp_tw_pcbs;
002170  484f              LDR      r0,|L1.8880|
002172  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;1007     while (pcb != NULL) {
002174  e022              B        |L1.8636|
                  |L1.8566|
;;;1008       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
002176  bf00              NOP      
002178  bf00              NOP      
;;;1009       pcb_remove = 0;
00217a  2600              MOVS     r6,#0
;;;1010   
;;;1011       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1012       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
00217c  4948              LDR      r1,|L1.8864|
00217e  6a60              LDR      r0,[r4,#0x24]
002180  6809              LDR      r1,[r1,#0]  ; tcp_ticks
002182  1a08              SUBS     r0,r1,r0
002184  28f0              CMP      r0,#0xf0
002186  d901              BLS      |L1.8588|
;;;1013         ++pcb_remove;
002188  1c70              ADDS     r0,r6,#1
00218a  b2c6              UXTB     r6,r0
                  |L1.8588|
;;;1014       }
;;;1015       
;;;1016   
;;;1017   
;;;1018       /* If the PCB should be removed, do it. */
;;;1019       if (pcb_remove) {
00218c  b1a6              CBZ      r6,|L1.8632|
;;;1020         struct tcp_pcb *pcb2;
;;;1021         tcp_pcb_purge(pcb);
00218e  4620              MOV      r0,r4
002190  f7fffffe          BL       tcp_pcb_purge
;;;1022         /* Remove PCB from tcp_tw_pcbs list. */
;;;1023         if (prev != NULL) {
002194  b125              CBZ      r5,|L1.8608|
;;;1024           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
002196  bf00              NOP      
002198  bf00              NOP      
;;;1025           prev->next = pcb->next;
00219a  68e0              LDR      r0,[r4,#0xc]
00219c  60e8              STR      r0,[r5,#0xc]
00219e  e004              B        |L1.8618|
                  |L1.8608|
;;;1026         } else {
;;;1027           /* This PCB was the first. */
;;;1028           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0021a0  bf00              NOP      
0021a2  bf00              NOP      
;;;1029           tcp_tw_pcbs = pcb->next;
0021a4  4942              LDR      r1,|L1.8880|
0021a6  68e0              LDR      r0,[r4,#0xc]
0021a8  6008              STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L1.8618|
;;;1030         }
;;;1031         pcb2 = pcb;
0021aa  4627              MOV      r7,r4
;;;1032         pcb = pcb->next;
0021ac  68e4              LDR      r4,[r4,#0xc]
;;;1033         memp_free(MEMP_TCP_PCB, pcb2);
0021ae  4639              MOV      r1,r7
0021b0  2002              MOVS     r0,#2
0021b2  f7fffffe          BL       memp_free
;;;1034       } else {
0021b6  e001              B        |L1.8636|
                  |L1.8632|
;;;1035         prev = pcb;
0021b8  4625              MOV      r5,r4
;;;1036         pcb = pcb->next;
0021ba  68e4              LDR      r4,[r4,#0xc]
                  |L1.8636|
0021bc  2c00              CMP      r4,#0                 ;1007
0021be  d1da              BNE      |L1.8566|
;;;1037       }
;;;1038     }
;;;1039   }
0021c0  e8bd8ffe          POP      {r1-r11,pc}
;;;1040   
                          ENDP

                  tcp_close PROC
;;;285    err_t
;;;286    tcp_close(struct tcp_pcb *pcb)
0021c4  b510              PUSH     {r4,lr}
;;;287    {
0021c6  4604              MOV      r4,r0
;;;288    #if TCP_DEBUG
;;;289      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;290      tcp_debug_print_state(pcb->state);
;;;291    #endif /* TCP_DEBUG */
;;;292    
;;;293      if (pcb->state != LISTEN) {
0021c8  7e20              LDRB     r0,[r4,#0x18]
0021ca  2801              CMP      r0,#1
0021cc  d003              BEQ      |L1.8662|
;;;294        /* Set a flag not to receive any more data... */
;;;295        pcb->flags |= TF_RXCLOSED;
0021ce  7fa0              LDRB     r0,[r4,#0x1e]
0021d0  f0400010          ORR      r0,r0,#0x10
0021d4  77a0              STRB     r0,[r4,#0x1e]
                  |L1.8662|
;;;296      }
;;;297      /* ... and close */
;;;298      return tcp_close_shutdown(pcb, 1);
0021d6  2101              MOVS     r1,#1
0021d8  4620              MOV      r0,r4
0021da  f7fffffe          BL       tcp_close_shutdown
;;;299    }
0021de  bd10              POP      {r4,pc}
;;;300    
                          ENDP

                  tcp_update_rcv_ann_wnd PROC
;;;580     */
;;;581    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
0021e0  b510              PUSH     {r4,lr}
;;;582    {
0021e2  4601              MOV      r1,r0
;;;583      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
0021e4  8d8b              LDRH     r3,[r1,#0x2c]
0021e6  6a88              LDR      r0,[r1,#0x28]
0021e8  18c2              ADDS     r2,r0,r3
;;;584    
;;;585      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
0021ea  8ec8              LDRH     r0,[r1,#0x36]
0021ec  6b0b              LDR      r3,[r1,#0x30]
0021ee  f5b06f00          CMP      r0,#0x800
0021f2  dd02              BLE      |L1.8698|
0021f4  f44f6000          MOV      r0,#0x800
0021f8  e000              B        |L1.8700|
                  |L1.8698|
0021fa  8ec8              LDRH     r0,[r1,#0x36]
                  |L1.8700|
0021fc  4418              ADD      r0,r0,r3
0021fe  1a10              SUBS     r0,r2,r0
002200  d404              BMI      |L1.8716|
;;;586        /* we can advertise more window */
;;;587        pcb->rcv_ann_wnd = pcb->rcv_wnd;
002202  8d88              LDRH     r0,[r1,#0x2c]
002204  85c8              STRH     r0,[r1,#0x2e]
;;;588        return new_right_edge - pcb->rcv_ann_right_edge;
002206  6b08              LDR      r0,[r1,#0x30]
002208  1a10              SUBS     r0,r2,r0
                  |L1.8714|
;;;589      } else {
;;;590        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;591          /* Can happen due to other end sending out of advertised window,
;;;592           * but within actual available (but not yet advertised) window */
;;;593          pcb->rcv_ann_wnd = 0;
;;;594        } else {
;;;595          /* keep the right edge of window constant */
;;;596          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;597          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;598          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;599        }
;;;600        return 0;
;;;601      }
;;;602    }
00220a  bd10              POP      {r4,pc}
                  |L1.8716|
00220c  6b0b              LDR      r3,[r1,#0x30]         ;590
00220e  6a88              LDR      r0,[r1,#0x28]         ;590
002210  1ac0              SUBS     r0,r0,r3              ;590
002212  2800              CMP      r0,#0                 ;590
002214  dd02              BLE      |L1.8732|
002216  2000              MOVS     r0,#0                 ;593
002218  85c8              STRH     r0,[r1,#0x2e]         ;593
00221a  e006              B        |L1.8746|
                  |L1.8732|
00221c  6a8c              LDR      r4,[r1,#0x28]         ;596
00221e  6b0b              LDR      r3,[r1,#0x30]         ;596
002220  1b18              SUBS     r0,r3,r4              ;596
002222  bf00              NOP                            ;597
002224  bf00              NOP                            ;597
002226  85c8              STRH     r0,[r1,#0x2e]         ;598
002228  bf00              NOP                            ;599
                  |L1.8746|
00222a  2000              MOVS     r0,#0                 ;600
00222c  e7ed              B        |L1.8714|
;;;603    
                          ENDP

                  tcp_recved PROC
;;;612    void
;;;613    tcp_recved(struct tcp_pcb *pcb, u16_t len)
00222e  b570              PUSH     {r4-r6,lr}
;;;614    {
002230  4604              MOV      r4,r0
002232  460e              MOV      r6,r1
;;;615      int wnd_inflation;
;;;616    
;;;617      /* pcb->state LISTEN not allowed here */
;;;618      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
002234  bf00              NOP      
002236  bf00              NOP      
;;;619        pcb->state != LISTEN);
;;;620      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
002238  bf00              NOP      
00223a  bf00              NOP      
;;;621                  len <= 0xffff - pcb->rcv_wnd );
;;;622    
;;;623      pcb->rcv_wnd += len;
00223c  8da0              LDRH     r0,[r4,#0x2c]
00223e  4430              ADD      r0,r0,r6
002240  85a0              STRH     r0,[r4,#0x2c]
;;;624      if (pcb->rcv_wnd > TCP_WND) {
002242  8da0              LDRH     r0,[r4,#0x2c]
002244  f5b05f80          CMP      r0,#0x1000
002248  dd02              BLE      |L1.8784|
;;;625        pcb->rcv_wnd = TCP_WND;
00224a  f44f5080          MOV      r0,#0x1000
00224e  85a0              STRH     r0,[r4,#0x2c]
                  |L1.8784|
;;;626      }
;;;627    
;;;628      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
002250  4620              MOV      r0,r4
002252  f7fffffe          BL       tcp_update_rcv_ann_wnd
002256  4605              MOV      r5,r0
;;;629    
;;;630      /* If the change in the right edge of window is significant (default
;;;631       * watermark is TCP_WND/4), then send an explicit update now.
;;;632       * Otherwise wait for a packet to be sent in the normal course of
;;;633       * events (or more window to be available later) */
;;;634      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
002258  f5b56f80          CMP      r5,#0x400
00225c  db08              BLT      |L1.8816|
;;;635        tcp_ack_now(pcb);
00225e  bf00              NOP      
002260  7fa0              LDRB     r0,[r4,#0x1e]
002262  f0400002          ORR      r0,r0,#2
002266  77a0              STRB     r0,[r4,#0x1e]
002268  bf00              NOP      
;;;636        tcp_output(pcb);
00226a  4620              MOV      r0,r4
00226c  f7fffffe          BL       tcp_output
                  |L1.8816|
;;;637      }
;;;638    
;;;639      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
002270  bf00              NOP      
002272  bf00              NOP      
;;;640             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;641    }
002274  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP

                  tcp_recv_null PROC
;;;1198   err_t
;;;1199   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
002276  e92d41f0          PUSH     {r4-r8,lr}
;;;1200   {
00227a  4607              MOV      r7,r0
00227c  460d              MOV      r5,r1
00227e  4614              MOV      r4,r2
002280  461e              MOV      r6,r3
;;;1201     LWIP_UNUSED_ARG(arg);
;;;1202     if (p != NULL) {
002282  b1bc              CBZ      r4,|L1.8884|
;;;1203       tcp_recved(pcb, p->tot_len);
002284  8921              LDRH     r1,[r4,#8]
002286  4628              MOV      r0,r5
002288  f7fffffe          BL       tcp_recved
;;;1204       pbuf_free(p);
00228c  4620              MOV      r0,r4
00228e  f7fffffe          BL       pbuf_free
002292  e015              B        |L1.8896|
                  |L1.8852|
                          DCD      tcp_timer_ctr
                  |L1.8856|
                          DCD      tcp_persist_backoff
                  |L1.8860|
                          DCD      tcp_backoff
                  |L1.8864|
                          DCD      tcp_ticks
                  |L1.8868|
                          DCD      0x000a4cb8
                  |L1.8872|
                          DCD      tcp_active_pcbs
                  |L1.8876|
                          DCD      tcp_active_pcbs_changed
                  |L1.8880|
                          DCD      tcp_tw_pcbs
                  |L1.8884|
;;;1205     } else if (err == ERR_OK) {
0022b4  b926              CBNZ     r6,|L1.8896|
;;;1206       return tcp_close(pcb);
0022b6  4628              MOV      r0,r5
0022b8  f7fffffe          BL       tcp_close
                  |L1.8892|
;;;1207     }
;;;1208     return ERR_OK;
;;;1209   }
0022bc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.8896|
0022c0  2000              MOVS     r0,#0                 ;1208
0022c2  e7fb              B        |L1.8892|
;;;1210   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_process_refused_data PROC
;;;1086   err_t
;;;1087   tcp_process_refused_data(struct tcp_pcb *pcb)
0022c4  e92d41f0          PUSH     {r4-r8,lr}
;;;1088   {
0022c8  4604              MOV      r4,r0
;;;1089     err_t err;
;;;1090     u8_t refused_flags = pcb->refused_data->flags;
0022ca  6fa0              LDR      r0,[r4,#0x78]
0022cc  7b47              LDRB     r7,[r0,#0xd]
;;;1091     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1092        closes the pcb */
;;;1093     struct pbuf *refused_data = pcb->refused_data;
0022ce  6fa6              LDR      r6,[r4,#0x78]
;;;1094     pcb->refused_data = NULL;
0022d0  2000              MOVS     r0,#0
0022d2  67a0              STR      r0,[r4,#0x78]
;;;1095     /* Notify again application with data previously received. */
;;;1096     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
0022d4  bf00              NOP      
0022d6  bf00              NOP      
;;;1097     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
0022d8  bf00              NOP      
0022da  f8d40080          LDR      r0,[r4,#0x80]
0022de  b140              CBZ      r0,|L1.8946|
0022e0  2300              MOVS     r3,#0
0022e2  4632              MOV      r2,r6
0022e4  4621              MOV      r1,r4
0022e6  f8d4c080          LDR      r12,[r4,#0x80]
0022ea  6920              LDR      r0,[r4,#0x10]
0022ec  47e0              BLX      r12
0022ee  4605              MOV      r5,r0
0022f0  e006              B        |L1.8960|
                  |L1.8946|
0022f2  2300              MOVS     r3,#0
0022f4  4632              MOV      r2,r6
0022f6  4621              MOV      r1,r4
0022f8  4618              MOV      r0,r3
0022fa  f7fffffe          BL       tcp_recv_null
0022fe  4605              MOV      r5,r0
                  |L1.8960|
002300  bf00              NOP      
;;;1098     if (err == ERR_OK) {
002302  b9fd              CBNZ     r5,|L1.9028|
;;;1099       /* did refused_data include a FIN? */
;;;1100       if (refused_flags & PBUF_FLAG_TCP_FIN) {
002304  f0170f20          TST      r7,#0x20
002308  d025              BEQ      |L1.9046|
;;;1101         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1102            for the FIN's seqno */
;;;1103         if (pcb->rcv_wnd != TCP_WND) {
00230a  8da0              LDRH     r0,[r4,#0x2c]
00230c  f5b05f80          CMP      r0,#0x1000
002310  d002              BEQ      |L1.8984|
;;;1104           pcb->rcv_wnd++;
002312  8da0              LDRH     r0,[r4,#0x2c]
002314  1c40              ADDS     r0,r0,#1
002316  85a0              STRH     r0,[r4,#0x2c]
                  |L1.8984|
;;;1105         }
;;;1106         TCP_EVENT_CLOSED(pcb, err);
002318  bf00              NOP      
00231a  f8d40080          LDR      r0,[r4,#0x80]
00231e  b140              CBZ      r0,|L1.9010|
002320  2300              MOVS     r3,#0
002322  461a              MOV      r2,r3
002324  4621              MOV      r1,r4
002326  f8d4c080          LDR      r12,[r4,#0x80]
00232a  6920              LDR      r0,[r4,#0x10]
00232c  47e0              BLX      r12
00232e  4605              MOV      r5,r0
002330  e000              B        |L1.9012|
                  |L1.9010|
002332  2500              MOVS     r5,#0
                  |L1.9012|
002334  bf00              NOP      
;;;1107         if (err == ERR_ABRT) {
002336  f115000a          ADDS     r0,r5,#0xa
00233a  d10c              BNE      |L1.9046|
;;;1108           return ERR_ABRT;
00233c  f06f0009          MVN      r0,#9
                  |L1.9024|
;;;1109         }
;;;1110       }
;;;1111     } else if (err == ERR_ABRT) {
;;;1112       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1113       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1114          segment contains data). */
;;;1115       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1116       return ERR_ABRT;
;;;1117     } else {
;;;1118       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1119       pcb->refused_data = refused_data;
;;;1120     }
;;;1121     return ERR_OK;
;;;1122   }
002340  e8bd81f0          POP      {r4-r8,pc}
                  |L1.9028|
002344  f115000a          ADDS     r0,r5,#0xa            ;1111
002348  d104              BNE      |L1.9044|
00234a  bf00              NOP                            ;1115
00234c  bf00              NOP                            ;1115
00234e  f06f0009          MVN      r0,#9                 ;1116
002352  e7f5              B        |L1.9024|
                  |L1.9044|
002354  67a6              STR      r6,[r4,#0x78]         ;1119
                  |L1.9046|
002356  2000              MOVS     r0,#0                 ;1121
002358  e7f2              B        |L1.9024|
;;;1123   
                          ENDP

                  tcp_fasttmr PROC
;;;1047   void
;;;1048   tcp_fasttmr(void)
00235a  b570              PUSH     {r4-r6,lr}
;;;1049   {
;;;1050     struct tcp_pcb *pcb;
;;;1051   
;;;1052     ++tcp_timer_ctr;
00235c  48fd              LDR      r0,|L1.10068|
00235e  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
002360  1c40              ADDS     r0,r0,#1
002362  49fc              LDR      r1,|L1.10068|
002364  7008              STRB     r0,[r1,#0]
;;;1053   
;;;1054   tcp_fasttmr_start:
002366  bf00              NOP      
                  |L1.9064|
;;;1055     pcb = tcp_active_pcbs;
002368  48fb              LDR      r0,|L1.10072|
00236a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;1056   
;;;1057     while(pcb != NULL) {
00236c  e02b              B        |L1.9158|
                  |L1.9070|
;;;1058       if (pcb->last_timer != tcp_timer_ctr) {
00236e  f8940021          LDRB     r0,[r4,#0x21]
002372  49f8              LDR      r1,|L1.10068|
002374  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
002376  4288              CMP      r0,r1
002378  d025              BEQ      |L1.9158|
;;;1059         struct tcp_pcb *next;
;;;1060         pcb->last_timer = tcp_timer_ctr;
00237a  48f6              LDR      r0,|L1.10068|
00237c  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
00237e  f8840021          STRB     r0,[r4,#0x21]
;;;1061         /* send delayed ACKs */
;;;1062         if (pcb->flags & TF_ACK_DELAY) {
002382  7fa0              LDRB     r0,[r4,#0x1e]
002384  f0100f01          TST      r0,#1
002388  d00e              BEQ      |L1.9128|
;;;1063           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
00238a  bf00              NOP      
00238c  bf00              NOP      
;;;1064           tcp_ack_now(pcb);
00238e  bf00              NOP      
002390  7fa0              LDRB     r0,[r4,#0x1e]
002392  f0400002          ORR      r0,r0,#2
002396  77a0              STRB     r0,[r4,#0x1e]
002398  bf00              NOP      
;;;1065           tcp_output(pcb);
00239a  4620              MOV      r0,r4
00239c  f7fffffe          BL       tcp_output
;;;1066           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
0023a0  7fa0              LDRB     r0,[r4,#0x1e]
0023a2  f0200003          BIC      r0,r0,#3
0023a6  77a0              STRB     r0,[r4,#0x1e]
                  |L1.9128|
;;;1067         }
;;;1068   
;;;1069         next = pcb->next;
0023a8  68e5              LDR      r5,[r4,#0xc]
;;;1070   
;;;1071         /* If there is data which was previously "refused" by upper layer */
;;;1072         if (pcb->refused_data != NULL) {
0023aa  6fa0              LDR      r0,[r4,#0x78]
0023ac  b148              CBZ      r0,|L1.9154|
;;;1073           tcp_active_pcbs_changed = 0;
0023ae  2000              MOVS     r0,#0
0023b0  49ea              LDR      r1,|L1.10076|
0023b2  7008              STRB     r0,[r1,#0]
;;;1074           tcp_process_refused_data(pcb);
0023b4  4620              MOV      r0,r4
0023b6  f7fffffe          BL       tcp_process_refused_data
;;;1075           if (tcp_active_pcbs_changed) {
0023ba  48e8              LDR      r0,|L1.10076|
0023bc  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
0023be  b100              CBZ      r0,|L1.9154|
;;;1076             /* application callback has changed the pcb list: restart the loop */
;;;1077             goto tcp_fasttmr_start;
0023c0  e7d2              B        |L1.9064|
                  |L1.9154|
;;;1078           }
;;;1079         }
;;;1080         pcb = next;
0023c2  462c              MOV      r4,r5
;;;1081       }
0023c4  bf00              NOP      
                  |L1.9158|
0023c6  2c00              CMP      r4,#0                 ;1057
0023c8  d1d1              BNE      |L1.9070|
;;;1082     }
;;;1083   }
0023ca  bd70              POP      {r4-r6,pc}
;;;1084   
                          ENDP

                  tcp_tmr PROC
;;;141    void
;;;142    tcp_tmr(void)
0023cc  b510              PUSH     {r4,lr}
;;;143    {
;;;144      /* Call tcp_fasttmr() every 250 ms */
;;;145      tcp_fasttmr();
0023ce  f7fffffe          BL       tcp_fasttmr
;;;146    
;;;147      if (++tcp_timer & 1) {
0023d2  48e3              LDR      r0,|L1.10080|
0023d4  7800              LDRB     r0,[r0,#0]  ; tcp_timer
0023d6  1c40              ADDS     r0,r0,#1
0023d8  b2c0              UXTB     r0,r0
0023da  49e1              LDR      r1,|L1.10080|
0023dc  7008              STRB     r0,[r1,#0]
0023de  f0100f01          TST      r0,#1
0023e2  d001              BEQ      |L1.9192|
;;;148        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;149           tcp_tmr() is called. */
;;;150        tcp_slowtmr();
0023e4  f7fffffe          BL       tcp_slowtmr
                  |L1.9192|
;;;151      }
;;;152    }
0023e8  bd10              POP      {r4,pc}
;;;153    
                          ENDP

                  tcpip_tcp_timer PROC
;;;78     static void
;;;79     tcpip_tcp_timer(void *arg)
0023ea  b510              PUSH     {r4,lr}
;;;80     {
0023ec  4604              MOV      r4,r0
;;;81       LWIP_UNUSED_ARG(arg);
;;;82     
;;;83       /* call TCP timer handler */
;;;84       tcp_tmr();
0023ee  f7fffffe          BL       tcp_tmr
;;;85       /* timer still needed? */
;;;86       if (tcp_active_pcbs || tcp_tw_pcbs) {
0023f2  48d9              LDR      r0,|L1.10072|
0023f4  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0023f6  b910              CBNZ     r0,|L1.9214|
0023f8  48da              LDR      r0,|L1.10084|
0023fa  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0023fc  b128              CBZ      r0,|L1.9226|
                  |L1.9214|
;;;87         /* restart timer */
;;;88         sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
0023fe  2200              MOVS     r2,#0
002400  49d9              LDR      r1,|L1.10088|
002402  20fa              MOVS     r0,#0xfa
002404  f7fffffe          BL       sys_timeout
002408  e002              B        |L1.9232|
                  |L1.9226|
;;;89       } else {
;;;90         /* disable timer */
;;;91         tcpip_tcp_timer_active = 0;
00240a  2000              MOVS     r0,#0
00240c  49d7              LDR      r1,|L1.10092|
00240e  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
                  |L1.9232|
;;;92       }
;;;93     }
002410  bd10              POP      {r4,pc}
;;;94     
                          ENDP

                  tcp_timer_needed PROC
;;;100    void
;;;101    tcp_timer_needed(void)
002412  b510              PUSH     {r4,lr}
;;;102    {
;;;103      /* timer is off but needed again? */
;;;104      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
002414  48d5              LDR      r0,|L1.10092|
002416  6800              LDR      r0,[r0,#0]  ; tcpip_tcp_timer_active
002418  b968              CBNZ     r0,|L1.9270|
00241a  48cf              LDR      r0,|L1.10072|
00241c  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00241e  b910              CBNZ     r0,|L1.9254|
002420  48d0              LDR      r0,|L1.10084|
002422  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
002424  b138              CBZ      r0,|L1.9270|
                  |L1.9254|
;;;105        /* enable and start timer */
;;;106        tcpip_tcp_timer_active = 1;
002426  2001              MOVS     r0,#1
002428  49d0              LDR      r1,|L1.10092|
00242a  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
;;;107        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
00242c  2200              MOVS     r2,#0
00242e  49ce              LDR      r1,|L1.10088|
002430  20fa              MOVS     r0,#0xfa
002432  f7fffffe          BL       sys_timeout
                  |L1.9270|
;;;108      }
;;;109    }
002436  bd10              POP      {r4,pc}
;;;110    #endif /* LWIP_TCP */
                          ENDP

                  tcp_close_shutdown PROC
;;;170    static err_t
;;;171    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
002438  b57c              PUSH     {r2-r6,lr}
;;;172    {
00243a  4604              MOV      r4,r0
00243c  460e              MOV      r6,r1
;;;173      err_t err;
;;;174    
;;;175      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
00243e  2e00              CMP      r6,#0
002440  d05a              BEQ      |L1.9464|
002442  7e20              LDRB     r0,[r4,#0x18]
002444  2804              CMP      r0,#4
002446  d002              BEQ      |L1.9294|
002448  7e20              LDRB     r0,[r4,#0x18]
00244a  2807              CMP      r0,#7
00244c  d154              BNE      |L1.9464|
                  |L1.9294|
;;;176        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
00244e  6fa0              LDR      r0,[r4,#0x78]
002450  b918              CBNZ     r0,|L1.9306|
002452  8da0              LDRH     r0,[r4,#0x2c]
002454  f5b05f80          CMP      r0,#0x1000
002458  d04e              BEQ      |L1.9464|
                  |L1.9306|
;;;177          /* Not all data received by application, send RST to tell the remote
;;;178             side about this. */
;;;179          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
00245a  bf00              NOP      
00245c  bf00              NOP      
;;;180    
;;;181          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;182             that might not be expected when calling tcp_close */
;;;183          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
00245e  8ba0              LDRH     r0,[r4,#0x1c]
002460  8b61              LDRH     r1,[r4,#0x1a]
002462  e9cd1000          STRD     r1,r0,[sp,#0]
002466  1d23              ADDS     r3,r4,#4
002468  4622              MOV      r2,r4
00246a  6aa1              LDR      r1,[r4,#0x28]
00246c  6d20              LDR      r0,[r4,#0x50]
00246e  f7fffffe          BL       tcp_rst
;;;184            pcb->local_port, pcb->remote_port);
;;;185    
;;;186          tcp_pcb_purge(pcb);
002472  4620              MOV      r0,r4
002474  f7fffffe          BL       tcp_pcb_purge
;;;187          TCP_RMV_ACTIVE(pcb);
002478  bf00              NOP      
00247a  bf00              NOP      
00247c  48b6              LDR      r0,|L1.10072|
00247e  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
002480  42a0              CMP      r0,r4
002482  d105              BNE      |L1.9360|
002484  48b4              LDR      r0,|L1.10072|
002486  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
002488  68c0              LDR      r0,[r0,#0xc]
00248a  49b3              LDR      r1,|L1.10072|
00248c  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
00248e  e018              B        |L1.9410|
                  |L1.9360|
002490  48b1              LDR      r0,|L1.10072|
002492  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
002494  49b6              LDR      r1,|L1.10096|
002496  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
002498  e00e              B        |L1.9400|
                  |L1.9370|
00249a  48b5              LDR      r0,|L1.10096|
00249c  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00249e  68c0              LDR      r0,[r0,#0xc]
0024a0  42a0              CMP      r0,r4
0024a2  d104              BNE      |L1.9390|
0024a4  49b2              LDR      r1,|L1.10096|
0024a6  68e0              LDR      r0,[r4,#0xc]
0024a8  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
0024aa  60c8              STR      r0,[r1,#0xc]
0024ac  e008              B        |L1.9408|
                  |L1.9390|
0024ae  48b0              LDR      r0,|L1.10096|
0024b0  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
0024b2  68c0              LDR      r0,[r0,#0xc]
0024b4  49ae              LDR      r1,|L1.10096|
0024b6  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L1.9400|
0024b8  48ad              LDR      r0,|L1.10096|
0024ba  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
0024bc  2800              CMP      r0,#0
0024be  d1ec              BNE      |L1.9370|
                  |L1.9408|
0024c0  bf00              NOP      
                  |L1.9410|
0024c2  2000              MOVS     r0,#0
0024c4  60e0              STR      r0,[r4,#0xc]
0024c6  bf00              NOP      
0024c8  2001              MOVS     r0,#1
0024ca  49a4              LDR      r1,|L1.10076|
0024cc  7008              STRB     r0,[r1,#0]
0024ce  bf00              NOP      
;;;188          if (pcb->state == ESTABLISHED) {
0024d0  7e20              LDRB     r0,[r4,#0x18]
0024d2  2804              CMP      r0,#4
0024d4  d10a              BNE      |L1.9452|
;;;189            /* move to TIME_WAIT since we close actively */
;;;190            pcb->state = TIME_WAIT;
0024d6  200a              MOVS     r0,#0xa
0024d8  7620              STRB     r0,[r4,#0x18]
;;;191            TCP_REG(&tcp_tw_pcbs, pcb);
0024da  bf00              NOP      
0024dc  48a1              LDR      r0,|L1.10084|
0024de  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0024e0  60e0              STR      r0,[r4,#0xc]
0024e2  48a0              LDR      r0,|L1.10084|
0024e4  6004              STR      r4,[r0,#0]  ; tcp_tw_pcbs
0024e6  f7fffffe          BL       tcp_timer_needed
0024ea  e003              B        |L1.9460|
                  |L1.9452|
;;;192          } else {
;;;193            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;194            memp_free(MEMP_TCP_PCB, pcb);
0024ec  4621              MOV      r1,r4
0024ee  2002              MOVS     r0,#2
0024f0  f7fffffe          BL       memp_free
                  |L1.9460|
;;;195          }
;;;196          return ERR_OK;
0024f4  2000              MOVS     r0,#0
                  |L1.9462|
;;;197        }
;;;198      }
;;;199    
;;;200      switch (pcb->state) {
;;;201      case CLOSED:
;;;202        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;203         * however, it is in this state once allocated and as yet unused
;;;204         * and the user needs some way to free it should the need arise.
;;;205         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;206         * or for a pcb that has been used and then entered the CLOSED state 
;;;207         * is erroneous, but this should never happen as the pcb has in those cases
;;;208         * been freed, and so any remaining handles are bogus. */
;;;209        err = ERR_OK;
;;;210        if (pcb->local_port != 0) {
;;;211          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;212        }
;;;213        memp_free(MEMP_TCP_PCB, pcb);
;;;214        pcb = NULL;
;;;215        break;
;;;216      case LISTEN:
;;;217        err = ERR_OK;
;;;218        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;219        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;220        pcb = NULL;
;;;221        break;
;;;222      case SYN_SENT:
;;;223        err = ERR_OK;
;;;224        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;225        memp_free(MEMP_TCP_PCB, pcb);
;;;226        pcb = NULL;
;;;227        snmp_inc_tcpattemptfails();
;;;228        break;
;;;229      case SYN_RCVD:
;;;230        err = tcp_send_fin(pcb);
;;;231        if (err == ERR_OK) {
;;;232          snmp_inc_tcpattemptfails();
;;;233          pcb->state = FIN_WAIT_1;
;;;234        }
;;;235        break;
;;;236      case ESTABLISHED:
;;;237        err = tcp_send_fin(pcb);
;;;238        if (err == ERR_OK) {
;;;239          snmp_inc_tcpestabresets();
;;;240          pcb->state = FIN_WAIT_1;
;;;241        }
;;;242        break;
;;;243      case CLOSE_WAIT:
;;;244        err = tcp_send_fin(pcb);
;;;245        if (err == ERR_OK) {
;;;246          snmp_inc_tcpestabresets();
;;;247          pcb->state = LAST_ACK;
;;;248        }
;;;249        break;
;;;250      default:
;;;251        /* Has already been closed, do nothing. */
;;;252        err = ERR_OK;
;;;253        pcb = NULL;
;;;254        break;
;;;255      }
;;;256    
;;;257      if (pcb != NULL && err == ERR_OK) {
;;;258        /* To ensure all data has been sent when tcp_close returns, we have
;;;259           to make sure tcp_output doesn't fail.
;;;260           Since we don't really have to ensure all data has been sent when tcp_close
;;;261           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;262           for the return value of tcp_output for now. */
;;;263        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;264           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;265           This can only be valid for sequential APIs, not for the raw API. */
;;;266        tcp_output(pcb);
;;;267      }
;;;268      return err;
;;;269    }
0024f6  bd7c              POP      {r2-r6,pc}
                  |L1.9464|
0024f8  7e20              LDRB     r0,[r4,#0x18]         ;200
0024fa  2808              CMP      r0,#8                 ;200
0024fc  d268              BCS      |L1.9680|
0024fe  e8dff000          TBB      [pc,r0]               ;200
002502  0434              DCB      0x04,0x34
002504  3f4f5767          DCB      0x3f,0x4f,0x57,0x67
002508  675f              DCB      0x67,0x5f
00250a  2500              MOVS     r5,#0                 ;209
00250c  8b60              LDRH     r0,[r4,#0x1a]         ;210
00250e  b330              CBZ      r0,|L1.9566|
002510  bf00              NOP                            ;211
002512  4898              LDR      r0,|L1.10100|
002514  6800              LDR      r0,[r0,#0]            ;211  ; tcp_bound_pcbs
002516  42a0              CMP      r0,r4                 ;211
002518  d105              BNE      |L1.9510|
00251a  4896              LDR      r0,|L1.10100|
00251c  6800              LDR      r0,[r0,#0]            ;211  ; tcp_bound_pcbs
00251e  68c0              LDR      r0,[r0,#0xc]          ;211
002520  4994              LDR      r1,|L1.10100|
002522  6008              STR      r0,[r1,#0]            ;211  ; tcp_bound_pcbs
002524  e018              B        |L1.9560|
                  |L1.9510|
002526  4893              LDR      r0,|L1.10100|
002528  6800              LDR      r0,[r0,#0]            ;211  ; tcp_bound_pcbs
00252a  4991              LDR      r1,|L1.10096|
00252c  6008              STR      r0,[r1,#0]            ;211  ; tcp_tmp_pcb
00252e  e00e              B        |L1.9550|
                  |L1.9520|
002530  488f              LDR      r0,|L1.10096|
002532  6800              LDR      r0,[r0,#0]            ;211  ; tcp_tmp_pcb
002534  68c0              LDR      r0,[r0,#0xc]          ;211
002536  42a0              CMP      r0,r4                 ;211
002538  d104              BNE      |L1.9540|
00253a  498d              LDR      r1,|L1.10096|
00253c  68e0              LDR      r0,[r4,#0xc]          ;211
00253e  6809              LDR      r1,[r1,#0]            ;211  ; tcp_tmp_pcb
002540  60c8              STR      r0,[r1,#0xc]          ;211
002542  e008              B        |L1.9558|
                  |L1.9540|
002544  488a              LDR      r0,|L1.10096|
002546  6800              LDR      r0,[r0,#0]            ;211  ; tcp_tmp_pcb
002548  68c0              LDR      r0,[r0,#0xc]          ;211
00254a  4989              LDR      r1,|L1.10096|
00254c  6008              STR      r0,[r1,#0]            ;211  ; tcp_tmp_pcb
                  |L1.9550|
00254e  4888              LDR      r0,|L1.10096|
002550  6800              LDR      r0,[r0,#0]            ;211  ; tcp_tmp_pcb
002552  2800              CMP      r0,#0                 ;211
002554  d1ec              BNE      |L1.9520|
                  |L1.9558|
002556  bf00              NOP                            ;211
                  |L1.9560|
002558  2000              MOVS     r0,#0                 ;211
00255a  60e0              STR      r0,[r4,#0xc]          ;211
00255c  bf00              NOP                            ;211
                  |L1.9566|
00255e  4621              MOV      r1,r4                 ;213
002560  2002              MOVS     r0,#2                 ;213
002562  f7fffffe          BL       memp_free
002566  2400              MOVS     r4,#0                 ;214
002568  e035              B        |L1.9686|
00256a  2500              MOVS     r5,#0                 ;217
00256c  4621              MOV      r1,r4                 ;218
00256e  4882              LDR      r0,|L1.10104|
002570  f7fffffe          BL       tcp_pcb_remove
002574  4621              MOV      r1,r4                 ;219
002576  2003              MOVS     r0,#3                 ;219
002578  f7fffffe          BL       memp_free
00257c  2400              MOVS     r4,#0                 ;220
00257e  e02a              B        |L1.9686|
002580  2500              MOVS     r5,#0                 ;223
002582  bf00              NOP                            ;224
002584  4621              MOV      r1,r4                 ;224
002586  4874              LDR      r0,|L1.10072|
002588  f7fffffe          BL       tcp_pcb_remove
00258c  2001              MOVS     r0,#1                 ;224
00258e  4973              LDR      r1,|L1.10076|
002590  7008              STRB     r0,[r1,#0]            ;224
002592  bf00              NOP                            ;224
002594  4621              MOV      r1,r4                 ;225
002596  2002              MOVS     r0,#2                 ;225
002598  f7fffffe          BL       memp_free
00259c  2400              MOVS     r4,#0                 ;226
00259e  e01a              B        |L1.9686|
0025a0  4620              MOV      r0,r4                 ;230
0025a2  f7fffffe          BL       tcp_send_fin
0025a6  4605              MOV      r5,r0                 ;230
0025a8  b90d              CBNZ     r5,|L1.9646|
0025aa  2005              MOVS     r0,#5                 ;233
0025ac  7620              STRB     r0,[r4,#0x18]         ;233
                  |L1.9646|
0025ae  e012              B        |L1.9686|
0025b0  4620              MOV      r0,r4                 ;237
0025b2  f7fffffe          BL       tcp_send_fin
0025b6  4605              MOV      r5,r0                 ;237
0025b8  b90d              CBNZ     r5,|L1.9662|
0025ba  2005              MOVS     r0,#5                 ;240
0025bc  7620              STRB     r0,[r4,#0x18]         ;240
                  |L1.9662|
0025be  e00a              B        |L1.9686|
0025c0  4620              MOV      r0,r4                 ;244
0025c2  f7fffffe          BL       tcp_send_fin
0025c6  4605              MOV      r5,r0                 ;244
0025c8  b90d              CBNZ     r5,|L1.9678|
0025ca  2009              MOVS     r0,#9                 ;247
0025cc  7620              STRB     r0,[r4,#0x18]         ;247
                  |L1.9678|
0025ce  e002              B        |L1.9686|
                  |L1.9680|
0025d0  2500              MOVS     r5,#0                 ;252
0025d2  2400              MOVS     r4,#0                 ;253
0025d4  bf00              NOP                            ;254
                  |L1.9686|
0025d6  bf00              NOP                            ;215
0025d8  b11c              CBZ      r4,|L1.9698|
0025da  b915              CBNZ     r5,|L1.9698|
0025dc  4620              MOV      r0,r4                 ;266
0025de  f7fffffe          BL       tcp_output
                  |L1.9698|
0025e2  4628              MOV      r0,r5                 ;268
0025e4  e787              B        |L1.9462|
;;;270    
                          ENDP

                  tcp_shutdown PROC
;;;313    err_t
;;;314    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
0025e6  b570              PUSH     {r4-r6,lr}
;;;315    {
0025e8  4604              MOV      r4,r0
0025ea  460d              MOV      r5,r1
0025ec  4616              MOV      r6,r2
;;;316      if (pcb->state == LISTEN) {
0025ee  7e20              LDRB     r0,[r4,#0x18]
0025f0  2801              CMP      r0,#1
0025f2  d102              BNE      |L1.9722|
;;;317        return ERR_CONN;
0025f4  f06f000c          MVN      r0,#0xc
                  |L1.9720|
;;;318      }
;;;319      if (shut_rx) {
;;;320        /* shut down the receive side: set a flag not to receive any more data... */
;;;321        pcb->flags |= TF_RXCLOSED;
;;;322        if (shut_tx) {
;;;323          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;324          return tcp_close_shutdown(pcb, 1);
;;;325        }
;;;326        /* ... and free buffered data */
;;;327        if (pcb->refused_data != NULL) {
;;;328          pbuf_free(pcb->refused_data);
;;;329          pcb->refused_data = NULL;
;;;330        }
;;;331      }
;;;332      if (shut_tx) {
;;;333        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;334           Only close in these states as the others directly deallocate the PCB */
;;;335        switch (pcb->state) {
;;;336        case SYN_RCVD:
;;;337        case ESTABLISHED:
;;;338        case CLOSE_WAIT:
;;;339          return tcp_close_shutdown(pcb, shut_rx);
;;;340        default:
;;;341          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;342            into CLOSED state, where the PCB is deallocated. */
;;;343          return ERR_CONN;
;;;344        }
;;;345      }
;;;346      return ERR_OK;
;;;347    }
0025f8  bd70              POP      {r4-r6,pc}
                  |L1.9722|
0025fa  b185              CBZ      r5,|L1.9758|
0025fc  7fa0              LDRB     r0,[r4,#0x1e]         ;321
0025fe  f0400010          ORR      r0,r0,#0x10           ;321
002602  77a0              STRB     r0,[r4,#0x1e]         ;321
002604  b126              CBZ      r6,|L1.9744|
002606  2101              MOVS     r1,#1                 ;324
002608  4620              MOV      r0,r4                 ;324
00260a  f7fffffe          BL       tcp_close_shutdown
00260e  e7f3              B        |L1.9720|
                  |L1.9744|
002610  6fa0              LDR      r0,[r4,#0x78]         ;327
002612  b120              CBZ      r0,|L1.9758|
002614  6fa0              LDR      r0,[r4,#0x78]         ;328
002616  f7fffffe          BL       pbuf_free
00261a  2000              MOVS     r0,#0                 ;329
00261c  67a0              STR      r0,[r4,#0x78]         ;329
                  |L1.9758|
00261e  b18e              CBZ      r6,|L1.9796|
002620  7e20              LDRB     r0,[r4,#0x18]         ;335
002622  2803              CMP      r0,#3                 ;335
002624  d004              BEQ      |L1.9776|
002626  2804              CMP      r0,#4                 ;335
002628  d003              BEQ      |L1.9778|
00262a  2807              CMP      r0,#7                 ;335
00262c  d107              BNE      |L1.9790|
00262e  e001              B        |L1.9780|
                  |L1.9776|
002630  bf00              NOP                            ;337
                  |L1.9778|
002632  bf00              NOP                            ;338
                  |L1.9780|
002634  b2e9              UXTB     r1,r5                 ;339
002636  4620              MOV      r0,r4                 ;339
002638  f7fffffe          BL       tcp_close_shutdown
00263c  e7dc              B        |L1.9720|
                  |L1.9790|
00263e  f06f000c          MVN      r0,#0xc               ;343
002642  e7d9              B        |L1.9720|
                  |L1.9796|
002644  2000              MOVS     r0,#0                 ;346
002646  e7d7              B        |L1.9720|
;;;348    
                          ENDP

                  tcp_accept PROC
;;;1437   void
;;;1438   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
002648  6141              STR      r1,[r0,#0x14]
;;;1439   {
;;;1440     /* This function is allowed to be called for both listen pcbs and
;;;1441        connection pcbs. */
;;;1442     pcb->accept = accept;
;;;1443   }
00264a  4770              BX       lr
;;;1444   #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_recv PROC
;;;1393   void
;;;1394   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
00264c  bf00              NOP      
;;;1395   {
;;;1396     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
00264e  bf00              NOP      
;;;1397     pcb->recv = recv;
002650  f8c01080          STR      r1,[r0,#0x80]
;;;1398   }
002654  4770              BX       lr
;;;1399   
                          ENDP

                  do_close_internal PROC
;;;749    static void
;;;750    do_close_internal(struct netconn *conn)
002656  e92d47f0          PUSH     {r4-r10,lr}
;;;751    {
00265a  4604              MOV      r4,r0
;;;752      err_t err;
;;;753      u8_t shut, shut_rx, shut_tx, close;
;;;754    
;;;755      LWIP_ASSERT("invalid conn", (conn != NULL));
00265c  bf00              NOP      
00265e  bf00              NOP      
;;;756      LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
002660  bf00              NOP      
002662  bf00              NOP      
;;;757      LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
002664  bf00              NOP      
002666  bf00              NOP      
;;;758      LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
002668  bf00              NOP      
00266a  bf00              NOP      
;;;759      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
00266c  bf00              NOP      
00266e  bf00              NOP      
;;;760    
;;;761      shut = conn->current_msg->msg.sd.shut;
002670  f8d40134          LDR      r0,[r4,#0x134]
002674  7a06              LDRB     r6,[r0,#8]
;;;762      shut_rx = shut & NETCONN_SHUT_RD;
002676  f0060701          AND      r7,r6,#1
;;;763      shut_tx = shut & NETCONN_SHUT_WR;
00267a  f0060802          AND      r8,r6,#2
;;;764      /* shutting down both ends is the same as closing */
;;;765      close = shut == NETCONN_SHUT_RDWR;
00267e  2e03              CMP      r6,#3
002680  d101              BNE      |L1.9862|
002682  2001              MOVS     r0,#1
002684  e000              B        |L1.9864|
                  |L1.9862|
002686  2000              MOVS     r0,#0
                  |L1.9864|
002688  4681              MOV      r9,r0
;;;766    
;;;767      /* Set back some callback pointers */
;;;768      if (close) {
00268a  f1b90f00          CMP      r9,#0
00268e  d003              BEQ      |L1.9880|
;;;769        tcp_arg(conn->pcb.tcp, NULL);
002690  2100              MOVS     r1,#0
002692  6860              LDR      r0,[r4,#4]
002694  f7fffffe          BL       tcp_arg
                  |L1.9880|
;;;770      }
;;;771      if (conn->pcb.tcp->state == LISTEN) {
002698  6860              LDR      r0,[r4,#4]
00269a  7e00              LDRB     r0,[r0,#0x18]
00269c  2801              CMP      r0,#1
00269e  d104              BNE      |L1.9898|
;;;772        tcp_accept(conn->pcb.tcp, NULL);
0026a0  2100              MOVS     r1,#0
0026a2  6860              LDR      r0,[r4,#4]
0026a4  f7fffffe          BL       tcp_accept
0026a8  e01b              B        |L1.9954|
                  |L1.9898|
;;;773      } else {
;;;774        /* some callbacks have to be reset if tcp_close is not successful */
;;;775        if (shut_rx) {
0026aa  b13f              CBZ      r7,|L1.9916|
;;;776          tcp_recv(conn->pcb.tcp, NULL);
0026ac  2100              MOVS     r1,#0
0026ae  6860              LDR      r0,[r4,#4]
0026b0  f7fffffe          BL       tcp_recv
;;;777          tcp_accept(conn->pcb.tcp, NULL);
0026b4  2100              MOVS     r1,#0
0026b6  6860              LDR      r0,[r4,#4]
0026b8  f7fffffe          BL       tcp_accept
                  |L1.9916|
;;;778        }
;;;779        if (shut_tx) {
0026bc  f1b80f00          CMP      r8,#0
0026c0  d003              BEQ      |L1.9930|
;;;780          tcp_sent(conn->pcb.tcp, NULL);
0026c2  2100              MOVS     r1,#0
0026c4  6860              LDR      r0,[r4,#4]
0026c6  f7fffffe          BL       tcp_sent
                  |L1.9930|
;;;781        }
;;;782        if (close) {
0026ca  f1b90f00          CMP      r9,#0
0026ce  d008              BEQ      |L1.9954|
;;;783          tcp_poll(conn->pcb.tcp, NULL, 4);
0026d0  2204              MOVS     r2,#4
0026d2  2100              MOVS     r1,#0
0026d4  6860              LDR      r0,[r4,#4]
0026d6  f7fffffe          BL       tcp_poll
;;;784          tcp_err(conn->pcb.tcp, NULL);
0026da  2100              MOVS     r1,#0
0026dc  6860              LDR      r0,[r4,#4]
0026de  f7fffffe          BL       tcp_err
                  |L1.9954|
;;;785        }
;;;786      }
;;;787      /* Try to close the connection */
;;;788      if (close) {
0026e2  f1b90f00          CMP      r9,#0
0026e6  d004              BEQ      |L1.9970|
;;;789        err = tcp_close(conn->pcb.tcp);
0026e8  6860              LDR      r0,[r4,#4]
0026ea  f7fffffe          BL       tcp_close
0026ee  4605              MOV      r5,r0
0026f0  e005              B        |L1.9982|
                  |L1.9970|
;;;790      } else {
;;;791        err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
0026f2  4642              MOV      r2,r8
0026f4  4639              MOV      r1,r7
0026f6  6860              LDR      r0,[r4,#4]
0026f8  f7fffffe          BL       tcp_shutdown
0026fc  4605              MOV      r5,r0
                  |L1.9982|
;;;792      }
;;;793      if (err == ERR_OK) {
0026fe  bbed              CBNZ     r5,|L1.10108|
;;;794        /* Closing succeeded */
;;;795        conn->current_msg->err = ERR_OK;
002700  2000              MOVS     r0,#0
002702  f8d41134          LDR      r1,[r4,#0x134]
002706  7108              STRB     r0,[r1,#4]
;;;796        conn->current_msg = NULL;
002708  f8c40134          STR      r0,[r4,#0x134]
;;;797        conn->state = NETCONN_NONE;
00270c  7060              STRB     r0,[r4,#1]
;;;798        if (close) {
00270e  f1b90f00          CMP      r9,#0
002712  d009              BEQ      |L1.10024|
;;;799          /* Set back some callback pointers as conn is going away */
;;;800          conn->pcb.tcp = NULL;
002714  6060              STR      r0,[r4,#4]
;;;801          /* Trigger select() in socket layer. Make sure everybody notices activity
;;;802           on the connection, error first! */
;;;803          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
002716  f8d40138          LDR      r0,[r4,#0x138]
00271a  b128              CBZ      r0,|L1.10024|
00271c  2200              MOVS     r2,#0
00271e  2104              MOVS     r1,#4
002720  4620              MOV      r0,r4
002722  f8d43138          LDR      r3,[r4,#0x138]
002726  4798              BLX      r3
                  |L1.10024|
;;;804        }
;;;805        if (shut_rx) {
002728  b147              CBZ      r7,|L1.10044|
;;;806          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
00272a  f8d40138          LDR      r0,[r4,#0x138]
00272e  b128              CBZ      r0,|L1.10044|
002730  2200              MOVS     r2,#0
002732  4611              MOV      r1,r2
002734  4620              MOV      r0,r4
002736  f8d43138          LDR      r3,[r4,#0x138]
00273a  4798              BLX      r3
                  |L1.10044|
;;;807        }
;;;808        if (shut_tx) {
00273c  f1b80f00          CMP      r8,#0
002740  d01e              BEQ      |L1.10112|
;;;809          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
002742  f8d40138          LDR      r0,[r4,#0x138]
002746  b1d8              CBZ      r0,|L1.10112|
002748  2200              MOVS     r2,#0
00274a  2102              MOVS     r1,#2
00274c  4620              MOV      r0,r4
00274e  f8d43138          LDR      r3,[r4,#0x138]
002752  e014              B        |L1.10110|
                  |L1.10068|
                          DCD      tcp_timer_ctr
                  |L1.10072|
                          DCD      tcp_active_pcbs
                  |L1.10076|
                          DCD      tcp_active_pcbs_changed
                  |L1.10080|
                          DCD      tcp_timer
                  |L1.10084|
                          DCD      tcp_tw_pcbs
                  |L1.10088|
                          DCD      tcpip_tcp_timer
                  |L1.10092|
                          DCD      tcpip_tcp_timer_active
                  |L1.10096|
                          DCD      tcp_tmp_pcb
                  |L1.10100|
                          DCD      tcp_bound_pcbs
                  |L1.10104|
                          DCD      tcp_listen_pcbs
                  |L1.10108|
00277c  e005              B        |L1.10122|
                  |L1.10110|
00277e  4798              BLX      r3
                  |L1.10112|
;;;810        }
;;;811        /* wake up the application task */
;;;812        sys_sem_signal(&conn->op_completed);
002780  f104000c          ADD      r0,r4,#0xc
002784  f7fffffe          BL       sys_sem_signal
002788  e012              B        |L1.10160|
                  |L1.10122|
;;;813      } else {
;;;814        /* Closing failed, restore some of the callbacks */
;;;815        /* Closing of listen pcb will never fail! */
;;;816        LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
00278a  bf00              NOP      
00278c  bf00              NOP      
;;;817        tcp_sent(conn->pcb.tcp, sent_tcp);
00278e  49f7              LDR      r1,|L1.11116|
002790  6860              LDR      r0,[r4,#4]
002792  f7fffffe          BL       tcp_sent
;;;818        tcp_poll(conn->pcb.tcp, poll_tcp, 4);
002796  2204              MOVS     r2,#4
002798  49f5              LDR      r1,|L1.11120|
00279a  6860              LDR      r0,[r4,#4]
00279c  f7fffffe          BL       tcp_poll
;;;819        tcp_err(conn->pcb.tcp, err_tcp);
0027a0  49f4              LDR      r1,|L1.11124|
0027a2  6860              LDR      r0,[r4,#4]
0027a4  f7fffffe          BL       tcp_err
;;;820        tcp_arg(conn->pcb.tcp, conn);
0027a8  4621              MOV      r1,r4
0027aa  6860              LDR      r0,[r4,#4]
0027ac  f7fffffe          BL       tcp_arg
                  |L1.10160|
;;;821        /* don't restore recv callback: we don't want to receive any more data */
;;;822      }
;;;823      /* If closing didn't succeed, we get called again either
;;;824         from poll_tcp or from sent_tcp */
;;;825    }
0027b0  e8bd87f0          POP      {r4-r10,pc}
;;;826    #endif /* LWIP_TCP */
                          ENDP

                  poll_tcp PROC
;;;277    static err_t
;;;278    poll_tcp(void *arg, struct tcp_pcb *pcb)
0027b4  b570              PUSH     {r4-r6,lr}
;;;279    {
0027b6  4605              MOV      r5,r0
0027b8  460e              MOV      r6,r1
;;;280      struct netconn *conn = (struct netconn *)arg;
0027ba  462c              MOV      r4,r5
;;;281    
;;;282      LWIP_UNUSED_ARG(pcb);
;;;283      LWIP_ASSERT("conn != NULL", (conn != NULL));
0027bc  bf00              NOP      
0027be  bf00              NOP      
;;;284    
;;;285      if (conn->state == NETCONN_WRITE) {
0027c0  7860              LDRB     r0,[r4,#1]
0027c2  2801              CMP      r0,#1
0027c4  d103              BNE      |L1.10190|
;;;286        do_writemore(conn);
0027c6  4620              MOV      r0,r4
0027c8  f7fffffe          BL       do_writemore
0027cc  e005              B        |L1.10202|
                  |L1.10190|
;;;287      } else if (conn->state == NETCONN_CLOSE) {
0027ce  7860              LDRB     r0,[r4,#1]
0027d0  2804              CMP      r0,#4
0027d2  d102              BNE      |L1.10202|
;;;288        do_close_internal(conn);
0027d4  4620              MOV      r0,r4
0027d6  f7fffffe          BL       do_close_internal
                  |L1.10202|
;;;289      }
;;;290      /* @todo: implement connect timeout here? */
;;;291    
;;;292      /* Did a nonblocking write fail before? Then check available write-space. */
;;;293      if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
0027da  f894012c          LDRB     r0,[r4,#0x12c]
0027de  f0100f10          TST      r0,#0x10
0027e2  d01c              BEQ      |L1.10270|
;;;294        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;295           let select mark this pcb as writable again. */
;;;296        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
0027e4  6860              LDR      r0,[r4,#4]
0027e6  b1d0              CBZ      r0,|L1.10270|
0027e8  6860              LDR      r0,[r4,#4]
0027ea  f8b00066          LDRH     r0,[r0,#0x66]
0027ee  f2417170          MOV      r1,#0x1770
0027f2  4288              CMP      r0,r1
0027f4  dd13              BLE      |L1.10270|
;;;297          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
0027f6  6860              LDR      r0,[r4,#4]
0027f8  f8b00068          LDRH     r0,[r0,#0x68]
0027fc  2810              CMP      r0,#0x10
0027fe  da0e              BGE      |L1.10270|
;;;298          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
002800  f894012c          LDRB     r0,[r4,#0x12c]
002804  f0200010          BIC      r0,r0,#0x10
002808  f884012c          STRB     r0,[r4,#0x12c]
;;;299          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
00280c  f8d40138          LDR      r0,[r4,#0x138]
002810  b128              CBZ      r0,|L1.10270|
002812  2200              MOVS     r2,#0
002814  2102              MOVS     r1,#2
002816  4620              MOV      r0,r4
002818  f8d43138          LDR      r3,[r4,#0x138]
00281c  4798              BLX      r3
                  |L1.10270|
;;;300        }
;;;301      }
;;;302    
;;;303      return ERR_OK;
00281e  2000              MOVS     r0,#0
;;;304    }
002820  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP

                  recv_tcp PROC
;;;216    static err_t
;;;217    recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
002822  e92d47f0          PUSH     {r4-r10,lr}
;;;218    {
002826  4607              MOV      r7,r0
002828  4688              MOV      r8,r1
00282a  4615              MOV      r5,r2
00282c  4699              MOV      r9,r3
;;;219      struct netconn *conn;
;;;220      u16_t len;
;;;221    
;;;222      LWIP_UNUSED_ARG(pcb);
;;;223      LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
00282e  bf00              NOP      
002830  bf00              NOP      
;;;224      LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
002832  bf00              NOP      
002834  bf00              NOP      
;;;225      conn = (struct netconn *)arg;
002836  463c              MOV      r4,r7
;;;226      LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
002838  bf00              NOP      
00283a  bf00              NOP      
;;;227    
;;;228      if (conn == NULL) {
00283c  b91c              CBNZ     r4,|L1.10310|
;;;229        return ERR_VAL;
00283e  f06f0005          MVN      r0,#5
                  |L1.10306|
;;;230      }
;;;231      if (!sys_mbox_valid(&conn->recvmbox)) {
;;;232        /* recvmbox already deleted */
;;;233        if (p != NULL) {
;;;234          tcp_recved(pcb, p->tot_len);
;;;235          pbuf_free(p);
;;;236        }
;;;237        return ERR_OK;
;;;238      }
;;;239      /* Unlike for UDP or RAW pcbs, don't check for available space
;;;240         using recv_avail since that could break the connection
;;;241         (data is already ACKed) */
;;;242    
;;;243      /* don't overwrite fatal errors! */
;;;244      NETCONN_SET_SAFE_ERR(conn, err);
;;;245    
;;;246      if (p != NULL) {
;;;247        len = p->tot_len;
;;;248      } else {
;;;249        len = 0;
;;;250      }
;;;251    
;;;252      if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
;;;253        /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
;;;254        return ERR_MEM;
;;;255      } else {
;;;256    #if LWIP_SO_RCVBUF
;;;257        SYS_ARCH_INC(conn->recv_avail, len);
;;;258    #endif /* LWIP_SO_RCVBUF */
;;;259        /* Register event with callback */
;;;260        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;261      }
;;;262    
;;;263      return ERR_OK;
;;;264    }
002842  e8bd87f0          POP      {r4-r10,pc}
                  |L1.10310|
002846  f1040018          ADD      r0,r4,#0x18           ;231
00284a  f7fffffe          BL       sys_mbox_valid
00284e  b948              CBNZ     r0,|L1.10340|
002850  b135              CBZ      r5,|L1.10336|
002852  8929              LDRH     r1,[r5,#8]            ;234
002854  4640              MOV      r0,r8                 ;234
002856  f7fffffe          BL       tcp_recved
00285a  4628              MOV      r0,r5                 ;235
00285c  f7fffffe          BL       pbuf_free
                  |L1.10336|
002860  2000              MOVS     r0,#0                 ;237
002862  e7ee              B        |L1.10306|
                  |L1.10340|
002864  bf00              NOP                            ;244
002866  f7fffffe          BL       sys_arch_protect
00286a  4682              MOV      r10,r0                ;244
00286c  f9940008          LDRSB    r0,[r4,#8]            ;244
002870  f1100f09          CMN      r0,#9                 ;244
002874  db01              BLT      |L1.10362|
002876  f8849008          STRB     r9,[r4,#8]            ;244
                  |L1.10362|
00287a  4650              MOV      r0,r10                ;244
00287c  f7fffffe          BL       sys_arch_unprotect
002880  bf00              NOP                            ;244
002882  b10d              CBZ      r5,|L1.10376|
002884  892e              LDRH     r6,[r5,#8]            ;247
002886  e000              B        |L1.10378|
                  |L1.10376|
002888  2600              MOVS     r6,#0                 ;249
                  |L1.10378|
00288a  4629              MOV      r1,r5                 ;252
00288c  f1040018          ADD      r0,r4,#0x18           ;252
002890  f7fffffe          BL       sys_mbox_trypost
002894  b110              CBZ      r0,|L1.10396|
002896  f04f30ff          MOV      r0,#0xffffffff        ;254
00289a  e7d2              B        |L1.10306|
                  |L1.10396|
00289c  f8d40138          LDR      r0,[r4,#0x138]        ;260
0028a0  b128              CBZ      r0,|L1.10414|
0028a2  4632              MOV      r2,r6                 ;260
0028a4  2100              MOVS     r1,#0                 ;260
0028a6  4620              MOV      r0,r4                 ;260
0028a8  f8d43138          LDR      r3,[r4,#0x138]        ;260
0028ac  4798              BLX      r3                    ;260
                  |L1.10414|
0028ae  2000              MOVS     r0,#0                 ;263
0028b0  e7c7              B        |L1.10306|
;;;265    
                          ENDP

                  setup_tcp PROC
;;;413    static void
;;;414    setup_tcp(struct netconn *conn)
0028b2  b510              PUSH     {r4,lr}
;;;415    {
0028b4  4603              MOV      r3,r0
;;;416      struct tcp_pcb *pcb;
;;;417    
;;;418      pcb = conn->pcb.tcp;
0028b6  685c              LDR      r4,[r3,#4]
;;;419      tcp_arg(pcb, conn);
0028b8  4619              MOV      r1,r3
0028ba  4620              MOV      r0,r4
0028bc  f7fffffe          BL       tcp_arg
;;;420      tcp_recv(pcb, recv_tcp);
0028c0  49ad              LDR      r1,|L1.11128|
0028c2  4620              MOV      r0,r4
0028c4  f7fffffe          BL       tcp_recv
;;;421      tcp_sent(pcb, sent_tcp);
0028c8  49a8              LDR      r1,|L1.11116|
0028ca  4620              MOV      r0,r4
0028cc  f7fffffe          BL       tcp_sent
;;;422      tcp_poll(pcb, poll_tcp, 4);
0028d0  2204              MOVS     r2,#4
0028d2  49a7              LDR      r1,|L1.11120|
0028d4  4620              MOV      r0,r4
0028d6  f7fffffe          BL       tcp_poll
;;;423      tcp_err(pcb, err_tcp);
0028da  49a6              LDR      r1,|L1.11124|
0028dc  4620              MOV      r0,r4
0028de  f7fffffe          BL       tcp_err
;;;424    }
0028e2  bd10              POP      {r4,pc}
;;;425    
                          ENDP

                  tcp_next_iss PROC
;;;1572   u32_t
;;;1573   tcp_next_iss(void)
0028e4  48a5              LDR      r0,|L1.11132|
;;;1574   {
;;;1575     static u32_t iss = 6510;
;;;1576     
;;;1577     iss += tcp_ticks;       /* XXX */
0028e6  6800              LDR      r0,[r0,#0]  ; iss
0028e8  49a5              LDR      r1,|L1.11136|
0028ea  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0028ec  4408              ADD      r0,r0,r1
0028ee  49a3              LDR      r1,|L1.11132|
0028f0  6008              STR      r0,[r1,#0]  ; iss
;;;1578     return iss;
0028f2  4608              MOV      r0,r1
0028f4  6800              LDR      r0,[r0,#0]  ; iss
;;;1579   }
0028f6  4770              BX       lr
;;;1580   
                          ENDP

                  tcp_abandon PROC
;;;357    void
;;;358    tcp_abandon(struct tcp_pcb *pcb, int reset)
0028f8  e92d47fc          PUSH     {r2-r10,lr}
;;;359    {
0028fc  4604              MOV      r4,r0
0028fe  460e              MOV      r6,r1
;;;360      u32_t seqno, ackno;
;;;361    #if LWIP_CALLBACK_API  
;;;362      tcp_err_fn errf;
;;;363    #endif /* LWIP_CALLBACK_API */
;;;364      void *errf_arg;
;;;365    
;;;366      /* pcb->state LISTEN not allowed here */
;;;367      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
002900  bf00              NOP      
002902  bf00              NOP      
;;;368        pcb->state != LISTEN);
;;;369      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;370         are in an active state, call the receive function associated with
;;;371         the PCB with a NULL argument, and send an RST to the remote end. */
;;;372      if (pcb->state == TIME_WAIT) {
002904  7e20              LDRB     r0,[r4,#0x18]
002906  280a              CMP      r0,#0xa
002908  d108              BNE      |L1.10524|
;;;373        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
00290a  4621              MOV      r1,r4
00290c  489d              LDR      r0,|L1.11140|
00290e  f7fffffe          BL       tcp_pcb_remove
;;;374        memp_free(MEMP_TCP_PCB, pcb);
002912  4621              MOV      r1,r4
002914  2002              MOVS     r0,#2
002916  f7fffffe          BL       memp_free
00291a  e036              B        |L1.10634|
                  |L1.10524|
;;;375      } else {
;;;376        seqno = pcb->snd_nxt;
00291c  6d27              LDR      r7,[r4,#0x50]
;;;377        ackno = pcb->rcv_nxt;
00291e  f8d48028          LDR      r8,[r4,#0x28]
;;;378    #if LWIP_CALLBACK_API
;;;379        errf = pcb->errf;
002922  f8d4508c          LDR      r5,[r4,#0x8c]
;;;380    #endif /* LWIP_CALLBACK_API */
;;;381        errf_arg = pcb->callback_arg;
002926  f8d49010          LDR      r9,[r4,#0x10]
;;;382        TCP_PCB_REMOVE_ACTIVE(pcb);
00292a  bf00              NOP      
00292c  4621              MOV      r1,r4
00292e  4896              LDR      r0,|L1.11144|
002930  f7fffffe          BL       tcp_pcb_remove
002934  2001              MOVS     r0,#1
002936  4995              LDR      r1,|L1.11148|
002938  7008              STRB     r0,[r1,#0]
00293a  bf00              NOP      
;;;383        if (pcb->unacked != NULL) {
00293c  6f20              LDR      r0,[r4,#0x70]
00293e  b110              CBZ      r0,|L1.10566|
;;;384          tcp_segs_free(pcb->unacked);
002940  6f20              LDR      r0,[r4,#0x70]
002942  f7fffffe          BL       tcp_segs_free
                  |L1.10566|
;;;385        }
;;;386        if (pcb->unsent != NULL) {
002946  6ee0              LDR      r0,[r4,#0x6c]
002948  b110              CBZ      r0,|L1.10576|
;;;387          tcp_segs_free(pcb->unsent);
00294a  6ee0              LDR      r0,[r4,#0x6c]
00294c  f7fffffe          BL       tcp_segs_free
                  |L1.10576|
;;;388        }
;;;389    #if TCP_QUEUE_OOSEQ    
;;;390        if (pcb->ooseq != NULL) {
002950  6f60              LDR      r0,[r4,#0x74]
002952  b110              CBZ      r0,|L1.10586|
;;;391          tcp_segs_free(pcb->ooseq);
002954  6f60              LDR      r0,[r4,#0x74]
002956  f7fffffe          BL       tcp_segs_free
                  |L1.10586|
;;;392        }
;;;393    #endif /* TCP_QUEUE_OOSEQ */
;;;394        if (reset) {
00295a  b15e              CBZ      r6,|L1.10612|
;;;395    
;;;396          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
00295c  bf00              NOP      
00295e  bf00              NOP      
;;;397          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
002960  8ba0              LDRH     r0,[r4,#0x1c]
002962  8b61              LDRH     r1,[r4,#0x1a]
002964  1d23              ADDS     r3,r4,#4
002966  4622              MOV      r2,r4
002968  e9cd1000          STRD     r1,r0,[sp,#0]
00296c  4641              MOV      r1,r8
00296e  4638              MOV      r0,r7
002970  f7fffffe          BL       tcp_rst
                  |L1.10612|
;;;398        }
;;;399        memp_free(MEMP_TCP_PCB, pcb);
002974  4621              MOV      r1,r4
002976  2002              MOVS     r0,#2
002978  f7fffffe          BL       memp_free
;;;400        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
00297c  bf00              NOP      
00297e  b11d              CBZ      r5,|L1.10632|
002980  f06f0109          MVN      r1,#9
002984  4648              MOV      r0,r9
002986  47a8              BLX      r5
                  |L1.10632|
002988  bf00              NOP      
                  |L1.10634|
;;;401      }
;;;402    }
00298a  e8bd87fc          POP      {r2-r10,pc}
;;;403    
                          ENDP

                  tcp_abort PROC
;;;414    void
;;;415    tcp_abort(struct tcp_pcb *pcb)
00298e  b510              PUSH     {r4,lr}
;;;416    {
002990  4604              MOV      r4,r0
;;;417      tcp_abandon(pcb, 1);
002992  2101              MOVS     r1,#1
002994  4620              MOV      r0,r4
002996  f7fffffe          BL       tcp_abandon
;;;418    }
00299a  bd10              POP      {r4,pc}
;;;419    
                          ENDP

                  tcp_kill_prio PROC
;;;1218   static void
;;;1219   tcp_kill_prio(u8_t prio)
00299c  e92d41f0          PUSH     {r4-r8,lr}
;;;1220   {
0029a0  4606              MOV      r6,r0
;;;1221     struct tcp_pcb *pcb, *inactive;
;;;1222     u32_t inactivity;
;;;1223     u8_t mprio;
;;;1224   
;;;1225   
;;;1226     mprio = TCP_PRIO_MAX;
0029a2  f04f087f          MOV      r8,#0x7f
;;;1227     
;;;1228     /* We kill the oldest active connection that has lower priority than prio. */
;;;1229     inactivity = 0;
0029a6  2700              MOVS     r7,#0
;;;1230     inactive = NULL;
0029a8  2500              MOVS     r5,#0
;;;1231     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
0029aa  4877              LDR      r0,|L1.11144|
0029ac  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
0029ae  e013              B        |L1.10712|
                  |L1.10672|
;;;1232       if (pcb->prio <= prio &&
0029b0  7e60              LDRB     r0,[r4,#0x19]
0029b2  42b0              CMP      r0,r6
0029b4  dc0f              BGT      |L1.10710|
;;;1233          pcb->prio <= mprio &&
0029b6  7e60              LDRB     r0,[r4,#0x19]
0029b8  4540              CMP      r0,r8
0029ba  dc0c              BGT      |L1.10710|
;;;1234          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
0029bc  4970              LDR      r1,|L1.11136|
0029be  6a60              LDR      r0,[r4,#0x24]
0029c0  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0029c2  1a08              SUBS     r0,r1,r0
0029c4  42b8              CMP      r0,r7
0029c6  d306              BCC      |L1.10710|
;;;1235         inactivity = tcp_ticks - pcb->tmr;
0029c8  496d              LDR      r1,|L1.11136|
0029ca  6a60              LDR      r0,[r4,#0x24]
0029cc  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0029ce  1a0f              SUBS     r7,r1,r0
;;;1236         inactive = pcb;
0029d0  4625              MOV      r5,r4
;;;1237         mprio = pcb->prio;
0029d2  f8948019          LDRB     r8,[r4,#0x19]
                  |L1.10710|
0029d6  68e4              LDR      r4,[r4,#0xc]          ;1231
                  |L1.10712|
0029d8  2c00              CMP      r4,#0                 ;1231
0029da  d1e9              BNE      |L1.10672|
;;;1238       }
;;;1239     }
;;;1240     if (inactive != NULL) {
0029dc  b125              CBZ      r5,|L1.10728|
;;;1241       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
0029de  bf00              NOP      
0029e0  bf00              NOP      
;;;1242              (void *)inactive, inactivity));
;;;1243       tcp_abort(inactive);
0029e2  4628              MOV      r0,r5
0029e4  f7fffffe          BL       tcp_abort
                  |L1.10728|
;;;1244     }
;;;1245   }
0029e8  e8bd81f0          POP      {r4-r8,pc}
;;;1246   
                          ENDP

                  tcp_kill_timewait PROC
;;;1251   static void
;;;1252   tcp_kill_timewait(void)
0029ec  b570              PUSH     {r4-r6,lr}
;;;1253   {
;;;1254     struct tcp_pcb *pcb, *inactive;
;;;1255     u32_t inactivity;
;;;1256   
;;;1257     inactivity = 0;
0029ee  2600              MOVS     r6,#0
;;;1258     inactive = NULL;
0029f0  2500              MOVS     r5,#0
;;;1259     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1260     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
0029f2  4864              LDR      r0,|L1.11140|
0029f4  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
0029f6  e00b              B        |L1.10768|
                  |L1.10744|
;;;1261       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
0029f8  4961              LDR      r1,|L1.11136|
0029fa  6a60              LDR      r0,[r4,#0x24]
0029fc  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0029fe  1a08              SUBS     r0,r1,r0
002a00  42b0              CMP      r0,r6
002a02  d304              BCC      |L1.10766|
;;;1262         inactivity = tcp_ticks - pcb->tmr;
002a04  495e              LDR      r1,|L1.11136|
002a06  6a60              LDR      r0,[r4,#0x24]
002a08  6809              LDR      r1,[r1,#0]  ; tcp_ticks
002a0a  1a0e              SUBS     r6,r1,r0
;;;1263         inactive = pcb;
002a0c  4625              MOV      r5,r4
                  |L1.10766|
002a0e  68e4              LDR      r4,[r4,#0xc]          ;1260
                  |L1.10768|
002a10  2c00              CMP      r4,#0                 ;1260
002a12  d1f1              BNE      |L1.10744|
;;;1264       }
;;;1265     }
;;;1266     if (inactive != NULL) {
002a14  b125              CBZ      r5,|L1.10784|
;;;1267       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
002a16  bf00              NOP      
002a18  bf00              NOP      
;;;1268              (void *)inactive, inactivity));
;;;1269       tcp_abort(inactive);
002a1a  4628              MOV      r0,r5
002a1c  f7fffffe          BL       tcp_abort
                  |L1.10784|
;;;1270     }
;;;1271   }
002a20  bd70              POP      {r4-r6,pc}
;;;1272   
                          ENDP

                  tcp_alloc PROC
;;;1279   struct tcp_pcb *
;;;1280   tcp_alloc(u8_t prio)
002a22  b570              PUSH     {r4-r6,lr}
;;;1281   {
002a24  4606              MOV      r6,r0
;;;1282     struct tcp_pcb *pcb;
;;;1283     u32_t iss;
;;;1284     
;;;1285     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
002a26  2002              MOVS     r0,#2
002a28  f7fffffe          BL       memp_malloc
002a2c  4604              MOV      r4,r0
;;;1286     if (pcb == NULL) {
002a2e  bb1c              CBNZ     r4,|L1.10872|
;;;1287       /* Try killing oldest connection in TIME-WAIT. */
;;;1288       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
002a30  bf00              NOP      
002a32  bf00              NOP      
;;;1289       tcp_kill_timewait();
002a34  f7fffffe          BL       tcp_kill_timewait
;;;1290       /* Try to allocate a tcp_pcb again. */
;;;1291       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
002a38  2002              MOVS     r0,#2
002a3a  f7fffffe          BL       memp_malloc
002a3e  4604              MOV      r4,r0
;;;1292       if (pcb == NULL) {
002a40  b98c              CBNZ     r4,|L1.10854|
;;;1293         /* Try killing active connections with lower priority than the new one. */
;;;1294         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
002a42  bf00              NOP      
002a44  bf00              NOP      
;;;1295         tcp_kill_prio(prio);
002a46  4630              MOV      r0,r6
002a48  f7fffffe          BL       tcp_kill_prio
;;;1296         /* Try to allocate a tcp_pcb again. */
;;;1297         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
002a4c  2002              MOVS     r0,#2
002a4e  f7fffffe          BL       memp_malloc
002a52  4604              MOV      r4,r0
;;;1298         if (pcb != NULL) {
002a54  b13c              CBZ      r4,|L1.10854|
;;;1299           /* adjust err stats: memp_malloc failed twice before */
;;;1300           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
002a56  484e              LDR      r0,|L1.11152|
002a58  f8b000f8          LDRH     r0,[r0,#0xf8]
002a5c  1e40              SUBS     r0,r0,#1
002a5e  b281              UXTH     r1,r0
002a60  484b              LDR      r0,|L1.11152|
002a62  f8a010f8          STRH     r1,[r0,#0xf8]
                  |L1.10854|
;;;1301         }
;;;1302       }
;;;1303       if (pcb != NULL) {
002a66  b13c              CBZ      r4,|L1.10872|
;;;1304         /* adjust err stats: timewait PCB was freed above */
;;;1305         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
002a68  4849              LDR      r0,|L1.11152|
002a6a  f8b000f8          LDRH     r0,[r0,#0xf8]
002a6e  1e40              SUBS     r0,r0,#1
002a70  b281              UXTH     r1,r0
002a72  4847              LDR      r0,|L1.11152|
002a74  f8a010f8          STRH     r1,[r0,#0xf8]
                  |L1.10872|
;;;1306       }
;;;1307     }
;;;1308     if (pcb != NULL) {
002a78  2c00              CMP      r4,#0
002a7a  d045              BEQ      |L1.11016|
;;;1309       memset(pcb, 0, sizeof(struct tcp_pcb));
002a7c  2198              MOVS     r1,#0x98
002a7e  4620              MOV      r0,r4
002a80  f7fffffe          BL       __aeabi_memclr4
;;;1310       pcb->prio = prio;
002a84  f1040414          ADD      r4,r4,#0x14
002a88  7166              STRB     r6,[r4,#5]
;;;1311       pcb->snd_buf = TCP_SND_BUF;
002a8a  f64260e0          MOV      r0,#0x2ee0
002a8e  f8a40052          STRH     r0,[r4,#0x52]
;;;1312       pcb->snd_queuelen = 0;
002a92  f04f0000          MOV      r0,#0
002a96  f8a40054          STRH     r0,[r4,#0x54]
;;;1313       pcb->rcv_wnd = TCP_WND;
002a9a  f44f5080          MOV      r0,#0x1000
002a9e  8320              STRH     r0,[r4,#0x18]
;;;1314       pcb->rcv_ann_wnd = TCP_WND;
002aa0  8360              STRH     r0,[r4,#0x1a]
;;;1315       pcb->tos = 0;
002aa2  f04f0000          MOV      r0,#0
002aa6  f8040c0b          STRB     r0,[r4,#-0xb]
;;;1316       pcb->ttl = TCP_TTL;
002aaa  f04f00ff          MOV      r0,#0xff
002aae  f8040c0a          STRB     r0,[r4,#-0xa]
;;;1317       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1318          The send MSS is updated when an MSS option is received. */
;;;1319       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
002ab2  f44f7006          MOV      r0,#0x218
002ab6  8460              STRH     r0,[r4,#0x22]
;;;1320       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
002ab8  f04f0006          MOV      r0,#6
002abc  8620              STRH     r0,[r4,#0x30]
;;;1321       pcb->sa = 0;
002abe  f04f0000          MOV      r0,#0
002ac2  85a0              STRH     r0,[r4,#0x2c]
;;;1322       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
002ac4  f04f0006          MOV      r0,#6
002ac8  85e0              STRH     r0,[r4,#0x2e]
;;;1323       pcb->rtime = -1;
002aca  f04f30ff          MOV      r0,#0xffffffff
002ace  8420              STRH     r0,[r4,#0x20]
;;;1324       pcb->cwnd = 1;
002ad0  f04f0001          MOV      r0,#1
002ad4  8720              STRH     r0,[r4,#0x38]
;;;1325       iss = tcp_next_iss();
002ad6  f7fffffe          BL       tcp_next_iss
002ada  4605              MOV      r5,r0
;;;1326       pcb->snd_wl2 = iss;
002adc  6465              STR      r5,[r4,#0x44]
;;;1327       pcb->snd_nxt = iss;
002ade  63e5              STR      r5,[r4,#0x3c]
;;;1328       pcb->lastack = iss;
002ae0  6365              STR      r5,[r4,#0x34]
;;;1329       pcb->snd_lbb = iss;   
002ae2  64a5              STR      r5,[r4,#0x48]
;;;1330       pcb->tmr = tcp_ticks;
002ae4  4826              LDR      r0,|L1.11136|
002ae6  6800              LDR      r0,[r0,#0]  ; tcp_ticks
002ae8  6120              STR      r0,[r4,#0x10]
;;;1331       pcb->last_timer = tcp_timer_ctr;
002aea  482a              LDR      r0,|L1.11156|
002aec  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
002aee  7360              STRB     r0,[r4,#0xd]
;;;1332   
;;;1333       pcb->polltmr = 0;
002af0  2000              MOVS     r0,#0
002af2  72e0              STRB     r0,[r4,#0xb]
;;;1334   
;;;1335   #if LWIP_CALLBACK_API
;;;1336       pcb->recv = tcp_recv_null;
002af4  f6af0081          ADR      r0,tcp_recv_null + 1
002af8  66e0              STR      r0,[r4,#0x6c]
;;;1337   #endif /* LWIP_CALLBACK_API */  
;;;1338       
;;;1339       /* Init KEEPALIVE timer */
;;;1340       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
002afa  4827              LDR      r0,|L1.11160|
002afc  67e0              STR      r0,[r4,#0x7c]
;;;1341       
;;;1342   #if LWIP_TCP_KEEPALIVE
;;;1343       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1344       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1345   #endif /* LWIP_TCP_KEEPALIVE */
;;;1346   
;;;1347       pcb->keep_cnt_sent = 0;
002afe  2000              MOVS     r0,#0
002b00  f8840082          STRB     r0,[r4,#0x82]
002b04  f1a40414          SUB      r4,r4,#0x14
                  |L1.11016|
;;;1348     }
;;;1349     return pcb;
002b08  4620              MOV      r0,r4
;;;1350   }
002b0a  bd70              POP      {r4-r6,pc}
;;;1351   
                          ENDP

                  tcp_new PROC
;;;1364   struct tcp_pcb *
;;;1365   tcp_new(void)
002b0c  b510              PUSH     {r4,lr}
;;;1366   {
;;;1367     return tcp_alloc(TCP_PRIO_NORMAL);
002b0e  2040              MOVS     r0,#0x40
002b10  f7fffffe          BL       tcp_alloc
;;;1368   }
002b14  bd10              POP      {r4,pc}
;;;1369   
                          ENDP

                  netbuf_delete PROC
;;;86     void
;;;87     netbuf_delete(struct netbuf *buf)
002b16  b510              PUSH     {r4,lr}
;;;88     {
002b18  4604              MOV      r4,r0
;;;89       if (buf != NULL) {
002b1a  b15c              CBZ      r4,|L1.11060|
;;;90         if (buf->p != NULL) {
002b1c  6820              LDR      r0,[r4,#0]
002b1e  b128              CBZ      r0,|L1.11052|
;;;91           pbuf_free(buf->p);
002b20  6820              LDR      r0,[r4,#0]
002b22  f7fffffe          BL       pbuf_free
;;;92           buf->p = buf->ptr = NULL;
002b26  2000              MOVS     r0,#0
002b28  6060              STR      r0,[r4,#4]
002b2a  6020              STR      r0,[r4,#0]
                  |L1.11052|
;;;93         }
;;;94         memp_free(MEMP_NETBUF, buf);
002b2c  4621              MOV      r1,r4
002b2e  2005              MOVS     r0,#5
002b30  f7fffffe          BL       memp_free
                  |L1.11060|
;;;95       }
;;;96     }
002b34  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  recv_udp PROC
;;;144    static void
;;;145    recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
002b36  e92d5ff0          PUSH     {r4-r12,lr}
;;;146       ip_addr_t *addr, u16_t port)
;;;147    {
002b3a  4680              MOV      r8,r0
002b3c  468b              MOV      r11,r1
002b3e  4616              MOV      r6,r2
002b40  461f              MOV      r7,r3
002b42  f8dda028          LDR      r10,[sp,#0x28]
;;;148      struct netbuf *buf;
;;;149      struct netconn *conn;
;;;150      u16_t len;
;;;151    #if LWIP_SO_RCVBUF
;;;152      int recv_avail;
;;;153    #endif /* LWIP_SO_RCVBUF */
;;;154    
;;;155      LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
;;;156      LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
002b46  bf00              NOP      
002b48  bf00              NOP      
;;;157      LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
002b4a  bf00              NOP      
002b4c  bf00              NOP      
;;;158      conn = (struct netconn *)arg;
002b4e  4645              MOV      r5,r8
;;;159      LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
002b50  bf00              NOP      
002b52  bf00              NOP      
;;;160    
;;;161    #if LWIP_SO_RCVBUF
;;;162      SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;163      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
;;;164          ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
;;;165    #else  /* LWIP_SO_RCVBUF */
;;;166      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
002b54  b125              CBZ      r5,|L1.11104|
002b56  f1050018          ADD      r0,r5,#0x18
002b5a  f7fffffe          BL       sys_mbox_valid
002b5e  b9e8              CBNZ     r0,|L1.11164|
                  |L1.11104|
;;;167    #endif /* LWIP_SO_RCVBUF */
;;;168        pbuf_free(p);
002b60  4630              MOV      r0,r6
002b62  f7fffffe          BL       pbuf_free
;;;169        return;
;;;170      }
;;;171    
;;;172      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;173      if (buf == NULL) {
;;;174        pbuf_free(p);
;;;175        return;
;;;176      } else {
;;;177        buf->p = p;
;;;178        buf->ptr = p;
;;;179        ip_addr_set(&buf->addr, addr);
;;;180        buf->port = port;
;;;181    #if LWIP_NETBUF_RECVINFO
;;;182        {
;;;183          const struct ip_hdr* iphdr = ip_current_header();
;;;184          /* get the UDP header - always in the first pbuf, ensured by udp_input */
;;;185          const struct udp_hdr* udphdr = (void*)(((char*)iphdr) + IPH_LEN(iphdr));
;;;186    #if LWIP_CHECKSUM_ON_COPY
;;;187          buf->flags = NETBUF_FLAG_DESTADDR;
;;;188    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;189          ip_addr_set(&buf->toaddr, ip_current_dest_addr());
;;;190          buf->toport_chksum = udphdr->dest;
;;;191        }
;;;192    #endif /* LWIP_NETBUF_RECVINFO */
;;;193      }
;;;194    
;;;195      len = p->tot_len;
;;;196      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;197        netbuf_delete(buf);
;;;198        return;
;;;199      } else {
;;;200    #if LWIP_SO_RCVBUF
;;;201        SYS_ARCH_INC(conn->recv_avail, len);
;;;202    #endif /* LWIP_SO_RCVBUF */
;;;203        /* Register event with callback */
;;;204        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;205      }
;;;206    }
002b66  e8bd9ff0          POP      {r4-r12,pc}
002b6a  0000              DCW      0x0000
                  |L1.11116|
                          DCD      sent_tcp
                  |L1.11120|
                          DCD      poll_tcp
                  |L1.11124|
                          DCD      err_tcp
                  |L1.11128|
                          DCD      recv_tcp
                  |L1.11132|
                          DCD      iss
                  |L1.11136|
                          DCD      tcp_ticks
                  |L1.11140|
                          DCD      tcp_tw_pcbs
                  |L1.11144|
                          DCD      tcp_active_pcbs
                  |L1.11148|
                          DCD      tcp_active_pcbs_changed
                  |L1.11152|
                          DCD      lwip_stats
                  |L1.11156|
                          DCD      tcp_timer_ctr
                  |L1.11160|
                          DCD      0x006ddd00
                  |L1.11164|
002b9c  2005              MOVS     r0,#5                 ;172
002b9e  f7fffffe          BL       memp_malloc
002ba2  4604              MOV      r4,r0                 ;172
002ba4  b924              CBNZ     r4,|L1.11184|
002ba6  4630              MOV      r0,r6                 ;174
002ba8  f7fffffe          BL       pbuf_free
                  |L1.11180|
002bac  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.11184|
002bb0  6026              STR      r6,[r4,#0]            ;177
002bb2  6066              STR      r6,[r4,#4]            ;178
002bb4  b90f              CBNZ     r7,|L1.11194|
002bb6  2000              MOVS     r0,#0                 ;179
002bb8  e000              B        |L1.11196|
                  |L1.11194|
002bba  6838              LDR      r0,[r7,#0]            ;179
                  |L1.11196|
002bbc  60a0              STR      r0,[r4,#8]            ;179
002bbe  f8a4a00c          STRH     r10,[r4,#0xc]         ;180
002bc2  f8b69008          LDRH     r9,[r6,#8]            ;195
002bc6  4621              MOV      r1,r4                 ;196
002bc8  f1050018          ADD      r0,r5,#0x18           ;196
002bcc  f7fffffe          BL       sys_mbox_trypost
002bd0  b118              CBZ      r0,|L1.11226|
002bd2  4620              MOV      r0,r4                 ;197
002bd4  f7fffffe          BL       netbuf_delete
002bd8  e7e8              B        |L1.11180|
                  |L1.11226|
002bda  f8d50138          LDR      r0,[r5,#0x138]        ;204
002bde  b128              CBZ      r0,|L1.11244|
002be0  464a              MOV      r2,r9                 ;204
002be2  2100              MOVS     r1,#0                 ;204
002be4  4628              MOV      r0,r5                 ;204
002be6  f8d53138          LDR      r3,[r5,#0x138]        ;204
002bea  4798              BLX      r3                    ;204
                  |L1.11244|
002bec  bf00              NOP      
002bee  e7dd              B        |L1.11180|
;;;207    #endif /* LWIP_UDP */
                          ENDP

                  udp_recv PROC
;;;929    void
;;;930    udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
002bf0  61c1              STR      r1,[r0,#0x1c]
;;;931    {
;;;932      /* remember recv() callback and user data */
;;;933      pcb->recv = recv;
;;;934      pcb->recv_arg = recv_arg;
002bf2  6202              STR      r2,[r0,#0x20]
;;;935    }
002bf4  4770              BX       lr
;;;936    
                          ENDP

                  udp_new PROC
;;;976    struct udp_pcb *
;;;977    udp_new(void)
002bf6  b510              PUSH     {r4,lr}
;;;978    {
;;;979      struct udp_pcb *pcb;
;;;980      pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
002bf8  2001              MOVS     r0,#1
002bfa  f7fffffe          BL       memp_malloc
002bfe  4604              MOV      r4,r0
;;;981      /* could allocate UDP PCB? */
;;;982      if (pcb != NULL) {
002c00  b12c              CBZ      r4,|L1.11278|
;;;983        /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
;;;984         * which means checksum is generated over the whole datagram per default
;;;985         * (recommended as default by RFC 3828). */
;;;986        /* initialize PCB to all zeroes */
;;;987        memset(pcb, 0, sizeof(struct udp_pcb));
002c02  2124              MOVS     r1,#0x24
002c04  4620              MOV      r0,r4
002c06  f7fffffe          BL       __aeabi_memclr4
;;;988        pcb->ttl = UDP_TTL;
002c0a  20ff              MOVS     r0,#0xff
002c0c  72a0              STRB     r0,[r4,#0xa]
                  |L1.11278|
;;;989      }
;;;990      return pcb;
002c0e  4620              MOV      r0,r4
;;;991    }
002c10  bd10              POP      {r4,pc}
;;;992    
                          ENDP

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
002c12  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
002c16  4605              MOV      r5,r0
002c18  460c              MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
002c1a  2600              MOVS     r6,#0
002c1c  2700              MOVS     r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
002c1e  bf00              NOP      
002c20  bf00              NOP      
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
002c22  bf00              NOP      
002c24  b125              CBZ      r5,|L1.11312|
002c26  b11c              CBZ      r4,|L1.11312|
002c28  8928              LDRH     r0,[r5,#8]
002c2a  8921              LDRH     r1,[r4,#8]
002c2c  4288              CMP      r0,r1
002c2e  da03              BGE      |L1.11320|
                  |L1.11312|
002c30  f06f000d          MVN      r0,#0xd
                  |L1.11316|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
002c34  e8bd81f0          POP      {r4-r8,pc}
                  |L1.11320|
002c38  bf00              NOP                            ;860
002c3a  bf00              NOP                            ;864
                  |L1.11324|
002c3c  8968              LDRH     r0,[r5,#0xa]          ;867
002c3e  1b80              SUBS     r0,r0,r6              ;867
002c40  8961              LDRH     r1,[r4,#0xa]          ;867
002c42  1bc9              SUBS     r1,r1,r7              ;867
002c44  4288              CMP      r0,r1                 ;867
002c46  db04              BLT      |L1.11346|
002c48  8960              LDRH     r0,[r4,#0xa]          ;869
002c4a  1bc0              SUBS     r0,r0,r7              ;869
002c4c  fa1ff880          UXTH     r8,r0                 ;869
002c50  e003              B        |L1.11354|
                  |L1.11346|
002c52  8968              LDRH     r0,[r5,#0xa]          ;872
002c54  1b80              SUBS     r0,r0,r6              ;872
002c56  fa1ff880          UXTH     r8,r0                 ;872
                  |L1.11354|
002c5a  6862              LDR      r2,[r4,#4]            ;874
002c5c  19d1              ADDS     r1,r2,r7              ;874
002c5e  686a              LDR      r2,[r5,#4]            ;874
002c60  1990              ADDS     r0,r2,r6              ;874
002c62  4642              MOV      r2,r8                 ;874
002c64  f7fffffe          BL       __aeabi_memcpy
002c68  eb060008          ADD      r0,r6,r8              ;875
002c6c  b286              UXTH     r6,r0                 ;875
002c6e  eb070008          ADD      r0,r7,r8              ;876
002c72  b287              UXTH     r7,r0                 ;876
002c74  bf00              NOP                            ;877
002c76  bf00              NOP                            ;877
002c78  bf00              NOP                            ;878
002c7a  bf00              NOP                            ;878
002c7c  8960              LDRH     r0,[r4,#0xa]          ;879
002c7e  42b8              CMP      r0,r7                 ;879
002c80  dc01              BGT      |L1.11398|
002c82  2700              MOVS     r7,#0                 ;881
002c84  6824              LDR      r4,[r4,#0]            ;882
                  |L1.11398|
002c86  8968              LDRH     r0,[r5,#0xa]          ;884
002c88  42b0              CMP      r0,r6                 ;884
002c8a  d108              BNE      |L1.11422|
002c8c  2600              MOVS     r6,#0                 ;886
002c8e  682d              LDR      r5,[r5,#0]            ;887
002c90  bf00              NOP                            ;888
002c92  b91d              CBNZ     r5,|L1.11420|
002c94  b114              CBZ      r4,|L1.11420|
002c96  f06f000d          MVN      r0,#0xd               ;888
002c9a  e7cb              B        |L1.11316|
                  |L1.11420|
002c9c  bf00              NOP                            ;888
                  |L1.11422|
002c9e  b154              CBZ      r4,|L1.11446|
002ca0  8960              LDRH     r0,[r4,#0xa]          ;891
002ca2  8921              LDRH     r1,[r4,#8]            ;891
002ca4  4288              CMP      r0,r1                 ;891
002ca6  d106              BNE      |L1.11446|
002ca8  bf00              NOP                            ;893
002caa  6820              LDR      r0,[r4,#0]            ;893
002cac  b110              CBZ      r0,|L1.11444|
002cae  f06f0005          MVN      r0,#5                 ;893
002cb2  e7bf              B        |L1.11316|
                  |L1.11444|
002cb4  bf00              NOP                            ;893
                  |L1.11446|
002cb6  b155              CBZ      r5,|L1.11470|
002cb8  8968              LDRH     r0,[r5,#0xa]          ;896
002cba  8929              LDRH     r1,[r5,#8]            ;896
002cbc  4288              CMP      r0,r1                 ;896
002cbe  d106              BNE      |L1.11470|
002cc0  bf00              NOP                            ;898
002cc2  6828              LDR      r0,[r5,#0]            ;898
002cc4  b110              CBZ      r0,|L1.11468|
002cc6  f06f0005          MVN      r0,#5                 ;898
002cca  e7b3              B        |L1.11316|
                  |L1.11468|
002ccc  bf00              NOP                            ;898
                  |L1.11470|
002cce  2c00              CMP      r4,#0                 ;901
002cd0  d1b4              BNE      |L1.11324|
002cd2  bf00              NOP                            ;902
002cd4  bf00              NOP                            ;902
002cd6  2000              MOVS     r0,#0                 ;903
002cd8  e7ac              B        |L1.11316|
;;;905    
                          ENDP

                  recv_raw PROC
;;;78     static u8_t
;;;79     recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
002cda  e92d5ff0          PUSH     {r4-r12,lr}
;;;80         ip_addr_t *addr)
;;;81     {
002cde  4607              MOV      r7,r0
002ce0  4689              MOV      r9,r1
002ce2  4690              MOV      r8,r2
002ce4  469b              MOV      r11,r3
;;;82       struct pbuf *q;
;;;83       struct netbuf *buf;
;;;84       struct netconn *conn;
;;;85     
;;;86       LWIP_UNUSED_ARG(addr);
;;;87       conn = (struct netconn *)arg;
002ce6  463e              MOV      r6,r7
;;;88     
;;;89       if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
002ce8  2e00              CMP      r6,#0
002cea  d041              BEQ      |L1.11632|
002cec  f1060018          ADD      r0,r6,#0x18
002cf0  f7fffffe          BL       sys_mbox_valid
002cf4  2800              CMP      r0,#0
002cf6  d03b              BEQ      |L1.11632|
;;;90     #if LWIP_SO_RCVBUF
;;;91         int recv_avail;
;;;92         SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;93         if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
;;;94           return 0;
;;;95         }
;;;96     #endif /* LWIP_SO_RCVBUF */
;;;97         /* copy the whole packet into new pbufs */
;;;98         q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
002cf8  f8b81008          LDRH     r1,[r8,#8]
002cfc  2200              MOVS     r2,#0
002cfe  2003              MOVS     r0,#3
002d00  f7fffffe          BL       pbuf_alloc
002d04  4605              MOV      r5,r0
;;;99         if(q != NULL) {
002d06  b145              CBZ      r5,|L1.11546|
;;;100          if (pbuf_copy(q, p) != ERR_OK) {
002d08  4641              MOV      r1,r8
002d0a  4628              MOV      r0,r5
002d0c  f7fffffe          BL       pbuf_copy
002d10  b118              CBZ      r0,|L1.11546|
;;;101            pbuf_free(q);
002d12  4628              MOV      r0,r5
002d14  f7fffffe          BL       pbuf_free
;;;102            q = NULL;
002d18  2500              MOVS     r5,#0
                  |L1.11546|
;;;103          }
;;;104        }
;;;105    
;;;106        if (q != NULL) {
002d1a  b34d              CBZ      r5,|L1.11632|
;;;107          u16_t len;
;;;108          buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
002d1c  2005              MOVS     r0,#5
002d1e  f7fffffe          BL       memp_malloc
002d22  4604              MOV      r4,r0
;;;109          if (buf == NULL) {
002d24  b92c              CBNZ     r4,|L1.11570|
;;;110            pbuf_free(q);
002d26  4628              MOV      r0,r5
002d28  f7fffffe          BL       pbuf_free
;;;111            return 0;
002d2c  2000              MOVS     r0,#0
                  |L1.11566|
;;;112          }
;;;113    
;;;114          buf->p = q;
;;;115          buf->ptr = q;
;;;116          ip_addr_copy(buf->addr, *ip_current_src_addr());
;;;117          buf->port = pcb->protocol;
;;;118    
;;;119          len = q->tot_len;
;;;120          if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;121            netbuf_delete(buf);
;;;122            return 0;
;;;123          } else {
;;;124    #if LWIP_SO_RCVBUF
;;;125            SYS_ARCH_INC(conn->recv_avail, len);
;;;126    #endif /* LWIP_SO_RCVBUF */
;;;127            /* Register event with callback */
;;;128            API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;129          }
;;;130        }
;;;131      }
;;;132    
;;;133      return 0; /* do not eat the packet */
;;;134    }
002d2e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.11570|
002d32  6025              STR      r5,[r4,#0]            ;114
002d34  6065              STR      r5,[r4,#4]            ;115
002d36  48fa              LDR      r0,|L1.12576|
002d38  6800              LDR      r0,[r0,#0]            ;116  ; current_iphdr_src
002d3a  60a0              STR      r0,[r4,#8]            ;116
002d3c  f8990010          LDRB     r0,[r9,#0x10]         ;117
002d40  81a0              STRH     r0,[r4,#0xc]          ;117
002d42  f8b5a008          LDRH     r10,[r5,#8]           ;119
002d46  4621              MOV      r1,r4                 ;120
002d48  f1060018          ADD      r0,r6,#0x18           ;120
002d4c  f7fffffe          BL       sys_mbox_trypost
002d50  b120              CBZ      r0,|L1.11612|
002d52  4620              MOV      r0,r4                 ;121
002d54  f7fffffe          BL       netbuf_delete
002d58  2000              MOVS     r0,#0                 ;122
002d5a  e7e8              B        |L1.11566|
                  |L1.11612|
002d5c  f8d60138          LDR      r0,[r6,#0x138]        ;128
002d60  b128              CBZ      r0,|L1.11630|
002d62  4652              MOV      r2,r10                ;128
002d64  2100              MOVS     r1,#0                 ;128
002d66  4630              MOV      r0,r6                 ;128
002d68  f8d63138          LDR      r3,[r6,#0x138]        ;128
002d6c  4798              BLX      r3                    ;128
                  |L1.11630|
002d6e  bf00              NOP                            ;130
                  |L1.11632|
002d70  2000              MOVS     r0,#0                 ;133
002d72  e7dc              B        |L1.11566|
;;;135    #endif /* LWIP_RAW*/
                          ENDP

                  raw_recv PROC
;;;182    void
;;;183    raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
002d74  6141              STR      r1,[r0,#0x14]
;;;184    {
;;;185      /* remember recv() callback and user data */
;;;186      pcb->recv = recv;
;;;187      pcb->recv_arg = recv_arg;
002d76  6182              STR      r2,[r0,#0x18]
;;;188    }
002d78  4770              BX       lr
;;;189    
                          ENDP

                  raw_new PROC
;;;330    struct raw_pcb *
;;;331    raw_new(u8_t proto)
002d7a  b570              PUSH     {r4-r6,lr}
;;;332    {
002d7c  4605              MOV      r5,r0
;;;333      struct raw_pcb *pcb;
;;;334    
;;;335      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
002d7e  bf00              NOP      
002d80  bf00              NOP      
;;;336    
;;;337      pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
002d82  2000              MOVS     r0,#0
002d84  f7fffffe          BL       memp_malloc
002d88  4604              MOV      r4,r0
;;;338      /* could allocate RAW PCB? */
;;;339      if (pcb != NULL) {
002d8a  b15c              CBZ      r4,|L1.11684|
;;;340        /* initialize PCB to all zeroes */
;;;341        memset(pcb, 0, sizeof(struct raw_pcb));
002d8c  211c              MOVS     r1,#0x1c
002d8e  4620              MOV      r0,r4
002d90  f7fffffe          BL       __aeabi_memclr4
;;;342        pcb->protocol = proto;
002d94  7425              STRB     r5,[r4,#0x10]
;;;343        pcb->ttl = RAW_TTL;
002d96  20ff              MOVS     r0,#0xff
002d98  72a0              STRB     r0,[r4,#0xa]
;;;344        pcb->next = raw_pcbs;
002d9a  48e2              LDR      r0,|L1.12580|
002d9c  6800              LDR      r0,[r0,#0]  ; raw_pcbs
002d9e  60e0              STR      r0,[r4,#0xc]
;;;345        raw_pcbs = pcb;
002da0  48e0              LDR      r0,|L1.12580|
002da2  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L1.11684|
;;;346      }
;;;347      return pcb;
002da4  4620              MOV      r0,r4
;;;348    }
002da6  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

                  pcb_new PROC
;;;493    static void
;;;494    pcb_new(struct api_msg_msg *msg)
002da8  b510              PUSH     {r4,lr}
;;;495    {
002daa  4604              MOV      r4,r0
;;;496      LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
002dac  bf00              NOP      
002dae  bf00              NOP      
;;;497    
;;;498      /* Allocate a PCB for this connection */
;;;499      switch(NETCONNTYPE_GROUP(msg->conn->type)) {
002db0  6820              LDR      r0,[r4,#0]
002db2  7800              LDRB     r0,[r0,#0]
002db4  f00000f0          AND      r0,r0,#0xf0
002db8  2810              CMP      r0,#0x10
002dba  d02c              BEQ      |L1.11798|
002dbc  2820              CMP      r0,#0x20
002dbe  d012              BEQ      |L1.11750|
002dc0  2840              CMP      r0,#0x40
002dc2  d136              BNE      |L1.11826|
;;;500    #if LWIP_RAW
;;;501      case NETCONN_RAW:
;;;502        msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
002dc4  7a20              LDRB     r0,[r4,#8]
002dc6  f7fffffe          BL       raw_new
002dca  6821              LDR      r1,[r4,#0]
002dcc  6048              STR      r0,[r1,#4]
;;;503        if(msg->conn->pcb.raw == NULL) {
002dce  6820              LDR      r0,[r4,#0]
002dd0  6840              LDR      r0,[r0,#4]
002dd2  b910              CBNZ     r0,|L1.11738|
;;;504          msg->err = ERR_MEM;
002dd4  20ff              MOVS     r0,#0xff
002dd6  7120              STRB     r0,[r4,#4]
;;;505          break;
002dd8  e02e              B        |L1.11832|
                  |L1.11738|
;;;506        }
;;;507        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
002dda  6822              LDR      r2,[r4,#0]
002ddc  49d2              LDR      r1,|L1.12584|
002dde  6850              LDR      r0,[r2,#4]
002de0  f7fffffe          BL       raw_recv
;;;508        break;
002de4  e028              B        |L1.11832|
                  |L1.11750|
;;;509    #endif /* LWIP_RAW */
;;;510    #if LWIP_UDP
;;;511      case NETCONN_UDP:
;;;512        msg->conn->pcb.udp = udp_new();
002de6  f7fffffe          BL       udp_new
002dea  6821              LDR      r1,[r4,#0]
002dec  6048              STR      r0,[r1,#4]
;;;513        if(msg->conn->pcb.udp == NULL) {
002dee  6820              LDR      r0,[r4,#0]
002df0  6840              LDR      r0,[r0,#4]
002df2  b910              CBNZ     r0,|L1.11770|
;;;514          msg->err = ERR_MEM;
002df4  20ff              MOVS     r0,#0xff
002df6  7120              STRB     r0,[r4,#4]
;;;515          break;
002df8  e01e              B        |L1.11832|
                  |L1.11770|
;;;516        }
;;;517    #if LWIP_UDPLITE
;;;518        if (msg->conn->type==NETCONN_UDPLITE) {
;;;519          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
;;;520        }
;;;521    #endif /* LWIP_UDPLITE */
;;;522        if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
002dfa  6820              LDR      r0,[r4,#0]
002dfc  7800              LDRB     r0,[r0,#0]
002dfe  2822              CMP      r0,#0x22
002e00  d103              BNE      |L1.11786|
;;;523          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
002e02  2001              MOVS     r0,#1
002e04  6821              LDR      r1,[r4,#0]
002e06  6849              LDR      r1,[r1,#4]
002e08  7408              STRB     r0,[r1,#0x10]
                  |L1.11786|
;;;524        }
;;;525        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
002e0a  6822              LDR      r2,[r4,#0]
002e0c  49c7              LDR      r1,|L1.12588|
002e0e  6850              LDR      r0,[r2,#4]
002e10  f7fffffe          BL       udp_recv
;;;526        break;
002e14  e010              B        |L1.11832|
                  |L1.11798|
;;;527    #endif /* LWIP_UDP */
;;;528    #if LWIP_TCP
;;;529      case NETCONN_TCP:
;;;530        msg->conn->pcb.tcp = tcp_new();
002e16  f7fffffe          BL       tcp_new
002e1a  6821              LDR      r1,[r4,#0]
002e1c  6048              STR      r0,[r1,#4]
;;;531        if(msg->conn->pcb.tcp == NULL) {
002e1e  6820              LDR      r0,[r4,#0]
002e20  6840              LDR      r0,[r0,#4]
002e22  b910              CBNZ     r0,|L1.11818|
;;;532          msg->err = ERR_MEM;
002e24  20ff              MOVS     r0,#0xff
002e26  7120              STRB     r0,[r4,#4]
;;;533          break;
002e28  e006              B        |L1.11832|
                  |L1.11818|
;;;534        }
;;;535        setup_tcp(msg->conn);
002e2a  6820              LDR      r0,[r4,#0]
002e2c  f7fffffe          BL       setup_tcp
;;;536        break;
002e30  e002              B        |L1.11832|
                  |L1.11826|
;;;537    #endif /* LWIP_TCP */
;;;538      default:
;;;539        /* Unsupported netconn type, e.g. protocol disabled */
;;;540        msg->err = ERR_VAL;
002e32  20fa              MOVS     r0,#0xfa
002e34  7120              STRB     r0,[r4,#4]
;;;541        break;
002e36  bf00              NOP      
                  |L1.11832|
002e38  bf00              NOP                            ;505
;;;542      }
;;;543    }
002e3a  bd10              POP      {r4,pc}
;;;544    
                          ENDP

                  do_newconn PROC
;;;551    void
;;;552    do_newconn(struct api_msg_msg *msg)
002e3c  b510              PUSH     {r4,lr}
;;;553    {
002e3e  4604              MOV      r4,r0
;;;554      msg->err = ERR_OK;
002e40  2000              MOVS     r0,#0
002e42  7120              STRB     r0,[r4,#4]
;;;555      if(msg->conn->pcb.tcp == NULL) {
002e44  6820              LDR      r0,[r4,#0]
002e46  6840              LDR      r0,[r0,#4]
002e48  b910              CBNZ     r0,|L1.11856|
;;;556        pcb_new(msg);
002e4a  4620              MOV      r0,r4
002e4c  f7fffffe          BL       pcb_new
                  |L1.11856|
;;;557      }
;;;558      /* Else? This "new" connection already has a PCB allocated. */
;;;559      /* Is this an error condition? Should it be deleted? */
;;;560      /* We currently just are happy and return. */
;;;561    
;;;562      TCPIP_APIMSG_ACK(msg);
002e50  6821              LDR      r1,[r4,#0]
002e52  f101000c          ADD      r0,r1,#0xc
002e56  f7fffffe          BL       sys_sem_signal
;;;563    }
002e5a  bd10              POP      {r4,pc}
;;;564    
                          ENDP

                  sys_mbox_set_invalid PROC
;;;394    
;;;395    void sys_mbox_set_invalid(sys_mbox_t *mbox)
002e5c  2100              MOVS     r1,#0
;;;396    {
;;;397    	mbox->queue = SYS_MBOX_NULL;
002e5e  6001              STR      r1,[r0,#0]
;;;398    }
002e60  4770              BX       lr
;;;399    
                          ENDP

                  sys_mbox_new PROC
;;;340    err_t
;;;341    sys_mbox_new(sys_mbox_t *mbox, int size)
002e62  b570              PUSH     {r4-r6,lr}
;;;342    {
002e64  4605              MOV      r5,r0
002e66  460e              MOV      r6,r1
;;;343      u32_t i;
;;;344    
;;;345      /* Fail if the mailbox size is too large. */
;;;346      if(size > MBOX_MAX) {
002e68  2e20              CMP      r6,#0x20
002e6a  dd0a              BLE      |L1.11906|
;;;347    #if SYS_STATS
;;;348        STATS_INC(sys.mbox.err);
002e6c  48b0              LDR      r0,|L1.12592|
002e6e  f8b001d4          LDRH     r0,[r0,#0x1d4]
002e72  1c40              ADDS     r0,r0,#1
002e74  b281              UXTH     r1,r0
002e76  48ae              LDR      r0,|L1.12592|
002e78  f8a011d4          STRH     r1,[r0,#0x1d4]
;;;349    #endif /* SYS_STATS */
;;;350        return ERR_MEM;
002e7c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.11904|
;;;351      }
;;;352      /* Find a mailbox that is not in use. */
;;;353      for(i = 0; i < SYS_MBOX_MAX; i++) {
;;;354        if(mboxes[i].queue == 0) {
;;;355          break;
;;;356        }
;;;357      }
;;;358      if(i == SYS_MBOX_MAX) {
;;;359    #if SYS_STATS
;;;360        STATS_INC(sys.mbox.err);
;;;361    #endif /* SYS_STATS */
;;;362        return ERR_MEM;
;;;363      }
;;;364    
;;;365    #if RTOS_FREERTOS
;;;366      /* Create a queue for this mailbox. */
;;;367      mbox->queue = xQueueCreate(size, sizeof(void *));
;;;368      if(mbox == NULL) {
;;;369    #endif /* RTOS_FREERTOS */
;;;370    
;;;371    #if SYS_STATS
;;;372        STATS_INC(sys.mbox.err);
;;;373    #endif /* SYS_STATS */
;;;374        return ERR_MEM;
;;;375      }
;;;376      /* Update the mailbox statistics. */
;;;377    #if SYS_STATS
;;;378      STATS_INC(sys.mbox.used);
;;;379    #if LWIP_STATS
;;;380      if(lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used) {
;;;381        lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
;;;382      }
;;;383    #endif
;;;384    #endif /* SYS_STATS */
;;;385    
;;;386      /* Save the queue handle. */
;;;387      mboxes[i].queue = mbox->queue;
;;;388    
;;;389      /* Return this mailbox. */
;;;390      return ERR_OK;
;;;391    	
;;;392    }
002e80  bd70              POP      {r4-r6,pc}
                  |L1.11906|
002e82  2400              MOVS     r4,#0                 ;353
002e84  e007              B        |L1.11926|
                  |L1.11910|
002e86  eb041004          ADD      r0,r4,r4,LSL #4       ;354
002e8a  49aa              LDR      r1,|L1.12596|
002e8c  f8510030          LDR      r0,[r1,r0,LSL #3]     ;354
002e90  b900              CBNZ     r0,|L1.11924|
002e92  e002              B        |L1.11930|
                  |L1.11924|
002e94  1c64              ADDS     r4,r4,#1              ;353
                  |L1.11926|
002e96  2c10              CMP      r4,#0x10              ;353
002e98  d3f5              BCC      |L1.11910|
                  |L1.11930|
002e9a  bf00              NOP                            ;355
002e9c  2c10              CMP      r4,#0x10              ;358
002e9e  d10a              BNE      |L1.11958|
002ea0  48a3              LDR      r0,|L1.12592|
002ea2  f8b001d4          LDRH     r0,[r0,#0x1d4]        ;360
002ea6  1c40              ADDS     r0,r0,#1              ;360
002ea8  b281              UXTH     r1,r0                 ;360
002eaa  48a1              LDR      r0,|L1.12592|
002eac  f8a011d4          STRH     r1,[r0,#0x1d4]        ;360
002eb0  f04f30ff          MOV      r0,#0xffffffff        ;362
002eb4  e7e4              B        |L1.11904|
                  |L1.11958|
002eb6  2200              MOVS     r2,#0                 ;367
002eb8  2104              MOVS     r1,#4                 ;367
002eba  4630              MOV      r0,r6                 ;367
002ebc  f7fffffe          BL       xQueueGenericCreate
002ec0  6028              STR      r0,[r5,#0]            ;367
002ec2  b955              CBNZ     r5,|L1.11994|
002ec4  489a              LDR      r0,|L1.12592|
002ec6  f8b001d4          LDRH     r0,[r0,#0x1d4]        ;372
002eca  1c40              ADDS     r0,r0,#1              ;372
002ecc  b281              UXTH     r1,r0                 ;372
002ece  4898              LDR      r0,|L1.12592|
002ed0  f8a011d4          STRH     r1,[r0,#0x1d4]        ;372
002ed4  f04f30ff          MOV      r0,#0xffffffff        ;374
002ed8  e7d2              B        |L1.11904|
                  |L1.11994|
002eda  4895              LDR      r0,|L1.12592|
002edc  f8b001d0          LDRH     r0,[r0,#0x1d0]        ;378
002ee0  1c40              ADDS     r0,r0,#1              ;378
002ee2  b281              UXTH     r1,r0                 ;378
002ee4  4892              LDR      r0,|L1.12592|
002ee6  f8a011d0          STRH     r1,[r0,#0x1d0]        ;378
002eea  f8b011d2          LDRH     r1,[r0,#0x1d2]        ;380
002eee  f8b001d0          LDRH     r0,[r0,#0x1d0]        ;380
002ef2  4281              CMP      r1,r0                 ;380
002ef4  da04              BGE      |L1.12032|
002ef6  488e              LDR      r0,|L1.12592|
002ef8  f8b011d0          LDRH     r1,[r0,#0x1d0]        ;381
002efc  f8a011d2          STRH     r1,[r0,#0x1d2]        ;381
                  |L1.12032|
002f00  eb041104          ADD      r1,r4,r4,LSL #4       ;387
002f04  4a8b              LDR      r2,|L1.12596|
002f06  6828              LDR      r0,[r5,#0]            ;387
002f08  f8420031          STR      r0,[r2,r1,LSL #3]     ;387
002f0c  2000              MOVS     r0,#0                 ;390
002f0e  e7b7              B        |L1.11904|
;;;393    
                          ENDP

                  sys_sem_new PROC
;;;184    err_t
;;;185    sys_sem_new(sys_sem_t *sem, u8_t count)
002f10  b5f8              PUSH     {r3-r7,lr}
;;;186    {
002f12  4604              MOV      r4,r0
002f14  460e              MOV      r6,r1
;;;187      void *temp;
;;;188      u32_t i;
;;;189    
;;;190      /* Find a semaphore that is not in use. */
;;;191      for(i = 0; i < SYS_SEM_MAX; i++) {
002f16  2500              MOVS     r5,#0
002f18  e007              B        |L1.12074|
                  |L1.12058|
;;;192        if(sems[i].queue == 0) {
002f1a  eb050045          ADD      r0,r5,r5,LSL #1
002f1e  4986              LDR      r1,|L1.12600|
002f20  f8510020          LDR      r0,[r1,r0,LSL #2]
002f24  b900              CBNZ     r0,|L1.12072|
;;;193          break;
002f26  e002              B        |L1.12078|
                  |L1.12072|
002f28  1c6d              ADDS     r5,r5,#1              ;191
                  |L1.12074|
002f2a  2d10              CMP      r5,#0x10              ;191
002f2c  d3f5              BCC      |L1.12058|
                  |L1.12078|
002f2e  bf00              NOP      
;;;194        }
;;;195      }
;;;196      if(i == SYS_SEM_MAX) {
002f30  2d10              CMP      r5,#0x10
002f32  d10a              BNE      |L1.12106|
;;;197    #if SYS_STATS
;;;198        STATS_INC(sys.sem.err);
002f34  487e              LDR      r0,|L1.12592|
002f36  f8b001c8          LDRH     r0,[r0,#0x1c8]
002f3a  1c40              ADDS     r0,r0,#1
002f3c  b281              UXTH     r1,r0
002f3e  487c              LDR      r0,|L1.12592|
002f40  f8a011c8          STRH     r1,[r0,#0x1c8]
;;;199    #endif /* SYS_STATS */
;;;200        return ERR_MEM;
002f44  f04f30ff          MOV      r0,#0xffffffff
                  |L1.12104|
;;;201      }
;;;202    
;;;203      /* Create a single-entry queue to act as a semaphore. */
;;;204    #if RTOS_FREERTOS
;;;205      sem->queue = xQueueCreate(1, sizeof(void *));
;;;206      if(sem->queue == NULL) {
;;;207    #endif /* RTOS_FREERTOS */
;;;208    
;;;209    #if SYS_STATS
;;;210        STATS_INC(sys.sem.err);
;;;211    #endif /* SYS_STATS */
;;;212        return ERR_MEM;
;;;213      }
;;;214    
;;;215      /* Acquired the semaphore if necessary. */
;;;216      if(count == 0) {
;;;217        temp = 0;
;;;218        xQueueSend(sem->queue, &temp, 0);
;;;219      }
;;;220    
;;;221      /* Update the semaphore statistics. */
;;;222    #if SYS_STATS
;;;223      STATS_INC(sys.sem.used);
;;;224    #if LWIP_STATS
;;;225      if(lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
;;;226        lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
;;;227      }
;;;228    #endif
;;;229    #endif /* SYS_STATS */
;;;230    
;;;231      /* Save the queue handle. */
;;;232      sems[i].queue = sem->queue;
;;;233    
;;;234      /* Return this semaphore. */
;;;235      return (ERR_OK);
;;;236    }
002f48  bdf8              POP      {r3-r7,pc}
                  |L1.12106|
002f4a  2200              MOVS     r2,#0                 ;205
002f4c  2104              MOVS     r1,#4                 ;205
002f4e  2001              MOVS     r0,#1                 ;205
002f50  f7fffffe          BL       xQueueGenericCreate
002f54  6020              STR      r0,[r4,#0]            ;205
002f56  6820              LDR      r0,[r4,#0]            ;206
002f58  b950              CBNZ     r0,|L1.12144|
002f5a  4875              LDR      r0,|L1.12592|
002f5c  f8b001c8          LDRH     r0,[r0,#0x1c8]        ;210
002f60  1c40              ADDS     r0,r0,#1              ;210
002f62  b281              UXTH     r1,r0                 ;210
002f64  4872              LDR      r0,|L1.12592|
002f66  f8a011c8          STRH     r1,[r0,#0x1c8]        ;210
002f6a  f04f30ff          MOV      r0,#0xffffffff        ;212
002f6e  e7eb              B        |L1.12104|
                  |L1.12144|
002f70  b93e              CBNZ     r6,|L1.12162|
002f72  2000              MOVS     r0,#0                 ;217
002f74  9000              STR      r0,[sp,#0]            ;217
002f76  2300              MOVS     r3,#0                 ;218
002f78  461a              MOV      r2,r3                 ;218
002f7a  4669              MOV      r1,sp                 ;218
002f7c  6820              LDR      r0,[r4,#0]            ;218
002f7e  f7fffffe          BL       xQueueGenericSend
                  |L1.12162|
002f82  486b              LDR      r0,|L1.12592|
002f84  f8b001c4          LDRH     r0,[r0,#0x1c4]        ;223  ; lwip_stats
002f88  1c40              ADDS     r0,r0,#1              ;223
002f8a  4969              LDR      r1,|L1.12592|
002f8c  f8a101c4          STRH     r0,[r1,#0x1c4]        ;223
002f90  4608              MOV      r0,r1                 ;225
002f92  f8b001c6          LDRH     r0,[r0,#0x1c6]        ;225
002f96  f8b111c4          LDRH     r1,[r1,#0x1c4]        ;225  ; lwip_stats
002f9a  4288              CMP      r0,r1                 ;225
002f9c  da04              BGE      |L1.12200|
002f9e  4864              LDR      r0,|L1.12592|
002fa0  f8b011c4          LDRH     r1,[r0,#0x1c4]        ;226  ; lwip_stats
002fa4  f8a011c6          STRH     r1,[r0,#0x1c6]        ;226
                  |L1.12200|
002fa8  eb050145          ADD      r1,r5,r5,LSL #1       ;232
002fac  4a62              LDR      r2,|L1.12600|
002fae  6820              LDR      r0,[r4,#0]            ;232
002fb0  f8420021          STR      r0,[r2,r1,LSL #2]     ;232
002fb4  2000              MOVS     r0,#0                 ;235
002fb6  e7c7              B        |L1.12104|
;;;237    
                          ENDP

                  netconn_alloc PROC
;;;575    struct netconn*
;;;576    netconn_alloc(enum netconn_type t, netconn_callback callback)
002fb8  e92d41f0          PUSH     {r4-r8,lr}
;;;577    {
002fbc  4606              MOV      r6,r0
002fbe  460f              MOV      r7,r1
;;;578      struct netconn *conn;
;;;579      int size;
;;;580    
;;;581      conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
002fc0  2006              MOVS     r0,#6
002fc2  f7fffffe          BL       memp_malloc
002fc6  4604              MOV      r4,r0
;;;582      if (conn == NULL) {
002fc8  b914              CBNZ     r4,|L1.12240|
;;;583        return NULL;
002fca  2000              MOVS     r0,#0
                  |L1.12236|
;;;584      }
;;;585      conn->last_err = ERR_OK;
;;;586      conn->type = t;
;;;587      conn->pcb.tcp = NULL;
;;;588    
;;;589    #if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
;;;590        (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
;;;591      size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;592    #else
;;;593      switch(NETCONNTYPE_GROUP(t)) {
;;;594    #if LWIP_RAW
;;;595      case NETCONN_RAW:
;;;596        size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;597        break;
;;;598    #endif /* LWIP_RAW */
;;;599    #if LWIP_UDP
;;;600      case NETCONN_UDP:
;;;601        size = DEFAULT_UDP_RECVMBOX_SIZE;
;;;602        break;
;;;603    #endif /* LWIP_UDP */
;;;604    #if LWIP_TCP
;;;605      case NETCONN_TCP:
;;;606        size = DEFAULT_TCP_RECVMBOX_SIZE;
;;;607        break;
;;;608    #endif /* LWIP_TCP */
;;;609      default:
;;;610        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
;;;611        goto free_and_return;
;;;612      }
;;;613    #endif
;;;614    
;;;615      if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
;;;616        goto free_and_return;
;;;617      }
;;;618      if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
;;;619        sys_sem_free(&conn->op_completed);
;;;620        goto free_and_return;
;;;621      }
;;;622    
;;;623    #if LWIP_TCP
;;;624      sys_mbox_set_invalid(&conn->acceptmbox);
;;;625    #endif
;;;626      conn->state        = NETCONN_NONE;
;;;627    #if LWIP_SOCKET
;;;628      /* initialize socket to -1 since 0 is a valid socket */
;;;629      conn->socket       = -1;
;;;630    #endif /* LWIP_SOCKET */
;;;631      conn->callback     = callback;
;;;632    #if LWIP_TCP
;;;633      conn->current_msg  = NULL;
;;;634      conn->write_offset = 0;
;;;635    #endif /* LWIP_TCP */
;;;636    #if LWIP_SO_SNDTIMEO
;;;637      conn->send_timeout = 0;
;;;638    #endif /* LWIP_SO_SNDTIMEO */
;;;639    #if LWIP_SO_RCVTIMEO
;;;640      conn->recv_timeout = 0;
;;;641    #endif /* LWIP_SO_RCVTIMEO */
;;;642    #if LWIP_SO_RCVBUF
;;;643      conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
;;;644      conn->recv_avail   = 0;
;;;645    #endif /* LWIP_SO_RCVBUF */
;;;646      conn->flags = 0;
;;;647      return conn;
;;;648    free_and_return:
;;;649      memp_free(MEMP_NETCONN, conn);
;;;650      return NULL;
;;;651    }
002fcc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.12240|
002fd0  2000              MOVS     r0,#0                 ;585
002fd2  7220              STRB     r0,[r4,#8]            ;585
002fd4  7026              STRB     r6,[r4,#0]            ;586
002fd6  6060              STR      r0,[r4,#4]            ;587
002fd8  f00600f0          AND      r0,r6,#0xf0           ;593
002fdc  2810              CMP      r0,#0x10              ;593
002fde  d007              BEQ      |L1.12272|
002fe0  2820              CMP      r0,#0x20              ;593
002fe2  d003              BEQ      |L1.12268|
002fe4  2840              CMP      r0,#0x40              ;593
002fe6  d105              BNE      |L1.12276|
002fe8  2500              MOVS     r5,#0                 ;596
002fea  e006              B        |L1.12282|
                  |L1.12268|
002fec  2518              MOVS     r5,#0x18              ;601
002fee  e004              B        |L1.12282|
                  |L1.12272|
002ff0  2518              MOVS     r5,#0x18              ;606
002ff2  e002              B        |L1.12282|
                  |L1.12276|
002ff4  bf00              NOP                            ;610
002ff6  bf00              NOP                            ;610
002ff8  e025              B        |L1.12358|
                  |L1.12282|
002ffa  bf00              NOP                            ;597
002ffc  2100              MOVS     r1,#0                 ;615
002ffe  f104000c          ADD      r0,r4,#0xc            ;615
003002  f7fffffe          BL       sys_sem_new
003006  b100              CBZ      r0,|L1.12298|
003008  e01d              B        |L1.12358|
                  |L1.12298|
00300a  4629              MOV      r1,r5                 ;618
00300c  f1040018          ADD      r0,r4,#0x18           ;618
003010  f7fffffe          BL       sys_mbox_new
003014  b120              CBZ      r0,|L1.12320|
003016  f104000c          ADD      r0,r4,#0xc            ;619
00301a  f7fffffe          BL       sys_sem_free
00301e  e012              B        |L1.12358|
                  |L1.12320|
003020  f10400a0          ADD      r0,r4,#0xa0           ;624
003024  f7fffffe          BL       sys_mbox_set_invalid
003028  2000              MOVS     r0,#0                 ;626
00302a  f10404bc          ADD      r4,r4,#0xbc           ;626
00302e  f8040cbb          STRB     r0,[r4,#-0xbb]        ;626
003032  67e7              STR      r7,[r4,#0x7c]         ;631
003034  67a0              STR      r0,[r4,#0x78]         ;633
003036  6760              STR      r0,[r4,#0x74]         ;634
003038  66e0              STR      r0,[r4,#0x6c]         ;640
00303a  f8840070          STRB     r0,[r4,#0x70]         ;646
00303e  f1a404bc          SUB      r4,r4,#0xbc           ;646
003042  4620              MOV      r0,r4                 ;647
003044  e7c2              B        |L1.12236|
                  |L1.12358|
003046  4621              MOV      r1,r4                 ;649
003048  2006              MOVS     r0,#6                 ;649
00304a  f7fffffe          BL       memp_free
00304e  2000              MOVS     r0,#0                 ;650
003050  e7bc              B        |L1.12236|
;;;652    
                          ENDP

                  netconn_new_with_proto_and_callback PROC
;;;67     struct netconn*
;;;68     netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
003052  b5f0              PUSH     {r4-r7,lr}
;;;69     {
003054  b087              SUB      sp,sp,#0x1c
003056  4607              MOV      r7,r0
003058  460d              MOV      r5,r1
00305a  4616              MOV      r6,r2
;;;70       struct netconn *conn;
;;;71       struct api_msg msg;
;;;72     
;;;73       conn = netconn_alloc(t, callback);
00305c  4631              MOV      r1,r6
00305e  4638              MOV      r0,r7
003060  f7fffffe          BL       netconn_alloc
003064  4604              MOV      r4,r0
;;;74       if (conn != NULL) {
003066  b364              CBZ      r4,|L1.12482|
;;;75         msg.function = do_newconn;
003068  f2af202f          ADR      r0,do_newconn + 1
00306c  9001              STR      r0,[sp,#4]
;;;76         msg.msg.msg.n.proto = proto;
00306e  f88d5010          STRB     r5,[sp,#0x10]
;;;77         msg.msg.conn = conn;
003072  9402              STR      r4,[sp,#8]
;;;78         if (TCPIP_APIMSG(&msg) != ERR_OK) {
003074  a801              ADD      r0,sp,#4
003076  f7fffffe          BL       tcpip_apimsg
00307a  b310              CBZ      r0,|L1.12482|
;;;79           LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
00307c  bf00              NOP      
00307e  bf00              NOP      
;;;80           LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
003080  bf00              NOP      
003082  f104000c          ADD      r0,r4,#0xc
003086  f7fffffe          BL       sys_sem_valid
00308a  bf00              NOP      
;;;81           LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
00308c  bf00              NOP      
00308e  f1040018          ADD      r0,r4,#0x18
003092  f7fffffe          BL       sys_mbox_valid
003096  bf00              NOP      
;;;82     #if LWIP_TCP
;;;83           LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
003098  bf00              NOP      
00309a  f10400a0          ADD      r0,r4,#0xa0
00309e  f7fffffe          BL       sys_mbox_valid
0030a2  bf00              NOP      
;;;84     #endif /* LWIP_TCP */
;;;85           sys_sem_free(&conn->op_completed);
0030a4  f104000c          ADD      r0,r4,#0xc
0030a8  f7fffffe          BL       sys_sem_free
;;;86           sys_mbox_free(&conn->recvmbox);
0030ac  f1040018          ADD      r0,r4,#0x18
0030b0  f7fffffe          BL       sys_mbox_free
;;;87           memp_free(MEMP_NETCONN, conn);
0030b4  4621              MOV      r1,r4
0030b6  2006              MOVS     r0,#6
0030b8  f7fffffe          BL       memp_free
;;;88           return NULL;
0030bc  2000              MOVS     r0,#0
                  |L1.12478|
;;;89         }
;;;90       }
;;;91       return conn;
;;;92     }
0030be  b007              ADD      sp,sp,#0x1c
0030c0  bdf0              POP      {r4-r7,pc}
                  |L1.12482|
0030c2  4620              MOV      r0,r4                 ;91
0030c4  e7fb              B        |L1.12478|
;;;93     
                          ENDP

                  sys_sem_set_invalid PROC
;;;249    
;;;250    void sys_sem_set_invalid(sys_sem_t *sem)
0030c6  2100              MOVS     r1,#0
;;;251    {
;;;252    	sem->queue = SYS_SEM_NULL ;
0030c8  6001              STR      r1,[r0,#0]
;;;253    }
0030ca  4770              BX       lr
;;;254    /**
                          ENDP

                  netconn_free PROC
;;;659    void
;;;660    netconn_free(struct netconn *conn)
0030cc  b510              PUSH     {r4,lr}
;;;661    {
0030ce  4604              MOV      r4,r0
;;;662      LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
0030d0  bf00              NOP      
0030d2  bf00              NOP      
;;;663      LWIP_ASSERT("recvmbox must be deallocated before calling this function",
0030d4  bf00              NOP      
0030d6  f1040018          ADD      r0,r4,#0x18
0030da  f7fffffe          BL       sys_mbox_valid
0030de  bf00              NOP      
;;;664        !sys_mbox_valid(&conn->recvmbox));
;;;665    #if LWIP_TCP
;;;666      LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
0030e0  bf00              NOP      
0030e2  f10400a0          ADD      r0,r4,#0xa0
0030e6  f7fffffe          BL       sys_mbox_valid
0030ea  bf00              NOP      
;;;667        !sys_mbox_valid(&conn->acceptmbox));
;;;668    #endif /* LWIP_TCP */
;;;669    
;;;670      sys_sem_free(&conn->op_completed);
0030ec  f104000c          ADD      r0,r4,#0xc
0030f0  f7fffffe          BL       sys_sem_free
;;;671      sys_sem_set_invalid(&conn->op_completed);
0030f4  f104000c          ADD      r0,r4,#0xc
0030f8  f7fffffe          BL       sys_sem_set_invalid
;;;672    
;;;673      memp_free(MEMP_NETCONN, conn);
0030fc  4621              MOV      r1,r4
0030fe  2006              MOVS     r0,#6
003100  f7fffffe          BL       memp_free
;;;674    }
003104  bd10              POP      {r4,pc}
;;;675    
                          ENDP

                  udp_remove PROC
;;;945    void
;;;946    udp_remove(struct udp_pcb *pcb)
003106  b570              PUSH     {r4-r6,lr}
;;;947    {
003108  4605              MOV      r5,r0
;;;948      struct udp_pcb *pcb2;
;;;949    
;;;950      snmp_delete_udpidx_tree(pcb);
;;;951      /* pcb to be removed is first in list? */
;;;952      if (udp_pcbs == pcb) {
00310a  480c              LDR      r0,|L1.12604|
00310c  6800              LDR      r0,[r0,#0]  ; udp_pcbs
00310e  42a8              CMP      r0,r5
003110  d116              BNE      |L1.12608|
;;;953        /* make list start at 2nd pcb */
;;;954        udp_pcbs = udp_pcbs->next;
003112  480a              LDR      r0,|L1.12604|
003114  6800              LDR      r0,[r0,#0]  ; udp_pcbs
003116  68c0              LDR      r0,[r0,#0xc]
003118  4908              LDR      r1,|L1.12604|
00311a  6008              STR      r0,[r1,#0]  ; udp_pcbs
00311c  e01d              B        |L1.12634|
00311e  0000              DCW      0x0000
                  |L1.12576|
                          DCD      current_iphdr_src
                  |L1.12580|
                          DCD      raw_pcbs
                  |L1.12584|
                          DCD      recv_raw
                  |L1.12588|
                          DCD      recv_udp
                  |L1.12592|
                          DCD      lwip_stats
                  |L1.12596|
                          DCD      mboxes
                  |L1.12600|
                          DCD      sems
                  |L1.12604|
                          DCD      udp_pcbs
                  |L1.12608|
;;;955        /* pcb not 1st in list */
;;;956      } else {
;;;957        for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
003140  48f7              LDR      r0,|L1.13600|
003142  6804              LDR      r4,[r0,#0]  ; udp_pcbs
003144  e007              B        |L1.12630|
                  |L1.12614|
;;;958          /* find pcb in udp_pcbs list */
;;;959          if (pcb2->next != NULL && pcb2->next == pcb) {
003146  68e0              LDR      r0,[r4,#0xc]
003148  b120              CBZ      r0,|L1.12628|
00314a  68e0              LDR      r0,[r4,#0xc]
00314c  42a8              CMP      r0,r5
00314e  d101              BNE      |L1.12628|
;;;960            /* remove pcb from list */
;;;961            pcb2->next = pcb->next;
003150  68e8              LDR      r0,[r5,#0xc]
003152  60e0              STR      r0,[r4,#0xc]
                  |L1.12628|
003154  68e4              LDR      r4,[r4,#0xc]          ;957
                  |L1.12630|
003156  2c00              CMP      r4,#0                 ;957
003158  d1f5              BNE      |L1.12614|
                  |L1.12634|
;;;962          }
;;;963        }
;;;964      }
;;;965      memp_free(MEMP_UDP_PCB, pcb);
00315a  4629              MOV      r1,r5
00315c  2001              MOVS     r0,#1
00315e  f7fffffe          BL       memp_free
;;;966    }
003162  bd70              POP      {r4-r6,pc}
;;;967    
                          ENDP

                  raw_remove PROC
;;;299    void
;;;300    raw_remove(struct raw_pcb *pcb)
003164  b570              PUSH     {r4-r6,lr}
;;;301    {
003166  4605              MOV      r5,r0
;;;302      struct raw_pcb *pcb2;
;;;303      /* pcb to be removed is first in list? */
;;;304      if (raw_pcbs == pcb) {
003168  48ee              LDR      r0,|L1.13604|
00316a  6800              LDR      r0,[r0,#0]  ; raw_pcbs
00316c  42a8              CMP      r0,r5
00316e  d105              BNE      |L1.12668|
;;;305        /* make list start at 2nd pcb */
;;;306        raw_pcbs = raw_pcbs->next;
003170  48ec              LDR      r0,|L1.13604|
003172  6800              LDR      r0,[r0,#0]  ; raw_pcbs
003174  68c0              LDR      r0,[r0,#0xc]
003176  49eb              LDR      r1,|L1.13604|
003178  6008              STR      r0,[r1,#0]  ; raw_pcbs
00317a  e00c              B        |L1.12694|
                  |L1.12668|
;;;307        /* pcb not 1st in list */
;;;308      } else {
;;;309        for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
00317c  48e9              LDR      r0,|L1.13604|
00317e  6804              LDR      r4,[r0,#0]  ; raw_pcbs
003180  e007              B        |L1.12690|
                  |L1.12674|
;;;310          /* find pcb in raw_pcbs list */
;;;311          if (pcb2->next != NULL && pcb2->next == pcb) {
003182  68e0              LDR      r0,[r4,#0xc]
003184  b120              CBZ      r0,|L1.12688|
003186  68e0              LDR      r0,[r4,#0xc]
003188  42a8              CMP      r0,r5
00318a  d101              BNE      |L1.12688|
;;;312            /* remove pcb from list */
;;;313            pcb2->next = pcb->next;
00318c  68e8              LDR      r0,[r5,#0xc]
00318e  60e0              STR      r0,[r4,#0xc]
                  |L1.12688|
003190  68e4              LDR      r4,[r4,#0xc]          ;309
                  |L1.12690|
003192  2c00              CMP      r4,#0                 ;309
003194  d1f5              BNE      |L1.12674|
                  |L1.12694|
;;;314          }
;;;315        }
;;;316      }
;;;317      memp_free(MEMP_RAW_PCB, pcb);
003196  4629              MOV      r1,r5
003198  2000              MOVS     r0,#0
00319a  f7fffffe          BL       memp_free
;;;318    }
00319e  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP

                  sys_arch_mbox_tryfetch PROC
;;;491    u32_t
;;;492    sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
0031a0  b538              PUSH     {r3-r5,lr}
;;;493    {
0031a2  4604              MOV      r4,r0
0031a4  460d              MOV      r5,r1
;;;494      void *dummyptr;
;;;495    
;;;496      /* If the actual message contents are not required, provide a local variable
;;;497         to recieve the message. */
;;;498      if(msg == NULL) {
0031a6  b905              CBNZ     r5,|L1.12714|
;;;499        msg = &dummyptr;
0031a8  466d              MOV      r5,sp
                  |L1.12714|
;;;500      }
;;;501    
;;;502      /* Recieve a message from the queue. */
;;;503      if(xQueueReceive(mbox->queue, msg, 0) == pdPASS) {
0031aa  2300              MOVS     r3,#0
0031ac  461a              MOV      r2,r3
0031ae  4629              MOV      r1,r5
0031b0  6820              LDR      r0,[r4,#0]
0031b2  f7fffffe          BL       xQueueGenericReceive
0031b6  2801              CMP      r0,#1
0031b8  d101              BNE      |L1.12734|
;;;504        /* A message was available. */
;;;505        return ERR_OK;
0031ba  2000              MOVS     r0,#0
                  |L1.12732|
;;;506      } else {
;;;507        /* A message was not available. */
;;;508        return SYS_MBOX_EMPTY;
;;;509      }
;;;510    }
0031bc  bd38              POP      {r3-r5,pc}
                  |L1.12734|
0031be  f04f30ff          MOV      r0,#0xffffffff        ;508
0031c2  e7fb              B        |L1.12732|
;;;511    
                          ENDP

                  netconn_drain PROC
;;;684    static void
;;;685    netconn_drain(struct netconn *conn)
0031c4  b5f8              PUSH     {r3-r7,lr}
;;;686    {
0031c6  4604              MOV      r4,r0
;;;687      void *mem;
;;;688    #if LWIP_TCP
;;;689      struct pbuf *p;
;;;690    #endif /* LWIP_TCP */
;;;691    
;;;692      /* This runs in tcpip_thread, so we don't need to lock against rx packets */
;;;693    
;;;694      /* Delete and drain the recvmbox. */
;;;695      if (sys_mbox_valid(&conn->recvmbox)) {
0031c8  f1040018          ADD      r0,r4,#0x18
0031cc  f7fffffe          BL       sys_mbox_valid
0031d0  b310              CBZ      r0,|L1.12824|
;;;696        while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
0031d2  e012              B        |L1.12794|
                  |L1.12756|
;;;697    #if LWIP_TCP
;;;698          if (conn->type == NETCONN_TCP) {
0031d4  7820              LDRB     r0,[r4,#0]
0031d6  2810              CMP      r0,#0x10
0031d8  d10c              BNE      |L1.12788|
;;;699            if(mem != NULL) {
0031da  9800              LDR      r0,[sp,#0]
0031dc  b168              CBZ      r0,|L1.12794|
;;;700              p = (struct pbuf*)mem;
0031de  9e00              LDR      r6,[sp,#0]
;;;701              /* pcb might be set to NULL already by err_tcp() */
;;;702              if (conn->pcb.tcp != NULL) {
0031e0  6860              LDR      r0,[r4,#4]
0031e2  b118              CBZ      r0,|L1.12780|
;;;703                tcp_recved(conn->pcb.tcp, p->tot_len);
0031e4  8931              LDRH     r1,[r6,#8]
0031e6  6860              LDR      r0,[r4,#4]
0031e8  f7fffffe          BL       tcp_recved
                  |L1.12780|
;;;704              }
;;;705              pbuf_free(p);
0031ec  4630              MOV      r0,r6
0031ee  f7fffffe          BL       pbuf_free
0031f2  e002              B        |L1.12794|
                  |L1.12788|
;;;706            }
;;;707          } else
;;;708    #endif /* LWIP_TCP */
;;;709          {
;;;710            netbuf_delete((struct netbuf *)mem);
0031f4  9800              LDR      r0,[sp,#0]
0031f6  f7fffffe          BL       netbuf_delete
                  |L1.12794|
0031fa  4669              MOV      r1,sp                 ;696
0031fc  f1040018          ADD      r0,r4,#0x18           ;696
003200  f7fffffe          BL       sys_arch_mbox_tryfetch
003204  1c40              ADDS     r0,r0,#1              ;696
003206  d1e5              BNE      |L1.12756|
;;;711          }
;;;712        }
;;;713        sys_mbox_free(&conn->recvmbox);
003208  f1040018          ADD      r0,r4,#0x18
00320c  f7fffffe          BL       sys_mbox_free
;;;714        sys_mbox_set_invalid(&conn->recvmbox);
003210  f1040018          ADD      r0,r4,#0x18
003214  f7fffffe          BL       sys_mbox_set_invalid
                  |L1.12824|
;;;715      }
;;;716    
;;;717      /* Delete and drain the acceptmbox. */
;;;718    #if LWIP_TCP
;;;719      if (sys_mbox_valid(&conn->acceptmbox)) {
003218  f10400a0          ADD      r0,r4,#0xa0
00321c  f7fffffe          BL       sys_mbox_valid
003220  b348              CBZ      r0,|L1.12918|
;;;720        while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
003222  e019              B        |L1.12888|
                  |L1.12836|
;;;721          struct netconn *newconn = (struct netconn *)mem;
003224  9d00              LDR      r5,[sp,#0]
;;;722          /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
;;;723          /* pcb might be set to NULL already by err_tcp() */
;;;724          if (conn->pcb.tcp != NULL) {
003226  6860              LDR      r0,[r4,#4]
003228  b140              CBZ      r0,|L1.12860|
;;;725            tcp_accepted(conn->pcb.tcp);
00322a  bf00              NOP      
00322c  bf00              NOP      
00322e  bf00              NOP      
003230  6860              LDR      r0,[r4,#4]
003232  7f40              LDRB     r0,[r0,#0x1d]
003234  1e40              SUBS     r0,r0,#1
003236  6861              LDR      r1,[r4,#4]
003238  7748              STRB     r0,[r1,#0x1d]
00323a  bf00              NOP      
                  |L1.12860|
;;;726          }
;;;727          /* drain recvmbox */
;;;728          netconn_drain(newconn);
00323c  4628              MOV      r0,r5
00323e  f7fffffe          BL       netconn_drain
;;;729          if (newconn->pcb.tcp != NULL) {
003242  6868              LDR      r0,[r5,#4]
003244  b120              CBZ      r0,|L1.12880|
;;;730            tcp_abort(newconn->pcb.tcp);
003246  6868              LDR      r0,[r5,#4]
003248  f7fffffe          BL       tcp_abort
;;;731            newconn->pcb.tcp = NULL;
00324c  2000              MOVS     r0,#0
00324e  6068              STR      r0,[r5,#4]
                  |L1.12880|
;;;732          }
;;;733          netconn_free(newconn);
003250  4628              MOV      r0,r5
003252  f7fffffe          BL       netconn_free
;;;734        }
003256  bf00              NOP      
                  |L1.12888|
003258  4669              MOV      r1,sp                 ;720
00325a  f10400a0          ADD      r0,r4,#0xa0           ;720
00325e  f7fffffe          BL       sys_arch_mbox_tryfetch
003262  1c40              ADDS     r0,r0,#1              ;720
003264  d1de              BNE      |L1.12836|
;;;735        sys_mbox_free(&conn->acceptmbox);
003266  f10400a0          ADD      r0,r4,#0xa0
00326a  f7fffffe          BL       sys_mbox_free
;;;736        sys_mbox_set_invalid(&conn->acceptmbox);
00326e  f10400a0          ADD      r0,r4,#0xa0
003272  f7fffffe          BL       sys_mbox_set_invalid
                  |L1.12918|
;;;737      }
;;;738    #endif /* LWIP_TCP */
;;;739    }
003276  bdf8              POP      {r3-r7,pc}
;;;740    
                          ENDP

                  do_delconn PROC
;;;834    void
;;;835    do_delconn(struct api_msg_msg *msg)
003278  b510              PUSH     {r4,lr}
;;;836    {
00327a  4604              MOV      r4,r0
;;;837      /* @todo TCP: abort running write/connect? */
;;;838     if ((msg->conn->state != NETCONN_NONE) &&
00327c  6820              LDR      r0,[r4,#0]
00327e  7840              LDRB     r0,[r0,#1]
003280  b160              CBZ      r0,|L1.12956|
;;;839         (msg->conn->state != NETCONN_LISTEN) &&
003282  6820              LDR      r0,[r4,#0]
003284  7840              LDRB     r0,[r0,#1]
003286  2802              CMP      r0,#2
003288  d008              BEQ      |L1.12956|
;;;840         (msg->conn->state != NETCONN_CONNECT)) {
00328a  6820              LDR      r0,[r4,#0]
00328c  7840              LDRB     r0,[r0,#1]
00328e  2803              CMP      r0,#3
003290  d004              BEQ      |L1.12956|
;;;841        /* this only happens for TCP netconns */
;;;842        LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
003292  bf00              NOP      
003294  bf00              NOP      
;;;843        msg->err = ERR_INPROGRESS;
003296  20fb              MOVS     r0,#0xfb
003298  7120              STRB     r0,[r4,#4]
00329a  e046              B        |L1.13098|
                  |L1.12956|
;;;844      } else {
;;;845        LWIP_ASSERT("blocking connect in progress",
00329c  bf00              NOP      
00329e  bf00              NOP      
;;;846          (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
;;;847        /* Drain and delete mboxes */
;;;848        netconn_drain(msg->conn);
0032a0  6820              LDR      r0,[r4,#0]
0032a2  f7fffffe          BL       netconn_drain
;;;849    
;;;850        if (msg->conn->pcb.tcp != NULL) {
0032a6  6820              LDR      r0,[r4,#0]
0032a8  6840              LDR      r0,[r0,#4]
0032aa  b350              CBZ      r0,|L1.13058|
;;;851    
;;;852          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
0032ac  6820              LDR      r0,[r4,#0]
0032ae  7800              LDRB     r0,[r0,#0]
0032b0  f00000f0          AND      r0,r0,#0xf0
0032b4  2810              CMP      r0,#0x10
0032b6  d011              BEQ      |L1.13020|
0032b8  2820              CMP      r0,#0x20
0032ba  d006              BEQ      |L1.13002|
0032bc  2840              CMP      r0,#0x40
0032be  d11b              BNE      |L1.13048|
;;;853    #if LWIP_RAW
;;;854          case NETCONN_RAW:
;;;855            raw_remove(msg->conn->pcb.raw);
0032c0  6821              LDR      r1,[r4,#0]
0032c2  6848              LDR      r0,[r1,#4]
0032c4  f7fffffe          BL       raw_remove
;;;856            break;
0032c8  e017              B        |L1.13050|
                  |L1.13002|
;;;857    #endif /* LWIP_RAW */
;;;858    #if LWIP_UDP
;;;859          case NETCONN_UDP:
;;;860            msg->conn->pcb.udp->recv_arg = NULL;
0032ca  2000              MOVS     r0,#0
0032cc  6821              LDR      r1,[r4,#0]
0032ce  6849              LDR      r1,[r1,#4]
0032d0  6208              STR      r0,[r1,#0x20]
;;;861            udp_remove(msg->conn->pcb.udp);
0032d2  6821              LDR      r1,[r4,#0]
0032d4  6848              LDR      r0,[r1,#4]
0032d6  f7fffffe          BL       udp_remove
;;;862            break;
0032da  e00e              B        |L1.13050|
                  |L1.13020|
;;;863    #endif /* LWIP_UDP */
;;;864    #if LWIP_TCP
;;;865          case NETCONN_TCP:
;;;866            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
0032dc  bf00              NOP      
0032de  bf00              NOP      
;;;867              msg->conn->write_offset == 0);
;;;868            msg->conn->state = NETCONN_CLOSE;
0032e0  2004              MOVS     r0,#4
0032e2  6821              LDR      r1,[r4,#0]
0032e4  7048              STRB     r0,[r1,#1]
;;;869            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
0032e6  2003              MOVS     r0,#3
0032e8  7220              STRB     r0,[r4,#8]
;;;870            msg->conn->current_msg = msg;
0032ea  6820              LDR      r0,[r4,#0]
0032ec  f8c04134          STR      r4,[r0,#0x134]
;;;871            do_close_internal(msg->conn);
0032f0  6820              LDR      r0,[r4,#0]
0032f2  f7fffffe          BL       do_close_internal
                  |L1.13046|
;;;872            /* API_EVENT is called inside do_close_internal, before releasing
;;;873               the application thread, so we can return at this point! */
;;;874            return;
;;;875    #endif /* LWIP_TCP */
;;;876          default:
;;;877            break;
;;;878          }
;;;879          msg->conn->pcb.tcp = NULL;
;;;880        }
;;;881        /* tcp netconns don't come here! */
;;;882    
;;;883        /* @todo: this lets select make the socket readable and writable,
;;;884           which is wrong! errfd instead? */
;;;885        API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
;;;886        API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
;;;887      }
;;;888      if (sys_sem_valid(&msg->conn->op_completed)) {
;;;889        sys_sem_signal(&msg->conn->op_completed);
;;;890      }
;;;891    }
0032f6  bd10              POP      {r4,pc}
                  |L1.13048|
0032f8  bf00              NOP                            ;877
                  |L1.13050|
0032fa  bf00              NOP                            ;856
0032fc  2000              MOVS     r0,#0                 ;879
0032fe  6821              LDR      r1,[r4,#0]            ;879
003300  6048              STR      r0,[r1,#4]            ;879
                  |L1.13058|
003302  6820              LDR      r0,[r4,#0]            ;885
003304  f8d00138          LDR      r0,[r0,#0x138]        ;885
003308  b128              CBZ      r0,|L1.13078|
00330a  6820              LDR      r0,[r4,#0]            ;885
00330c  2200              MOVS     r2,#0                 ;885
00330e  4611              MOV      r1,r2                 ;885
003310  f8d03138          LDR      r3,[r0,#0x138]        ;885
003314  4798              BLX      r3                    ;885
                  |L1.13078|
003316  6820              LDR      r0,[r4,#0]            ;886
003318  f8d00138          LDR      r0,[r0,#0x138]        ;886
00331c  b128              CBZ      r0,|L1.13098|
00331e  6820              LDR      r0,[r4,#0]            ;886
003320  2200              MOVS     r2,#0                 ;886
003322  2102              MOVS     r1,#2                 ;886
003324  f8d03138          LDR      r3,[r0,#0x138]        ;886
003328  4798              BLX      r3                    ;886
                  |L1.13098|
00332a  6821              LDR      r1,[r4,#0]            ;888
00332c  f101000c          ADD      r0,r1,#0xc            ;888
003330  f7fffffe          BL       sys_sem_valid
003334  b120              CBZ      r0,|L1.13120|
003336  6821              LDR      r1,[r4,#0]            ;889
003338  f101000c          ADD      r0,r1,#0xc            ;889
00333c  f7fffffe          BL       sys_sem_signal
                  |L1.13120|
003340  bf00              NOP      
003342  e7d8              B        |L1.13046|
;;;892    
                          ENDP

                  netconn_delete PROC
;;;102    err_t
;;;103    netconn_delete(struct netconn *conn)
003344  b510              PUSH     {r4,lr}
;;;104    {
003346  b086              SUB      sp,sp,#0x18
003348  4604              MOV      r4,r0
;;;105      struct api_msg msg;
;;;106    
;;;107      /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
;;;108      if (conn == NULL) {
00334a  b914              CBNZ     r4,|L1.13138|
;;;109        return ERR_OK;
00334c  2000              MOVS     r0,#0
                  |L1.13134|
;;;110      }
;;;111    
;;;112      msg.function = do_delconn;
;;;113      msg.msg.conn = conn;
;;;114      tcpip_apimsg(&msg);
;;;115    
;;;116      netconn_free(conn);
;;;117    
;;;118      /* don't care for return value of do_delconn since it only calls void functions */
;;;119    
;;;120      return ERR_OK;
;;;121    }
00334e  b006              ADD      sp,sp,#0x18
003350  bd10              POP      {r4,pc}
                  |L1.13138|
003352  f2af00db          ADR      r0,do_delconn + 1
003356  9000              STR      r0,[sp,#0]            ;112
003358  9401              STR      r4,[sp,#4]            ;113
00335a  4668              MOV      r0,sp                 ;114
00335c  f7fffffe          BL       tcpip_apimsg
003360  4620              MOV      r0,r4                 ;116
003362  f7fffffe          BL       netconn_free
003366  2000              MOVS     r0,#0                 ;120
003368  e7f1              B        |L1.13134|
;;;122    
                          ENDP

                  do_getaddr PROC
;;;1400   void
;;;1401   do_getaddr(struct api_msg_msg *msg)
00336a  b510              PUSH     {r4,lr}
;;;1402   {
00336c  4604              MOV      r4,r0
;;;1403     if (msg->conn->pcb.ip != NULL) {
00336e  6820              LDR      r0,[r4,#0]
003370  6840              LDR      r0,[r0,#4]
003372  2800              CMP      r0,#0
003374  d04a              BEQ      |L1.13324|
;;;1404       *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
003376  7c20              LDRB     r0,[r4,#0x10]
003378  b128              CBZ      r0,|L1.13190|
00337a  6821              LDR      r1,[r4,#0]
00337c  68a0              LDR      r0,[r4,#8]
00337e  6849              LDR      r1,[r1,#4]
003380  6809              LDR      r1,[r1,#0]
003382  6001              STR      r1,[r0,#0]
003384  e004              B        |L1.13200|
                  |L1.13190|
003386  6821              LDR      r1,[r4,#0]
003388  68a0              LDR      r0,[r4,#8]
00338a  6849              LDR      r1,[r1,#4]
00338c  6849              LDR      r1,[r1,#4]
00338e  6001              STR      r1,[r0,#0]
                  |L1.13200|
;;;1405                                msg->conn->pcb.ip->remote_ip);
;;;1406   
;;;1407       msg->err = ERR_OK;
003390  2000              MOVS     r0,#0
003392  7120              STRB     r0,[r4,#4]
;;;1408       switch (NETCONNTYPE_GROUP(msg->conn->type)) {
003394  6820              LDR      r0,[r4,#0]
003396  7800              LDRB     r0,[r0,#0]
003398  f00000f0          AND      r0,r0,#0xf0
00339c  2810              CMP      r0,#0x10
00339e  d025              BEQ      |L1.13292|
0033a0  2820              CMP      r0,#0x20
0033a2  d00c              BEQ      |L1.13246|
0033a4  2840              CMP      r0,#0x40
0033a6  d12d              BNE      |L1.13316|
;;;1409   #if LWIP_RAW
;;;1410       case NETCONN_RAW:
;;;1411         if (msg->msg.ad.local) {
0033a8  7c20              LDRB     r0,[r4,#0x10]
0033aa  b128              CBZ      r0,|L1.13240|
;;;1412           *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
0033ac  6820              LDR      r0,[r4,#0]
0033ae  6840              LDR      r0,[r0,#4]
0033b0  7c01              LDRB     r1,[r0,#0x10]
0033b2  68e0              LDR      r0,[r4,#0xc]
0033b4  8001              STRH     r1,[r0,#0]
0033b6  e001              B        |L1.13244|
                  |L1.13240|
;;;1413         } else {
;;;1414           /* return an error as connecting is only a helper for upper layers */
;;;1415           msg->err = ERR_CONN;
0033b8  20f3              MOVS     r0,#0xf3
0033ba  7120              STRB     r0,[r4,#4]
                  |L1.13244|
;;;1416         }
;;;1417         break;
0033bc  e025              B        |L1.13322|
                  |L1.13246|
;;;1418   #endif /* LWIP_RAW */
;;;1419   #if LWIP_UDP
;;;1420       case NETCONN_UDP:
;;;1421         if (msg->msg.ad.local) {
0033be  7c20              LDRB     r0,[r4,#0x10]
0033c0  b128              CBZ      r0,|L1.13262|
;;;1422           *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
0033c2  6820              LDR      r0,[r4,#0]
0033c4  6840              LDR      r0,[r0,#4]
0033c6  8a41              LDRH     r1,[r0,#0x12]
0033c8  68e0              LDR      r0,[r4,#0xc]
0033ca  8001              STRH     r1,[r0,#0]
0033cc  e00d              B        |L1.13290|
                  |L1.13262|
;;;1423         } else {
;;;1424           if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
0033ce  6820              LDR      r0,[r4,#0]
0033d0  6840              LDR      r0,[r0,#4]
0033d2  7c00              LDRB     r0,[r0,#0x10]
0033d4  f0100f04          TST      r0,#4
0033d8  d102              BNE      |L1.13280|
;;;1425             msg->err = ERR_CONN;
0033da  20f3              MOVS     r0,#0xf3
0033dc  7120              STRB     r0,[r4,#4]
0033de  e004              B        |L1.13290|
                  |L1.13280|
;;;1426           } else {
;;;1427             *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
0033e0  6820              LDR      r0,[r4,#0]
0033e2  6840              LDR      r0,[r0,#4]
0033e4  8a81              LDRH     r1,[r0,#0x14]
0033e6  68e0              LDR      r0,[r4,#0xc]
0033e8  8001              STRH     r1,[r0,#0]
                  |L1.13290|
;;;1428           }
;;;1429         }
;;;1430         break;
0033ea  e00e              B        |L1.13322|
                  |L1.13292|
;;;1431   #endif /* LWIP_UDP */
;;;1432   #if LWIP_TCP
;;;1433       case NETCONN_TCP:
;;;1434         *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
0033ec  7c20              LDRB     r0,[r4,#0x10]
0033ee  b118              CBZ      r0,|L1.13304|
0033f0  6820              LDR      r0,[r4,#0]
0033f2  6840              LDR      r0,[r0,#4]
0033f4  8b40              LDRH     r0,[r0,#0x1a]
0033f6  e002              B        |L1.13310|
                  |L1.13304|
0033f8  6820              LDR      r0,[r4,#0]
0033fa  6840              LDR      r0,[r0,#4]
0033fc  8b80              LDRH     r0,[r0,#0x1c]
                  |L1.13310|
0033fe  68e1              LDR      r1,[r4,#0xc]
003400  8008              STRH     r0,[r1,#0]
;;;1435         break;
003402  e002              B        |L1.13322|
                  |L1.13316|
;;;1436   #endif /* LWIP_TCP */
;;;1437       default:
;;;1438         LWIP_ASSERT("invalid netconn_type", 0);
003404  bf00              NOP      
003406  bf00              NOP      
;;;1439         break;
003408  bf00              NOP      
                  |L1.13322|
00340a  e001              B        |L1.13328|
                  |L1.13324|
;;;1440       }
;;;1441     } else {
;;;1442       msg->err = ERR_CONN;
00340c  20f3              MOVS     r0,#0xf3
00340e  7120              STRB     r0,[r4,#4]
                  |L1.13328|
;;;1443     }
;;;1444     TCPIP_APIMSG_ACK(msg);
003410  6821              LDR      r1,[r4,#0]
003412  f101000c          ADD      r0,r1,#0xc
003416  f7fffffe          BL       sys_sem_signal
;;;1445   }
00341a  bd10              POP      {r4,pc}
;;;1446   
                          ENDP

                  netconn_getaddr PROC
;;;134    err_t
;;;135    netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
00341c  e92d43f0          PUSH     {r4-r9,lr}
;;;136    {
003420  b087              SUB      sp,sp,#0x1c
003422  4604              MOV      r4,r0
003424  460d              MOV      r5,r1
003426  4616              MOV      r6,r2
003428  4698              MOV      r8,r3
;;;137      struct api_msg msg;
;;;138      err_t err;
;;;139    
;;;140      LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
00342a  bf00              NOP      
00342c  b924              CBNZ     r4,|L1.13368|
00342e  f06f000d          MVN      r0,#0xd
                  |L1.13362|
;;;141      LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
;;;142      LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
;;;143    
;;;144      msg.function = do_getaddr;
;;;145      msg.msg.conn = conn;
;;;146      msg.msg.msg.ad.ipaddr = addr;
;;;147      msg.msg.msg.ad.port = port;
;;;148      msg.msg.msg.ad.local = local;
;;;149      err = TCPIP_APIMSG(&msg);
;;;150    
;;;151      NETCONN_SET_SAFE_ERR(conn, err);
;;;152      return err;
;;;153    }
003432  b007              ADD      sp,sp,#0x1c
003434  e8bd83f0          POP      {r4-r9,pc}
                  |L1.13368|
003438  bf00              NOP                            ;140
00343a  bf00              NOP                            ;141
00343c  b915              CBNZ     r5,|L1.13380|
00343e  f06f000d          MVN      r0,#0xd               ;141
003442  e7f6              B        |L1.13362|
                  |L1.13380|
003444  bf00              NOP                            ;141
003446  bf00              NOP                            ;142
003448  b916              CBNZ     r6,|L1.13392|
00344a  f06f000d          MVN      r0,#0xd               ;142
00344e  e7f0              B        |L1.13362|
                  |L1.13392|
003450  bf00              NOP                            ;142
003452  f2af00e9          ADR      r0,do_getaddr + 1
003456  9001              STR      r0,[sp,#4]            ;144
003458  9402              STR      r4,[sp,#8]            ;145
00345a  9504              STR      r5,[sp,#0x10]         ;146
00345c  9605              STR      r6,[sp,#0x14]         ;147
00345e  f88d8018          STRB     r8,[sp,#0x18]         ;148
003462  a801              ADD      r0,sp,#4              ;149
003464  f7fffffe          BL       tcpip_apimsg
003468  4607              MOV      r7,r0                 ;149
00346a  bf00              NOP                            ;151
00346c  f7fffffe          BL       sys_arch_protect
003470  4681              MOV      r9,r0                 ;151
003472  f9940008          LDRSB    r0,[r4,#8]            ;151
003476  f1100f09          CMN      r0,#9                 ;151
00347a  db00              BLT      |L1.13438|
00347c  7227              STRB     r7,[r4,#8]            ;151
                  |L1.13438|
00347e  4648              MOV      r0,r9                 ;151
003480  f7fffffe          BL       sys_arch_unprotect
003484  bf00              NOP                            ;151
003486  4638              MOV      r0,r7                 ;152
003488  e7d3              B        |L1.13362|
;;;154    
                          ENDP

                  tcp_new_port PROC
;;;648    static u16_t
;;;649    tcp_new_port(void)
00348a  b530              PUSH     {r4,r5,lr}
;;;650    {
;;;651      u8_t i;
;;;652      u16_t n = 0;
00348c  2300              MOVS     r3,#0
;;;653      struct tcp_pcb *pcb;
;;;654      
;;;655    again:
00348e  bf00              NOP      
                  |L1.13456|
;;;656      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
003490  4825              LDR      r0,|L1.13608|
003492  8804              LDRH     r4,[r0,#0]  ; tcp_port
003494  8800              LDRH     r0,[r0,#0]  ; tcp_port
003496  1c40              ADDS     r0,r0,#1
003498  4d23              LDR      r5,|L1.13608|
00349a  8028              STRH     r0,[r5,#0]
00349c  f5a4407f          SUB      r0,r4,#0xff00
0034a0  38ff              SUBS     r0,r0,#0xff
0034a2  d103              BNE      |L1.13484|
;;;657        tcp_port = TCP_LOCAL_PORT_RANGE_START;
0034a4  f44f4040          MOV      r0,#0xc000
0034a8  462c              MOV      r4,r5
0034aa  8020              STRH     r0,[r4,#0]
                  |L1.13484|
;;;658      }
;;;659      /* Check all PCB lists. */
;;;660      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
0034ac  2100              MOVS     r1,#0
0034ae  e017              B        |L1.13536|
                  |L1.13488|
;;;661        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
0034b0  481e              LDR      r0,|L1.13612|
0034b2  f8500021          LDR      r0,[r0,r1,LSL #2]
0034b6  6802              LDR      r2,[r0,#0]
0034b8  e00e              B        |L1.13528|
                  |L1.13498|
;;;662          if (pcb->local_port == tcp_port) {
0034ba  8b50              LDRH     r0,[r2,#0x1a]
0034bc  4c1a              LDR      r4,|L1.13608|
0034be  8824              LDRH     r4,[r4,#0]  ; tcp_port
0034c0  42a0              CMP      r0,r4
0034c2  d108              BNE      |L1.13526|
;;;663            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
0034c4  1c58              ADDS     r0,r3,#1
0034c6  b280              UXTH     r0,r0
0034c8  4603              MOV      r3,r0
0034ca  f5b04f80          CMP      r0,#0x4000
0034ce  db01              BLT      |L1.13524|
;;;664              return 0;
0034d0  2000              MOVS     r0,#0
                  |L1.13522|
;;;665            }
;;;666            goto again;
;;;667          }
;;;668        }
;;;669      }
;;;670      return tcp_port;
;;;671    }
0034d2  bd30              POP      {r4,r5,pc}
                  |L1.13524|
0034d4  e7dc              B        |L1.13456|
                  |L1.13526|
0034d6  68d2              LDR      r2,[r2,#0xc]          ;661
                  |L1.13528|
0034d8  2a00              CMP      r2,#0                 ;661
0034da  d1ee              BNE      |L1.13498|
0034dc  1c48              ADDS     r0,r1,#1              ;660
0034de  b2c1              UXTB     r1,r0                 ;660
                  |L1.13536|
0034e0  2904              CMP      r1,#4                 ;660
0034e2  dbe5              BLT      |L1.13488|
0034e4  4810              LDR      r0,|L1.13608|
0034e6  8800              LDRH     r0,[r0,#0]            ;670  ; tcp_port
0034e8  e7f3              B        |L1.13522|
;;;672    
                          ENDP

                  tcp_bind PROC
;;;434    err_t
;;;435    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
0034ea  e92d47f0          PUSH     {r4-r10,lr}
;;;436    {
0034ee  4605              MOV      r5,r0
0034f0  460c              MOV      r4,r1
0034f2  4617              MOV      r7,r2
;;;437      int i;
;;;438      int max_pcb_list = NUM_TCP_PCB_LISTS;
0034f4  f04f0904          MOV      r9,#4
;;;439      struct tcp_pcb *cpcb;
;;;440    
;;;441      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
0034f8  bf00              NOP      
0034fa  7e28              LDRB     r0,[r5,#0x18]
0034fc  b118              CBZ      r0,|L1.13574|
0034fe  f06f0005          MVN      r0,#5
                  |L1.13570|
;;;442    
;;;443    #if SO_REUSE
;;;444      /* Unless the REUSEADDR flag is set,
;;;445         we have to check the pcbs in TIME-WAIT state, also.
;;;446         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;447         packets using both local and remote IP addresses and ports to distinguish.
;;;448       */
;;;449      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;450        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;451      }
;;;452    #endif /* SO_REUSE */
;;;453    
;;;454      if (port == 0) {
;;;455        port = tcp_new_port();
;;;456        if (port == 0) {
;;;457          return ERR_BUF;
;;;458        }
;;;459      }
;;;460    
;;;461      /* Check if the address already is in use (on all lists) */
;;;462      for (i = 0; i < max_pcb_list; i++) {
;;;463        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;464          if (cpcb->local_port == port) {
;;;465    #if SO_REUSE
;;;466            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;467               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;468               tcp_connect. */
;;;469            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;470                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;471    #endif /* SO_REUSE */
;;;472            {
;;;473              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;474                  ip_addr_isany(ipaddr) ||
;;;475                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;476                return ERR_USE;
;;;477              }
;;;478            }
;;;479          }
;;;480        }
;;;481      }
;;;482    
;;;483      if (!ip_addr_isany(ipaddr)) {
;;;484        pcb->local_ip = *ipaddr;
;;;485      }
;;;486      pcb->local_port = port;
;;;487      TCP_REG(&tcp_bound_pcbs, pcb);
;;;488      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;489      return ERR_OK;
;;;490    }
003502  e8bd87f0          POP      {r4-r10,pc}
                  |L1.13574|
003506  bf00              NOP                            ;441
003508  b937              CBNZ     r7,|L1.13592|
00350a  f7fffffe          BL       tcp_new_port
00350e  4607              MOV      r7,r0                 ;455
003510  b917              CBNZ     r7,|L1.13592|
003512  f06f0001          MVN      r0,#1                 ;457
003516  e7f4              B        |L1.13570|
                  |L1.13592|
003518  f04f0800          MOV      r8,#0                 ;462
00351c  e022              B        |L1.13668|
00351e  0000              DCW      0x0000
                  |L1.13600|
                          DCD      udp_pcbs
                  |L1.13604|
                          DCD      raw_pcbs
                  |L1.13608|
                          DCD      tcp_port
                  |L1.13612|
                          DCD      tcp_pcb_lists
                  |L1.13616|
003530  48fe              LDR      r0,|L1.14636|
003532  f8500028          LDR      r0,[r0,r8,LSL #2]     ;463
003536  6806              LDR      r6,[r0,#0]            ;463
003538  e010              B        |L1.13660|
                  |L1.13626|
00353a  8b70              LDRH     r0,[r6,#0x1a]         ;464
00353c  42b8              CMP      r0,r7                 ;464
00353e  d10c              BNE      |L1.13658|
003540  b146              CBZ      r6,|L1.13652|
003542  6830              LDR      r0,[r6,#0]            ;473
003544  b130              CBZ      r0,|L1.13652|
003546  b12c              CBZ      r4,|L1.13652|
003548  6820              LDR      r0,[r4,#0]            ;474
00354a  b118              CBZ      r0,|L1.13652|
00354c  6830              LDR      r0,[r6,#0]            ;475
00354e  6821              LDR      r1,[r4,#0]            ;475
003550  4288              CMP      r0,r1                 ;475
003552  d102              BNE      |L1.13658|
                  |L1.13652|
003554  f06f0007          MVN      r0,#7                 ;476
003558  e7d3              B        |L1.13570|
                  |L1.13658|
00355a  68f6              LDR      r6,[r6,#0xc]          ;463
                  |L1.13660|
00355c  2e00              CMP      r6,#0                 ;463
00355e  d1ec              BNE      |L1.13626|
003560  f1080801          ADD      r8,r8,#1              ;462
                  |L1.13668|
003564  45c8              CMP      r8,r9                 ;462
003566  dbe3              BLT      |L1.13616|
003568  b11c              CBZ      r4,|L1.13682|
00356a  6820              LDR      r0,[r4,#0]            ;483
00356c  b108              CBZ      r0,|L1.13682|
00356e  6820              LDR      r0,[r4,#0]            ;484
003570  6028              STR      r0,[r5,#0]            ;484
                  |L1.13682|
003572  836f              STRH     r7,[r5,#0x1a]         ;486
003574  bf00              NOP                            ;487
003576  48ee              LDR      r0,|L1.14640|
003578  6800              LDR      r0,[r0,#0]            ;487  ; tcp_bound_pcbs
00357a  60e8              STR      r0,[r5,#0xc]          ;487
00357c  48ec              LDR      r0,|L1.14640|
00357e  6005              STR      r5,[r0,#0]            ;487  ; tcp_bound_pcbs
003580  f7fffffe          BL       tcp_timer_needed
003584  bf00              NOP                            ;487
003586  bf00              NOP                            ;488
003588  bf00              NOP                            ;488
00358a  2000              MOVS     r0,#0                 ;489
00358c  e7b9              B        |L1.13570|
;;;491    #if LWIP_CALLBACK_API
                          ENDP

                  udp_new_port PROC
;;;98     static u16_t
;;;99     udp_new_port(void)
00358e  b510              PUSH     {r4,lr}
;;;100    {
;;;101      u16_t n = 0;
003590  2200              MOVS     r2,#0
;;;102      struct udp_pcb *pcb;
;;;103      
;;;104    again:
003592  bf00              NOP      
                  |L1.13716|
;;;105      if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
003594  48e7              LDR      r0,|L1.14644|
003596  8803              LDRH     r3,[r0,#0]  ; udp_port
003598  8800              LDRH     r0,[r0,#0]  ; udp_port
00359a  1c40              ADDS     r0,r0,#1
00359c  4ce5              LDR      r4,|L1.14644|
00359e  8020              STRH     r0,[r4,#0]
0035a0  f5a3407f          SUB      r0,r3,#0xff00
0035a4  38ff              SUBS     r0,r0,#0xff
0035a6  d103              BNE      |L1.13744|
;;;106        udp_port = UDP_LOCAL_PORT_RANGE_START;
0035a8  f44f4040          MOV      r0,#0xc000
0035ac  4623              MOV      r3,r4
0035ae  8018              STRH     r0,[r3,#0]
                  |L1.13744|
;;;107      }
;;;108      /* Check all PCBs. */
;;;109      for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
0035b0  48e1              LDR      r0,|L1.14648|
0035b2  6801              LDR      r1,[r0,#0]  ; udp_pcbs
0035b4  e00e              B        |L1.13780|
                  |L1.13750|
;;;110        if (pcb->local_port == udp_port) {
0035b6  8a48              LDRH     r0,[r1,#0x12]
0035b8  4bde              LDR      r3,|L1.14644|
0035ba  881b              LDRH     r3,[r3,#0]  ; udp_port
0035bc  4298              CMP      r0,r3
0035be  d108              BNE      |L1.13778|
;;;111          if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
0035c0  1c50              ADDS     r0,r2,#1
0035c2  b280              UXTH     r0,r0
0035c4  4602              MOV      r2,r0
0035c6  f5b04f80          CMP      r0,#0x4000
0035ca  db01              BLT      |L1.13776|
;;;112            return 0;
0035cc  2000              MOVS     r0,#0
                  |L1.13774|
;;;113          }
;;;114          goto again;
;;;115        }
;;;116      }
;;;117      return udp_port;
;;;118    #if 0
;;;119      struct udp_pcb *ipcb = udp_pcbs;
;;;120      while ((ipcb != NULL) && (udp_port != UDP_LOCAL_PORT_RANGE_END)) {
;;;121        if (ipcb->local_port == udp_port) {
;;;122          /* port is already used by another udp_pcb */
;;;123          udp_port++;
;;;124          /* restart scanning all udp pcbs */
;;;125          ipcb = udp_pcbs;
;;;126        } else {
;;;127          /* go on with next udp pcb */
;;;128          ipcb = ipcb->next;
;;;129        }
;;;130      }
;;;131      if (ipcb != NULL) {
;;;132        return 0;
;;;133      }
;;;134      return udp_port;
;;;135    #endif
;;;136    }
0035ce  bd10              POP      {r4,pc}
                  |L1.13776|
0035d0  e7e0              B        |L1.13716|
                  |L1.13778|
0035d2  68c9              LDR      r1,[r1,#0xc]          ;109
                  |L1.13780|
0035d4  2900              CMP      r1,#0                 ;109
0035d6  d1ee              BNE      |L1.13750|
0035d8  48d6              LDR      r0,|L1.14644|
0035da  8800              LDRH     r0,[r0,#0]            ;117  ; udp_port
0035dc  e7f7              B        |L1.13774|
;;;137    
                          ENDP

                  udp_bind PROC
;;;765    err_t
;;;766    udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
0035de  e92d41f0          PUSH     {r4-r8,lr}
;;;767    {
0035e2  4605              MOV      r5,r0
0035e4  460e              MOV      r6,r1
0035e6  4617              MOV      r7,r2
;;;768      struct udp_pcb *ipcb;
;;;769      u8_t rebind;
;;;770    
;;;771      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
0035e8  bf00              NOP      
0035ea  bf00              NOP      
;;;772      ip_addr_debug_print(UDP_DEBUG, ipaddr);
0035ec  bf00              NOP      
0035ee  bf00              NOP      
;;;773      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
0035f0  bf00              NOP      
0035f2  bf00              NOP      
;;;774    
;;;775      rebind = 0;
0035f4  f04f0800          MOV      r8,#0
;;;776      /* Check for double bind and rebind of the same pcb */
;;;777      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
0035f8  48cf              LDR      r0,|L1.14648|
0035fa  6804              LDR      r4,[r0,#0]  ; udp_pcbs
0035fc  e01a              B        |L1.13876|
                  |L1.13822|
;;;778        /* is this UDP PCB already on active list? */
;;;779        if (pcb == ipcb) {
0035fe  42a5              CMP      r5,r4
003600  d104              BNE      |L1.13836|
;;;780          /* pcb may occur at most once in active list */
;;;781          LWIP_ASSERT("rebind == 0", rebind == 0);
003602  bf00              NOP      
003604  bf00              NOP      
;;;782          /* pcb already in list, just rebind */
;;;783          rebind = 1;
003606  f04f0801          MOV      r8,#1
00360a  e012              B        |L1.13874|
                  |L1.13836|
;;;784        }
;;;785    
;;;786        /* By default, we don't allow to bind to a port that any other udp
;;;787           PCB is alread bound to, unless *all* PCBs with that port have tha
;;;788           REUSEADDR flag set. */
;;;789    #if SO_REUSE
;;;790        else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
;;;791                 !ip_get_option(ipcb, SOF_REUSEADDR)) {
;;;792    #else /* SO_REUSE */
;;;793        /* port matches that of PCB in list and REUSEADDR not set -> reject */
;;;794        else {
;;;795    #endif /* SO_REUSE */
;;;796          if ((ipcb->local_port == port) &&
00360c  8a60              LDRH     r0,[r4,#0x12]
00360e  42b8              CMP      r0,r7
003610  d10f              BNE      |L1.13874|
;;;797              /* IP address matches, or one is IP_ADDR_ANY? */
;;;798              (ip_addr_isany(&(ipcb->local_ip)) ||
003612  b144              CBZ      r4,|L1.13862|
003614  6820              LDR      r0,[r4,#0]
003616  b130              CBZ      r0,|L1.13862|
;;;799               ip_addr_isany(ipaddr) ||
003618  b12e              CBZ      r6,|L1.13862|
00361a  6830              LDR      r0,[r6,#0]
00361c  b118              CBZ      r0,|L1.13862|
;;;800               ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
00361e  6820              LDR      r0,[r4,#0]
003620  6831              LDR      r1,[r6,#0]
003622  4288              CMP      r0,r1
003624  d105              BNE      |L1.13874|
                  |L1.13862|
;;;801            /* other PCB already binds to this local IP and port */
;;;802            LWIP_DEBUGF(UDP_DEBUG,
003626  bf00              NOP      
003628  bf00              NOP      
;;;803                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
;;;804            return ERR_USE;
00362a  f06f0007          MVN      r0,#7
                  |L1.13870|
;;;805          }
;;;806        }
;;;807      }
;;;808    
;;;809      ip_addr_set(&pcb->local_ip, ipaddr);
;;;810    
;;;811      /* no port specified? */
;;;812      if (port == 0) {
;;;813        port = udp_new_port();
;;;814        if (port == 0) {
;;;815          /* no more ports available in local range */
;;;816          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
;;;817          return ERR_USE;
;;;818        }
;;;819      }
;;;820      pcb->local_port = port;
;;;821      snmp_insert_udpidx_tree(pcb);
;;;822      /* pcb not active yet? */
;;;823      if (rebind == 0) {
;;;824        /* place the PCB on the active list if not already there */
;;;825        pcb->next = udp_pcbs;
;;;826        udp_pcbs = pcb;
;;;827      }
;;;828      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;829                  ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
;;;830                   ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;831                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
;;;832                   pcb->local_port));
;;;833      return ERR_OK;
;;;834    }
00362e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.13874|
003632  68e4              LDR      r4,[r4,#0xc]          ;777
                  |L1.13876|
003634  2c00              CMP      r4,#0                 ;777
003636  d1e2              BNE      |L1.13822|
003638  b90e              CBNZ     r6,|L1.13886|
00363a  2000              MOVS     r0,#0                 ;809
00363c  e000              B        |L1.13888|
                  |L1.13886|
00363e  6830              LDR      r0,[r6,#0]            ;809
                  |L1.13888|
003640  6028              STR      r0,[r5,#0]            ;809
003642  b947              CBNZ     r7,|L1.13910|
003644  f7fffffe          BL       udp_new_port
003648  4607              MOV      r7,r0                 ;813
00364a  b927              CBNZ     r7,|L1.13910|
00364c  bf00              NOP                            ;816
00364e  bf00              NOP                            ;816
003650  f06f0007          MVN      r0,#7                 ;817
003654  e7eb              B        |L1.13870|
                  |L1.13910|
003656  826f              STRH     r7,[r5,#0x12]         ;820
003658  f1b80f00          CMP      r8,#0                 ;823
00365c  d104              BNE      |L1.13928|
00365e  48b6              LDR      r0,|L1.14648|
003660  6800              LDR      r0,[r0,#0]            ;825  ; udp_pcbs
003662  60e8              STR      r0,[r5,#0xc]          ;825
003664  48b4              LDR      r0,|L1.14648|
003666  6005              STR      r5,[r0,#0]            ;826  ; udp_pcbs
                  |L1.13928|
003668  bf00              NOP                            ;828
00366a  bf00              NOP                            ;828
00366c  2000              MOVS     r0,#0                 ;833
00366e  e7de              B        |L1.13870|
;;;835    /**
                          ENDP

                  raw_bind PROC
;;;141    err_t
;;;142    raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
003670  4602              MOV      r2,r0
;;;143    {
;;;144      ip_addr_set(&pcb->local_ip, ipaddr);
003672  b909              CBNZ     r1,|L1.13944|
003674  2000              MOVS     r0,#0
003676  e000              B        |L1.13946|
                  |L1.13944|
003678  6808              LDR      r0,[r1,#0]
                  |L1.13946|
00367a  6010              STR      r0,[r2,#0]
;;;145      return ERR_OK;
00367c  2000              MOVS     r0,#0
;;;146    }
00367e  4770              BX       lr
;;;147    
                          ENDP

                  do_bind PROC
;;;900    void
;;;901    do_bind(struct api_msg_msg *msg)
003680  b510              PUSH     {r4,lr}
;;;902    {
003682  4604              MOV      r4,r0
;;;903      if (ERR_IS_FATAL(msg->conn->last_err)) {
003684  6820              LDR      r0,[r4,#0]
003686  f9900008          LDRSB    r0,[r0,#8]
00368a  f1100f09          CMN      r0,#9
00368e  da03              BGE      |L1.13976|
;;;904        msg->err = msg->conn->last_err;
003690  6820              LDR      r0,[r4,#0]
003692  7a00              LDRB     r0,[r0,#8]
003694  7120              STRB     r0,[r4,#4]
003696  e027              B        |L1.14056|
                  |L1.13976|
;;;905      } else {
;;;906        msg->err = ERR_VAL;
003698  20fa              MOVS     r0,#0xfa
00369a  7120              STRB     r0,[r4,#4]
;;;907        if (msg->conn->pcb.tcp != NULL) {
00369c  6820              LDR      r0,[r4,#0]
00369e  6840              LDR      r0,[r0,#4]
0036a0  b310              CBZ      r0,|L1.14056|
;;;908          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
0036a2  6820              LDR      r0,[r4,#0]
0036a4  7800              LDRB     r0,[r0,#0]
0036a6  f00000f0          AND      r0,r0,#0xf0
0036aa  2810              CMP      r0,#0x10
0036ac  d012              BEQ      |L1.14036|
0036ae  2820              CMP      r0,#0x20
0036b0  d008              BEQ      |L1.14020|
0036b2  2840              CMP      r0,#0x40
0036b4  d116              BNE      |L1.14052|
;;;909    #if LWIP_RAW
;;;910          case NETCONN_RAW:
;;;911            msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
0036b6  6822              LDR      r2,[r4,#0]
0036b8  68a1              LDR      r1,[r4,#8]
0036ba  6850              LDR      r0,[r2,#4]
0036bc  f7fffffe          BL       raw_bind
0036c0  7120              STRB     r0,[r4,#4]
;;;912            break;
0036c2  e010              B        |L1.14054|
                  |L1.14020|
;;;913    #endif /* LWIP_RAW */
;;;914    #if LWIP_UDP
;;;915          case NETCONN_UDP:
;;;916            msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
0036c4  89a2              LDRH     r2,[r4,#0xc]
0036c6  6823              LDR      r3,[r4,#0]
0036c8  68a1              LDR      r1,[r4,#8]
0036ca  6858              LDR      r0,[r3,#4]
0036cc  f7fffffe          BL       udp_bind
0036d0  7120              STRB     r0,[r4,#4]
;;;917            break;
0036d2  e008              B        |L1.14054|
                  |L1.14036|
;;;918    #endif /* LWIP_UDP */
;;;919    #if LWIP_TCP
;;;920          case NETCONN_TCP:
;;;921            msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
0036d4  89a2              LDRH     r2,[r4,#0xc]
0036d6  6823              LDR      r3,[r4,#0]
0036d8  68a1              LDR      r1,[r4,#8]
0036da  6858              LDR      r0,[r3,#4]
0036dc  f7fffffe          BL       tcp_bind
0036e0  7120              STRB     r0,[r4,#4]
;;;922            break;
0036e2  e000              B        |L1.14054|
                  |L1.14052|
;;;923    #endif /* LWIP_TCP */
;;;924          default:
;;;925            break;
0036e4  bf00              NOP      
                  |L1.14054|
0036e6  bf00              NOP                            ;912
                  |L1.14056|
;;;926          }
;;;927        }
;;;928      }
;;;929      TCPIP_APIMSG_ACK(msg);
0036e8  6821              LDR      r1,[r4,#0]
0036ea  f101000c          ADD      r0,r1,#0xc
0036ee  f7fffffe          BL       sys_sem_signal
;;;930    }
0036f2  bd10              POP      {r4,pc}
;;;931    
                          ENDP

                  netconn_bind PROC
;;;165    err_t
;;;166    netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
0036f4  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
0036f8  b086              SUB      sp,sp,#0x18
0036fa  4604              MOV      r4,r0
0036fc  460e              MOV      r6,r1
0036fe  4617              MOV      r7,r2
;;;168      struct api_msg msg;
;;;169      err_t err;
;;;170    
;;;171      LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
003700  bf00              NOP      
003702  b924              CBNZ     r4,|L1.14094|
003704  f06f000d          MVN      r0,#0xd
                  |L1.14088|
;;;172    
;;;173      msg.function = do_bind;
;;;174      msg.msg.conn = conn;
;;;175      msg.msg.msg.bc.ipaddr = addr;
;;;176      msg.msg.msg.bc.port = port;
;;;177      err = TCPIP_APIMSG(&msg);
;;;178    
;;;179      NETCONN_SET_SAFE_ERR(conn, err);
;;;180      return err;
;;;181    }
003708  b006              ADD      sp,sp,#0x18
00370a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.14094|
00370e  bf00              NOP                            ;171
003710  f2af0093          ADR      r0,do_bind + 1
003714  9000              STR      r0,[sp,#0]            ;173
003716  9401              STR      r4,[sp,#4]            ;174
003718  9603              STR      r6,[sp,#0xc]          ;175
00371a  f8ad7010          STRH     r7,[sp,#0x10]         ;176
00371e  4668              MOV      r0,sp                 ;177
003720  f7fffffe          BL       tcpip_apimsg
003724  4605              MOV      r5,r0                 ;177
003726  bf00              NOP                            ;179
003728  f7fffffe          BL       sys_arch_protect
00372c  4680              MOV      r8,r0                 ;179
00372e  f9940008          LDRSB    r0,[r4,#8]            ;179
003732  f1100f09          CMN      r0,#9                 ;179
003736  db00              BLT      |L1.14138|
003738  7225              STRB     r5,[r4,#8]            ;179
                  |L1.14138|
00373a  4640              MOV      r0,r8                 ;179
00373c  f7fffffe          BL       sys_arch_unprotect
003740  bf00              NOP                            ;179
003742  4628              MOV      r0,r5                 ;180
003744  e7e0              B        |L1.14088|
;;;182    
                          ENDP

                  do_connected PROC
;;;939    static err_t
;;;940    do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
003746  e92d47f0          PUSH     {r4-r10,lr}
;;;941    {
00374a  4605              MOV      r5,r0
00374c  4689              MOV      r9,r1
00374e  4616              MOV      r6,r2
;;;942      struct netconn *conn;
;;;943      int was_blocking;
;;;944    
;;;945      LWIP_UNUSED_ARG(pcb);
;;;946    
;;;947      conn = (struct netconn *)arg;
003750  462c              MOV      r4,r5
;;;948    
;;;949      if (conn == NULL) {
003752  b91c              CBNZ     r4,|L1.14172|
;;;950        return ERR_VAL;
003754  f06f0005          MVN      r0,#5
                  |L1.14168|
;;;951      }
;;;952    
;;;953      LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
;;;954      LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
;;;955        (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
;;;956    
;;;957      if (conn->current_msg != NULL) {
;;;958        conn->current_msg->err = err;
;;;959      }
;;;960      if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
;;;961        setup_tcp(conn);
;;;962      }
;;;963      was_blocking = !IN_NONBLOCKING_CONNECT(conn);
;;;964      SET_NONBLOCKING_CONNECT(conn, 0);
;;;965      conn->current_msg = NULL;
;;;966      conn->state = NETCONN_NONE;
;;;967      if (!was_blocking) {
;;;968        NETCONN_SET_SAFE_ERR(conn, ERR_OK);
;;;969      }
;;;970      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
;;;971    
;;;972      if (was_blocking) {
;;;973        sys_sem_signal(&conn->op_completed);
;;;974      }
;;;975      return ERR_OK;
;;;976    }
003758  e8bd87f0          POP      {r4-r10,pc}
                  |L1.14172|
00375c  bf00              NOP                            ;953
00375e  bf00              NOP                            ;953
003760  bf00              NOP                            ;954
003762  bf00              NOP                            ;954
003764  f8d40134          LDR      r0,[r4,#0x134]        ;957
003768  b110              CBZ      r0,|L1.14192|
00376a  f8d40134          LDR      r0,[r4,#0x134]        ;958
00376e  7106              STRB     r6,[r0,#4]            ;958
                  |L1.14192|
003770  7820              LDRB     r0,[r4,#0]            ;960
003772  2810              CMP      r0,#0x10              ;960
003774  d103              BNE      |L1.14206|
003776  b916              CBNZ     r6,|L1.14206|
003778  4620              MOV      r0,r4                 ;961
00377a  f7fffffe          BL       setup_tcp
                  |L1.14206|
00377e  f894012c          LDRB     r0,[r4,#0x12c]        ;963
003782  2101              MOVS     r1,#1                 ;963
003784  ea210790          BIC      r7,r1,r0,LSR #2       ;963
003788  bf00              NOP                            ;964
00378a  f894012c          LDRB     r0,[r4,#0x12c]        ;964
00378e  f0200004          BIC      r0,r0,#4              ;964
003792  f884012c          STRB     r0,[r4,#0x12c]        ;964
003796  bf00              NOP                            ;964
003798  2000              MOVS     r0,#0                 ;965
00379a  f8c40134          STR      r0,[r4,#0x134]        ;965
00379e  7060              STRB     r0,[r4,#1]            ;966
0037a0  b977              CBNZ     r7,|L1.14272|
0037a2  bf00              NOP                            ;968
0037a4  f7fffffe          BL       sys_arch_protect
0037a8  4680              MOV      r8,r0                 ;968
0037aa  f9940008          LDRSB    r0,[r4,#8]            ;968
0037ae  f1100f09          CMN      r0,#9                 ;968
0037b2  db01              BLT      |L1.14264|
0037b4  2000              MOVS     r0,#0                 ;968
0037b6  7220              STRB     r0,[r4,#8]            ;968
                  |L1.14264|
0037b8  4640              MOV      r0,r8                 ;968
0037ba  f7fffffe          BL       sys_arch_unprotect
0037be  bf00              NOP                            ;968
                  |L1.14272|
0037c0  f8d40138          LDR      r0,[r4,#0x138]        ;970
0037c4  b128              CBZ      r0,|L1.14290|
0037c6  2200              MOVS     r2,#0                 ;970
0037c8  2102              MOVS     r1,#2                 ;970
0037ca  4620              MOV      r0,r4                 ;970
0037cc  f8d43138          LDR      r3,[r4,#0x138]        ;970
0037d0  4798              BLX      r3                    ;970
                  |L1.14290|
0037d2  b11f              CBZ      r7,|L1.14300|
0037d4  f104000c          ADD      r0,r4,#0xc            ;973
0037d8  f7fffffe          BL       sys_sem_signal
                  |L1.14300|
0037dc  2000              MOVS     r0,#0                 ;975
0037de  e7bb              B        |L1.14168|
;;;977    #endif /* LWIP_TCP */
                          ENDP

                  tcp_connect PROC
;;;685    err_t
;;;686    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
0037e0  e92d5ff0          PUSH     {r4-r12,lr}
;;;687          tcp_connected_fn connected)
;;;688    {
0037e4  4604              MOV      r4,r0
0037e6  460e              MOV      r6,r1
0037e8  4690              MOV      r8,r2
0037ea  4699              MOV      r9,r3
;;;689      err_t ret;
;;;690      u32_t iss;
;;;691      u16_t old_local_port;
;;;692    
;;;693      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
0037ec  bf00              NOP      
0037ee  7e20              LDRB     r0,[r4,#0x18]
0037f0  b118              CBZ      r0,|L1.14330|
0037f2  f06f0008          MVN      r0,#8
                  |L1.14326|
;;;694    
;;;695      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;696      if (ipaddr != NULL) {
;;;697        pcb->remote_ip = *ipaddr;
;;;698      } else {
;;;699        return ERR_VAL;
;;;700      }
;;;701      pcb->remote_port = port;
;;;702    
;;;703      /* check if we have a route to the remote host */
;;;704      if (ip_addr_isany(&(pcb->local_ip))) {
;;;705        /* no local IP address set, yet. */
;;;706        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;707        if (netif == NULL) {
;;;708          /* Don't even try to send a SYN packet if we have no route
;;;709             since that will fail. */
;;;710          return ERR_RTE;
;;;711        }
;;;712        /* Use the netif's IP address as local address. */
;;;713        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;714      }
;;;715    
;;;716      old_local_port = pcb->local_port;
;;;717      if (pcb->local_port == 0) {
;;;718        pcb->local_port = tcp_new_port();
;;;719        if (pcb->local_port == 0) {
;;;720          return ERR_BUF;
;;;721        }
;;;722      }
;;;723    #if SO_REUSE
;;;724      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;725        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;726           now that the 5-tuple is unique. */
;;;727        struct tcp_pcb *cpcb;
;;;728        int i;
;;;729        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;730        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;731          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;732            if ((cpcb->local_port == pcb->local_port) &&
;;;733                (cpcb->remote_port == port) &&
;;;734                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;735                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;736              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;737              return ERR_USE;
;;;738            }
;;;739          }
;;;740        }
;;;741      }
;;;742    #endif /* SO_REUSE */
;;;743      iss = tcp_next_iss();
;;;744      pcb->rcv_nxt = 0;
;;;745      pcb->snd_nxt = iss;
;;;746      pcb->lastack = iss - 1;
;;;747      pcb->snd_lbb = iss - 1;
;;;748      pcb->rcv_wnd = TCP_WND;
;;;749      pcb->rcv_ann_wnd = TCP_WND;
;;;750      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;751      pcb->snd_wnd = TCP_WND;
;;;752      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;753         The send MSS is updated when an MSS option is received. */
;;;754      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;755    #if TCP_CALCULATE_EFF_SEND_MSS
;;;756      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;757    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;758      pcb->cwnd = 1;
;;;759      pcb->ssthresh = pcb->mss * 10;
;;;760    #if LWIP_CALLBACK_API
;;;761      pcb->connected = connected;
;;;762    #else /* LWIP_CALLBACK_API */  
;;;763      LWIP_UNUSED_ARG(connected);
;;;764    #endif /* LWIP_CALLBACK_API */
;;;765    
;;;766      /* Send a SYN together with the MSS option. */
;;;767      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;768      if (ret == ERR_OK) {
;;;769        /* SYN segment was enqueued, changed the pcbs state now */
;;;770        pcb->state = SYN_SENT;
;;;771        if (old_local_port != 0) {
;;;772          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;773        }
;;;774        TCP_REG_ACTIVE(pcb);
;;;775        snmp_inc_tcpactiveopens();
;;;776    
;;;777        tcp_output(pcb);
;;;778      }
;;;779      return ret;
;;;780    }
0037f6  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.14330|
0037fa  bf00              NOP                            ;693
0037fc  bf00              NOP                            ;695
0037fe  bf00              NOP                            ;695
003800  b116              CBZ      r6,|L1.14344|
003802  6830              LDR      r0,[r6,#0]            ;697
003804  6060              STR      r0,[r4,#4]            ;697
003806  e002              B        |L1.14350|
                  |L1.14344|
003808  f06f0005          MVN      r0,#5                 ;699
00380c  e7f3              B        |L1.14326|
                  |L1.14350|
00380e  f8a4801c          STRH     r8,[r4,#0x1c]         ;701
003812  b10c              CBZ      r4,|L1.14360|
003814  6820              LDR      r0,[r4,#0]            ;704
003816  b968              CBNZ     r0,|L1.14388|
                  |L1.14360|
003818  1d20              ADDS     r0,r4,#4              ;706
00381a  f7fffffe          BL       ip_route
00381e  4683              MOV      r11,r0                ;706
003820  f1bb0f00          CMP      r11,#0                ;707
003824  d102              BNE      |L1.14380|
003826  f06f0003          MVN      r0,#3                 ;710
00382a  e7e4              B        |L1.14326|
                  |L1.14380|
00382c  f8db0004          LDR      r0,[r11,#4]           ;713
003830  6020              STR      r0,[r4,#0]            ;713
003832  bf00              NOP                            ;714
                  |L1.14388|
003834  f8b4a01a          LDRH     r10,[r4,#0x1a]        ;716
003838  8b60              LDRH     r0,[r4,#0x1a]         ;717
00383a  b938              CBNZ     r0,|L1.14412|
00383c  f7fffffe          BL       tcp_new_port
003840  8360              STRH     r0,[r4,#0x1a]         ;718
003842  8b60              LDRH     r0,[r4,#0x1a]         ;719
003844  b910              CBNZ     r0,|L1.14412|
003846  f06f0001          MVN      r0,#1                 ;720
00384a  e7d4              B        |L1.14326|
                  |L1.14412|
00384c  f7fffffe          BL       tcp_next_iss
003850  4605              MOV      r5,r0                 ;743
003852  2000              MOVS     r0,#0                 ;744
003854  f8440f28          STR      r0,[r4,#0x28]!        ;744
003858  62a5              STR      r5,[r4,#0x28]         ;745
00385a  1e68              SUBS     r0,r5,#1              ;746
00385c  6220              STR      r0,[r4,#0x20]         ;746
00385e  6360              STR      r0,[r4,#0x34]         ;747
003860  f44f5080          MOV      r0,#0x1000            ;748
003864  80a0              STRH     r0,[r4,#4]            ;748
003866  80e0              STRH     r0,[r4,#6]            ;749
003868  6820              LDR      r0,[r4,#0]            ;750
00386a  60a0              STR      r0,[r4,#8]            ;750
00386c  f44f5080          MOV      r0,#0x1000            ;751
003870  8720              STRH     r0,[r4,#0x38]         ;751
003872  f44f7006          MOV      r0,#0x218             ;754
003876  81e0              STRH     r0,[r4,#0xe]          ;754
003878  89e0              LDRH     r0,[r4,#0xe]          ;756
00387a  4631              MOV      r1,r6                 ;756
00387c  f7fffffe          BL       tcp_eff_send_mss
003880  81e0              STRH     r0,[r4,#0xe]          ;756
003882  2001              MOVS     r0,#1                 ;758
003884  84a0              STRH     r0,[r4,#0x24]         ;758
003886  89e0              LDRH     r0,[r4,#0xe]          ;759
003888  eb000080          ADD      r0,r0,r0,LSL #2       ;759
00388c  f64f71ff          MOV      r1,#0xffff            ;759
003890  ea010040          AND      r0,r1,r0,LSL #1       ;759
003894  84e0              STRH     r0,[r4,#0x26]         ;759
003896  f8c4905c          STR      r9,[r4,#0x5c]         ;761
00389a  f1a40428          SUB      r4,r4,#0x28           ;761
00389e  f04f0102          MOV      r1,#2                 ;767
0038a2  4620              MOV      r0,r4                 ;767
0038a4  f7fffffe          BL       tcp_enqueue_flags
0038a8  4607              MOV      r7,r0                 ;767
0038aa  2f00              CMP      r7,#0                 ;768
0038ac  d13c              BNE      |L1.14632|
0038ae  2002              MOVS     r0,#2                 ;770
0038b0  7620              STRB     r0,[r4,#0x18]         ;770
0038b2  f1ba0f00          CMP      r10,#0                ;771
0038b6  d026              BEQ      |L1.14598|
0038b8  bf00              NOP                            ;772
0038ba  481d              LDR      r0,|L1.14640|
0038bc  6800              LDR      r0,[r0,#0]            ;772  ; tcp_bound_pcbs
0038be  42a0              CMP      r0,r4                 ;772
0038c0  d105              BNE      |L1.14542|
0038c2  481b              LDR      r0,|L1.14640|
0038c4  6800              LDR      r0,[r0,#0]            ;772  ; tcp_bound_pcbs
0038c6  68c0              LDR      r0,[r0,#0xc]          ;772
0038c8  4919              LDR      r1,|L1.14640|
0038ca  6008              STR      r0,[r1,#0]            ;772  ; tcp_bound_pcbs
0038cc  e018              B        |L1.14592|
                  |L1.14542|
0038ce  4818              LDR      r0,|L1.14640|
0038d0  6800              LDR      r0,[r0,#0]            ;772  ; tcp_bound_pcbs
0038d2  491a              LDR      r1,|L1.14652|
0038d4  6008              STR      r0,[r1,#0]            ;772  ; tcp_tmp_pcb
0038d6  e00e              B        |L1.14582|
                  |L1.14552|
0038d8  4818              LDR      r0,|L1.14652|
0038da  6800              LDR      r0,[r0,#0]            ;772  ; tcp_tmp_pcb
0038dc  68c0              LDR      r0,[r0,#0xc]          ;772
0038de  42a0              CMP      r0,r4                 ;772
0038e0  d104              BNE      |L1.14572|
0038e2  4916              LDR      r1,|L1.14652|
0038e4  68e0              LDR      r0,[r4,#0xc]          ;772
0038e6  6809              LDR      r1,[r1,#0]            ;772  ; tcp_tmp_pcb
0038e8  60c8              STR      r0,[r1,#0xc]          ;772
0038ea  e008              B        |L1.14590|
                  |L1.14572|
0038ec  4813              LDR      r0,|L1.14652|
0038ee  6800              LDR      r0,[r0,#0]            ;772  ; tcp_tmp_pcb
0038f0  68c0              LDR      r0,[r0,#0xc]          ;772
0038f2  4912              LDR      r1,|L1.14652|
0038f4  6008              STR      r0,[r1,#0]            ;772  ; tcp_tmp_pcb
                  |L1.14582|
0038f6  4811              LDR      r0,|L1.14652|
0038f8  6800              LDR      r0,[r0,#0]            ;772  ; tcp_tmp_pcb
0038fa  2800              CMP      r0,#0                 ;772
0038fc  d1ec              BNE      |L1.14552|
                  |L1.14590|
0038fe  bf00              NOP                            ;772
                  |L1.14592|
003900  2000              MOVS     r0,#0                 ;772
003902  60e0              STR      r0,[r4,#0xc]          ;772
003904  bf00              NOP                            ;772
                  |L1.14598|
003906  bf00              NOP                            ;774
003908  bf00              NOP                            ;774
00390a  480d              LDR      r0,|L1.14656|
00390c  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
00390e  60e0              STR      r0,[r4,#0xc]          ;774
003910  480b              LDR      r0,|L1.14656|
003912  6004              STR      r4,[r0,#0]            ;774  ; tcp_active_pcbs
003914  f7fffffe          BL       tcp_timer_needed
003918  bf00              NOP                            ;774
00391a  2001              MOVS     r0,#1                 ;774
00391c  4909              LDR      r1,|L1.14660|
00391e  7008              STRB     r0,[r1,#0]            ;774
003920  bf00              NOP                            ;774
003922  4620              MOV      r0,r4                 ;777
003924  f7fffffe          BL       tcp_output
                  |L1.14632|
003928  4638              MOV      r0,r7                 ;779
00392a  e764              B        |L1.14326|
                  |L1.14636|
                          DCD      tcp_pcb_lists
                  |L1.14640|
                          DCD      tcp_bound_pcbs
                  |L1.14644|
                          DCD      udp_port
                  |L1.14648|
                          DCD      udp_pcbs
                  |L1.14652|
                          DCD      tcp_tmp_pcb
                  |L1.14656|
                          DCD      tcp_active_pcbs
                  |L1.14660|
                          DCD      tcp_active_pcbs_changed
                          ENDP

                  udp_connect PROC
;;;852    err_t
;;;853    udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
003948  e92d41f0          PUSH     {r4-r8,lr}
;;;854    {
00394c  4604              MOV      r4,r0
00394e  460e              MOV      r6,r1
003950  4617              MOV      r7,r2
;;;855      struct udp_pcb *ipcb;
;;;856    
;;;857      if (pcb->local_port == 0) {
003952  8a60              LDRH     r0,[r4,#0x12]
003954  b960              CBNZ     r0,|L1.14704|
;;;858        err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
003956  8a62              LDRH     r2,[r4,#0x12]
003958  4621              MOV      r1,r4
00395a  4620              MOV      r0,r4
00395c  f7fffffe          BL       udp_bind
003960  4680              MOV      r8,r0
;;;859        if (err != ERR_OK) {
003962  f1b80f00          CMP      r8,#0
003966  d002              BEQ      |L1.14702|
;;;860          return err;
003968  4640              MOV      r0,r8
                  |L1.14698|
;;;861        }
;;;862      }
;;;863    
;;;864      ip_addr_set(&pcb->remote_ip, ipaddr);
;;;865      pcb->remote_port = port;
;;;866      pcb->flags |= UDP_FLAGS_CONNECTED;
;;;867    /** TODO: this functionality belongs in upper layers */
;;;868    #ifdef LWIP_UDP_TODO
;;;869      /* Nail down local IP for netconn_addr()/getsockname() */
;;;870      if (ip_addr_isany(&pcb->local_ip) && !ip_addr_isany(&pcb->remote_ip)) {
;;;871        struct netif *netif;
;;;872    
;;;873        if ((netif = ip_route(&(pcb->remote_ip))) == NULL) {
;;;874          LWIP_DEBUGF(UDP_DEBUG, ("udp_connect: No route to 0x%lx\n", pcb->remote_ip.addr));
;;;875          UDP_STATS_INC(udp.rterr);
;;;876          return ERR_RTE;
;;;877        }
;;;878        /** TODO: this will bind the udp pcb locally, to the interface which
;;;879            is used to route output packets to the remote address. However, we
;;;880            might want to accept incoming packets on any interface! */
;;;881        pcb->local_ip = netif->ip_addr;
;;;882      } else if (ip_addr_isany(&pcb->remote_ip)) {
;;;883        pcb->local_ip.addr = 0;
;;;884      }
;;;885    #endif
;;;886      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;887                  ("udp_connect: connected to %"U16_F".%"U16_F".%"U16_F".%"U16_F",port %"U16_F"\n",
;;;888                   ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;889                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
;;;890                   pcb->local_port));
;;;891    
;;;892      /* Insert UDP PCB into the list of active UDP PCBs. */
;;;893      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
;;;894        if (pcb == ipcb) {
;;;895          /* already on the list, just return */
;;;896          return ERR_OK;
;;;897        }
;;;898      }
;;;899      /* PCB not yet on the list, add PCB now */
;;;900      pcb->next = udp_pcbs;
;;;901      udp_pcbs = pcb;
;;;902      return ERR_OK;
;;;903    }
00396a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.14702|
00396e  bf00              NOP                            ;862
                  |L1.14704|
003970  b90e              CBNZ     r6,|L1.14710|
003972  2000              MOVS     r0,#0                 ;864
003974  e000              B        |L1.14712|
                  |L1.14710|
003976  6830              LDR      r0,[r6,#0]            ;864
                  |L1.14712|
003978  6060              STR      r0,[r4,#4]            ;864
00397a  82a7              STRH     r7,[r4,#0x14]         ;865
00397c  7c20              LDRB     r0,[r4,#0x10]         ;866
00397e  f0400004          ORR      r0,r0,#4              ;866
003982  7420              STRB     r0,[r4,#0x10]         ;866
003984  bf00              NOP                            ;886
003986  bf00              NOP                            ;886
003988  48fe              LDR      r0,|L1.15748|
00398a  6805              LDR      r5,[r0,#0]            ;893  ; udp_pcbs
00398c  e004              B        |L1.14744|
                  |L1.14734|
00398e  42ac              CMP      r4,r5                 ;894
003990  d101              BNE      |L1.14742|
003992  2000              MOVS     r0,#0                 ;896
003994  e7e9              B        |L1.14698|
                  |L1.14742|
003996  68ed              LDR      r5,[r5,#0xc]          ;893
                  |L1.14744|
003998  2d00              CMP      r5,#0                 ;893
00399a  d1f8              BNE      |L1.14734|
00399c  48f9              LDR      r0,|L1.15748|
00399e  6800              LDR      r0,[r0,#0]            ;900  ; udp_pcbs
0039a0  60e0              STR      r0,[r4,#0xc]          ;900
0039a2  48f8              LDR      r0,|L1.15748|
0039a4  6004              STR      r4,[r0,#0]            ;901  ; udp_pcbs
0039a6  2000              MOVS     r0,#0                 ;902
0039a8  e7df              B        |L1.14698|
;;;904    
                          ENDP

                  raw_connect PROC
;;;161    err_t
;;;162    raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
0039aa  4602              MOV      r2,r0
;;;163    {
;;;164      ip_addr_set(&pcb->remote_ip, ipaddr);
0039ac  b909              CBNZ     r1,|L1.14770|
0039ae  2000              MOVS     r0,#0
0039b0  e000              B        |L1.14772|
                  |L1.14770|
0039b2  6808              LDR      r0,[r1,#0]
                  |L1.14772|
0039b4  6050              STR      r0,[r2,#4]
;;;165      return ERR_OK;
0039b6  2000              MOVS     r0,#0
;;;166    }
0039b8  4770              BX       lr
;;;167    
                          ENDP

                  do_connect PROC
;;;986    void
;;;987    do_connect(struct api_msg_msg *msg)
0039ba  b510              PUSH     {r4,lr}
;;;988    {
0039bc  4604              MOV      r4,r0
;;;989      if (msg->conn->pcb.tcp == NULL) {
0039be  6820              LDR      r0,[r4,#0]
0039c0  6840              LDR      r0,[r0,#4]
0039c2  b910              CBNZ     r0,|L1.14794|
;;;990        /* This may happen when calling netconn_connect() a second time */
;;;991        msg->err = ERR_CLSD;
0039c4  20f4              MOVS     r0,#0xf4
0039c6  7120              STRB     r0,[r4,#4]
0039c8  e059              B        |L1.14974|
                  |L1.14794|
;;;992      } else {
;;;993        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
0039ca  6820              LDR      r0,[r4,#0]
0039cc  7800              LDRB     r0,[r0,#0]
0039ce  f00000f0          AND      r0,r0,#0xf0
0039d2  2810              CMP      r0,#0x10
0039d4  d012              BEQ      |L1.14844|
0039d6  2820              CMP      r0,#0x20
0039d8  d008              BEQ      |L1.14828|
0039da  2840              CMP      r0,#0x40
0039dc  d147              BNE      |L1.14958|
;;;994    #if LWIP_RAW
;;;995      case NETCONN_RAW:
;;;996        msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
0039de  6822              LDR      r2,[r4,#0]
0039e0  68a1              LDR      r1,[r4,#8]
0039e2  6850              LDR      r0,[r2,#4]
0039e4  f7fffffe          BL       raw_connect
0039e8  7120              STRB     r0,[r4,#4]
;;;997        break;
0039ea  e047              B        |L1.14972|
                  |L1.14828|
;;;998    #endif /* LWIP_RAW */
;;;999    #if LWIP_UDP
;;;1000     case NETCONN_UDP:
;;;1001       msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
0039ec  89a2              LDRH     r2,[r4,#0xc]
0039ee  6823              LDR      r3,[r4,#0]
0039f0  68a1              LDR      r1,[r4,#8]
0039f2  6858              LDR      r0,[r3,#4]
0039f4  f7fffffe          BL       udp_connect
0039f8  7120              STRB     r0,[r4,#4]
;;;1002       break;
0039fa  e03f              B        |L1.14972|
                  |L1.14844|
;;;1003   #endif /* LWIP_UDP */
;;;1004   #if LWIP_TCP
;;;1005     case NETCONN_TCP:
;;;1006       /* Prevent connect while doing any other action. */
;;;1007       if (msg->conn->state != NETCONN_NONE) {
0039fc  6820              LDR      r0,[r4,#0]
0039fe  7840              LDRB     r0,[r0,#1]
003a00  b110              CBZ      r0,|L1.14856|
;;;1008         msg->err = ERR_ISCONN;
003a02  20f7              MOVS     r0,#0xf7
003a04  7120              STRB     r0,[r4,#4]
003a06  e031              B        |L1.14956|
                  |L1.14856|
;;;1009       } else {
;;;1010         setup_tcp(msg->conn);
003a08  6820              LDR      r0,[r4,#0]
003a0a  f7fffffe          BL       setup_tcp
;;;1011         msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
003a0e  89a2              LDRH     r2,[r4,#0xc]
003a10  6823              LDR      r3,[r4,#0]
003a12  68a1              LDR      r1,[r4,#8]
003a14  6858              LDR      r0,[r3,#4]
003a16  4bdc              LDR      r3,|L1.15752|
003a18  f7fffffe          BL       tcp_connect
003a1c  7120              STRB     r0,[r4,#4]
;;;1012           msg->msg.bc.port, do_connected);
;;;1013         if (msg->err == ERR_OK) {
003a1e  7920              LDRB     r0,[r4,#4]
003a20  bb20              CBNZ     r0,|L1.14956|
;;;1014           u8_t non_blocking = netconn_is_nonblocking(msg->conn);
003a22  6821              LDR      r1,[r4,#0]
003a24  f891112c          LDRB     r1,[r1,#0x12c]
003a28  f3c10040          UBFX     r0,r1,#1,#1
;;;1015           msg->conn->state = NETCONN_CONNECT;
003a2c  2103              MOVS     r1,#3
003a2e  6822              LDR      r2,[r4,#0]
003a30  7051              STRB     r1,[r2,#1]
;;;1016           SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
003a32  bf00              NOP      
003a34  b140              CBZ      r0,|L1.14920|
003a36  6821              LDR      r1,[r4,#0]
003a38  f891112c          LDRB     r1,[r1,#0x12c]
003a3c  f0410104          ORR      r1,r1,#4
003a40  6822              LDR      r2,[r4,#0]
003a42  f882112c          STRB     r1,[r2,#0x12c]
003a46  e007              B        |L1.14936|
                  |L1.14920|
003a48  6821              LDR      r1,[r4,#0]
003a4a  f891112c          LDRB     r1,[r1,#0x12c]
003a4e  f0210104          BIC      r1,r1,#4
003a52  6822              LDR      r2,[r4,#0]
003a54  f882112c          STRB     r1,[r2,#0x12c]
                  |L1.14936|
003a58  bf00              NOP      
;;;1017           if (non_blocking) {
003a5a  b110              CBZ      r0,|L1.14946|
;;;1018             msg->err = ERR_INPROGRESS;
003a5c  21fb              MOVS     r1,#0xfb
003a5e  7121              STRB     r1,[r4,#4]
003a60  e003              B        |L1.14954|
                  |L1.14946|
;;;1019           } else {
;;;1020             msg->conn->current_msg = msg;
003a62  6821              LDR      r1,[r4,#0]
003a64  f8c14134          STR      r4,[r1,#0x134]
                  |L1.14952|
;;;1021             /* sys_sem_signal() is called from do_connected (or err_tcp()),
;;;1022             * when the connection is established! */
;;;1023             return;
;;;1024           }
;;;1025         }
;;;1026       }
;;;1027       break;
;;;1028   #endif /* LWIP_TCP */
;;;1029     default:
;;;1030       LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
;;;1031       break;
;;;1032       }
;;;1033     }
;;;1034     sys_sem_signal(&msg->conn->op_completed);
;;;1035   }
003a68  bd10              POP      {r4,pc}
                  |L1.14954|
003a6a  bf00              NOP                            ;1025
                  |L1.14956|
003a6c  e006              B        |L1.14972|
                  |L1.14958|
003a6e  bf00              NOP                            ;1030
003a70  bf00              NOP                            ;1030
003a72  20fa              MOVS     r0,#0xfa              ;1030
003a74  7120              STRB     r0,[r4,#4]            ;1030
003a76  bf00              NOP                            ;1030
003a78  bf00              NOP                            ;1030
003a7a  bf00              NOP                            ;1031
                  |L1.14972|
003a7c  bf00              NOP                            ;997
                  |L1.14974|
003a7e  6821              LDR      r1,[r4,#0]            ;1034
003a80  f101000c          ADD      r0,r1,#0xc            ;1034
003a84  f7fffffe          BL       sys_sem_signal
003a88  bf00              NOP      
003a8a  e7ed              B        |L1.14952|
;;;1036   
                          ENDP

                  netconn_connect PROC
;;;191    err_t
;;;192    netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
003a8c  e92d41f0          PUSH     {r4-r8,lr}
;;;193    {
003a90  b086              SUB      sp,sp,#0x18
003a92  4604              MOV      r4,r0
003a94  460e              MOV      r6,r1
003a96  4617              MOV      r7,r2
;;;194      struct api_msg msg;
;;;195      err_t err;
;;;196    
;;;197      LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
003a98  bf00              NOP      
003a9a  b924              CBNZ     r4,|L1.15014|
003a9c  f06f000d          MVN      r0,#0xd
                  |L1.15008|
;;;198    
;;;199      msg.function = do_connect;
;;;200      msg.msg.conn = conn;
;;;201      msg.msg.msg.bc.ipaddr = addr;
;;;202      msg.msg.msg.bc.port = port;
;;;203      /* This is the only function which need to not block tcpip_thread */
;;;204      err = tcpip_apimsg(&msg);
;;;205    
;;;206      NETCONN_SET_SAFE_ERR(conn, err);
;;;207      return err;
;;;208    }
003aa0  b006              ADD      sp,sp,#0x18
003aa2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.15014|
003aa6  bf00              NOP                            ;197
003aa8  f2af00f1          ADR      r0,do_connect + 1
003aac  9000              STR      r0,[sp,#0]            ;199
003aae  9401              STR      r4,[sp,#4]            ;200
003ab0  9603              STR      r6,[sp,#0xc]          ;201
003ab2  f8ad7010          STRH     r7,[sp,#0x10]         ;202
003ab6  4668              MOV      r0,sp                 ;204
003ab8  f7fffffe          BL       tcpip_apimsg
003abc  4605              MOV      r5,r0                 ;204
003abe  bf00              NOP                            ;206
003ac0  f7fffffe          BL       sys_arch_protect
003ac4  4680              MOV      r8,r0                 ;206
003ac6  f9940008          LDRSB    r0,[r4,#8]            ;206
003aca  f1100f09          CMN      r0,#9                 ;206
003ace  db00              BLT      |L1.15058|
003ad0  7225              STRB     r5,[r4,#8]            ;206
                  |L1.15058|
003ad2  4640              MOV      r0,r8                 ;206
003ad4  f7fffffe          BL       sys_arch_unprotect
003ad8  bf00              NOP                            ;206
003ada  4628              MOV      r0,r5                 ;207
003adc  e7e0              B        |L1.15008|
;;;209    
                          ENDP

                  udp_disconnect PROC
;;;910    void
;;;911    udp_disconnect(struct udp_pcb *pcb)
003ade  2100              MOVS     r1,#0
;;;912    {
;;;913      /* reset remote address association */
;;;914      ip_addr_set_any(&pcb->remote_ip);
003ae0  6041              STR      r1,[r0,#4]
;;;915      pcb->remote_port = 0;
003ae2  8281              STRH     r1,[r0,#0x14]
;;;916      /* mark PCB as unconnected */
;;;917      pcb->flags &= ~UDP_FLAGS_CONNECTED;
003ae4  7c01              LDRB     r1,[r0,#0x10]
003ae6  f0210104          BIC      r1,r1,#4
003aea  7401              STRB     r1,[r0,#0x10]
;;;918    }
003aec  4770              BX       lr
;;;919    
                          ENDP

                  do_disconnect PROC
;;;1044   void
;;;1045   do_disconnect(struct api_msg_msg *msg)
003aee  b510              PUSH     {r4,lr}
;;;1046   {
003af0  4604              MOV      r4,r0
;;;1047   #if LWIP_UDP
;;;1048     if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
003af2  6820              LDR      r0,[r4,#0]
003af4  7800              LDRB     r0,[r0,#0]
003af6  f00000f0          AND      r0,r0,#0xf0
003afa  2820              CMP      r0,#0x20
003afc  d106              BNE      |L1.15116|
;;;1049       udp_disconnect(msg->conn->pcb.udp);
003afe  6821              LDR      r1,[r4,#0]
003b00  6848              LDR      r0,[r1,#4]
003b02  f7fffffe          BL       udp_disconnect
;;;1050       msg->err = ERR_OK;
003b06  2000              MOVS     r0,#0
003b08  7120              STRB     r0,[r4,#4]
003b0a  e001              B        |L1.15120|
                  |L1.15116|
;;;1051     } else
;;;1052   #endif /* LWIP_UDP */
;;;1053     {
;;;1054       msg->err = ERR_VAL;
003b0c  20fa              MOVS     r0,#0xfa
003b0e  7120              STRB     r0,[r4,#4]
                  |L1.15120|
;;;1055     }
;;;1056     TCPIP_APIMSG_ACK(msg);
003b10  6821              LDR      r1,[r4,#0]
003b12  f101000c          ADD      r0,r1,#0xc
003b16  f7fffffe          BL       sys_sem_signal
;;;1057   }
003b1a  bd10              POP      {r4,pc}
;;;1058   
                          ENDP

                  netconn_disconnect PROC
;;;216    err_t
;;;217    netconn_disconnect(struct netconn *conn)
003b1c  b570              PUSH     {r4-r6,lr}
;;;218    {
003b1e  b086              SUB      sp,sp,#0x18
003b20  4604              MOV      r4,r0
;;;219      struct api_msg msg;
;;;220      err_t err;
;;;221    
;;;222      LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
003b22  bf00              NOP      
003b24  b91c              CBNZ     r4,|L1.15150|
003b26  f06f000d          MVN      r0,#0xd
                  |L1.15146|
;;;223    
;;;224      msg.function = do_disconnect;
;;;225      msg.msg.conn = conn;
;;;226      err = TCPIP_APIMSG(&msg);
;;;227    
;;;228      NETCONN_SET_SAFE_ERR(conn, err);
;;;229      return err;
;;;230    }
003b2a  b006              ADD      sp,sp,#0x18
003b2c  bd70              POP      {r4-r6,pc}
                  |L1.15150|
003b2e  bf00              NOP                            ;222
003b30  f2af0045          ADR      r0,do_disconnect + 1
003b34  9000              STR      r0,[sp,#0]            ;224
003b36  9401              STR      r4,[sp,#4]            ;225
003b38  4668              MOV      r0,sp                 ;226
003b3a  f7fffffe          BL       tcpip_apimsg
003b3e  4605              MOV      r5,r0                 ;226
003b40  bf00              NOP                            ;228
003b42  f7fffffe          BL       sys_arch_protect
003b46  4606              MOV      r6,r0                 ;228
003b48  f9940008          LDRSB    r0,[r4,#8]            ;228
003b4c  f1100f09          CMN      r0,#9                 ;228
003b50  db00              BLT      |L1.15188|
003b52  7225              STRB     r5,[r4,#8]            ;228
                  |L1.15188|
003b54  4630              MOV      r0,r6                 ;228
003b56  f7fffffe          BL       sys_arch_unprotect
003b5a  bf00              NOP                            ;228
003b5c  4628              MOV      r0,r5                 ;229
003b5e  e7e4              B        |L1.15146|
;;;231    
                          ENDP

                  accept_function PROC
;;;432    static err_t
;;;433    accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
003b60  e92d47f0          PUSH     {r4-r10,lr}
;;;434    {
003b64  4606              MOV      r6,r0
003b66  460f              MOV      r7,r1
003b68  4690              MOV      r8,r2
;;;435      struct netconn *newconn;
;;;436      struct netconn *conn = (struct netconn *)arg;
003b6a  4635              MOV      r5,r6
;;;437    	
;;;438    
;;;439      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));
003b6c  bf00              NOP      
003b6e  bf00              NOP      
;;;440    
;;;441      if (!sys_mbox_valid(&conn->acceptmbox)) {
003b70  f10500a0          ADD      r0,r5,#0xa0
003b74  f7fffffe          BL       sys_mbox_valid
003b78  b928              CBNZ     r0,|L1.15238|
;;;442        LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
003b7a  bf00              NOP      
003b7c  bf00              NOP      
;;;443        return ERR_VAL;
003b7e  f06f0005          MVN      r0,#5
                  |L1.15234|
;;;444      }
;;;445    	
;;;446    
;;;447      /* We have to set the callback here even though
;;;448       * the new socket is unknown. conn->socket is marked as -1. */
;;;449      newconn = netconn_alloc(conn->type, conn->callback);
;;;450      if (newconn == NULL) {
;;;451        return ERR_MEM;
;;;452      }
;;;453    	
;;;454      newconn->pcb.tcp = newpcb;
;;;455      setup_tcp(newconn);
;;;456      /* no protection: when creating the pcb, the netconn is not yet known
;;;457         to the application thread */
;;;458      newconn->last_err = err;
;;;459    
;;;460      if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
;;;461        /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
;;;462           so do nothing here! */
;;;463        /* remove all references to this netconn from the pcb */
;;;464        struct tcp_pcb* pcb = newconn->pcb.tcp;
;;;465        tcp_arg(pcb, NULL);
;;;466        tcp_recv(pcb, NULL);
;;;467        tcp_sent(pcb, NULL);
;;;468        tcp_poll(pcb, NULL, 4);
;;;469        tcp_err(pcb, NULL);
;;;470        /* remove reference from to the pcb from this netconn */
;;;471        newconn->pcb.tcp = NULL;
;;;472        /* no need to drain since we know the recvmbox is empty. */
;;;473        sys_mbox_free(&newconn->recvmbox);
;;;474        sys_mbox_set_invalid(&newconn->recvmbox);
;;;475        netconn_free(newconn);
;;;476        return ERR_MEM;
;;;477      } else {
;;;478        /* Register event with callback */
;;;479        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
;;;480      }
;;;481    
;;;482      return ERR_OK;
;;;483    }
003b82  e8bd87f0          POP      {r4-r10,pc}
                  |L1.15238|
003b86  7828              LDRB     r0,[r5,#0]            ;449
003b88  f8d51138          LDR      r1,[r5,#0x138]        ;449
003b8c  f7fffffe          BL       netconn_alloc
003b90  4604              MOV      r4,r0                 ;449
003b92  b914              CBNZ     r4,|L1.15258|
003b94  f04f30ff          MOV      r0,#0xffffffff        ;451
003b98  e7f3              B        |L1.15234|
                  |L1.15258|
003b9a  6067              STR      r7,[r4,#4]            ;454
003b9c  4620              MOV      r0,r4                 ;455
003b9e  f7fffffe          BL       setup_tcp
003ba2  f8848008          STRB     r8,[r4,#8]            ;458
003ba6  4621              MOV      r1,r4                 ;460
003ba8  f10500a0          ADD      r0,r5,#0xa0           ;460
003bac  f7fffffe          BL       sys_mbox_trypost
003bb0  b330              CBZ      r0,|L1.15360|
003bb2  f8d49004          LDR      r9,[r4,#4]            ;464
003bb6  2100              MOVS     r1,#0                 ;465
003bb8  4648              MOV      r0,r9                 ;465
003bba  f7fffffe          BL       tcp_arg
003bbe  2100              MOVS     r1,#0                 ;466
003bc0  4648              MOV      r0,r9                 ;466
003bc2  f7fffffe          BL       tcp_recv
003bc6  2100              MOVS     r1,#0                 ;467
003bc8  4648              MOV      r0,r9                 ;467
003bca  f7fffffe          BL       tcp_sent
003bce  2204              MOVS     r2,#4                 ;468
003bd0  2100              MOVS     r1,#0                 ;468
003bd2  4648              MOV      r0,r9                 ;468
003bd4  f7fffffe          BL       tcp_poll
003bd8  2100              MOVS     r1,#0                 ;469
003bda  4648              MOV      r0,r9                 ;469
003bdc  f7fffffe          BL       tcp_err
003be0  2000              MOVS     r0,#0                 ;471
003be2  6060              STR      r0,[r4,#4]            ;471
003be4  f1040018          ADD      r0,r4,#0x18           ;473
003be8  f7fffffe          BL       sys_mbox_free
003bec  f1040018          ADD      r0,r4,#0x18           ;474
003bf0  f7fffffe          BL       sys_mbox_set_invalid
003bf4  4620              MOV      r0,r4                 ;475
003bf6  f7fffffe          BL       netconn_free
003bfa  f04f30ff          MOV      r0,#0xffffffff        ;476
003bfe  e7c0              B        |L1.15234|
                  |L1.15360|
003c00  f8d50138          LDR      r0,[r5,#0x138]        ;479
003c04  b128              CBZ      r0,|L1.15378|
003c06  2200              MOVS     r2,#0                 ;479
003c08  4611              MOV      r1,r2                 ;479
003c0a  4628              MOV      r0,r5                 ;479
003c0c  f8d53138          LDR      r3,[r5,#0x138]        ;479
003c10  4798              BLX      r3                    ;479
                  |L1.15378|
003c12  2000              MOVS     r0,#0                 ;482
003c14  e7b5              B        |L1.15234|
;;;484    #endif /* LWIP_TCP */
                          ENDP

                  tcp_accept_null PROC
;;;495    static err_t
;;;496    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
003c16  4603              MOV      r3,r0
;;;497    {
;;;498      LWIP_UNUSED_ARG(arg);
;;;499      LWIP_UNUSED_ARG(pcb);
;;;500      LWIP_UNUSED_ARG(err);
;;;501    
;;;502      return ERR_ABRT;
003c18  f06f0009          MVN      r0,#9
;;;503    }
003c1c  4770              BX       lr
;;;504    #endif /* LWIP_CALLBACK_API */
                          ENDP

                  tcp_listen_with_backlog PROC
;;;520    struct tcp_pcb *
;;;521    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
003c1e  b570              PUSH     {r4-r6,lr}
;;;522    {
003c20  4605              MOV      r5,r0
003c22  460e              MOV      r6,r1
;;;523      struct tcp_pcb_listen *lpcb;
;;;524    
;;;525      LWIP_UNUSED_ARG(backlog);
;;;526      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
003c24  bf00              NOP      
003c26  7e28              LDRB     r0,[r5,#0x18]
003c28  b108              CBZ      r0,|L1.15406|
003c2a  2000              MOVS     r0,#0
                  |L1.15404|
;;;527    
;;;528      /* already listening? */
;;;529      if (pcb->state == LISTEN) {
;;;530        return pcb;
;;;531      }
;;;532    #if SO_REUSE
;;;533      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;534        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;535           is declared (listen-/connection-pcb), we have to make sure now that
;;;536           this port is only used once for every local IP. */
;;;537        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;538          if (lpcb->local_port == pcb->local_port) {
;;;539            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;540              /* this address/port is already used */
;;;541              return NULL;
;;;542            }
;;;543          }
;;;544        }
;;;545      }
;;;546    #endif /* SO_REUSE */
;;;547      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;548      if (lpcb == NULL) {
;;;549        return NULL;
;;;550      }
;;;551      lpcb->callback_arg = pcb->callback_arg;
;;;552      lpcb->local_port = pcb->local_port;
;;;553      lpcb->state = LISTEN;
;;;554      lpcb->prio = pcb->prio;
;;;555      lpcb->so_options = pcb->so_options;
;;;556      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;557      lpcb->ttl = pcb->ttl;
;;;558      lpcb->tos = pcb->tos;
;;;559      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;560      if (pcb->local_port != 0) {
;;;561        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;562      }
;;;563      memp_free(MEMP_TCP_PCB, pcb);
;;;564    #if LWIP_CALLBACK_API
;;;565      lpcb->accept = tcp_accept_null;
;;;566    #endif /* LWIP_CALLBACK_API */
;;;567    #if TCP_LISTEN_BACKLOG
;;;568      lpcb->accepts_pending = 0;
;;;569      lpcb->backlog = (backlog ? backlog : 1);
;;;570    #endif /* TCP_LISTEN_BACKLOG */
;;;571      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;572      return (struct tcp_pcb *)lpcb;
;;;573    }
003c2c  bd70              POP      {r4-r6,pc}
                  |L1.15406|
003c2e  bf00              NOP                            ;526
003c30  7e28              LDRB     r0,[r5,#0x18]         ;529
003c32  2801              CMP      r0,#1                 ;529
003c34  d101              BNE      |L1.15418|
003c36  4628              MOV      r0,r5                 ;530
003c38  e7f8              B        |L1.15404|
                  |L1.15418|
003c3a  2003              MOVS     r0,#3                 ;547
003c3c  f7fffffe          BL       memp_malloc
003c40  4604              MOV      r4,r0                 ;547
003c42  b90c              CBNZ     r4,|L1.15432|
003c44  2000              MOVS     r0,#0                 ;549
003c46  e7f1              B        |L1.15404|
                  |L1.15432|
003c48  6928              LDR      r0,[r5,#0x10]         ;551
003c4a  6120              STR      r0,[r4,#0x10]         ;551
003c4c  8b68              LDRH     r0,[r5,#0x1a]         ;552
003c4e  8360              STRH     r0,[r4,#0x1a]         ;552
003c50  2001              MOVS     r0,#1                 ;553
003c52  7620              STRB     r0,[r4,#0x18]         ;553
003c54  7e68              LDRB     r0,[r5,#0x19]         ;554
003c56  7660              STRB     r0,[r4,#0x19]         ;554
003c58  7a28              LDRB     r0,[r5,#8]            ;555
003c5a  7220              STRB     r0,[r4,#8]            ;555
003c5c  7a20              LDRB     r0,[r4,#8]            ;556
003c5e  f0400002          ORR      r0,r0,#2              ;556
003c62  7220              STRB     r0,[r4,#8]            ;556
003c64  7aa8              LDRB     r0,[r5,#0xa]          ;557
003c66  72a0              STRB     r0,[r4,#0xa]          ;557
003c68  7a68              LDRB     r0,[r5,#9]            ;558
003c6a  7260              STRB     r0,[r4,#9]            ;558
003c6c  6828              LDR      r0,[r5,#0]            ;559
003c6e  6020              STR      r0,[r4,#0]            ;559
003c70  8b68              LDRH     r0,[r5,#0x1a]         ;560
003c72  b330              CBZ      r0,|L1.15554|
003c74  bf00              NOP                            ;561
003c76  4845              LDR      r0,|L1.15756|
003c78  6800              LDR      r0,[r0,#0]            ;561  ; tcp_bound_pcbs
003c7a  42a8              CMP      r0,r5                 ;561
003c7c  d105              BNE      |L1.15498|
003c7e  4843              LDR      r0,|L1.15756|
003c80  6800              LDR      r0,[r0,#0]            ;561  ; tcp_bound_pcbs
003c82  68c0              LDR      r0,[r0,#0xc]          ;561
003c84  4941              LDR      r1,|L1.15756|
003c86  6008              STR      r0,[r1,#0]            ;561  ; tcp_bound_pcbs
003c88  e018              B        |L1.15548|
                  |L1.15498|
003c8a  4840              LDR      r0,|L1.15756|
003c8c  6800              LDR      r0,[r0,#0]            ;561  ; tcp_bound_pcbs
003c8e  4940              LDR      r1,|L1.15760|
003c90  6008              STR      r0,[r1,#0]            ;561  ; tcp_tmp_pcb
003c92  e00e              B        |L1.15538|
                  |L1.15508|
003c94  483e              LDR      r0,|L1.15760|
003c96  6800              LDR      r0,[r0,#0]            ;561  ; tcp_tmp_pcb
003c98  68c0              LDR      r0,[r0,#0xc]          ;561
003c9a  42a8              CMP      r0,r5                 ;561
003c9c  d104              BNE      |L1.15528|
003c9e  493c              LDR      r1,|L1.15760|
003ca0  68e8              LDR      r0,[r5,#0xc]          ;561
003ca2  6809              LDR      r1,[r1,#0]            ;561  ; tcp_tmp_pcb
003ca4  60c8              STR      r0,[r1,#0xc]          ;561
003ca6  e008              B        |L1.15546|
                  |L1.15528|
003ca8  4839              LDR      r0,|L1.15760|
003caa  6800              LDR      r0,[r0,#0]            ;561  ; tcp_tmp_pcb
003cac  68c0              LDR      r0,[r0,#0xc]          ;561
003cae  4938              LDR      r1,|L1.15760|
003cb0  6008              STR      r0,[r1,#0]            ;561  ; tcp_tmp_pcb
                  |L1.15538|
003cb2  4837              LDR      r0,|L1.15760|
003cb4  6800              LDR      r0,[r0,#0]            ;561  ; tcp_tmp_pcb
003cb6  2800              CMP      r0,#0                 ;561
003cb8  d1ec              BNE      |L1.15508|
                  |L1.15546|
003cba  bf00              NOP                            ;561
                  |L1.15548|
003cbc  2000              MOVS     r0,#0                 ;561
003cbe  60e8              STR      r0,[r5,#0xc]          ;561
003cc0  bf00              NOP                            ;561
                  |L1.15554|
003cc2  4629              MOV      r1,r5                 ;563
003cc4  2002              MOVS     r0,#2                 ;563
003cc6  f7fffffe          BL       memp_free
003cca  4832              LDR      r0,|L1.15764|
003ccc  6160              STR      r0,[r4,#0x14]         ;565
003cce  2000              MOVS     r0,#0                 ;568
003cd0  7760              STRB     r0,[r4,#0x1d]         ;568
003cd2  b10e              CBZ      r6,|L1.15576|
003cd4  4630              MOV      r0,r6                 ;569
003cd6  e000              B        |L1.15578|
                  |L1.15576|
003cd8  2001              MOVS     r0,#1                 ;569
                  |L1.15578|
003cda  7720              STRB     r0,[r4,#0x1c]         ;569
003cdc  bf00              NOP                            ;571
003cde  482e              LDR      r0,|L1.15768|
003ce0  6800              LDR      r0,[r0,#0]            ;571  ; tcp_listen_pcbs
003ce2  60e0              STR      r0,[r4,#0xc]          ;571
003ce4  482c              LDR      r0,|L1.15768|
003ce6  6004              STR      r4,[r0,#0]            ;571  ; tcp_listen_pcbs
003ce8  f7fffffe          BL       tcp_timer_needed
003cec  bf00              NOP                            ;571
003cee  4620              MOV      r0,r4                 ;572
003cf0  e79c              B        |L1.15404|
;;;574    
                          ENDP

                  do_listen PROC
;;;1066   void
;;;1067   do_listen(struct api_msg_msg *msg)
003cf2  b570              PUSH     {r4-r6,lr}
;;;1068   {
003cf4  4604              MOV      r4,r0
;;;1069     if (ERR_IS_FATAL(msg->conn->last_err)) {
003cf6  6820              LDR      r0,[r4,#0]
003cf8  f9900008          LDRSB    r0,[r0,#8]
003cfc  f1100f09          CMN      r0,#9
003d00  da03              BGE      |L1.15626|
;;;1070       msg->err = msg->conn->last_err;
003d02  6820              LDR      r0,[r4,#0]
003d04  7a00              LDRB     r0,[r0,#8]
003d06  7120              STRB     r0,[r4,#4]
003d08  e05d              B        |L1.15814|
                  |L1.15626|
;;;1071     } else {
;;;1072       msg->err = ERR_CONN;
003d0a  20f3              MOVS     r0,#0xf3
003d0c  7120              STRB     r0,[r4,#4]
;;;1073       if (msg->conn->pcb.tcp != NULL) {
003d0e  6820              LDR      r0,[r4,#0]
003d10  6840              LDR      r0,[r0,#4]
003d12  2800              CMP      r0,#0
003d14  d057              BEQ      |L1.15814|
;;;1074         if (msg->conn->type == NETCONN_TCP) {
003d16  6820              LDR      r0,[r4,#0]
003d18  7800              LDRB     r0,[r0,#0]
003d1a  2810              CMP      r0,#0x10
003d1c  d151              BNE      |L1.15810|
;;;1075           if (msg->conn->state == NETCONN_NONE) {
003d1e  6820              LDR      r0,[r4,#0]
003d20  7840              LDRB     r0,[r0,#1]
003d22  2800              CMP      r0,#0
003d24  d14f              BNE      |L1.15814|
;;;1076   #if TCP_LISTEN_BACKLOG
;;;1077             struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
003d26  7a21              LDRB     r1,[r4,#8]
003d28  6822              LDR      r2,[r4,#0]
003d2a  6850              LDR      r0,[r2,#4]
003d2c  f7fffffe          BL       tcp_listen_with_backlog
003d30  4605              MOV      r5,r0
;;;1078   #else  /* TCP_LISTEN_BACKLOG */
;;;1079             struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
;;;1080   #endif /* TCP_LISTEN_BACKLOG */
;;;1081             if (lpcb == NULL) {
003d32  b915              CBNZ     r5,|L1.15674|
;;;1082               /* in this case, the old pcb is still allocated */
;;;1083               msg->err = ERR_MEM;
003d34  20ff              MOVS     r0,#0xff
003d36  7120              STRB     r0,[r4,#4]
003d38  e042              B        |L1.15808|
                  |L1.15674|
;;;1084             } else {
;;;1085               /* delete the recvmbox and allocate the acceptmbox */
;;;1086               if (sys_mbox_valid(&msg->conn->recvmbox)) {
003d3a  6821              LDR      r1,[r4,#0]
003d3c  f1010018          ADD      r0,r1,#0x18
003d40  f7fffffe          BL       sys_mbox_valid
003d44  b148              CBZ      r0,|L1.15706|
;;;1087                 /** @todo: should we drain the recvmbox here? */
;;;1088                 sys_mbox_free(&msg->conn->recvmbox);
003d46  6821              LDR      r1,[r4,#0]
003d48  f1010018          ADD      r0,r1,#0x18
003d4c  f7fffffe          BL       sys_mbox_free
;;;1089                 sys_mbox_set_invalid(&msg->conn->recvmbox);
003d50  6821              LDR      r1,[r4,#0]
003d52  f1010018          ADD      r0,r1,#0x18
003d56  f7fffffe          BL       sys_mbox_set_invalid
                  |L1.15706|
;;;1090               }
;;;1091               msg->err = ERR_OK;
003d5a  2000              MOVS     r0,#0
003d5c  7120              STRB     r0,[r4,#4]
;;;1092               if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
003d5e  6821              LDR      r1,[r4,#0]
003d60  f10100a0          ADD      r0,r1,#0xa0
003d64  f7fffffe          BL       sys_mbox_valid
003d68  b930              CBNZ     r0,|L1.15736|
;;;1093                 msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
003d6a  6821              LDR      r1,[r4,#0]
003d6c  f10100a0          ADD      r0,r1,#0xa0
003d70  2110              MOVS     r1,#0x10
003d72  f7fffffe          BL       sys_mbox_new
003d76  7120              STRB     r0,[r4,#4]
                  |L1.15736|
;;;1094               }
;;;1095               if (msg->err == ERR_OK) {
003d78  7920              LDRB     r0,[r4,#4]
003d7a  b9d8              CBNZ     r0,|L1.15796|
;;;1096                 msg->conn->state = NETCONN_LISTEN;
003d7c  2002              MOVS     r0,#2
003d7e  6821              LDR      r1,[r4,#0]
003d80  7048              STRB     r0,[r1,#1]
;;;1097                 msg->conn->pcb.tcp = lpcb;
003d82  e00b              B        |L1.15772|
                  |L1.15748|
                          DCD      udp_pcbs
                  |L1.15752|
                          DCD      do_connected
                  |L1.15756|
                          DCD      tcp_bound_pcbs
                  |L1.15760|
                          DCD      tcp_tmp_pcb
                  |L1.15764|
                          DCD      tcp_accept_null
                  |L1.15768|
                          DCD      tcp_listen_pcbs
                  |L1.15772|
003d9c  6820              LDR      r0,[r4,#0]
003d9e  6045              STR      r5,[r0,#4]
;;;1098                 tcp_arg(msg->conn->pcb.tcp, msg->conn);
003da0  6821              LDR      r1,[r4,#0]
003da2  6848              LDR      r0,[r1,#4]
003da4  f7fffffe          BL       tcp_arg
;;;1099                 tcp_accept(msg->conn->pcb.tcp, accept_function);
003da8  6821              LDR      r1,[r4,#0]
003daa  6848              LDR      r0,[r1,#4]
003dac  49f8              LDR      r1,|L1.16784|
003dae  f7fffffe          BL       tcp_accept
003db2  e005              B        |L1.15808|
                  |L1.15796|
;;;1100               } else {
;;;1101                 /* since the old pcb is already deallocated, free lpcb now */
;;;1102                 tcp_close(lpcb);
003db4  4628              MOV      r0,r5
003db6  f7fffffe          BL       tcp_close
;;;1103                 msg->conn->pcb.tcp = NULL;
003dba  2000              MOVS     r0,#0
003dbc  6821              LDR      r1,[r4,#0]
003dbe  6048              STR      r0,[r1,#4]
                  |L1.15808|
;;;1104               }
;;;1105             }
;;;1106           }
003dc0  e001              B        |L1.15814|
                  |L1.15810|
;;;1107         } else {
;;;1108           msg->err = ERR_ARG;
003dc2  20f2              MOVS     r0,#0xf2
003dc4  7120              STRB     r0,[r4,#4]
                  |L1.15814|
;;;1109         }
;;;1110       }
;;;1111     }
;;;1112     TCPIP_APIMSG_ACK(msg);
003dc6  6821              LDR      r1,[r4,#0]
003dc8  f101000c          ADD      r0,r1,#0xc
003dcc  f7fffffe          BL       sys_sem_signal
;;;1113   }
003dd0  bd70              POP      {r4-r6,pc}
;;;1114   #endif /* LWIP_TCP */
                          ENDP

                  netconn_listen_with_backlog PROC
;;;240    err_t
;;;241    netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
003dd2  b5f0              PUSH     {r4-r7,lr}
;;;242    {
003dd4  b087              SUB      sp,sp,#0x1c
003dd6  4604              MOV      r4,r0
003dd8  460e              MOV      r6,r1
;;;243    #if LWIP_TCP
;;;244      struct api_msg msg;
;;;245      err_t err;
;;;246    
;;;247      /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
;;;248      LWIP_UNUSED_ARG(backlog);
;;;249    
;;;250      LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
003dda  bf00              NOP      
003ddc  b91c              CBNZ     r4,|L1.15846|
003dde  f06f000d          MVN      r0,#0xd
                  |L1.15842|
;;;251    
;;;252      msg.function = do_listen;
;;;253      msg.msg.conn = conn;
;;;254    #if TCP_LISTEN_BACKLOG
;;;255      msg.msg.msg.lb.backlog = backlog;
;;;256    #endif /* TCP_LISTEN_BACKLOG */
;;;257      err = TCPIP_APIMSG(&msg);
;;;258    
;;;259      NETCONN_SET_SAFE_ERR(conn, err);
;;;260      return err;
;;;261    #else /* LWIP_TCP */
;;;262      LWIP_UNUSED_ARG(conn);
;;;263      LWIP_UNUSED_ARG(backlog);
;;;264      return ERR_ARG;
;;;265    #endif /* LWIP_TCP */
;;;266    }
003de2  b007              ADD      sp,sp,#0x1c
003de4  bdf0              POP      {r4-r7,pc}
                  |L1.15846|
003de6  bf00              NOP                            ;250
003de8  f2af00f9          ADR      r0,do_listen + 1
003dec  9001              STR      r0,[sp,#4]            ;252
003dee  9402              STR      r4,[sp,#8]            ;253
003df0  f88d6010          STRB     r6,[sp,#0x10]         ;255
003df4  a801              ADD      r0,sp,#4              ;257
003df6  f7fffffe          BL       tcpip_apimsg
003dfa  4605              MOV      r5,r0                 ;257
003dfc  bf00              NOP                            ;259
003dfe  f7fffffe          BL       sys_arch_protect
003e02  4607              MOV      r7,r0                 ;259
003e04  f9940008          LDRSB    r0,[r4,#8]            ;259
003e08  f1100f09          CMN      r0,#9                 ;259
003e0c  db00              BLT      |L1.15888|
003e0e  7225              STRB     r5,[r4,#8]            ;259
                  |L1.15888|
003e10  4638              MOV      r0,r7                 ;259
003e12  f7fffffe          BL       sys_arch_unprotect
003e16  bf00              NOP                            ;259
003e18  4628              MOV      r0,r5                 ;260
003e1a  e7e2              B        |L1.15842|
;;;267    
                          ENDP

                  do_recv PROC
;;;1175   void
;;;1176   do_recv(struct api_msg_msg *msg)
003e1c  b570              PUSH     {r4-r6,lr}
;;;1177   {
003e1e  4604              MOV      r4,r0
;;;1178     msg->err = ERR_OK;
003e20  2000              MOVS     r0,#0
003e22  7120              STRB     r0,[r4,#4]
;;;1179     if (msg->conn->pcb.tcp != NULL) {
003e24  6820              LDR      r0,[r4,#0]
003e26  6840              LDR      r0,[r0,#4]
003e28  b330              CBZ      r0,|L1.15992|
;;;1180       if (msg->conn->type == NETCONN_TCP) {
003e2a  6820              LDR      r0,[r4,#0]
003e2c  7800              LDRB     r0,[r0,#0]
003e2e  2810              CMP      r0,#0x10
003e30  d122              BNE      |L1.15992|
;;;1181   #if TCP_LISTEN_BACKLOG
;;;1182         if (msg->conn->pcb.tcp->state == LISTEN) {
003e32  6820              LDR      r0,[r4,#0]
003e34  6840              LDR      r0,[r0,#4]
003e36  7e00              LDRB     r0,[r0,#0x18]
003e38  2801              CMP      r0,#1
003e3a  d10a              BNE      |L1.15954|
;;;1183           tcp_accepted(msg->conn->pcb.tcp);
003e3c  bf00              NOP      
003e3e  bf00              NOP      
003e40  bf00              NOP      
003e42  6820              LDR      r0,[r4,#0]
003e44  6840              LDR      r0,[r0,#4]
003e46  7f40              LDRB     r0,[r0,#0x1d]
003e48  1e40              SUBS     r0,r0,#1
003e4a  6821              LDR      r1,[r4,#0]
003e4c  6849              LDR      r1,[r1,#4]
003e4e  7748              STRB     r0,[r1,#0x1d]
003e50  e012              B        |L1.15992|
                  |L1.15954|
;;;1184         } else
;;;1185   #endif /* TCP_LISTEN_BACKLOG */
;;;1186         {
;;;1187           u32_t remaining = msg->msg.r.len;
003e52  68a5              LDR      r5,[r4,#8]
;;;1188           do {
003e54  bf00              NOP      
                  |L1.15958|
;;;1189             u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
003e56  f5b53f80          CMP      r5,#0x10000
003e5a  d302              BCC      |L1.15970|
003e5c  f64f70ff          MOV      r0,#0xffff
003e60  e000              B        |L1.15972|
                  |L1.15970|
003e62  b2a8              UXTH     r0,r5
                  |L1.15972|
003e64  4606              MOV      r6,r0
;;;1190             tcp_recved(msg->conn->pcb.tcp, recved);
003e66  6821              LDR      r1,[r4,#0]
003e68  6848              LDR      r0,[r1,#4]
003e6a  4631              MOV      r1,r6
003e6c  f7fffffe          BL       tcp_recved
;;;1191             remaining -= recved;
003e70  1bad              SUBS     r5,r5,r6
;;;1192           }while(remaining != 0);
003e72  2d00              CMP      r5,#0
003e74  d1ef              BNE      |L1.15958|
;;;1193         }
003e76  bf00              NOP      
                  |L1.15992|
;;;1194       }
;;;1195     }
;;;1196     TCPIP_APIMSG_ACK(msg);
003e78  6821              LDR      r1,[r4,#0]
003e7a  f101000c          ADD      r0,r1,#0xc
003e7e  f7fffffe          BL       sys_sem_signal
;;;1197   }
003e82  bd70              POP      {r4-r6,pc}
;;;1198   
                          ENDP

                  sys_arch_mbox_fetch PROC
;;;447    u32_t
;;;448    sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
003e84  b5f8              PUSH     {r3-r7,lr}
;;;449    {
003e86  4605              MOV      r5,r0
003e88  460e              MOV      r6,r1
003e8a  4617              MOV      r7,r2
;;;450      portTickType starttime;
;;;451      void *dummyptr;
;;;452    
;;;453      /* If the actual message contents are not required, provide a local variable
;;;454         to recieve the message. */
;;;455      if(msg == NULL) {
003e8c  b906              CBNZ     r6,|L1.16016|
;;;456        msg = &dummyptr;
003e8e  466e              MOV      r6,sp
                  |L1.16016|
;;;457      }
;;;458    
;;;459      /* Get the starting time. */
;;;460      starttime = xTaskGetTickCount();
003e90  f7fffffe          BL       xTaskGetTickCount
003e94  4604              MOV      r4,r0
;;;461    
;;;462      /* See if there is a timeout. */
;;;463      if(timeout != 0) {
003e96  b17f              CBZ      r7,|L1.16056|
;;;464        /* Receive a message from the queue. */
;;;465        if(xQueueReceive(mbox->queue, msg, timeout / portTICK_RATE_MS) == pdPASS) {
003e98  2300              MOVS     r3,#0
003e9a  463a              MOV      r2,r7
003e9c  4631              MOV      r1,r6
003e9e  6828              LDR      r0,[r5,#0]
003ea0  f7fffffe          BL       xQueueGenericReceive
003ea4  2801              CMP      r0,#1
003ea6  d103              BNE      |L1.16048|
;;;466          /* Return the amount of time it took for the message to be received. */
;;;467          return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
003ea8  f7fffffe          BL       xTaskGetTickCount
003eac  1b00              SUBS     r0,r0,r4
                  |L1.16046|
;;;468        } else {
;;;469          /* No message arrived in the allotted time. */
;;;470          *msg = NULL;
;;;471          return SYS_ARCH_TIMEOUT;
;;;472        }
;;;473      } else {
;;;474        /* Try to receive a message until one arrives. */
;;;475        while(xQueueReceive(mbox->queue, msg, portMAX_DELAY) != pdPASS);
;;;476    
;;;477        /* Return the amount of time it took for the message to be received. */
;;;478        return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
;;;479      }
;;;480    }
003eae  bdf8              POP      {r3-r7,pc}
                  |L1.16048|
003eb0  2000              MOVS     r0,#0                 ;470
003eb2  6030              STR      r0,[r6,#0]            ;470
003eb4  1e40              SUBS     r0,r0,#1              ;471
003eb6  e7fa              B        |L1.16046|
                  |L1.16056|
003eb8  bf00              NOP                            ;475
                  |L1.16058|
003eba  2300              MOVS     r3,#0                 ;475
003ebc  1e5a              SUBS     r2,r3,#1              ;475
003ebe  4631              MOV      r1,r6                 ;475
003ec0  6828              LDR      r0,[r5,#0]            ;475
003ec2  f7fffffe          BL       xQueueGenericReceive
003ec6  2801              CMP      r0,#1                 ;475
003ec8  d1f7              BNE      |L1.16058|
003eca  f7fffffe          BL       xTaskGetTickCount
003ece  1b00              SUBS     r0,r0,r4              ;478
003ed0  e7ed              B        |L1.16046|
;;;481    
                          ENDP

                  netconn_accept PROC
;;;276    err_t
;;;277    netconn_accept(struct netconn *conn, struct netconn **new_conn)
003ed2  b5f0              PUSH     {r4-r7,lr}
;;;278    {
003ed4  b087              SUB      sp,sp,#0x1c
003ed6  4604              MOV      r4,r0
003ed8  460d              MOV      r5,r1
;;;279    #if LWIP_TCP
;;;280      struct netconn *newconn;
;;;281      err_t err;
;;;282    #if TCP_LISTEN_BACKLOG
;;;283      struct api_msg msg;
;;;284    #endif /* TCP_LISTEN_BACKLOG */
;;;285    
;;;286      LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
003eda  bf00              NOP      
003edc  b91d              CBNZ     r5,|L1.16102|
003ede  f06f000d          MVN      r0,#0xd
                  |L1.16098|
;;;287      *new_conn = NULL;
;;;288      LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
;;;289      LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
;;;290    
;;;291      err = conn->last_err;
;;;292      if (ERR_IS_FATAL(err)) {
;;;293        /* don't recv on fatal errors: this might block the application task
;;;294           waiting on acceptmbox forever! */
;;;295        return err;
;;;296      }
;;;297    
;;;298    #if LWIP_SO_RCVTIMEO
;;;299      if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
;;;300        NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
;;;301        return ERR_TIMEOUT;
;;;302      }
;;;303    #else
;;;304      sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
;;;305    #endif /* LWIP_SO_RCVTIMEO*/
;;;306      /* Register event with callback */
;;;307      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
;;;308    
;;;309      if (newconn == NULL) {
;;;310        /* connection has been aborted */
;;;311        NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
;;;312        return ERR_ABRT;
;;;313      }
;;;314    #if TCP_LISTEN_BACKLOG
;;;315      /* Let the stack know that we have accepted the connection. */
;;;316      msg.function = do_recv;
;;;317      msg.msg.conn = conn;
;;;318      /* don't care for the return value of do_recv */
;;;319      TCPIP_APIMSG(&msg);
;;;320    #endif /* TCP_LISTEN_BACKLOG */
;;;321    
;;;322      *new_conn = newconn;
;;;323      /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;324      return ERR_OK;
;;;325    #else /* LWIP_TCP */
;;;326      LWIP_UNUSED_ARG(conn);
;;;327      LWIP_UNUSED_ARG(new_conn);
;;;328      return ERR_ARG;
;;;329    #endif /* LWIP_TCP */
;;;330    }
003ee2  b007              ADD      sp,sp,#0x1c
003ee4  bdf0              POP      {r4-r7,pc}
                  |L1.16102|
003ee6  bf00              NOP                            ;286
003ee8  2000              MOVS     r0,#0                 ;287
003eea  6028              STR      r0,[r5,#0]            ;287
003eec  bf00              NOP                            ;288
003eee  b914              CBNZ     r4,|L1.16118|
003ef0  f06f000d          MVN      r0,#0xd               ;288
003ef4  e7f5              B        |L1.16098|
                  |L1.16118|
003ef6  bf00              NOP                            ;288
003ef8  bf00              NOP                            ;289
003efa  f10400a0          ADD      r0,r4,#0xa0           ;289
003efe  f7fffffe          BL       sys_mbox_valid
003f02  b910              CBNZ     r0,|L1.16138|
003f04  f06f000d          MVN      r0,#0xd               ;289
003f08  e7eb              B        |L1.16098|
                  |L1.16138|
003f0a  bf00              NOP                            ;289
003f0c  f9946008          LDRSB    r6,[r4,#8]            ;291
003f10  f1160f09          CMN      r6,#9                 ;292
003f14  da01              BGE      |L1.16154|
003f16  4630              MOV      r0,r6                 ;295
003f18  e7e3              B        |L1.16098|
                  |L1.16154|
003f1a  a906              ADD      r1,sp,#0x18           ;299
003f1c  f10400a0          ADD      r0,r4,#0xa0           ;299
003f20  f8d42128          LDR      r2,[r4,#0x128]        ;299
003f24  f7fffffe          BL       sys_arch_mbox_fetch
003f28  1c40              ADDS     r0,r0,#1              ;299
003f2a  d111              BNE      |L1.16208|
003f2c  bf00              NOP                            ;300
003f2e  f7fffffe          BL       sys_arch_protect
003f32  4607              MOV      r7,r0                 ;300
003f34  f9940008          LDRSB    r0,[r4,#8]            ;300
003f38  f1100f09          CMN      r0,#9                 ;300
003f3c  db01              BLT      |L1.16194|
003f3e  20fd              MOVS     r0,#0xfd              ;300
003f40  7220              STRB     r0,[r4,#8]            ;300
                  |L1.16194|
003f42  4638              MOV      r0,r7                 ;300
003f44  f7fffffe          BL       sys_arch_unprotect
003f48  bf00              NOP                            ;300
003f4a  f06f0002          MVN      r0,#2                 ;301
003f4e  e7c8              B        |L1.16098|
                  |L1.16208|
003f50  f8d40138          LDR      r0,[r4,#0x138]        ;307
003f54  b128              CBZ      r0,|L1.16226|
003f56  2200              MOVS     r2,#0                 ;307
003f58  2101              MOVS     r1,#1                 ;307
003f5a  4620              MOV      r0,r4                 ;307
003f5c  f8d43138          LDR      r3,[r4,#0x138]        ;307
003f60  4798              BLX      r3                    ;307
                  |L1.16226|
003f62  9806              LDR      r0,[sp,#0x18]         ;309
003f64  b988              CBNZ     r0,|L1.16266|
003f66  bf00              NOP                            ;311
003f68  f7fffffe          BL       sys_arch_protect
003f6c  4607              MOV      r7,r0                 ;311
003f6e  f9940008          LDRSB    r0,[r4,#8]            ;311
003f72  f1100f09          CMN      r0,#9                 ;311
003f76  db01              BLT      |L1.16252|
003f78  20f6              MOVS     r0,#0xf6              ;311
003f7a  7220              STRB     r0,[r4,#8]            ;311
                  |L1.16252|
003f7c  4638              MOV      r0,r7                 ;311
003f7e  f7fffffe          BL       sys_arch_unprotect
003f82  bf00              NOP                            ;311
003f84  f06f0009          MVN      r0,#9                 ;312
003f88  e7ab              B        |L1.16098|
                  |L1.16266|
003f8a  f2af106f          ADR      r0,do_recv + 1
003f8e  9000              STR      r0,[sp,#0]            ;316
003f90  9401              STR      r4,[sp,#4]            ;317
003f92  4668              MOV      r0,sp                 ;319
003f94  f7fffffe          BL       tcpip_apimsg
003f98  9806              LDR      r0,[sp,#0x18]         ;322
003f9a  6028              STR      r0,[r5,#0]            ;322
003f9c  2000              MOVS     r0,#0                 ;324
003f9e  e7a0              B        |L1.16098|
;;;331    
                          ENDP

                  netconn_recv_data PROC
;;;341    static err_t
;;;342    netconn_recv_data(struct netconn *conn, void **new_buf)
003fa0  e92d41f0          PUSH     {r4-r8,lr}
;;;343    {
003fa4  b088              SUB      sp,sp,#0x20
003fa6  4604              MOV      r4,r0
003fa8  460d              MOV      r5,r1
;;;344      void *buf = NULL;
003faa  2000              MOVS     r0,#0
003fac  9007              STR      r0,[sp,#0x1c]
;;;345      u16_t len;
;;;346      err_t err;
;;;347    #if LWIP_TCP
;;;348      struct api_msg msg;
;;;349    #endif /* LWIP_TCP */
;;;350    
;;;351      LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
003fae  bf00              NOP      
003fb0  b925              CBNZ     r5,|L1.16316|
003fb2  f06f000d          MVN      r0,#0xd
                  |L1.16310|
;;;352      *new_buf = NULL;
;;;353      LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
;;;354      LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
;;;355    
;;;356      err = conn->last_err;
;;;357      if (ERR_IS_FATAL(err)) {
;;;358        /* don't recv on fatal errors: this might block the application task
;;;359           waiting on recvmbox forever! */
;;;360        /* @todo: this does not allow us to fetch data that has been put into recvmbox
;;;361           before the fatal error occurred - is that a problem? */
;;;362        return err;
;;;363      }
;;;364    
;;;365    #if LWIP_SO_RCVTIMEO
;;;366      if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
;;;367        NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
;;;368        return ERR_TIMEOUT;
;;;369      }
;;;370    #else
;;;371      sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
;;;372    #endif /* LWIP_SO_RCVTIMEO*/
;;;373    
;;;374    #if LWIP_TCP
;;;375    #if (LWIP_UDP || LWIP_RAW)
;;;376      if (conn->type == NETCONN_TCP)
;;;377    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;378      {
;;;379        if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
;;;380          /* Let the stack know that we have taken the data. */
;;;381          /* TODO: Speedup: Don't block and wait for the answer here
;;;382             (to prevent multiple thread-switches). */
;;;383          msg.function = do_recv;
;;;384          msg.msg.conn = conn;
;;;385          if (buf != NULL) {
;;;386            msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
;;;387          } else {
;;;388            msg.msg.msg.r.len = 1;
;;;389          }
;;;390          /* don't care for the return value of do_recv */
;;;391          TCPIP_APIMSG(&msg);
;;;392        }
;;;393    
;;;394        /* If we are closed, we indicate that we no longer wish to use the socket */
;;;395        if (buf == NULL) {
;;;396          API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
;;;397          /* Avoid to lose any previous error code */
;;;398          NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
;;;399          return ERR_CLSD;
;;;400        }
;;;401        len = ((struct pbuf *)buf)->tot_len;
;;;402      }
;;;403    #endif /* LWIP_TCP */
;;;404    #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
;;;405      else
;;;406    #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
;;;407    #if (LWIP_UDP || LWIP_RAW)
;;;408      {
;;;409        LWIP_ASSERT("buf != NULL", buf != NULL);
;;;410        len = netbuf_len((struct netbuf *)buf);
;;;411      }
;;;412    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;413    
;;;414    #if LWIP_SO_RCVBUF
;;;415      SYS_ARCH_DEC(conn->recv_avail, len);
;;;416    #endif /* LWIP_SO_RCVBUF */
;;;417      /* Register event with callback */
;;;418      API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
;;;419    
;;;420      LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));
;;;421    
;;;422      *new_buf = buf;
;;;423      /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;424      return ERR_OK;
;;;425    }
003fb6  b008              ADD      sp,sp,#0x20
003fb8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.16316|
003fbc  bf00              NOP                            ;351
003fbe  2000              MOVS     r0,#0                 ;352
003fc0  6028              STR      r0,[r5,#0]            ;352
003fc2  bf00              NOP                            ;353
003fc4  b914              CBNZ     r4,|L1.16332|
003fc6  f06f000d          MVN      r0,#0xd               ;353
003fca  e7f4              B        |L1.16310|
                  |L1.16332|
003fcc  bf00              NOP                            ;353
003fce  bf00              NOP                            ;354
003fd0  f1040018          ADD      r0,r4,#0x18           ;354
003fd4  f7fffffe          BL       sys_mbox_valid
003fd8  b910              CBNZ     r0,|L1.16352|
003fda  f06f000c          MVN      r0,#0xc               ;354
003fde  e7ea              B        |L1.16310|
                  |L1.16352|
003fe0  bf00              NOP                            ;354
003fe2  f9947008          LDRSB    r7,[r4,#8]            ;356
003fe6  f1170f09          CMN      r7,#9                 ;357
003fea  da01              BGE      |L1.16368|
003fec  4638              MOV      r0,r7                 ;362
003fee  e7e2              B        |L1.16310|
                  |L1.16368|
003ff0  a907              ADD      r1,sp,#0x1c           ;366
003ff2  f1040018          ADD      r0,r4,#0x18           ;366
003ff6  f8d42128          LDR      r2,[r4,#0x128]        ;366
003ffa  f7fffffe          BL       sys_arch_mbox_fetch
003ffe  1c40              ADDS     r0,r0,#1              ;366
004000  d111              BNE      |L1.16422|
004002  bf00              NOP                            ;367
004004  f7fffffe          BL       sys_arch_protect
004008  4680              MOV      r8,r0                 ;367
00400a  f9940008          LDRSB    r0,[r4,#8]            ;367
00400e  f1100f09          CMN      r0,#9                 ;367
004012  db01              BLT      |L1.16408|
004014  20fd              MOVS     r0,#0xfd              ;367
004016  7220              STRB     r0,[r4,#8]            ;367
                  |L1.16408|
004018  4640              MOV      r0,r8                 ;367
00401a  f7fffffe          BL       sys_arch_unprotect
00401e  bf00              NOP                            ;367
004020  f06f0002          MVN      r0,#2                 ;368
004024  e7c7              B        |L1.16310|
                  |L1.16422|
004026  7820              LDRB     r0,[r4,#0]            ;376
004028  2810              CMP      r0,#0x10              ;376
00402a  d135              BNE      |L1.16536|
00402c  f894012c          LDRB     r0,[r4,#0x12c]        ;379
004030  f0100f08          TST      r0,#8                 ;379
004034  d001              BEQ      |L1.16442|
004036  9807              LDR      r0,[sp,#0x1c]         ;379
004038  b970              CBNZ     r0,|L1.16472|
                  |L1.16442|
00403a  f2af201f          ADR      r0,do_recv + 1
00403e  9001              STR      r0,[sp,#4]            ;383
004040  9402              STR      r4,[sp,#8]            ;384
004042  9807              LDR      r0,[sp,#0x1c]         ;385
004044  b118              CBZ      r0,|L1.16462|
004046  9807              LDR      r0,[sp,#0x1c]         ;386
004048  8901              LDRH     r1,[r0,#8]            ;386
00404a  9104              STR      r1,[sp,#0x10]         ;386
00404c  e001              B        |L1.16466|
                  |L1.16462|
00404e  2101              MOVS     r1,#1                 ;388
004050  9104              STR      r1,[sp,#0x10]         ;388
                  |L1.16466|
004052  a801              ADD      r0,sp,#4              ;391
004054  f7fffffe          BL       tcpip_apimsg
                  |L1.16472|
004058  9807              LDR      r0,[sp,#0x1c]         ;395
00405a  b9d0              CBNZ     r0,|L1.16530|
00405c  f8d40138          LDR      r0,[r4,#0x138]        ;396
004060  b128              CBZ      r0,|L1.16494|
004062  2200              MOVS     r2,#0                 ;396
004064  2101              MOVS     r1,#1                 ;396
004066  4620              MOV      r0,r4                 ;396
004068  f8d43138          LDR      r3,[r4,#0x138]        ;396
00406c  4798              BLX      r3                    ;396
                  |L1.16494|
00406e  bf00              NOP                            ;398
004070  f7fffffe          BL       sys_arch_protect
004074  4680              MOV      r8,r0                 ;398
004076  f9940008          LDRSB    r0,[r4,#8]            ;398
00407a  f1100f09          CMN      r0,#9                 ;398
00407e  db01              BLT      |L1.16516|
004080  20f4              MOVS     r0,#0xf4              ;398
004082  7220              STRB     r0,[r4,#8]            ;398
                  |L1.16516|
004084  4640              MOV      r0,r8                 ;398
004086  f7fffffe          BL       sys_arch_unprotect
00408a  bf00              NOP                            ;398
00408c  f06f000b          MVN      r0,#0xb               ;399
004090  e791              B        |L1.16310|
                  |L1.16530|
004092  9807              LDR      r0,[sp,#0x1c]         ;401
004094  8906              LDRH     r6,[r0,#8]            ;401
004096  e004              B        |L1.16546|
                  |L1.16536|
004098  bf00              NOP                            ;409
00409a  bf00              NOP                            ;409
00409c  9807              LDR      r0,[sp,#0x1c]         ;410
00409e  6800              LDR      r0,[r0,#0]            ;410
0040a0  8906              LDRH     r6,[r0,#8]            ;410
                  |L1.16546|
0040a2  f8d40138          LDR      r0,[r4,#0x138]        ;418
0040a6  b128              CBZ      r0,|L1.16564|
0040a8  4632              MOV      r2,r6                 ;418
0040aa  2101              MOVS     r1,#1                 ;418
0040ac  4620              MOV      r0,r4                 ;418
0040ae  f8d43138          LDR      r3,[r4,#0x138]        ;418
0040b2  4798              BLX      r3                    ;418
                  |L1.16564|
0040b4  bf00              NOP                            ;420
0040b6  bf00              NOP                            ;420
0040b8  9807              LDR      r0,[sp,#0x1c]         ;422
0040ba  6028              STR      r0,[r5,#0]            ;422
0040bc  2000              MOVS     r0,#0                 ;424
0040be  e77a              B        |L1.16310|
;;;426    
                          ENDP

                  netconn_recv_tcp_pbuf PROC
;;;436    err_t
;;;437    netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
0040c0  b570              PUSH     {r4-r6,lr}
;;;438    {
0040c2  4604              MOV      r4,r0
0040c4  460d              MOV      r5,r1
;;;439      LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
0040c6  bf00              NOP      
0040c8  b114              CBZ      r4,|L1.16592|
0040ca  7820              LDRB     r0,[r4,#0]
0040cc  2810              CMP      r0,#0x10
0040ce  d002              BEQ      |L1.16598|
                  |L1.16592|
0040d0  f06f000d          MVN      r0,#0xd
                  |L1.16596|
;;;440                 netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);
;;;441    
;;;442      return netconn_recv_data(conn, (void **)new_buf);
;;;443    }
0040d4  bd70              POP      {r4-r6,pc}
                  |L1.16598|
0040d6  bf00              NOP                            ;439
0040d8  4629              MOV      r1,r5                 ;442
0040da  4620              MOV      r0,r4                 ;442
0040dc  f7fffffe          BL       netconn_recv_data
0040e0  e7f8              B        |L1.16596|
;;;444    
                          ENDP

                  netconn_recv PROC
;;;453    err_t
;;;454    netconn_recv(struct netconn *conn, struct netbuf **new_buf)
0040e2  e92d43f8          PUSH     {r3-r9,lr}
;;;455    {
0040e6  4605              MOV      r5,r0
0040e8  460e              MOV      r6,r1
;;;456    #if LWIP_TCP
;;;457      struct netbuf *buf = NULL;
0040ea  2400              MOVS     r4,#0
;;;458      err_t err;
;;;459    #endif /* LWIP_TCP */
;;;460    
;;;461      LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
0040ec  bf00              NOP      
0040ee  b91e              CBNZ     r6,|L1.16632|
0040f0  f06f000d          MVN      r0,#0xd
                  |L1.16628|
;;;462      *new_buf = NULL;
;;;463      LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
;;;464      LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
;;;465    
;;;466    #if LWIP_TCP
;;;467    #if (LWIP_UDP || LWIP_RAW)
;;;468      if (conn->type == NETCONN_TCP)
;;;469    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;470      {
;;;471        struct pbuf *p = NULL;
;;;472        /* This is not a listening netconn, since recvmbox is set */
;;;473    
;;;474        buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;475        if (buf == NULL) {
;;;476          NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
;;;477          return ERR_MEM;
;;;478        }
;;;479    
;;;480        err = netconn_recv_data(conn, (void **)&p);
;;;481        if (err != ERR_OK) {
;;;482          memp_free(MEMP_NETBUF, buf);
;;;483          return err;
;;;484        }
;;;485        LWIP_ASSERT("p != NULL", p != NULL);
;;;486    
;;;487        buf->p = p;
;;;488        buf->ptr = p;
;;;489        buf->port = 0;
;;;490        ip_addr_set_any(&buf->addr);
;;;491        *new_buf = buf;
;;;492        /* don't set conn->last_err: it's only ERR_OK, anyway */
;;;493        return ERR_OK;
;;;494      }
;;;495    #endif /* LWIP_TCP */
;;;496    #if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
;;;497      else
;;;498    #endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
;;;499      {
;;;500    #if (LWIP_UDP || LWIP_RAW)
;;;501        return netconn_recv_data(conn, (void **)new_buf);
;;;502    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;503      }
;;;504    }
0040f4  e8bd83f8          POP      {r3-r9,pc}
                  |L1.16632|
0040f8  bf00              NOP                            ;461
0040fa  2000              MOVS     r0,#0                 ;462
0040fc  6030              STR      r0,[r6,#0]            ;462
0040fe  bf00              NOP                            ;463
004100  b915              CBNZ     r5,|L1.16648|
004102  f06f000d          MVN      r0,#0xd               ;463
004106  e7f5              B        |L1.16628|
                  |L1.16648|
004108  bf00              NOP                            ;463
00410a  bf00              NOP                            ;464
00410c  f1050018          ADD      r0,r5,#0x18           ;464
004110  f7fffffe          BL       sys_mbox_valid
004114  b910              CBNZ     r0,|L1.16668|
004116  f06f000c          MVN      r0,#0xc               ;464
00411a  e7eb              B        |L1.16628|
                  |L1.16668|
00411c  bf00              NOP                            ;464
00411e  7828              LDRB     r0,[r5,#0]            ;468
004120  2810              CMP      r0,#0x10              ;468
004122  d12f              BNE      |L1.16772|
004124  2000              MOVS     r0,#0                 ;471
004126  9000              STR      r0,[sp,#0]            ;471
004128  2005              MOVS     r0,#5                 ;474
00412a  f7fffffe          BL       memp_malloc
00412e  4604              MOV      r4,r0                 ;474
004130  b98c              CBNZ     r4,|L1.16726|
004132  bf00              NOP                            ;476
004134  f7fffffe          BL       sys_arch_protect
004138  4680              MOV      r8,r0                 ;476
00413a  f9950008          LDRSB    r0,[r5,#8]            ;476
00413e  f1100f09          CMN      r0,#9                 ;476
004142  db01              BLT      |L1.16712|
004144  20ff              MOVS     r0,#0xff              ;476
004146  7228              STRB     r0,[r5,#8]            ;476
                  |L1.16712|
004148  4640              MOV      r0,r8                 ;476
00414a  f7fffffe          BL       sys_arch_unprotect
00414e  bf00              NOP                            ;476
004150  f04f30ff          MOV      r0,#0xffffffff        ;477
004154  e7ce              B        |L1.16628|
                  |L1.16726|
004156  4669              MOV      r1,sp                 ;480
004158  4628              MOV      r0,r5                 ;480
00415a  f7fffffe          BL       netconn_recv_data
00415e  4607              MOV      r7,r0                 ;480
004160  b12f              CBZ      r7,|L1.16750|
004162  4621              MOV      r1,r4                 ;482
004164  2005              MOVS     r0,#5                 ;482
004166  f7fffffe          BL       memp_free
00416a  4638              MOV      r0,r7                 ;483
00416c  e7c2              B        |L1.16628|
                  |L1.16750|
00416e  bf00              NOP                            ;485
004170  bf00              NOP                            ;485
004172  9800              LDR      r0,[sp,#0]            ;487
004174  6020              STR      r0,[r4,#0]            ;487
004176  9800              LDR      r0,[sp,#0]            ;488
004178  6060              STR      r0,[r4,#4]            ;488
00417a  2000              MOVS     r0,#0                 ;489
00417c  81a0              STRH     r0,[r4,#0xc]          ;489
00417e  60a0              STR      r0,[r4,#8]            ;490
004180  6034              STR      r4,[r6,#0]            ;491
004182  e7b7              B        |L1.16628|
                  |L1.16772|
004184  4631              MOV      r1,r6                 ;501
004186  4628              MOV      r0,r5                 ;501
004188  f7fffffe          BL       netconn_recv_data
00418c  e7b2              B        |L1.16628|
00418e  0000              DCW      0x0000
                  |L1.16784|
                          DCD      accept_function
                          ENDP

                  netconn_recved PROC
;;;516    void
;;;517    netconn_recved(struct netconn *conn, u32_t length)
004194  b530              PUSH     {r4,r5,lr}
;;;518    {
004196  b087              SUB      sp,sp,#0x1c
004198  4604              MOV      r4,r0
00419a  460d              MOV      r5,r1
;;;519    #if LWIP_TCP
;;;520      if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
00419c  b184              CBZ      r4,|L1.16832|
00419e  7820              LDRB     r0,[r4,#0]
0041a0  2810              CMP      r0,#0x10
0041a2  d10d              BNE      |L1.16832|
;;;521          (netconn_get_noautorecved(conn))) {
0041a4  f894012c          LDRB     r0,[r4,#0x12c]
0041a8  f0100f08          TST      r0,#8
0041ac  d008              BEQ      |L1.16832|
;;;522        struct api_msg msg;
;;;523        /* Let the stack know that we have taken the data. */
;;;524        /* TODO: Speedup: Don't block and wait for the answer here
;;;525           (to prevent multiple thread-switches). */
;;;526        msg.function = do_recv;
0041ae  f2af3093          ADR      r0,do_recv + 1
0041b2  9001              STR      r0,[sp,#4]
;;;527        msg.msg.conn = conn;
0041b4  9402              STR      r4,[sp,#8]
;;;528        msg.msg.msg.r.len = length;
0041b6  9504              STR      r5,[sp,#0x10]
;;;529        /* don't care for the return value of do_recv */
;;;530        TCPIP_APIMSG(&msg);
0041b8  a801              ADD      r0,sp,#4
0041ba  f7fffffe          BL       tcpip_apimsg
;;;531      }
0041be  bf00              NOP      
                  |L1.16832|
;;;532    #else /* LWIP_TCP */
;;;533      LWIP_UNUSED_ARG(conn);
;;;534      LWIP_UNUSED_ARG(length);
;;;535    #endif /* LWIP_TCP */
;;;536    }
0041c0  b007              ADD      sp,sp,#0x1c
0041c2  bd30              POP      {r4,r5,pc}
;;;537    
                          ENDP

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
0041c4  b570              PUSH     {r4-r6,lr}
;;;724    {
0041c6  4604              MOV      r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
0041c8  b144              CBZ      r4,|L1.16860|
;;;728        SYS_ARCH_PROTECT(old_level);
0041ca  f7fffffe          BL       sys_arch_protect
0041ce  4605              MOV      r5,r0
;;;729        ++(p->ref);
0041d0  89e0              LDRH     r0,[r4,#0xe]
0041d2  1c40              ADDS     r0,r0,#1
0041d4  81e0              STRH     r0,[r4,#0xe]
;;;730        SYS_ARCH_UNPROTECT(old_level);
0041d6  4628              MOV      r0,r5
0041d8  f7fffffe          BL       sys_arch_unprotect
                  |L1.16860|
;;;731      }
;;;732    }
0041dc  bd70              POP      {r4-r6,pc}
;;;733    
                          ENDP

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
0041de  b570              PUSH     {r4-r6,lr}
;;;787    {
0041e0  4605              MOV      r5,r0
0041e2  460c              MOV      r4,r1
;;;788      pbuf_cat(h, t);
0041e4  4621              MOV      r1,r4
0041e6  4628              MOV      r0,r5
0041e8  f7fffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
0041ec  4620              MOV      r0,r4
0041ee  f7fffffe          BL       pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
0041f2  bf00              NOP      
0041f4  bf00              NOP      
;;;792    }
0041f6  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP

                  udp_sendto_if PROC
;;;548    err_t
;;;549    udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
0041f8  e92d4fff          PUSH     {r0-r11,lr}
;;;550      ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
;;;551    {
0041fc  b083              SUB      sp,sp,#0xc
0041fe  4604              MOV      r4,r0
004200  460e              MOV      r6,r1
004202  4693              MOV      r11,r2
004204  f8dd8040          LDR      r8,[sp,#0x40]
;;;552    #if LWIP_CHECKSUM_ON_COPY
;;;553      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
;;;554    }
;;;555    
;;;556    /** Same as udp_sendto_if(), but with checksum */
;;;557    err_t
;;;558    udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
;;;559                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
;;;560                         u16_t chksum)
;;;561    {
;;;562    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;563      struct udp_hdr *udphdr;
;;;564      ip_addr_t *src_ip;
;;;565      err_t err;
;;;566      struct pbuf *q; /* q will be sent down the stack */
;;;567    
;;;568    #if IP_SOF_BROADCAST
;;;569      /* broadcast filter? */
;;;570      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(dst_ip, netif)) {
;;;571        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;572          ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;573        return ERR_VAL;
;;;574      }
;;;575    #endif /* IP_SOF_BROADCAST */
;;;576    
;;;577      /* if the PCB is not yet bound to a port, bind it here */
;;;578      if (pcb->local_port == 0) {
004208  8a60              LDRH     r0,[r4,#0x12]
00420a  b980              CBNZ     r0,|L1.16942|
;;;579        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
00420c  bf00              NOP      
00420e  bf00              NOP      
;;;580        err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
004210  8a62              LDRH     r2,[r4,#0x12]
004212  4621              MOV      r1,r4
004214  4620              MOV      r0,r4
004216  f7fffffe          BL       udp_bind
00421a  4682              MOV      r10,r0
;;;581        if (err != ERR_OK) {
00421c  f1ba0f00          CMP      r10,#0
004220  d005              BEQ      |L1.16942|
;;;582          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
004222  bf00              NOP      
004224  bf00              NOP      
;;;583          return err;
004226  4650              MOV      r0,r10
                  |L1.16936|
;;;584        }
;;;585      }
;;;586    
;;;587      /* not enough space to add an UDP header to first pbuf in given p chain? */
;;;588      if (pbuf_header(p, UDP_HLEN)) {
;;;589        /* allocate header in a separate new pbuf */
;;;590        q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
;;;591        /* new header pbuf could not be allocated? */
;;;592        if (q == NULL) {
;;;593          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
;;;594          return ERR_MEM;
;;;595        }
;;;596        if (p->tot_len != 0) {
;;;597          /* chain header q in front of given pbuf p (only if p contains data) */
;;;598          pbuf_chain(q, p);
;;;599        }
;;;600        /* first pbuf q points to header pbuf */
;;;601        LWIP_DEBUGF(UDP_DEBUG,
;;;602                    ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;603      } else {
;;;604        /* adding space for header within p succeeded */
;;;605        /* first pbuf q equals given pbuf */
;;;606        q = p;
;;;607        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
;;;608      }
;;;609      LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
;;;610                  (q->len >= sizeof(struct udp_hdr)));
;;;611      /* q now represents the packet to be sent */
;;;612      udphdr = (struct udp_hdr *)q->payload;
;;;613      udphdr->src = htons(pcb->local_port);
;;;614      udphdr->dest = htons(dst_port);
;;;615      /* in UDP, 0 checksum means 'no checksum' */
;;;616      udphdr->chksum = 0x0000; 
;;;617    
;;;618      /* Multicast Loop? */
;;;619    #if LWIP_IGMP
;;;620      if (ip_addr_ismulticast(dst_ip) && ((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)) {
;;;621        q->flags |= PBUF_FLAG_MCASTLOOP;
;;;622      }
;;;623    #endif /* LWIP_IGMP */
;;;624    
;;;625    
;;;626      /* PCB local address is IP_ANY_ADDR? */
;;;627      if (ip_addr_isany(&pcb->local_ip)) {
;;;628        /* use outgoing network interface IP address as source address */
;;;629        src_ip = &(netif->ip_addr);
;;;630      } else {
;;;631        /* check if UDP PCB local IP address is correct
;;;632         * this could be an old address if netif->ip_addr has changed */
;;;633        if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
;;;634          /* local_ip doesn't match, drop the packet */
;;;635          if (q != p) {
;;;636            /* free the header pbuf */
;;;637            pbuf_free(q);
;;;638            q = NULL;
;;;639            /* p is still referenced by the caller, and will live on */
;;;640          }
;;;641          return ERR_VAL;
;;;642        }
;;;643        /* use UDP PCB local IP address as source address */
;;;644        src_ip = &(pcb->local_ip);
;;;645      }
;;;646    
;;;647      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
;;;648    
;;;649    #if LWIP_UDPLITE
;;;650      /* UDP Lite protocol? */
;;;651      if (pcb->flags & UDP_FLAGS_UDPLITE) {
;;;652        u16_t chklen, chklen_hdr;
;;;653        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
;;;654        /* set UDP message length in UDP header */
;;;655        chklen_hdr = chklen = pcb->chksum_len_tx;
;;;656        if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
;;;657          if (chklen != 0) {
;;;658            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
;;;659          }
;;;660          /* For UDP-Lite, checksum length of 0 means checksum
;;;661             over the complete packet. (See RFC 3828 chap. 3.1)
;;;662             At least the UDP-Lite header must be covered by the
;;;663             checksum, therefore, if chksum_len has an illegal
;;;664             value, we generate the checksum over the complete
;;;665             packet to be safe. */
;;;666          chklen_hdr = 0;
;;;667          chklen = q->tot_len;
;;;668        }
;;;669        udphdr->len = htons(chklen_hdr);
;;;670        /* calculate checksum */
;;;671    #if CHECKSUM_GEN_UDP
;;;672        udphdr->chksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip,
;;;673          IP_PROTO_UDPLITE, q->tot_len,
;;;674    #if !LWIP_CHECKSUM_ON_COPY
;;;675          chklen);
;;;676    #else /* !LWIP_CHECKSUM_ON_COPY */
;;;677          (have_chksum ? UDP_HLEN : chklen));
;;;678        if (have_chksum) {
;;;679          u32_t acc;
;;;680          acc = udphdr->chksum + (u16_t)~(chksum);
;;;681          udphdr->chksum = FOLD_U32T(acc);
;;;682        }
;;;683    #endif /* !LWIP_CHECKSUM_ON_COPY */
;;;684    
;;;685        /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;686        if (udphdr->chksum == 0x0000) {
;;;687          udphdr->chksum = 0xffff;
;;;688        }
;;;689    #endif /* CHECKSUM_GEN_UDP */
;;;690        /* output to IP */
;;;691        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDPLITE,)\n"));
;;;692        NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;693        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDPLITE, netif);
;;;694        NETIF_SET_HWADDRHINT(netif, NULL);
;;;695      } else
;;;696    #endif /* LWIP_UDPLITE */
;;;697      {      /* UDP */
;;;698        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
;;;699        udphdr->len = htons(q->tot_len);
;;;700        /* calculate checksum */
;;;701    #if CHECKSUM_GEN_UDP
;;;702        if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
;;;703          u16_t udpchksum;
;;;704    #if LWIP_CHECKSUM_ON_COPY
;;;705          if (have_chksum) {
;;;706            u32_t acc;
;;;707            udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
;;;708              q->tot_len, UDP_HLEN);
;;;709            acc = udpchksum + (u16_t)~(chksum);
;;;710            udpchksum = FOLD_U32T(acc);
;;;711          } else
;;;712    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;713          {
;;;714            udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
;;;715          }
;;;716    
;;;717          /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;718          if (udpchksum == 0x0000) {
;;;719            udpchksum = 0xffff;
;;;720          }
;;;721          udphdr->chksum = udpchksum;
;;;722        }
;;;723    #endif /* CHECKSUM_GEN_UDP */
;;;724        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
;;;725        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
;;;726        /* output to IP */
;;;727        NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;728        err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
;;;729        NETIF_SET_HWADDRHINT(netif, NULL);
;;;730      }
;;;731      /* TODO: must this be increased even if error occured? */
;;;732      snmp_inc_udpoutdatagrams();
;;;733    
;;;734      /* did we chain a separate header pbuf earlier? */
;;;735      if (q != p) {
;;;736        /* free the header pbuf */
;;;737        pbuf_free(q);
;;;738        q = NULL;
;;;739        /* p is still referenced by the caller, and will live on */
;;;740      }
;;;741    
;;;742      UDP_STATS_INC(udp.xmit);
;;;743      return err;
;;;744    }
004228  b007              ADD      sp,sp,#0x1c
00422a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.16942|
00422e  2108              MOVS     r1,#8                 ;588
004230  4630              MOV      r0,r6                 ;588
004232  f7fffffe          BL       pbuf_header
004236  b198              CBZ      r0,|L1.16992|
004238  2200              MOVS     r2,#0                 ;590
00423a  2108              MOVS     r1,#8                 ;590
00423c  2001              MOVS     r0,#1                 ;590
00423e  f7fffffe          BL       pbuf_alloc
004242  4605              MOV      r5,r0                 ;590
004244  b925              CBNZ     r5,|L1.16976|
004246  bf00              NOP                            ;593
004248  bf00              NOP                            ;593
00424a  f04f30ff          MOV      r0,#0xffffffff        ;594
00424e  e7eb              B        |L1.16936|
                  |L1.16976|
004250  8930              LDRH     r0,[r6,#8]            ;596
004252  b118              CBZ      r0,|L1.16988|
004254  4631              MOV      r1,r6                 ;598
004256  4628              MOV      r0,r5                 ;598
004258  f7fffffe          BL       pbuf_chain
                  |L1.16988|
00425c  bf00              NOP                            ;601
00425e  e002              B        |L1.16998|
                  |L1.16992|
004260  4635              MOV      r5,r6                 ;606
004262  bf00              NOP                            ;607
004264  bf00              NOP                            ;607
                  |L1.16998|
004266  bf00              NOP                            ;609
004268  bf00              NOP                            ;609
00426a  686f              LDR      r7,[r5,#4]            ;612
00426c  8a60              LDRH     r0,[r4,#0x12]         ;613
00426e  f7fffffe          BL       lwip_htons
004272  8038              STRH     r0,[r7,#0]            ;613
004274  9806              LDR      r0,[sp,#0x18]         ;614
004276  f7fffffe          BL       lwip_htons
00427a  8078              STRH     r0,[r7,#2]            ;614
00427c  2000              MOVS     r0,#0                 ;616
00427e  80f8              STRH     r0,[r7,#6]            ;616
004280  f89b0000          LDRB     r0,[r11,#0]           ;620
004284  f00000f0          AND      r0,r0,#0xf0           ;620
004288  28e0              CMP      r0,#0xe0              ;620
00428a  d107              BNE      |L1.17052|
00428c  7c20              LDRB     r0,[r4,#0x10]         ;620
00428e  f0100f08          TST      r0,#8                 ;620
004292  d003              BEQ      |L1.17052|
004294  7b68              LDRB     r0,[r5,#0xd]          ;621
004296  f0400004          ORR      r0,r0,#4              ;621
00429a  7368              STRB     r0,[r5,#0xd]          ;621
                  |L1.17052|
00429c  b10c              CBZ      r4,|L1.17058|
00429e  6820              LDR      r0,[r4,#0]            ;627
0042a0  b910              CBNZ     r0,|L1.17064|
                  |L1.17058|
0042a2  f1080904          ADD      r9,r8,#4              ;629
0042a6  e00e              B        |L1.17094|
                  |L1.17064|
0042a8  6820              LDR      r0,[r4,#0]            ;633
0042aa  f8d81004          LDR      r1,[r8,#4]            ;633
0042ae  4288              CMP      r0,r1                 ;633
0042b0  d008              BEQ      |L1.17092|
0042b2  42b5              CMP      r5,r6                 ;635
0042b4  d003              BEQ      |L1.17086|
0042b6  4628              MOV      r0,r5                 ;637
0042b8  f7fffffe          BL       pbuf_free
0042bc  2500              MOVS     r5,#0                 ;638
                  |L1.17086|
0042be  f06f0005          MVN      r0,#5                 ;641
0042c2  e7b1              B        |L1.16936|
                  |L1.17092|
0042c4  46a1              MOV      r9,r4                 ;644
                  |L1.17094|
0042c6  bf00              NOP                            ;647
0042c8  bf00              NOP                            ;647
0042ca  bf00              NOP                            ;698
0042cc  bf00              NOP                            ;698
0042ce  8928              LDRH     r0,[r5,#8]            ;699
0042d0  f7fffffe          BL       lwip_htons
0042d4  80b8              STRH     r0,[r7,#4]            ;699
0042d6  bf00              NOP                            ;724
0042d8  bf00              NOP                            ;724
0042da  bf00              NOP                            ;725
0042dc  bf00              NOP                            ;725
0042de  2111              MOVS     r1,#0x11              ;728
0042e0  7a60              LDRB     r0,[r4,#9]            ;728
0042e2  e88d0103          STM      sp,{r0,r1,r8}         ;728
0042e6  7aa3              LDRB     r3,[r4,#0xa]          ;728
0042e8  465a              MOV      r2,r11                ;728
0042ea  4649              MOV      r1,r9                 ;728
0042ec  4628              MOV      r0,r5                 ;728
0042ee  f7fffffe          BL       ip_output_if
0042f2  4682              MOV      r10,r0                ;728
0042f4  42b5              CMP      r5,r6                 ;735
0042f6  d003              BEQ      |L1.17152|
0042f8  4628              MOV      r0,r5                 ;737
0042fa  f7fffffe          BL       pbuf_free
0042fe  2500              MOVS     r5,#0                 ;738
                  |L1.17152|
004300  48f9              LDR      r0,|L1.18152|
004302  f8b0007c          LDRH     r0,[r0,#0x7c]         ;742  ; lwip_stats
004306  1c40              ADDS     r0,r0,#1              ;742
004308  49f7              LDR      r1,|L1.18152|
00430a  f8a1007c          STRH     r0,[r1,#0x7c]         ;742
00430e  4650              MOV      r0,r10                ;743
004310  e78a              B        |L1.16936|
;;;745    
                          ENDP

                  udp_sendto PROC
;;;490    err_t
;;;491    udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
004312  e92d43f8          PUSH     {r3-r9,lr}
;;;492      ip_addr_t *dst_ip, u16_t dst_port)
;;;493    {
004316  4605              MOV      r5,r0
004318  460f              MOV      r7,r1
00431a  4616              MOV      r6,r2
00431c  4698              MOV      r8,r3
;;;494    #if LWIP_CHECKSUM_ON_COPY
;;;495      return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
;;;496    }
;;;497    
;;;498    /** Same as udp_sendto(), but with checksum */
;;;499    err_t
;;;500    udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
;;;501                      u16_t dst_port, u8_t have_chksum, u16_t chksum)
;;;502    {
;;;503    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;504      struct netif *netif;
;;;505    
;;;506      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
00431e  bf00              NOP      
004320  bf00              NOP      
;;;507    
;;;508      /* find the outgoing network interface for this packet */
;;;509    #if LWIP_IGMP
;;;510      netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
004322  7831              LDRB     r1,[r6,#0]
004324  f00101f0          AND      r1,r1,#0xf0
004328  29e0              CMP      r1,#0xe0
00432a  d102              BNE      |L1.17202|
00432c  f1050118          ADD      r1,r5,#0x18
004330  e000              B        |L1.17204|
                  |L1.17202|
004332  4631              MOV      r1,r6
                  |L1.17204|
004334  4608              MOV      r0,r1
004336  f7fffffe          BL       ip_route
00433a  4604              MOV      r4,r0
;;;511    #else
;;;512      netif = ip_route(dst_ip);
;;;513    #endif /* LWIP_IGMP */
;;;514    
;;;515      /* no outgoing network interface could be found? */
;;;516      if (netif == NULL) {
00433c  b96c              CBNZ     r4,|L1.17242|
;;;517        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
00433e  bf00              NOP      
004340  bf00              NOP      
;;;518          ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
;;;519        UDP_STATS_INC(udp.rterr);
004342  48e9              LDR      r0,|L1.18152|
004344  f8b0008a          LDRH     r0,[r0,#0x8a]
004348  1c40              ADDS     r0,r0,#1
00434a  b281              UXTH     r1,r0
00434c  48e6              LDR      r0,|L1.18152|
00434e  f8a0108a          STRH     r1,[r0,#0x8a]
;;;520        return ERR_RTE;
004352  f06f0003          MVN      r0,#3
                  |L1.17238|
;;;521      }
;;;522    #if LWIP_CHECKSUM_ON_COPY
;;;523      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
;;;524    #else /* LWIP_CHECKSUM_ON_COPY */
;;;525      return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
;;;526    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;527    }
004356  e8bd83f8          POP      {r3-r9,pc}
                  |L1.17242|
00435a  4643              MOV      r3,r8                 ;525
00435c  4632              MOV      r2,r6                 ;525
00435e  4639              MOV      r1,r7                 ;525
004360  4628              MOV      r0,r5                 ;525
004362  9400              STR      r4,[sp,#0]            ;525
004364  f7fffffe          BL       udp_sendto_if
004368  e7f5              B        |L1.17238|
;;;528    
                          ENDP

                  udp_send PROC
;;;453    err_t
;;;454    udp_send(struct udp_pcb *pcb, struct pbuf *p)
00436a  b570              PUSH     {r4-r6,lr}
;;;455    {
00436c  4604              MOV      r4,r0
00436e  460d              MOV      r5,r1
;;;456      /* send to the packet using remote ip and port stored in the pcb */
;;;457      return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
004370  8aa3              LDRH     r3,[r4,#0x14]
004372  1d22              ADDS     r2,r4,#4
004374  4629              MOV      r1,r5
004376  4620              MOV      r0,r4
004378  f7fffffe          BL       udp_sendto
;;;458    }
00437c  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP

                  raw_sendto PROC
;;;202    err_t
;;;203    raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
00437e  e92d4ffe          PUSH     {r1-r11,lr}
;;;204    {
004382  4604              MOV      r4,r0
004384  460d              MOV      r5,r1
004386  4691              MOV      r9,r2
;;;205      err_t err;
;;;206      struct netif *netif;
;;;207      ip_addr_t *src_ip;
;;;208      struct pbuf *q; /* q will be sent down the stack */
;;;209      
;;;210      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
004388  bf00              NOP      
00438a  bf00              NOP      
;;;211      
;;;212      /* not enough space to add an IP header to first pbuf in given p chain? */
;;;213      if (pbuf_header(p, IP_HLEN)) {
00438c  2114              MOVS     r1,#0x14
00438e  4628              MOV      r0,r5
004390  f7fffffe          BL       pbuf_header
004394  b1a0              CBZ      r0,|L1.17344|
;;;214        /* allocate header in new pbuf */
;;;215        q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
004396  2200              MOVS     r2,#0
004398  4611              MOV      r1,r2
00439a  2001              MOVS     r0,#1
00439c  f7fffffe          BL       pbuf_alloc
0043a0  4606              MOV      r6,r0
;;;216        /* new header pbuf could not be allocated? */
;;;217        if (q == NULL) {
0043a2  b92e              CBNZ     r6,|L1.17328|
;;;218          LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
0043a4  bf00              NOP      
0043a6  bf00              NOP      
;;;219          return ERR_MEM;
0043a8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.17324|
;;;220        }
;;;221        if (p->tot_len != 0) {
;;;222          /* chain header q in front of given pbuf p */
;;;223          pbuf_chain(q, p);
;;;224        }
;;;225        /* { first pbuf q points to header pbuf } */
;;;226        LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;227      }  else {
;;;228        /* first pbuf q equals given pbuf */
;;;229        q = p;
;;;230        if(pbuf_header(q, -IP_HLEN)) {
;;;231          LWIP_ASSERT("Can't restore header we just removed!", 0);
;;;232          return ERR_MEM;
;;;233        }
;;;234      }
;;;235    
;;;236      if ((netif = ip_route(ipaddr)) == NULL) {
;;;237        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;238          ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
;;;239        /* free any temporary header pbuf allocated by pbuf_header() */
;;;240        if (q != p) {
;;;241          pbuf_free(q);
;;;242        }
;;;243        return ERR_RTE;
;;;244      }
;;;245    
;;;246    #if IP_SOF_BROADCAST
;;;247      /* broadcast filter? */
;;;248      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
;;;249        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;250        /* free any temporary header pbuf allocated by pbuf_header() */
;;;251        if (q != p) {
;;;252          pbuf_free(q);
;;;253        }
;;;254        return ERR_VAL;
;;;255      }
;;;256    #endif /* IP_SOF_BROADCAST */
;;;257    
;;;258      if (ip_addr_isany(&pcb->local_ip)) {
;;;259        /* use outgoing network interface IP address as source address */
;;;260        src_ip = &(netif->ip_addr);
;;;261      } else {
;;;262        /* use RAW PCB local IP address as source address */
;;;263        src_ip = &(pcb->local_ip);
;;;264      }
;;;265    
;;;266      NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;267      err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
;;;268      NETIF_SET_HWADDRHINT(netif, NULL);
;;;269    
;;;270      /* did we chain a header earlier? */
;;;271      if (q != p) {
;;;272        /* free the header */
;;;273        pbuf_free(q);
;;;274      }
;;;275      return err;
;;;276    }
0043ac  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.17328|
0043b0  8928              LDRH     r0,[r5,#8]            ;221
0043b2  b118              CBZ      r0,|L1.17340|
0043b4  4629              MOV      r1,r5                 ;223
0043b6  4630              MOV      r0,r6                 ;223
0043b8  f7fffffe          BL       pbuf_chain
                  |L1.17340|
0043bc  bf00              NOP                            ;226
0043be  e00b              B        |L1.17368|
                  |L1.17344|
0043c0  462e              MOV      r6,r5                 ;229
0043c2  f06f0113          MVN      r1,#0x13              ;230
0043c6  4630              MOV      r0,r6                 ;230
0043c8  f7fffffe          BL       pbuf_header
0043cc  b120              CBZ      r0,|L1.17368|
0043ce  bf00              NOP                            ;231
0043d0  bf00              NOP                            ;231
0043d2  f04f30ff          MOV      r0,#0xffffffff        ;232
0043d6  e7e9              B        |L1.17324|
                  |L1.17368|
0043d8  4648              MOV      r0,r9                 ;236
0043da  f7fffffe          BL       ip_route
0043de  0007              MOVS     r7,r0                 ;236
0043e0  d109              BNE      |L1.17398|
0043e2  bf00              NOP                            ;237
0043e4  bf00              NOP                            ;237
0043e6  42ae              CMP      r6,r5                 ;240
0043e8  d002              BEQ      |L1.17392|
0043ea  4630              MOV      r0,r6                 ;241
0043ec  f7fffffe          BL       pbuf_free
                  |L1.17392|
0043f0  f06f0003          MVN      r0,#3                 ;243
0043f4  e7da              B        |L1.17324|
                  |L1.17398|
0043f6  b10c              CBZ      r4,|L1.17404|
0043f8  6820              LDR      r0,[r4,#0]            ;258
0043fa  b910              CBNZ     r0,|L1.17410|
                  |L1.17404|
0043fc  f1070804          ADD      r8,r7,#4              ;260
004400  e000              B        |L1.17412|
                  |L1.17410|
004402  46a0              MOV      r8,r4                 ;263
                  |L1.17412|
004404  7c20              LDRB     r0,[r4,#0x10]         ;267
004406  7a61              LDRB     r1,[r4,#9]            ;267
004408  e9cd0701          STRD     r0,r7,[sp,#4]         ;267
00440c  9100              STR      r1,[sp,#0]            ;267
00440e  7aa3              LDRB     r3,[r4,#0xa]          ;267
004410  464a              MOV      r2,r9                 ;267
004412  4641              MOV      r1,r8                 ;267
004414  4630              MOV      r0,r6                 ;267
004416  f7fffffe          BL       ip_output_if
00441a  4682              MOV      r10,r0                ;267
00441c  42ae              CMP      r6,r5                 ;271
00441e  d002              BEQ      |L1.17446|
004420  4630              MOV      r0,r6                 ;273
004422  f7fffffe          BL       pbuf_free
                  |L1.17446|
004426  4650              MOV      r0,r10                ;275
004428  e7c0              B        |L1.17324|
;;;277    
                          ENDP

                  raw_send PROC
;;;285    err_t
;;;286    raw_send(struct raw_pcb *pcb, struct pbuf *p)
00442a  b570              PUSH     {r4-r6,lr}
;;;287    {
00442c  4604              MOV      r4,r0
00442e  460d              MOV      r5,r1
;;;288      return raw_sendto(pcb, p, &pcb->remote_ip);
004430  1d22              ADDS     r2,r4,#4
004432  4629              MOV      r1,r5
004434  4620              MOV      r0,r4
004436  f7fffffe          BL       raw_sendto
;;;289    }
00443a  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP

                  do_send PROC
;;;1122   void
;;;1123   do_send(struct api_msg_msg *msg)
00443c  b570              PUSH     {r4-r6,lr}
;;;1124   {
00443e  4604              MOV      r4,r0
;;;1125     if (ERR_IS_FATAL(msg->conn->last_err)) {
004440  6820              LDR      r0,[r4,#0]
004442  f9900008          LDRSB    r0,[r0,#8]
004446  f1100f09          CMN      r0,#9
00444a  da03              BGE      |L1.17492|
;;;1126       msg->err = msg->conn->last_err;
00444c  6820              LDR      r0,[r4,#0]
00444e  7a00              LDRB     r0,[r0,#8]
004450  7120              STRB     r0,[r4,#4]
004452  e040              B        |L1.17622|
                  |L1.17492|
;;;1127     } else {
;;;1128       msg->err = ERR_CONN;
004454  20f3              MOVS     r0,#0xf3
004456  7120              STRB     r0,[r4,#4]
;;;1129       if (msg->conn->pcb.tcp != NULL) {
004458  6820              LDR      r0,[r4,#0]
00445a  6840              LDR      r0,[r0,#4]
00445c  2800              CMP      r0,#0
00445e  d03a              BEQ      |L1.17622|
;;;1130         switch (NETCONNTYPE_GROUP(msg->conn->type)) {
004460  6820              LDR      r0,[r4,#0]
004462  7800              LDRB     r0,[r0,#0]
004464  f00000f0          AND      r0,r0,#0xf0
004468  2820              CMP      r0,#0x20
00446a  d019              BEQ      |L1.17568|
00446c  2840              CMP      r0,#0x40
00446e  d130              BNE      |L1.17618|
;;;1131   #if LWIP_RAW
;;;1132         case NETCONN_RAW:
;;;1133           if (ip_addr_isany(&msg->msg.b->addr)) {
004470  68a0              LDR      r0,[r4,#8]
004472  3008              ADDS     r0,r0,#8
004474  d002              BEQ      |L1.17532|
004476  68a0              LDR      r0,[r4,#8]
004478  6880              LDR      r0,[r0,#8]
00447a  b938              CBNZ     r0,|L1.17548|
                  |L1.17532|
;;;1134             msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
00447c  68a2              LDR      r2,[r4,#8]
00447e  6811              LDR      r1,[r2,#0]
004480  6822              LDR      r2,[r4,#0]
004482  6850              LDR      r0,[r2,#4]
004484  f7fffffe          BL       raw_send
004488  7120              STRB     r0,[r4,#4]
00448a  e008              B        |L1.17566|
                  |L1.17548|
;;;1135           } else {
;;;1136             msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
00448c  68a3              LDR      r3,[r4,#8]
00448e  f1030208          ADD      r2,r3,#8
004492  6819              LDR      r1,[r3,#0]
004494  6823              LDR      r3,[r4,#0]
004496  6858              LDR      r0,[r3,#4]
004498  f7fffffe          BL       raw_sendto
00449c  7120              STRB     r0,[r4,#4]
                  |L1.17566|
;;;1137           }
;;;1138           break;
00449e  e019              B        |L1.17620|
                  |L1.17568|
;;;1139   #endif
;;;1140   #if LWIP_UDP
;;;1141         case NETCONN_UDP:
;;;1142   #if LWIP_CHECKSUM_ON_COPY
;;;1143           if (ip_addr_isany(&msg->msg.b->addr)) {
;;;1144             msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1145               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1146           } else {
;;;1147             msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1148               &msg->msg.b->addr, msg->msg.b->port,
;;;1149               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1150           }
;;;1151   #else /* LWIP_CHECKSUM_ON_COPY */
;;;1152           if (ip_addr_isany(&msg->msg.b->addr)) {
0044a0  68a0              LDR      r0,[r4,#8]
0044a2  3008              ADDS     r0,r0,#8
0044a4  d002              BEQ      |L1.17580|
0044a6  68a0              LDR      r0,[r4,#8]
0044a8  6880              LDR      r0,[r0,#8]
0044aa  b938              CBNZ     r0,|L1.17596|
                  |L1.17580|
;;;1153             msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
0044ac  68a2              LDR      r2,[r4,#8]
0044ae  6811              LDR      r1,[r2,#0]
0044b0  6822              LDR      r2,[r4,#0]
0044b2  6850              LDR      r0,[r2,#4]
0044b4  f7fffffe          BL       udp_send
0044b8  7120              STRB     r0,[r4,#4]
0044ba  e009              B        |L1.17616|
                  |L1.17596|
;;;1154           } else {
;;;1155             msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
0044bc  68a5              LDR      r5,[r4,#8]
0044be  89ab              LDRH     r3,[r5,#0xc]
0044c0  f1050208          ADD      r2,r5,#8
0044c4  6829              LDR      r1,[r5,#0]
0044c6  6825              LDR      r5,[r4,#0]
0044c8  6868              LDR      r0,[r5,#4]
0044ca  f7fffffe          BL       udp_sendto
0044ce  7120              STRB     r0,[r4,#4]
                  |L1.17616|
;;;1156           }
;;;1157   #endif /* LWIP_CHECKSUM_ON_COPY */
;;;1158           break;
0044d0  e000              B        |L1.17620|
                  |L1.17618|
;;;1159   #endif /* LWIP_UDP */
;;;1160         default:
;;;1161           break;
0044d2  bf00              NOP      
                  |L1.17620|
0044d4  bf00              NOP                            ;1138
                  |L1.17622|
;;;1162         }
;;;1163       }
;;;1164     }
;;;1165     TCPIP_APIMSG_ACK(msg);
0044d6  6821              LDR      r1,[r4,#0]
0044d8  f101000c          ADD      r0,r1,#0xc
0044dc  f7fffffe          BL       sys_sem_signal
;;;1166   }
0044e0  bd70              POP      {r4-r6,pc}
;;;1167   
                          ENDP

                  netconn_send PROC
;;;566    err_t
;;;567    netconn_send(struct netconn *conn, struct netbuf *buf)
0044e2  b5f0              PUSH     {r4-r7,lr}
;;;568    {
0044e4  b087              SUB      sp,sp,#0x1c
0044e6  4604              MOV      r4,r0
0044e8  460e              MOV      r6,r1
;;;569      struct api_msg msg;
;;;570      err_t err;
;;;571    
;;;572      LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
0044ea  bf00              NOP      
0044ec  b91c              CBNZ     r4,|L1.17654|
0044ee  f06f000d          MVN      r0,#0xd
                  |L1.17650|
;;;573    
;;;574      LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
;;;575      msg.function = do_send;
;;;576      msg.msg.conn = conn;
;;;577      msg.msg.msg.b = buf;
;;;578      err = TCPIP_APIMSG(&msg);
;;;579    
;;;580      NETCONN_SET_SAFE_ERR(conn, err);
;;;581      return err;
;;;582    }
0044f2  b007              ADD      sp,sp,#0x1c
0044f4  bdf0              POP      {r4-r7,pc}
                  |L1.17654|
0044f6  bf00              NOP                            ;572
0044f8  bf00              NOP                            ;574
0044fa  bf00              NOP                            ;574
0044fc  f2af00c3          ADR      r0,do_send + 1
004500  9001              STR      r0,[sp,#4]            ;575
004502  9402              STR      r4,[sp,#8]            ;576
004504  9604              STR      r6,[sp,#0x10]         ;577
004506  a801              ADD      r0,sp,#4              ;578
004508  f7fffffe          BL       tcpip_apimsg
00450c  4605              MOV      r5,r0                 ;578
00450e  bf00              NOP                            ;580
004510  f7fffffe          BL       sys_arch_protect
004514  4607              MOV      r7,r0                 ;580
004516  f9940008          LDRSB    r0,[r4,#8]            ;580
00451a  f1100f09          CMN      r0,#9                 ;580
00451e  db00              BLT      |L1.17698|
004520  7225              STRB     r5,[r4,#8]            ;580
                  |L1.17698|
004522  4638              MOV      r0,r7                 ;580
004524  f7fffffe          BL       sys_arch_unprotect
004528  bf00              NOP                            ;580
00452a  4628              MOV      r0,r5                 ;581
00452c  e7e1              B        |L1.17650|
;;;583    
                          ENDP

                  netconn_sendto PROC
;;;548    err_t
;;;549    netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
00452e  e92d41f0          PUSH     {r4-r8,lr}
;;;550    {
004532  4607              MOV      r7,r0
004534  460c              MOV      r4,r1
004536  4615              MOV      r5,r2
004538  461e              MOV      r6,r3
;;;551      if (buf != NULL) {
00453a  b15c              CBZ      r4,|L1.17748|
;;;552        ip_addr_set(&buf->addr, addr);
00453c  b90d              CBNZ     r5,|L1.17730|
00453e  2000              MOVS     r0,#0
004540  e000              B        |L1.17732|
                  |L1.17730|
004542  6828              LDR      r0,[r5,#0]
                  |L1.17732|
004544  60a0              STR      r0,[r4,#8]
;;;553        buf->port = port;
004546  81a6              STRH     r6,[r4,#0xc]
;;;554        return netconn_send(conn, buf);
004548  4621              MOV      r1,r4
00454a  4638              MOV      r0,r7
00454c  f7fffffe          BL       netconn_send
                  |L1.17744|
;;;555      }
;;;556      return ERR_VAL;
;;;557    }
004550  e8bd81f0          POP      {r4-r8,pc}
                  |L1.17748|
004554  f06f0005          MVN      r0,#5                 ;556
004558  e7fa              B        |L1.17744|
;;;558    
                          ENDP

                  do_write PROC
;;;1345   void
;;;1346   do_write(struct api_msg_msg *msg)
00455a  b510              PUSH     {r4,lr}
;;;1347   {
00455c  4604              MOV      r4,r0
;;;1348     if (ERR_IS_FATAL(msg->conn->last_err)) {
00455e  6820              LDR      r0,[r4,#0]
004560  f9900008          LDRSB    r0,[r0,#8]
004564  f1100f09          CMN      r0,#9
004568  da03              BGE      |L1.17778|
;;;1349       msg->err = msg->conn->last_err;
00456a  6820              LDR      r0,[r4,#0]
00456c  7a00              LDRB     r0,[r0,#8]
00456e  7120              STRB     r0,[r4,#4]
004570  e023              B        |L1.17850|
                  |L1.17778|
;;;1350     } else {
;;;1351       if (msg->conn->type == NETCONN_TCP) {
004572  6820              LDR      r0,[r4,#0]
004574  7800              LDRB     r0,[r0,#0]
004576  2810              CMP      r0,#0x10
004578  d11d              BNE      |L1.17846|
;;;1352   #if LWIP_TCP
;;;1353         if (msg->conn->state != NETCONN_NONE) {
00457a  6820              LDR      r0,[r4,#0]
00457c  7840              LDRB     r0,[r0,#1]
00457e  b110              CBZ      r0,|L1.17798|
;;;1354           /* netconn is connecting, closing or in blocking write */
;;;1355           msg->err = ERR_INPROGRESS;
004580  20fb              MOVS     r0,#0xfb
004582  7120              STRB     r0,[r4,#4]
004584  e019              B        |L1.17850|
                  |L1.17798|
;;;1356         } else if (msg->conn->pcb.tcp != NULL) {
004586  6820              LDR      r0,[r4,#0]
004588  6840              LDR      r0,[r0,#4]
00458a  b188              CBZ      r0,|L1.17840|
;;;1357           msg->conn->state = NETCONN_WRITE;
00458c  2001              MOVS     r0,#1
00458e  6821              LDR      r1,[r4,#0]
004590  7048              STRB     r0,[r1,#1]
;;;1358           /* set all the variables used by do_writemore */
;;;1359           LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
004592  bf00              NOP      
004594  bf00              NOP      
;;;1360             msg->conn->write_offset == 0);
;;;1361           LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
004596  bf00              NOP      
004598  bf00              NOP      
;;;1362           msg->conn->current_msg = msg;
00459a  6820              LDR      r0,[r4,#0]
00459c  f8c04134          STR      r4,[r0,#0x134]
;;;1363           msg->conn->write_offset = 0;
0045a0  2000              MOVS     r0,#0
0045a2  6821              LDR      r1,[r4,#0]
0045a4  f8c10130          STR      r0,[r1,#0x130]
;;;1364   #if LWIP_TCPIP_CORE_LOCKING
;;;1365           msg->conn->flags &= ~NETCONN_FLAG_WRITE_DELAYED;
;;;1366           if (do_writemore(msg->conn) != ERR_OK) {
;;;1367             LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
;;;1368             UNLOCK_TCPIP_CORE();
;;;1369             sys_arch_sem_wait(&msg->conn->op_completed, 0);
;;;1370             LOCK_TCPIP_CORE();
;;;1371             LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
;;;1372           }
;;;1373   #else /* LWIP_TCPIP_CORE_LOCKING */
;;;1374           do_writemore(msg->conn);
0045a8  6820              LDR      r0,[r4,#0]
0045aa  f7fffffe          BL       do_writemore
                  |L1.17838|
;;;1375   #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;1376           /* for both cases: if do_writemore was called, don't ACK the APIMSG
;;;1377              since do_writemore ACKs it! */
;;;1378           return;
;;;1379         } else {
;;;1380           msg->err = ERR_CONN;
;;;1381         }
;;;1382   #else /* LWIP_TCP */
;;;1383         msg->err = ERR_VAL;
;;;1384   #endif /* LWIP_TCP */
;;;1385   #if (LWIP_UDP || LWIP_RAW)
;;;1386       } else {
;;;1387         msg->err = ERR_VAL;
;;;1388   #endif /* (LWIP_UDP || LWIP_RAW) */
;;;1389       }
;;;1390     }
;;;1391     TCPIP_APIMSG_ACK(msg);
;;;1392   }
0045ae  bd10              POP      {r4,pc}
                  |L1.17840|
0045b0  20f3              MOVS     r0,#0xf3              ;1380
0045b2  7120              STRB     r0,[r4,#4]            ;1380
0045b4  e001              B        |L1.17850|
                  |L1.17846|
0045b6  20fa              MOVS     r0,#0xfa              ;1387
0045b8  7120              STRB     r0,[r4,#4]            ;1387
                  |L1.17850|
0045ba  6821              LDR      r1,[r4,#0]            ;1391
0045bc  f101000c          ADD      r0,r1,#0xc            ;1391
0045c0  f7fffffe          BL       sys_sem_signal
0045c4  bf00              NOP      
0045c6  e7f2              B        |L1.17838|
;;;1393   
                          ENDP

                  netconn_write_partly PROC
;;;597    err_t
;;;598    netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
0045c8  e92d4ff0          PUSH     {r4-r11,lr}
;;;599                         u8_t apiflags, size_t *bytes_written)
;;;600    {
0045cc  b087              SUB      sp,sp,#0x1c
0045ce  4604              MOV      r4,r0
0045d0  4689              MOV      r9,r1
0045d2  4615              MOV      r5,r2
0045d4  4698              MOV      r8,r3
0045d6  9e10              LDR      r6,[sp,#0x40]
;;;601      struct api_msg msg;
;;;602      err_t err;
;;;603      u8_t dontblock;
;;;604    
;;;605      LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
0045d8  bf00              NOP      
0045da  b924              CBNZ     r4,|L1.17894|
0045dc  f06f000d          MVN      r0,#0xd
                  |L1.17888|
;;;606      LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
;;;607      if (size == 0) {
;;;608        return ERR_OK;
;;;609      }
;;;610      dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
;;;611      if (dontblock && !bytes_written) {
;;;612        /* This implies netconn_write() cannot be used for non-blocking send, since
;;;613           it has no way to return the number of bytes written. */
;;;614        return ERR_VAL;
;;;615      }
;;;616    
;;;617      /* non-blocking write sends as much  */
;;;618      msg.function = do_write;
;;;619      msg.msg.conn = conn;
;;;620      msg.msg.msg.w.dataptr = dataptr;
;;;621      msg.msg.msg.w.apiflags = apiflags;
;;;622      msg.msg.msg.w.len = size;
;;;623    #if LWIP_SO_SNDTIMEO
;;;624      if (conn->send_timeout != 0) {
;;;625        /* get the time we started, which is later compared to
;;;626            sys_now() + conn->send_timeout */
;;;627        msg.msg.msg.w.time_started = sys_now();
;;;628      } else {
;;;629        msg.msg.msg.w.time_started = 0;
;;;630      }
;;;631    #endif /* LWIP_SO_SNDTIMEO */
;;;632    
;;;633      /* For locking the core: this _can_ be delayed on low memory/low send buffer,
;;;634         but if it is, this is done inside api_msg.c:do_write(), so we can use the
;;;635         non-blocking version here. */
;;;636      err = TCPIP_APIMSG(&msg);
;;;637      if ((err == ERR_OK) && (bytes_written != NULL)) {
;;;638        if (dontblock
;;;639    #if LWIP_SO_SNDTIMEO
;;;640            || (conn->send_timeout != 0)
;;;641    #endif /* LWIP_SO_SNDTIMEO */
;;;642           ) {
;;;643          /* nonblocking write: maybe the data has been sent partly */
;;;644          *bytes_written = msg.msg.msg.w.len;
;;;645        } else {
;;;646          /* blocking call succeeded: all data has been sent if it */
;;;647          *bytes_written = size;
;;;648        }
;;;649      }
;;;650    
;;;651      NETCONN_SET_SAFE_ERR(conn, err);
;;;652      return err;
;;;653    }
0045e0  b007              ADD      sp,sp,#0x1c
0045e2  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.17894|
0045e6  bf00              NOP                            ;605
0045e8  bf00              NOP                            ;606
0045ea  7820              LDRB     r0,[r4,#0]            ;606
0045ec  2810              CMP      r0,#0x10              ;606
0045ee  d002              BEQ      |L1.17910|
0045f0  f06f0005          MVN      r0,#5                 ;606
0045f4  e7f4              B        |L1.17888|
                  |L1.17910|
0045f6  bf00              NOP                            ;606
0045f8  b90d              CBNZ     r5,|L1.17918|
0045fa  2000              MOVS     r0,#0                 ;608
0045fc  e7f0              B        |L1.17888|
                  |L1.17918|
0045fe  f894012c          LDRB     r0,[r4,#0x12c]        ;610
004602  f0100f02          TST      r0,#2                 ;610
004606  d102              BNE      |L1.17934|
004608  f0180f04          TST      r8,#4                 ;610
00460c  d001              BEQ      |L1.17938|
                  |L1.17934|
00460e  2001              MOVS     r0,#1                 ;610
004610  e000              B        |L1.17940|
                  |L1.17938|
004612  2000              MOVS     r0,#0                 ;610
                  |L1.17940|
004614  4682              MOV      r10,r0                ;610
004616  f1ba0f00          CMP      r10,#0                ;611
00461a  d003              BEQ      |L1.17956|
00461c  b916              CBNZ     r6,|L1.17956|
00461e  f06f0005          MVN      r0,#5                 ;614
004622  e7dd              B        |L1.17888|
                  |L1.17956|
004624  f2af00cd          ADR      r0,do_write + 1
004628  9001              STR      r0,[sp,#4]            ;618
00462a  9402              STR      r4,[sp,#8]            ;619
00462c  f8cd9010          STR      r9,[sp,#0x10]         ;620
004630  f88d8018          STRB     r8,[sp,#0x18]         ;621
004634  9505              STR      r5,[sp,#0x14]         ;622
004636  a801              ADD      r0,sp,#4              ;636
004638  f7fffffe          BL       tcpip_apimsg
00463c  4607              MOV      r7,r0                 ;636
00463e  b93f              CBNZ     r7,|L1.18000|
004640  b136              CBZ      r6,|L1.18000|
004642  f1ba0f00          CMP      r10,#0                ;638
004646  d002              BEQ      |L1.17998|
004648  9805              LDR      r0,[sp,#0x14]         ;644
00464a  6030              STR      r0,[r6,#0]            ;644
00464c  e000              B        |L1.18000|
                  |L1.17998|
00464e  6035              STR      r5,[r6,#0]            ;647
                  |L1.18000|
004650  bf00              NOP                            ;651
004652  f7fffffe          BL       sys_arch_protect
004656  4683              MOV      r11,r0                ;651
004658  f9940008          LDRSB    r0,[r4,#8]            ;651
00465c  f1100f09          CMN      r0,#9                 ;651
004660  db00              BLT      |L1.18020|
004662  7227              STRB     r7,[r4,#8]            ;651
                  |L1.18020|
004664  4658              MOV      r0,r11                ;651
004666  f7fffffe          BL       sys_arch_unprotect
00466a  bf00              NOP                            ;651
00466c  4638              MOV      r0,r7                 ;652
00466e  e7b7              B        |L1.17888|
;;;654    
                          ENDP

                  do_close PROC
;;;1453   void
;;;1454   do_close(struct api_msg_msg *msg)
004670  b510              PUSH     {r4,lr}
;;;1455   {
004672  4604              MOV      r4,r0
;;;1456   #if LWIP_TCP
;;;1457     /* @todo: abort running write/connect? */
;;;1458     if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
004674  6820              LDR      r0,[r4,#0]
004676  7840              LDRB     r0,[r0,#1]
004678  b140              CBZ      r0,|L1.18060|
00467a  6820              LDR      r0,[r4,#0]
00467c  7840              LDRB     r0,[r0,#1]
00467e  2802              CMP      r0,#2
004680  d004              BEQ      |L1.18060|
;;;1459       /* this only happens for TCP netconns */
;;;1460       LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
004682  bf00              NOP      
004684  bf00              NOP      
;;;1461       msg->err = ERR_INPROGRESS;
004686  20fb              MOVS     r0,#0xfb
004688  7120              STRB     r0,[r4,#4]
00468a  e025              B        |L1.18136|
                  |L1.18060|
;;;1462     } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
00468c  6820              LDR      r0,[r4,#0]
00468e  6840              LDR      r0,[r0,#4]
004690  b300              CBZ      r0,|L1.18132|
004692  6820              LDR      r0,[r4,#0]
004694  7800              LDRB     r0,[r0,#0]
004696  2810              CMP      r0,#0x10
004698  d11c              BNE      |L1.18132|
;;;1463       if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
00469a  7a20              LDRB     r0,[r4,#8]
00469c  2803              CMP      r0,#3
00469e  d006              BEQ      |L1.18094|
0046a0  6820              LDR      r0,[r4,#0]
0046a2  7840              LDRB     r0,[r0,#1]
0046a4  2802              CMP      r0,#2
0046a6  d102              BNE      |L1.18094|
;;;1464         /* LISTEN doesn't support half shutdown */
;;;1465         msg->err = ERR_CONN;
0046a8  20f3              MOVS     r0,#0xf3
0046aa  7120              STRB     r0,[r4,#4]
0046ac  e014              B        |L1.18136|
                  |L1.18094|
;;;1466       } else {
;;;1467         if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
0046ae  7a20              LDRB     r0,[r4,#8]
0046b0  f0100f01          TST      r0,#1
0046b4  d002              BEQ      |L1.18108|
;;;1468           /* Drain and delete mboxes */
;;;1469           netconn_drain(msg->conn);
0046b6  6820              LDR      r0,[r4,#0]
0046b8  f7fffffe          BL       netconn_drain
                  |L1.18108|
;;;1470         }
;;;1471         LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
0046bc  bf00              NOP      
0046be  bf00              NOP      
;;;1472           msg->conn->write_offset == 0);
;;;1473         msg->conn->state = NETCONN_CLOSE;
0046c0  2004              MOVS     r0,#4
0046c2  6821              LDR      r1,[r4,#0]
0046c4  7048              STRB     r0,[r1,#1]
;;;1474         msg->conn->current_msg = msg;
0046c6  6820              LDR      r0,[r4,#0]
0046c8  f8c04134          STR      r4,[r0,#0x134]
;;;1475         do_close_internal(msg->conn);
0046cc  6820              LDR      r0,[r4,#0]
0046ce  f7fffffe          BL       do_close_internal
                  |L1.18130|
;;;1476         /* for tcp netconns, do_close_internal ACKs the message */
;;;1477         return;
;;;1478       }
;;;1479     } else
;;;1480   #endif /* LWIP_TCP */
;;;1481     {
;;;1482       msg->err = ERR_VAL;
;;;1483     }
;;;1484     sys_sem_signal(&msg->conn->op_completed);
;;;1485   }
0046d2  bd10              POP      {r4,pc}
                  |L1.18132|
0046d4  20fa              MOVS     r0,#0xfa              ;1482
0046d6  7120              STRB     r0,[r4,#4]            ;1482
                  |L1.18136|
0046d8  6821              LDR      r1,[r4,#0]            ;1484
0046da  f101000c          ADD      r0,r1,#0xc            ;1484
0046de  f7fffffe          BL       sys_sem_signal
0046e2  bf00              NOP      
0046e4  e7f5              B        |L1.18130|
0046e6  0000              DCW      0x0000
                  |L1.18152|
                          DCD      lwip_stats
                          ENDP

                  netconn_close_shutdown PROC
;;;662    static err_t
;;;663    netconn_close_shutdown(struct netconn *conn, u8_t how)
0046ec  b5f0              PUSH     {r4-r7,lr}
;;;664    {
0046ee  b087              SUB      sp,sp,#0x1c
0046f0  4604              MOV      r4,r0
0046f2  460e              MOV      r6,r1
;;;665      struct api_msg msg;
;;;666      err_t err;
;;;667    
;;;668      LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
0046f4  bf00              NOP      
0046f6  b91c              CBNZ     r4,|L1.18176|
0046f8  f06f000d          MVN      r0,#0xd
                  |L1.18172|
;;;669    
;;;670      msg.function = do_close;
;;;671      msg.msg.conn = conn;
;;;672      /* shutting down both ends is the same as closing */
;;;673      msg.msg.msg.sd.shut = how;
;;;674      /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
;;;675         don't use TCPIP_APIMSG here */
;;;676      err = tcpip_apimsg(&msg);
;;;677    
;;;678      NETCONN_SET_SAFE_ERR(conn, err);
;;;679      return err;
;;;680    }
0046fc  b007              ADD      sp,sp,#0x1c
0046fe  bdf0              POP      {r4-r7,pc}
                  |L1.18176|
004700  bf00              NOP                            ;668
004702  f2af0093          ADR      r0,do_close + 1
004706  9001              STR      r0,[sp,#4]            ;670
004708  9402              STR      r4,[sp,#8]            ;671
00470a  f88d6010          STRB     r6,[sp,#0x10]         ;673
00470e  a801              ADD      r0,sp,#4              ;676
004710  f7fffffe          BL       tcpip_apimsg
004714  4605              MOV      r5,r0                 ;676
004716  bf00              NOP                            ;678
004718  f7fffffe          BL       sys_arch_protect
00471c  4607              MOV      r7,r0                 ;678
00471e  f9940008          LDRSB    r0,[r4,#8]            ;678
004722  f1100f09          CMN      r0,#9                 ;678
004726  db00              BLT      |L1.18218|
004728  7225              STRB     r5,[r4,#8]            ;678
                  |L1.18218|
00472a  4638              MOV      r0,r7                 ;678
00472c  f7fffffe          BL       sys_arch_unprotect
004730  bf00              NOP                            ;678
004732  4628              MOV      r0,r5                 ;679
004734  e7e2              B        |L1.18172|
;;;681    
                          ENDP

                  netconn_close PROC
;;;688    err_t
;;;689    netconn_close(struct netconn *conn)
004736  b510              PUSH     {r4,lr}
;;;690    {
004738  4604              MOV      r4,r0
;;;691      /* shutting down both ends is the same as closing */
;;;692      return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
00473a  2103              MOVS     r1,#3
00473c  4620              MOV      r0,r4
00473e  f7fffffe          BL       netconn_close_shutdown
;;;693    }
004742  bd10              POP      {r4,pc}
;;;694    
                          ENDP

                  netconn_shutdown PROC
;;;701    err_t
;;;702    netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
004744  b570              PUSH     {r4-r6,lr}
;;;703    {
004746  4606              MOV      r6,r0
004748  460c              MOV      r4,r1
00474a  4615              MOV      r5,r2
;;;704      return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
00474c  b10c              CBZ      r4,|L1.18258|
00474e  2001              MOVS     r0,#1
004750  e000              B        |L1.18260|
                  |L1.18258|
004752  2000              MOVS     r0,#0
                  |L1.18260|
004754  b10d              CBZ      r5,|L1.18266|
004756  2202              MOVS     r2,#2
004758  e000              B        |L1.18268|
                  |L1.18266|
00475a  2200              MOVS     r2,#0
                  |L1.18268|
00475c  ea400102          ORR      r1,r0,r2
004760  4630              MOV      r0,r6
004762  f7fffffe          BL       netconn_close_shutdown
;;;705    }
004766  bd70              POP      {r4-r6,pc}
;;;706    
                          ENDP

                  igmp_remove_group PROC
;;;354    static err_t
;;;355    igmp_remove_group(struct igmp_group *group)
004768  b570              PUSH     {r4-r6,lr}
;;;356    {
00476a  4604              MOV      r4,r0
;;;357      err_t err = ERR_OK;
00476c  2500              MOVS     r5,#0
;;;358    
;;;359      /* Is it the first group? */
;;;360      if (igmp_group_list == group) {
00476e  48fb              LDR      r0,|L1.19292|
004770  6800              LDR      r0,[r0,#0]  ; igmp_group_list
004772  42a0              CMP      r0,r4
004774  d103              BNE      |L1.18302|
;;;361        igmp_group_list = group->next;
004776  49f9              LDR      r1,|L1.19292|
004778  6820              LDR      r0,[r4,#0]
00477a  6008              STR      r0,[r1,#0]  ; igmp_group_list
00477c  e010              B        |L1.18336|
                  |L1.18302|
;;;362      } else {
;;;363        /* look for group further down the list */
;;;364        struct igmp_group *tmpGroup;
;;;365        for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {
00477e  49f7              LDR      r1,|L1.19292|
004780  6808              LDR      r0,[r1,#0]  ; igmp_group_list
004782  e006              B        |L1.18322|
                  |L1.18308|
;;;366          if (tmpGroup->next == group) {
004784  6801              LDR      r1,[r0,#0]
004786  42a1              CMP      r1,r4
004788  d102              BNE      |L1.18320|
;;;367            tmpGroup->next = group->next;
00478a  6821              LDR      r1,[r4,#0]
00478c  6001              STR      r1,[r0,#0]
;;;368            break;
00478e  e002              B        |L1.18326|
                  |L1.18320|
004790  6800              LDR      r0,[r0,#0]            ;365
                  |L1.18322|
004792  2800              CMP      r0,#0                 ;365
004794  d1f6              BNE      |L1.18308|
                  |L1.18326|
004796  bf00              NOP      
;;;369          }
;;;370        }
;;;371        /* Group not found in the global igmp_group_list */
;;;372        if (tmpGroup == NULL)
004798  b908              CBNZ     r0,|L1.18334|
;;;373          err = ERR_ARG;
00479a  f06f050d          MVN      r5,#0xd
                  |L1.18334|
;;;374      }
00479e  bf00              NOP      
                  |L1.18336|
;;;375      /* free group */
;;;376      memp_free(MEMP_IGMP_GROUP, group);
0047a0  4621              MOV      r1,r4
0047a2  2009              MOVS     r0,#9
0047a4  f7fffffe          BL       memp_free
;;;377    
;;;378      return err;
0047a8  4628              MOV      r0,r5
;;;379    }
0047aa  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP

                  igmp_ip_output_if PROC
;;;744    static err_t
;;;745    igmp_ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, struct netif *netif)
0047ac  b5f0              PUSH     {r4-r7,lr}
;;;746    {
0047ae  b087              SUB      sp,sp,#0x1c
0047b0  4605              MOV      r5,r0
0047b2  460e              MOV      r6,r1
0047b4  4617              MOV      r7,r2
0047b6  461c              MOV      r4,r3
;;;747      /* This is the "router alert" option */
;;;748      u16_t ra[2];
;;;749      ra[0] = PP_HTONS(ROUTER_ALERT);
0047b8  f2404094          MOV      r0,#0x494
0047bc  f8ad0018          STRH     r0,[sp,#0x18]
;;;750      ra[1] = 0x0000; /* Router shall examine packet */
0047c0  2000              MOVS     r0,#0
0047c2  f8ad001a          STRH     r0,[sp,#0x1a]
;;;751      IGMP_STATS_INC(igmp.xmit);
0047c6  48e6              LDR      r0,|L1.19296|
0047c8  f8b00060          LDRH     r0,[r0,#0x60]  ; lwip_stats
0047cc  1c40              ADDS     r0,r0,#1
0047ce  49e4              LDR      r1,|L1.19296|
0047d0  f8a10060          STRH     r0,[r1,#0x60]
;;;752      return ip_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
0047d4  2004              MOVS     r0,#4
0047d6  a906              ADD      r1,sp,#0x18
0047d8  2202              MOVS     r2,#2
0047da  e9cd2401          STRD     r2,r4,[sp,#4]
0047de  e9cd1003          STRD     r1,r0,[sp,#0xc]
0047e2  2000              MOVS     r0,#0
0047e4  2301              MOVS     r3,#1
0047e6  463a              MOV      r2,r7
0047e8  4631              MOV      r1,r6
0047ea  9000              STR      r0,[sp,#0]
0047ec  4628              MOV      r0,r5
0047ee  f7fffffe          BL       ip_output_if_opt
;;;753    }
0047f2  b007              ADD      sp,sp,#0x1c
0047f4  bdf0              POP      {r4-r7,pc}
;;;754    
                          ENDP

                  lwip_standard_chksum PROC
;;;134    static u16_t
;;;135    lwip_standard_chksum(void *dataptr, int len)
0047f6  b5f8              PUSH     {r3-r7,lr}
;;;136    {
0047f8  4605              MOV      r5,r0
0047fa  460a              MOV      r2,r1
;;;137      u8_t *pb = (u8_t *)dataptr;
0047fc  462b              MOV      r3,r5
;;;138      u16_t *ps, t = 0;
0047fe  2000              MOVS     r0,#0
004800  9000              STR      r0,[sp,#0]
;;;139      u32_t sum = 0;
004802  2100              MOVS     r1,#0
;;;140      int odd = ((mem_ptr_t)pb & 1);
004804  f0030601          AND      r6,r3,#1
;;;141    
;;;142      /* Get aligned to u16_t */
;;;143      if (odd && len > 0) {
004808  b136              CBZ      r6,|L1.18456|
00480a  2a00              CMP      r2,#0
00480c  dd04              BLE      |L1.18456|
;;;144        ((u8_t *)&t)[1] = *pb++;
00480e  f8130b01          LDRB     r0,[r3],#1
004812  f88d0001          STRB     r0,[sp,#1]
;;;145        len--;
004816  1e52              SUBS     r2,r2,#1
                  |L1.18456|
;;;146      }
;;;147    
;;;148      /* Add the bulk of the data */
;;;149      ps = (u16_t *)(void *)pb;
004818  461c              MOV      r4,r3
;;;150      while (len > 1) {
00481a  e003              B        |L1.18468|
                  |L1.18460|
;;;151        sum += *ps++;
00481c  f8347b02          LDRH     r7,[r4],#2
004820  4439              ADD      r1,r1,r7
;;;152        len -= 2;
004822  1e92              SUBS     r2,r2,#2
                  |L1.18468|
004824  2a01              CMP      r2,#1                 ;150
004826  dcf9              BGT      |L1.18460|
;;;153      }
;;;154    
;;;155      /* Consume left-over byte, if any */
;;;156      if (len > 0) {
004828  2a00              CMP      r2,#0
00482a  dd02              BLE      |L1.18482|
;;;157        ((u8_t *)&t)[0] = *(u8_t *)ps;
00482c  7820              LDRB     r0,[r4,#0]
00482e  f88d0000          STRB     r0,[sp,#0]
                  |L1.18482|
;;;158      }
;;;159    
;;;160      /* Add end bytes */
;;;161      sum += t;
004832  f8bd0000          LDRH     r0,[sp,#0]
004836  4401              ADD      r1,r1,r0
;;;162    
;;;163      /* Fold 32-bit sum to 16 bits
;;;164         calling this twice is propably faster than if statements... */
;;;165      sum = FOLD_U32T(sum);
004838  b288              UXTH     r0,r1
00483a  eb004111          ADD      r1,r0,r1,LSR #16
;;;166      sum = FOLD_U32T(sum);
00483e  b288              UXTH     r0,r1
004840  eb004111          ADD      r1,r0,r1,LSR #16
;;;167    
;;;168      /* Swap if alignment was odd */
;;;169      if (odd) {
004844  b126              CBZ      r6,|L1.18512|
;;;170        sum = SWAP_BYTES_IN_WORD(sum);
004846  b2c8              UXTB     r0,r1
004848  f3c12707          UBFX     r7,r1,#8,#8
00484c  ea472100          ORR      r1,r7,r0,LSL #8
                  |L1.18512|
;;;171      }
;;;172    
;;;173      return (u16_t)sum;
004850  b288              UXTH     r0,r1
;;;174    }
004852  bdf8              POP      {r3-r7,pc}
;;;175    #endif
                          ENDP

                  inet_chksum PROC
;;;395    u16_t
;;;396    inet_chksum(void *dataptr, u16_t len)
004854  b570              PUSH     {r4-r6,lr}
;;;397    {
004856  4604              MOV      r4,r0
004858  460d              MOV      r5,r1
;;;398      return ~LWIP_CHKSUM(dataptr, len);
00485a  4629              MOV      r1,r5
00485c  4620              MOV      r0,r4
00485e  f7fffffe          BL       lwip_standard_chksum
004862  43c0              MVNS     r0,r0
004864  b280              UXTH     r0,r0
;;;399    }
004866  bd70              POP      {r4-r6,pc}
;;;400    
                          ENDP

                  igmp_send PROC
;;;761    static void
;;;762    igmp_send(struct igmp_group *group, u8_t type)
004868  e92d43f8          PUSH     {r3-r9,lr}
;;;763    {
00486c  4604              MOV      r4,r0
00486e  460e              MOV      r6,r1
;;;764      struct pbuf*     p    = NULL;
004870  2700              MOVS     r7,#0
;;;765      struct igmp_msg* igmp = NULL;
004872  2500              MOVS     r5,#0
;;;766      ip_addr_t   src  = *IP_ADDR_ANY;
004874  48bb              LDR      r0,|L1.19300|
004876  6800              LDR      r0,[r0,#0]  ; ip_addr_any
004878  9000              STR      r0,[sp,#0]
;;;767      ip_addr_t*  dest = NULL;
00487a  46a8              MOV      r8,r5
;;;768    
;;;769      /* IP header + "router alert" option + IGMP header */
;;;770      p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
00487c  2200              MOVS     r2,#0
00487e  2108              MOVS     r1,#8
004880  4610              MOV      r0,r2
004882  f7fffffe          BL       pbuf_alloc
004886  4607              MOV      r7,r0
;;;771      
;;;772      if (p) {
004888  b35f              CBZ      r7,|L1.18658|
;;;773        igmp = (struct igmp_msg *)p->payload;
00488a  687d              LDR      r5,[r7,#4]
;;;774        LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
00488c  bf00              NOP      
00488e  bf00              NOP      
;;;775                   (p->len >= sizeof(struct igmp_msg)));
;;;776        ip_addr_copy(src, group->netif->ip_addr);
004890  6860              LDR      r0,[r4,#4]
004892  6840              LDR      r0,[r0,#4]
004894  9000              STR      r0,[sp,#0]
;;;777         
;;;778        if (type == IGMP_V2_MEMB_REPORT) {
004896  2e16              CMP      r6,#0x16
004898  d106              BNE      |L1.18600|
;;;779          dest = &(group->group_address);
00489a  f1040808          ADD      r8,r4,#8
;;;780          ip_addr_copy(igmp->igmp_group_address, group->group_address);
00489e  68a0              LDR      r0,[r4,#8]
0048a0  6068              STR      r0,[r5,#4]
;;;781          group->last_reporter_flag = 1; /* Remember we were the last to report */
0048a2  2001              MOVS     r0,#1
0048a4  7320              STRB     r0,[r4,#0xc]
0048a6  e005              B        |L1.18612|
                  |L1.18600|
;;;782        } else {
;;;783          if (type == IGMP_LEAVE_GROUP) {
0048a8  2e17              CMP      r6,#0x17
0048aa  d103              BNE      |L1.18612|
;;;784            dest = &allrouters;
0048ac  f8df82b8          LDR      r8,|L1.19304|
;;;785            ip_addr_copy(igmp->igmp_group_address, group->group_address);
0048b0  68a0              LDR      r0,[r4,#8]
0048b2  6068              STR      r0,[r5,#4]
                  |L1.18612|
;;;786          }
;;;787        }
;;;788    
;;;789        if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
0048b4  2e16              CMP      r6,#0x16
0048b6  d001              BEQ      |L1.18620|
0048b8  2e17              CMP      r6,#0x17
0048ba  d10e              BNE      |L1.18650|
                  |L1.18620|
;;;790          igmp->igmp_msgtype  = type;
0048bc  702e              STRB     r6,[r5,#0]
;;;791          igmp->igmp_maxresp  = 0;
0048be  2000              MOVS     r0,#0
0048c0  7068              STRB     r0,[r5,#1]
;;;792          igmp->igmp_checksum = 0;
0048c2  8068              STRH     r0,[r5,#2]
;;;793          igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);
0048c4  2108              MOVS     r1,#8
0048c6  4628              MOV      r0,r5
0048c8  f7fffffe          BL       inet_chksum
0048cc  8068              STRH     r0,[r5,#2]
;;;794    
;;;795          igmp_ip_output_if(p, &src, dest, group->netif);
0048ce  4642              MOV      r2,r8
0048d0  4669              MOV      r1,sp
0048d2  4638              MOV      r0,r7
0048d4  6863              LDR      r3,[r4,#4]
0048d6  f7fffffe          BL       igmp_ip_output_if
                  |L1.18650|
;;;796        }
;;;797    
;;;798        pbuf_free(p);
0048da  4638              MOV      r0,r7
0048dc  f7fffffe          BL       pbuf_free
0048e0  e009              B        |L1.18678|
                  |L1.18658|
;;;799      } else {
;;;800        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
0048e2  bf00              NOP      
0048e4  bf00              NOP      
;;;801        IGMP_STATS_INC(igmp.memerr);
0048e6  489e              LDR      r0,|L1.19296|
0048e8  f8b0006a          LDRH     r0,[r0,#0x6a]
0048ec  1c40              ADDS     r0,r0,#1
0048ee  b281              UXTH     r1,r0
0048f0  489b              LDR      r0,|L1.19296|
0048f2  f8a0106a          STRH     r1,[r0,#0x6a]
                  |L1.18678|
;;;802      }
;;;803    }
0048f6  e8bd83f8          POP      {r3-r9,pc}
;;;804    
                          ENDP

                  igmp_lookfor_group PROC
;;;289    struct igmp_group *
;;;290    igmp_lookfor_group(struct netif *ifp, ip_addr_t *addr)
0048fa  b510              PUSH     {r4,lr}
;;;291    {
0048fc  4602              MOV      r2,r0
0048fe  460b              MOV      r3,r1
;;;292      struct igmp_group *group = igmp_group_list;
004900  4896              LDR      r0,|L1.19292|
004902  6801              LDR      r1,[r0,#0]  ; igmp_group_list
;;;293    
;;;294      while (group != NULL) {
004904  e009              B        |L1.18714|
                  |L1.18694|
;;;295        if ((group->netif == ifp) && (ip_addr_cmp(&(group->group_address), addr))) {
004906  6848              LDR      r0,[r1,#4]
004908  4290              CMP      r0,r2
00490a  d105              BNE      |L1.18712|
00490c  6888              LDR      r0,[r1,#8]
00490e  681c              LDR      r4,[r3,#0]
004910  42a0              CMP      r0,r4
004912  d101              BNE      |L1.18712|
;;;296          return group;
004914  4608              MOV      r0,r1
                  |L1.18710|
;;;297        }
;;;298        group = group->next;
;;;299      }
;;;300    
;;;301      /* to be clearer, we return NULL here instead of
;;;302       * 'group' (which is also NULL at this point).
;;;303       */
;;;304      return NULL;
;;;305    }
004916  bd10              POP      {r4,pc}
                  |L1.18712|
004918  6809              LDR      r1,[r1,#0]            ;298
                  |L1.18714|
00491a  2900              CMP      r1,#0                 ;294
00491c  d1f3              BNE      |L1.18694|
00491e  2000              MOVS     r0,#0                 ;304
004920  e7f9              B        |L1.18710|
;;;306    
                          ENDP

                  igmp_leavegroup PROC
;;;584    err_t
;;;585    igmp_leavegroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)
004922  e92d41f0          PUSH     {r4-r8,lr}
;;;586    {
004926  4606              MOV      r6,r0
004928  460f              MOV      r7,r1
;;;587      err_t              err = ERR_VAL; /* no matching interface */
00492a  f06f0805          MVN      r8,#5
;;;588      struct igmp_group *group;
;;;589      struct netif      *netif;
;;;590    
;;;591      /* make sure it is multicast address */
;;;592      LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
00492e  bf00              NOP      
004930  7838              LDRB     r0,[r7,#0]
004932  f00000f0          AND      r0,r0,#0xf0
004936  28e0              CMP      r0,#0xe0
004938  d002              BEQ      |L1.18752|
00493a  4640              MOV      r0,r8
                  |L1.18748|
;;;593      LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
;;;594    
;;;595      /* loop through netif's */
;;;596      netif = netif_list;
;;;597      while (netif != NULL) {
;;;598        /* Should we leave this interface ? */
;;;599        if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
;;;600          /* find group */
;;;601          group = igmp_lookfor_group(netif, groupaddr);
;;;602    
;;;603          if (group != NULL) {
;;;604            /* Only send a leave if the flag is set according to the state diagram */
;;;605            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: Leaving group: "));
;;;606            ip_addr_debug_print(IGMP_DEBUG, groupaddr);
;;;607            LWIP_DEBUGF(IGMP_DEBUG, ("\n"));
;;;608    
;;;609            /* If there is no other use of the group */
;;;610            if (group->use <= 1) {
;;;611              /* If we are the last reporter for this group */
;;;612              if (group->last_reporter_flag) {
;;;613                LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: sending leaving group\n"));
;;;614                IGMP_STATS_INC(igmp.tx_leave);
;;;615                igmp_send(group, IGMP_LEAVE_GROUP);
;;;616              }
;;;617              
;;;618              /* Disable the group at the MAC level */
;;;619              if (netif->igmp_mac_filter != NULL) {
;;;620                LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: igmp_mac_filter(DEL "));
;;;621                ip_addr_debug_print(IGMP_DEBUG, groupaddr);
;;;622                LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
;;;623                netif->igmp_mac_filter(netif, groupaddr, IGMP_DEL_MAC_FILTER);
;;;624              }
;;;625              
;;;626              LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: remove group: "));
;;;627              ip_addr_debug_print(IGMP_DEBUG, groupaddr);
;;;628              LWIP_DEBUGF(IGMP_DEBUG, ("\n"));          
;;;629              
;;;630              /* Free the group */
;;;631              igmp_remove_group(group);
;;;632            } else {
;;;633              /* Decrement group use */
;;;634              group->use--;
;;;635            }
;;;636            /* Leave on this interface */
;;;637            err = ERR_OK;
;;;638          } else {
;;;639            /* It's not a fatal error on "leavegroup" */
;;;640            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: not member of group\n"));
;;;641          }
;;;642        }
;;;643        /* proceed to next network interface */
;;;644        netif = netif->next;
;;;645      }
;;;646    
;;;647      return err;
;;;648    }
00493c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.18752|
004940  bf00              NOP                            ;592
004942  bf00              NOP                            ;593
004944  4989              LDR      r1,|L1.19308|
004946  6838              LDR      r0,[r7,#0]            ;593
004948  6809              LDR      r1,[r1,#0]            ;593  ; allsystems
00494a  4288              CMP      r0,r1                 ;593
00494c  d102              BNE      |L1.18772|
00494e  f06f0005          MVN      r0,#5                 ;593
004952  e7f3              B        |L1.18748|
                  |L1.18772|
004954  bf00              NOP                            ;593
004956  4886              LDR      r0,|L1.19312|
004958  6804              LDR      r4,[r0,#0]            ;596  ; netif_list
00495a  e04b              B        |L1.18932|
                  |L1.18780|
00495c  f8940031          LDRB     r0,[r4,#0x31]         ;599
004960  f0100f80          TST      r0,#0x80              ;599
004964  d045              BEQ      |L1.18930|
004966  b12e              CBZ      r6,|L1.18804|
004968  6830              LDR      r0,[r6,#0]            ;599
00496a  b118              CBZ      r0,|L1.18804|
00496c  6860              LDR      r0,[r4,#4]            ;599
00496e  6831              LDR      r1,[r6,#0]            ;599
004970  4288              CMP      r0,r1                 ;599
004972  d13e              BNE      |L1.18930|
                  |L1.18804|
004974  4639              MOV      r1,r7                 ;601
004976  4620              MOV      r0,r4                 ;601
004978  f7fffffe          BL       igmp_lookfor_group
00497c  4605              MOV      r5,r0                 ;601
00497e  b37d              CBZ      r5,|L1.18912|
004980  bf00              NOP                            ;605
004982  bf00              NOP                            ;605
004984  bf00              NOP                            ;606
004986  bf00              NOP                            ;606
004988  bf00              NOP                            ;607
00498a  bf00              NOP                            ;607
00498c  7c28              LDRB     r0,[r5,#0x10]         ;610
00498e  2801              CMP      r0,#1                 ;610
004990  dc27              BGT      |L1.18914|
004992  7b28              LDRB     r0,[r5,#0xc]          ;612
004994  b168              CBZ      r0,|L1.18866|
004996  bf00              NOP                            ;613
004998  bf00              NOP                            ;613
00499a  4871              LDR      r0,|L1.19296|
00499c  f8b00078          LDRH     r0,[r0,#0x78]         ;614
0049a0  1c40              ADDS     r0,r0,#1              ;614
0049a2  b281              UXTH     r1,r0                 ;614
0049a4  486e              LDR      r0,|L1.19296|
0049a6  f8a01078          STRH     r1,[r0,#0x78]         ;614
0049aa  2117              MOVS     r1,#0x17              ;615
0049ac  4628              MOV      r0,r5                 ;615
0049ae  f7fffffe          BL       igmp_send
                  |L1.18866|
0049b2  6ba0              LDR      r0,[r4,#0x38]         ;619
0049b4  b150              CBZ      r0,|L1.18892|
0049b6  bf00              NOP                            ;620
0049b8  bf00              NOP                            ;620
0049ba  bf00              NOP                            ;621
0049bc  bf00              NOP                            ;621
0049be  bf00              NOP                            ;622
0049c0  bf00              NOP                            ;622
0049c2  2200              MOVS     r2,#0                 ;623
0049c4  4639              MOV      r1,r7                 ;623
0049c6  4620              MOV      r0,r4                 ;623
0049c8  6ba3              LDR      r3,[r4,#0x38]         ;623
0049ca  4798              BLX      r3                    ;623
                  |L1.18892|
0049cc  bf00              NOP                            ;626
0049ce  bf00              NOP                            ;626
0049d0  bf00              NOP                            ;627
0049d2  bf00              NOP                            ;627
0049d4  bf00              NOP                            ;628
0049d6  bf00              NOP                            ;628
0049d8  4628              MOV      r0,r5                 ;631
0049da  f7fffffe          BL       igmp_remove_group
0049de  e003              B        |L1.18920|
                  |L1.18912|
0049e0  e005              B        |L1.18926|
                  |L1.18914|
0049e2  7c28              LDRB     r0,[r5,#0x10]         ;634
0049e4  1e40              SUBS     r0,r0,#1              ;634
0049e6  7428              STRB     r0,[r5,#0x10]         ;634
                  |L1.18920|
0049e8  f04f0800          MOV      r8,#0                 ;637
0049ec  e001              B        |L1.18930|
                  |L1.18926|
0049ee  bf00              NOP                            ;640
0049f0  bf00              NOP                            ;640
                  |L1.18930|
0049f2  6824              LDR      r4,[r4,#0]            ;644
                  |L1.18932|
0049f4  2c00              CMP      r4,#0                 ;597
0049f6  d1b1              BNE      |L1.18780|
0049f8  4640              MOV      r0,r8                 ;647
0049fa  e79f              B        |L1.18748|
;;;649    
                          ENDP

                  igmp_start_timer PROC
;;;697    static void
;;;698    igmp_start_timer(struct igmp_group *group, u8_t max_time)
0049fc  b570              PUSH     {r4-r6,lr}
;;;699    {
0049fe  4605              MOV      r5,r0
004a00  460c              MOV      r4,r1
;;;700      /* ensure the input value is > 0 */
;;;701      if (max_time == 0) {
004a02  b904              CBNZ     r4,|L1.18950|
;;;702        max_time = 1;
004a04  2401              MOVS     r4,#1
                  |L1.18950|
;;;703      }
;;;704      /* ensure the random value is > 0 */
;;;705      group->timer = (LWIP_RAND() % (max_time - 1)) + 1;
004a06  f7fffffe          BL       rand
004a0a  1e61              SUBS     r1,r4,#1
004a0c  fb90f2f1          SDIV     r2,r0,r1
004a10  fb010012          MLS      r0,r1,r2,r0
004a14  1c40              ADDS     r0,r0,#1
004a16  81e8              STRH     r0,[r5,#0xe]
;;;706    }
004a18  bd70              POP      {r4-r6,pc}
;;;707    
                          ENDP

                  igmp_lookup_group PROC
;;;315    struct igmp_group *
;;;316    igmp_lookup_group(struct netif *ifp, ip_addr_t *addr)
004a1a  b570              PUSH     {r4-r6,lr}
;;;317    {
004a1c  4606              MOV      r6,r0
004a1e  460d              MOV      r5,r1
;;;318      struct igmp_group *group = igmp_group_list;
004a20  484e              LDR      r0,|L1.19292|
004a22  6804              LDR      r4,[r0,#0]  ; igmp_group_list
;;;319      
;;;320      /* Search if the group already exists */
;;;321      group = igmp_lookfor_group(ifp, addr);
004a24  4629              MOV      r1,r5
004a26  4630              MOV      r0,r6
004a28  f7fffffe          BL       igmp_lookfor_group
004a2c  4604              MOV      r4,r0
;;;322      if (group != NULL) {
004a2e  b10c              CBZ      r4,|L1.18996|
;;;323        /* Group already exists. */
;;;324        return group;
004a30  4620              MOV      r0,r4
                  |L1.18994|
;;;325      }
;;;326    
;;;327      /* Group doesn't exist yet, create a new one */
;;;328      group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
;;;329      if (group != NULL) {
;;;330        group->netif              = ifp;
;;;331        ip_addr_set(&(group->group_address), addr);
;;;332        group->timer              = 0; /* Not running */
;;;333        group->group_state        = IGMP_GROUP_NON_MEMBER;
;;;334        group->last_reporter_flag = 0;
;;;335        group->use                = 0;
;;;336        group->next               = igmp_group_list;
;;;337        
;;;338        igmp_group_list = group;
;;;339      }
;;;340    
;;;341      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_lookup_group: %sallocated a new group with address ", (group?"":"impossible to ")));
;;;342      ip_addr_debug_print(IGMP_DEBUG, addr);
;;;343      LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", ifp));
;;;344    
;;;345      return group;
;;;346    }
004a32  bd70              POP      {r4-r6,pc}
                  |L1.18996|
004a34  2009              MOVS     r0,#9                 ;328
004a36  f7fffffe          BL       memp_malloc
004a3a  4604              MOV      r4,r0                 ;328
004a3c  b17c              CBZ      r4,|L1.19038|
004a3e  6066              STR      r6,[r4,#4]            ;330
004a40  b90d              CBNZ     r5,|L1.19014|
004a42  2000              MOVS     r0,#0                 ;331
004a44  e000              B        |L1.19016|
                  |L1.19014|
004a46  6828              LDR      r0,[r5,#0]            ;331
                  |L1.19016|
004a48  60a0              STR      r0,[r4,#8]            ;331
004a4a  2000              MOVS     r0,#0                 ;332
004a4c  81e0              STRH     r0,[r4,#0xe]          ;332
004a4e  7360              STRB     r0,[r4,#0xd]          ;333
004a50  7320              STRB     r0,[r4,#0xc]          ;334
004a52  7420              STRB     r0,[r4,#0x10]         ;335
004a54  4841              LDR      r0,|L1.19292|
004a56  6800              LDR      r0,[r0,#0]            ;336  ; igmp_group_list
004a58  6020              STR      r0,[r4,#0]            ;336
004a5a  4840              LDR      r0,|L1.19292|
004a5c  6004              STR      r4,[r0,#0]            ;338  ; igmp_group_list
                  |L1.19038|
004a5e  bf00              NOP                            ;341
004a60  bf00              NOP                            ;341
004a62  bf00              NOP                            ;342
004a64  bf00              NOP                            ;342
004a66  bf00              NOP                            ;343
004a68  bf00              NOP                            ;343
004a6a  4620              MOV      r0,r4                 ;345
004a6c  e7e1              B        |L1.18994|
;;;347    
                          ENDP

                  igmp_joingroup PROC
;;;514    err_t
;;;515    igmp_joingroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)
004a6e  e92d41f0          PUSH     {r4-r8,lr}
;;;516    {
004a72  4606              MOV      r6,r0
004a74  460f              MOV      r7,r1
;;;517      err_t              err = ERR_VAL; /* no matching interface */
004a76  f06f0805          MVN      r8,#5
;;;518      struct igmp_group *group;
;;;519      struct netif      *netif;
;;;520    
;;;521      /* make sure it is multicast address */
;;;522      LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
004a7a  bf00              NOP      
004a7c  7838              LDRB     r0,[r7,#0]
004a7e  f00000f0          AND      r0,r0,#0xf0
004a82  28e0              CMP      r0,#0xe0
004a84  d002              BEQ      |L1.19084|
004a86  4640              MOV      r0,r8
                  |L1.19080|
;;;523      LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
;;;524    
;;;525      /* loop through netif's */
;;;526      netif = netif_list;
;;;527      while (netif != NULL) {
;;;528        /* Should we join this interface ? */
;;;529        if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
;;;530          /* find group or create a new one if not found */
;;;531          group = igmp_lookup_group(netif, groupaddr);
;;;532    
;;;533          if (group != NULL) {
;;;534            /* This should create a new group, check the state to make sure */
;;;535            if (group->group_state != IGMP_GROUP_NON_MEMBER) {
;;;536              LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: join to group not in state IGMP_GROUP_NON_MEMBER\n"));
;;;537            } else {
;;;538              /* OK - it was new group */
;;;539              LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: join to new group: "));
;;;540              ip_addr_debug_print(IGMP_DEBUG, groupaddr);
;;;541              LWIP_DEBUGF(IGMP_DEBUG, ("\n"));
;;;542    
;;;543              /* If first use of the group, allow the group at the MAC level */
;;;544              if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {
;;;545                LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: igmp_mac_filter(ADD "));
;;;546                ip_addr_debug_print(IGMP_DEBUG, groupaddr);
;;;547                LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
;;;548                netif->igmp_mac_filter(netif, groupaddr, IGMP_ADD_MAC_FILTER);
;;;549              }
;;;550    
;;;551              IGMP_STATS_INC(igmp.tx_join);
;;;552              igmp_send(group, IGMP_V2_MEMB_REPORT);
;;;553    
;;;554              igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
;;;555    
;;;556              /* Need to work out where this timer comes from */
;;;557              group->group_state = IGMP_GROUP_DELAYING_MEMBER;
;;;558            }
;;;559            /* Increment group use */
;;;560            group->use++;
;;;561            /* Join on this interface */
;;;562            err = ERR_OK;
;;;563          } else {
;;;564            /* Return an error even if some network interfaces are joined */
;;;565            /** @todo undo any other netif already joined */
;;;566            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: Not enought memory to join to group\n"));
;;;567            return ERR_MEM;
;;;568          }
;;;569        }
;;;570        /* proceed to next network interface */
;;;571        netif = netif->next;
;;;572      }
;;;573    
;;;574      return err;
;;;575    }
004a88  e8bd81f0          POP      {r4-r8,pc}
                  |L1.19084|
004a8c  bf00              NOP                            ;522
004a8e  bf00              NOP                            ;523
004a90  4936              LDR      r1,|L1.19308|
004a92  6838              LDR      r0,[r7,#0]            ;523
004a94  6809              LDR      r1,[r1,#0]            ;523  ; allsystems
004a96  4288              CMP      r0,r1                 ;523
004a98  d102              BNE      |L1.19104|
004a9a  f06f0005          MVN      r0,#5                 ;523
004a9e  e7f3              B        |L1.19080|
                  |L1.19104|
004aa0  bf00              NOP                            ;523
004aa2  4833              LDR      r0,|L1.19312|
004aa4  6805              LDR      r5,[r0,#0]            ;526  ; netif_list
004aa6  e049              B        |L1.19260|
                  |L1.19112|
004aa8  f8950031          LDRB     r0,[r5,#0x31]         ;529
004aac  f0100f80          TST      r0,#0x80              ;529
004ab0  d043              BEQ      |L1.19258|
004ab2  b12e              CBZ      r6,|L1.19136|
004ab4  6830              LDR      r0,[r6,#0]            ;529
004ab6  b118              CBZ      r0,|L1.19136|
004ab8  6868              LDR      r0,[r5,#4]            ;529
004aba  6831              LDR      r1,[r6,#0]            ;529
004abc  4288              CMP      r0,r1                 ;529
004abe  d13c              BNE      |L1.19258|
                  |L1.19136|
004ac0  4639              MOV      r1,r7                 ;531
004ac2  4628              MOV      r0,r5                 ;531
004ac4  f7fffffe          BL       igmp_lookup_group
004ac8  4604              MOV      r4,r0                 ;531
004aca  b384              CBZ      r4,|L1.19246|
004acc  7b60              LDRB     r0,[r4,#0xd]          ;535
004ace  b108              CBZ      r0,|L1.19156|
004ad0  bf00              NOP                            ;536
004ad2  e026              B        |L1.19234|
                  |L1.19156|
004ad4  bf00              NOP                            ;539
004ad6  bf00              NOP                            ;539
004ad8  bf00              NOP                            ;540
004ada  bf00              NOP                            ;540
004adc  bf00              NOP                            ;541
004ade  bf00              NOP                            ;541
004ae0  7c20              LDRB     r0,[r4,#0x10]         ;544
004ae2  b960              CBNZ     r0,|L1.19198|
004ae4  6ba8              LDR      r0,[r5,#0x38]         ;544
004ae6  b150              CBZ      r0,|L1.19198|
004ae8  bf00              NOP                            ;545
004aea  bf00              NOP                            ;545
004aec  bf00              NOP                            ;546
004aee  bf00              NOP                            ;546
004af0  bf00              NOP                            ;547
004af2  bf00              NOP                            ;547
004af4  2201              MOVS     r2,#1                 ;548
004af6  4639              MOV      r1,r7                 ;548
004af8  4628              MOV      r0,r5                 ;548
004afa  6bab              LDR      r3,[r5,#0x38]         ;548
004afc  4798              BLX      r3                    ;548
                  |L1.19198|
004afe  4818              LDR      r0,|L1.19296|
004b00  f8b00076          LDRH     r0,[r0,#0x76]         ;551
004b04  1c40              ADDS     r0,r0,#1              ;551
004b06  b281              UXTH     r1,r0                 ;551
004b08  4815              LDR      r0,|L1.19296|
004b0a  f8a01076          STRH     r1,[r0,#0x76]         ;551
004b0e  2116              MOVS     r1,#0x16              ;552
004b10  4620              MOV      r0,r4                 ;552
004b12  f7fffffe          BL       igmp_send
004b16  2105              MOVS     r1,#5                 ;554
004b18  4620              MOV      r0,r4                 ;554
004b1a  f7fffffe          BL       igmp_start_timer
004b1e  2001              MOVS     r0,#1                 ;557
004b20  7360              STRB     r0,[r4,#0xd]          ;557
                  |L1.19234|
004b22  7c20              LDRB     r0,[r4,#0x10]         ;560
004b24  1c40              ADDS     r0,r0,#1              ;560
004b26  7420              STRB     r0,[r4,#0x10]         ;560
004b28  f04f0800          MOV      r8,#0                 ;562
004b2c  e005              B        |L1.19258|
                  |L1.19246|
004b2e  e7ff              B        |L1.19248|
                  |L1.19248|
004b30  bf00              NOP                            ;566
004b32  bf00              NOP                            ;566
004b34  f04f30ff          MOV      r0,#0xffffffff        ;567
004b38  e7a6              B        |L1.19080|
                  |L1.19258|
004b3a  682d              LDR      r5,[r5,#0]            ;571
                  |L1.19260|
004b3c  2d00              CMP      r5,#0                 ;527
004b3e  d1b3              BNE      |L1.19112|
004b40  4640              MOV      r0,r8                 ;574
004b42  e7a1              B        |L1.19080|
;;;576    
                          ENDP

                  do_join_leave_group PROC
;;;1494   void
;;;1495   do_join_leave_group(struct api_msg_msg *msg)
004b44  b510              PUSH     {r4,lr}
;;;1496   { 
004b46  4604              MOV      r4,r0
;;;1497     if (ERR_IS_FATAL(msg->conn->last_err)) {
004b48  6820              LDR      r0,[r4,#0]
004b4a  f9900008          LDRSB    r0,[r0,#8]
004b4e  f1100f09          CMN      r0,#9
004b52  da0f              BGE      |L1.19316|
;;;1498       msg->err = msg->conn->last_err;
004b54  6820              LDR      r0,[r4,#0]
004b56  7a00              LDRB     r0,[r0,#8]
004b58  7120              STRB     r0,[r4,#4]
004b5a  e027              B        |L1.19372|
                  |L1.19292|
                          DCD      igmp_group_list
                  |L1.19296|
                          DCD      lwip_stats
                  |L1.19300|
                          DCD      ip_addr_any
                  |L1.19304|
                          DCD      allrouters
                  |L1.19308|
                          DCD      allsystems
                  |L1.19312|
                          DCD      netif_list
                  |L1.19316|
;;;1499     } else {
;;;1500       if (msg->conn->pcb.tcp != NULL) {
004b74  6820              LDR      r0,[r4,#0]
004b76  6840              LDR      r0,[r0,#4]
004b78  b1b0              CBZ      r0,|L1.19368|
;;;1501         if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
004b7a  6820              LDR      r0,[r4,#0]
004b7c  7800              LDRB     r0,[r0,#0]
004b7e  f00000f0          AND      r0,r0,#0xf0
004b82  2820              CMP      r0,#0x20
004b84  d10d              BNE      |L1.19362|
;;;1502   #if LWIP_UDP
;;;1503           if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
004b86  7c20              LDRB     r0,[r4,#0x10]
004b88  b928              CBNZ     r0,|L1.19350|
;;;1504             msg->err = igmp_joingroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
004b8a  e9d41002          LDRD     r1,r0,[r4,#8]
004b8e  f7fffffe          BL       igmp_joingroup
004b92  7120              STRB     r0,[r4,#4]
004b94  e00a              B        |L1.19372|
                  |L1.19350|
;;;1505           } else {
;;;1506             msg->err = igmp_leavegroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
004b96  e9d41002          LDRD     r1,r0,[r4,#8]
004b9a  f7fffffe          BL       igmp_leavegroup
004b9e  7120              STRB     r0,[r4,#4]
004ba0  e004              B        |L1.19372|
                  |L1.19362|
;;;1507           }
;;;1508   #endif /* LWIP_UDP */
;;;1509   #if (LWIP_TCP || LWIP_RAW)
;;;1510         } else {
;;;1511           msg->err = ERR_VAL;
004ba2  20fa              MOVS     r0,#0xfa
004ba4  7120              STRB     r0,[r4,#4]
004ba6  e001              B        |L1.19372|
                  |L1.19368|
;;;1512   #endif /* (LWIP_TCP || LWIP_RAW) */
;;;1513         }
;;;1514       } else {
;;;1515         msg->err = ERR_CONN;
004ba8  20f3              MOVS     r0,#0xf3
004baa  7120              STRB     r0,[r4,#4]
                  |L1.19372|
;;;1516       }
;;;1517     }
;;;1518     TCPIP_APIMSG_ACK(msg);
004bac  6821              LDR      r1,[r4,#0]
004bae  f101000c          ADD      r0,r1,#0xc
004bb2  f7fffffe          BL       sys_sem_signal
;;;1519   }
004bb6  bd10              POP      {r4,pc}
;;;1520   #endif /* LWIP_IGMP */
                          ENDP

                  netconn_join_leave_group PROC
;;;718    err_t
;;;719    netconn_join_leave_group(struct netconn *conn,
004bb8  e92d43f0          PUSH     {r4-r9,lr}
;;;720                             ip_addr_t *multiaddr,
;;;721                             ip_addr_t *netif_addr,
;;;722                             enum netconn_igmp join_or_leave)
;;;723    {
004bbc  b087              SUB      sp,sp,#0x1c
004bbe  4604              MOV      r4,r0
004bc0  460e              MOV      r6,r1
004bc2  4617              MOV      r7,r2
004bc4  4698              MOV      r8,r3
;;;724      struct api_msg msg;
;;;725      err_t err;
;;;726    
;;;727      LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
004bc6  bf00              NOP      
004bc8  b924              CBNZ     r4,|L1.19412|
004bca  f06f000d          MVN      r0,#0xd
                  |L1.19406|
;;;728    
;;;729      msg.function = do_join_leave_group;
;;;730      msg.msg.conn = conn;
;;;731      msg.msg.msg.jl.multiaddr = multiaddr;
;;;732      msg.msg.msg.jl.netif_addr = netif_addr;
;;;733      msg.msg.msg.jl.join_or_leave = join_or_leave;
;;;734      err = TCPIP_APIMSG(&msg);
;;;735    
;;;736      NETCONN_SET_SAFE_ERR(conn, err);
;;;737      return err;
;;;738    }
004bce  b007              ADD      sp,sp,#0x1c
004bd0  e8bd83f0          POP      {r4-r9,pc}
                  |L1.19412|
004bd4  bf00              NOP                            ;727
004bd6  f2af0093          ADR      r0,do_join_leave_group + 1
004bda  9001              STR      r0,[sp,#4]            ;729
004bdc  9402              STR      r4,[sp,#8]            ;730
004bde  9604              STR      r6,[sp,#0x10]         ;731
004be0  9705              STR      r7,[sp,#0x14]         ;732
004be2  f88d8018          STRB     r8,[sp,#0x18]         ;733
004be6  a801              ADD      r0,sp,#4              ;734
004be8  f7fffffe          BL       tcpip_apimsg
004bec  4605              MOV      r5,r0                 ;734
004bee  bf00              NOP                            ;736
004bf0  f7fffffe          BL       sys_arch_protect
004bf4  4681              MOV      r9,r0                 ;736
004bf6  f9940008          LDRSB    r0,[r4,#8]            ;736
004bfa  f1100f09          CMN      r0,#9                 ;736
004bfe  db00              BLT      |L1.19458|
004c00  7225              STRB     r5,[r4,#8]            ;736
                  |L1.19458|
004c02  4648              MOV      r0,r9                 ;736
004c04  f7fffffe          BL       sys_arch_unprotect
004c08  bf00              NOP                            ;736
004c0a  4628              MOV      r0,r5                 ;737
004c0c  e7df              B        |L1.19406|
;;;739    #endif /* LWIP_IGMP */
                          ENDP

                  lwip_strerr PROC
;;;68     const char *
;;;69     lwip_strerr(err_t err)
004c0e  4601              MOV      r1,r0
;;;70     {
;;;71       return err_strerr[-err];
004c10  48fb              LDR      r0,|L1.20480|
004c12  424a              RSBS     r2,r1,#0
004c14  f8500022          LDR      r0,[r0,r2,LSL #2]
;;;72     
;;;73     }
004c18  4770              BX       lr
;;;74     
                          ENDP

                  netbuf_new PROC
;;;55     struct
;;;56     netbuf *netbuf_new(void)
004c1a  b510              PUSH     {r4,lr}
;;;57     {
;;;58       struct netbuf *buf;
;;;59     
;;;60       buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
004c1c  2005              MOVS     r0,#5
004c1e  f7fffffe          BL       memp_malloc
004c22  4604              MOV      r4,r0
;;;61       if (buf != NULL) {
004c24  b134              CBZ      r4,|L1.19508|
;;;62         buf->p = NULL;
004c26  2000              MOVS     r0,#0
004c28  6020              STR      r0,[r4,#0]
;;;63         buf->ptr = NULL;
004c2a  6060              STR      r0,[r4,#4]
;;;64         ip_addr_set_any(&buf->addr);
004c2c  60a0              STR      r0,[r4,#8]
;;;65         buf->port = 0;
004c2e  81a0              STRH     r0,[r4,#0xc]
;;;66     #if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
;;;67     #if LWIP_CHECKSUM_ON_COPY
;;;68         buf->flags = 0;
;;;69     #endif /* LWIP_CHECKSUM_ON_COPY */
;;;70         buf->toport_chksum = 0;
;;;71     #if LWIP_NETBUF_RECVINFO
;;;72         ip_addr_set_any(&buf->toaddr);
;;;73     #endif /* LWIP_NETBUF_RECVINFO */
;;;74     #endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
;;;75         return buf;
004c30  4620              MOV      r0,r4
                  |L1.19506|
;;;76       } else {
;;;77         return NULL;
;;;78       }
;;;79     }
004c32  bd10              POP      {r4,pc}
                  |L1.19508|
004c34  2000              MOVS     r0,#0                 ;77
004c36  e7fc              B        |L1.19506|
;;;80     
                          ENDP

                  netbuf_alloc PROC
;;;106    void *
;;;107    netbuf_alloc(struct netbuf *buf, u16_t size)
004c38  b570              PUSH     {r4-r6,lr}
;;;108    {
004c3a  4604              MOV      r4,r0
004c3c  460d              MOV      r5,r1
;;;109      LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
004c3e  bf00              NOP      
004c40  b90c              CBNZ     r4,|L1.19526|
004c42  2000              MOVS     r0,#0
                  |L1.19524|
;;;110    
;;;111      /* Deallocate any previously allocated memory. */
;;;112      if (buf->p != NULL) {
;;;113        pbuf_free(buf->p);
;;;114      }
;;;115      buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
;;;116      if (buf->p == NULL) {
;;;117         return NULL;
;;;118      }
;;;119      LWIP_ASSERT("check that first pbuf can hold size",
;;;120                 (buf->p->len >= size));
;;;121      buf->ptr = buf->p;
;;;122      return buf->p->payload;
;;;123    }
004c44  bd70              POP      {r4-r6,pc}
                  |L1.19526|
004c46  bf00              NOP                            ;109
004c48  6820              LDR      r0,[r4,#0]            ;112
004c4a  b110              CBZ      r0,|L1.19538|
004c4c  6820              LDR      r0,[r4,#0]            ;113
004c4e  f7fffffe          BL       pbuf_free
                  |L1.19538|
004c52  2200              MOVS     r2,#0                 ;115
004c54  4629              MOV      r1,r5                 ;115
004c56  4610              MOV      r0,r2                 ;115
004c58  f7fffffe          BL       pbuf_alloc
004c5c  6020              STR      r0,[r4,#0]            ;115
004c5e  6820              LDR      r0,[r4,#0]            ;116
004c60  b908              CBNZ     r0,|L1.19558|
004c62  2000              MOVS     r0,#0                 ;117
004c64  e7ee              B        |L1.19524|
                  |L1.19558|
004c66  bf00              NOP                            ;119
004c68  bf00              NOP                            ;119
004c6a  6820              LDR      r0,[r4,#0]            ;121
004c6c  6060              STR      r0,[r4,#4]            ;121
004c6e  6820              LDR      r0,[r4,#0]            ;122
004c70  6840              LDR      r0,[r0,#4]            ;122
004c72  e7e7              B        |L1.19524|
;;;124    
                          ENDP

                  netbuf_free PROC
;;;130    void
;;;131    netbuf_free(struct netbuf *buf)
004c74  b510              PUSH     {r4,lr}
;;;132    {
004c76  4604              MOV      r4,r0
;;;133      LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
004c78  bf00              NOP      
004c7a  b904              CBNZ     r4,|L1.19582|
                  |L1.19580|
;;;134      if (buf->p != NULL) {
;;;135        pbuf_free(buf->p);
;;;136      }
;;;137      buf->p = buf->ptr = NULL;
;;;138    }
004c7c  bd10              POP      {r4,pc}
                  |L1.19582|
004c7e  bf00              NOP                            ;133
004c80  6820              LDR      r0,[r4,#0]            ;134
004c82  b110              CBZ      r0,|L1.19594|
004c84  6820              LDR      r0,[r4,#0]            ;135
004c86  f7fffffe          BL       pbuf_free
                  |L1.19594|
004c8a  2000              MOVS     r0,#0                 ;137
004c8c  6060              STR      r0,[r4,#4]            ;137
004c8e  6020              STR      r0,[r4,#0]            ;137
004c90  bf00              NOP      
004c92  e7f3              B        |L1.19580|
;;;139    
                          ENDP

                  netbuf_ref PROC
;;;149    err_t
;;;150    netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
004c94  b570              PUSH     {r4-r6,lr}
;;;151    {
004c96  4604              MOV      r4,r0
004c98  460d              MOV      r5,r1
004c9a  4616              MOV      r6,r2
;;;152      LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
004c9c  bf00              NOP      
004c9e  b914              CBNZ     r4,|L1.19622|
004ca0  f06f000d          MVN      r0,#0xd
                  |L1.19620|
;;;153      if (buf->p != NULL) {
;;;154        pbuf_free(buf->p);
;;;155      }
;;;156      buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
;;;157      if (buf->p == NULL) {
;;;158        buf->ptr = NULL;
;;;159        return ERR_MEM;
;;;160      }
;;;161      buf->p->payload = (void*)dataptr;
;;;162      buf->p->len = buf->p->tot_len = size;
;;;163      buf->ptr = buf->p;
;;;164      return ERR_OK;
;;;165    }
004ca4  bd70              POP      {r4-r6,pc}
                  |L1.19622|
004ca6  bf00              NOP                            ;152
004ca8  6820              LDR      r0,[r4,#0]            ;153
004caa  b110              CBZ      r0,|L1.19634|
004cac  6820              LDR      r0,[r4,#0]            ;154
004cae  f7fffffe          BL       pbuf_free
                  |L1.19634|
004cb2  2202              MOVS     r2,#2                 ;156
004cb4  2100              MOVS     r1,#0                 ;156
004cb6  4608              MOV      r0,r1                 ;156
004cb8  f7fffffe          BL       pbuf_alloc
004cbc  6020              STR      r0,[r4,#0]            ;156
004cbe  6820              LDR      r0,[r4,#0]            ;157
004cc0  b918              CBNZ     r0,|L1.19658|
004cc2  2000              MOVS     r0,#0                 ;158
004cc4  6060              STR      r0,[r4,#4]            ;158
004cc6  1e40              SUBS     r0,r0,#1              ;159
004cc8  e7ec              B        |L1.19620|
                  |L1.19658|
004cca  6820              LDR      r0,[r4,#0]            ;161
004ccc  6045              STR      r5,[r0,#4]            ;161
004cce  6820              LDR      r0,[r4,#0]            ;162
004cd0  8106              STRH     r6,[r0,#8]            ;162
004cd2  6820              LDR      r0,[r4,#0]            ;162
004cd4  8146              STRH     r6,[r0,#0xa]          ;162
004cd6  6820              LDR      r0,[r4,#0]            ;163
004cd8  6060              STR      r0,[r4,#4]            ;163
004cda  2000              MOVS     r0,#0                 ;164
004cdc  e7e2              B        |L1.19620|
;;;166    
                          ENDP

                  netbuf_chain PROC
;;;173    void
;;;174    netbuf_chain(struct netbuf *head, struct netbuf *tail)
004cde  b570              PUSH     {r4-r6,lr}
;;;175    {
004ce0  4604              MOV      r4,r0
004ce2  460d              MOV      r5,r1
;;;176      LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
004ce4  bf00              NOP      
004ce6  b904              CBNZ     r4,|L1.19690|
                  |L1.19688|
;;;177      LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
;;;178      pbuf_cat(head->p, tail->p);
;;;179      head->ptr = head->p;
;;;180      memp_free(MEMP_NETBUF, tail);
;;;181    }
004ce8  bd70              POP      {r4-r6,pc}
                  |L1.19690|
004cea  bf00              NOP                            ;176
004cec  bf00              NOP                            ;177
004cee  b905              CBNZ     r5,|L1.19698|
004cf0  e7fa              B        |L1.19688|
                  |L1.19698|
004cf2  bf00              NOP                            ;177
004cf4  6829              LDR      r1,[r5,#0]            ;178
004cf6  6820              LDR      r0,[r4,#0]            ;178
004cf8  f7fffffe          BL       pbuf_cat
004cfc  6820              LDR      r0,[r4,#0]            ;179
004cfe  6060              STR      r0,[r4,#4]            ;179
004d00  4629              MOV      r1,r5                 ;180
004d02  2005              MOVS     r0,#5                 ;180
004d04  f7fffffe          BL       memp_free
004d08  bf00              NOP      
004d0a  e7ed              B        |L1.19688|
;;;182    
                          ENDP

                  netbuf_data PROC
;;;192    err_t
;;;193    netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
004d0c  4603              MOV      r3,r0
;;;194    {
;;;195      LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
004d0e  bf00              NOP      
004d10  b913              CBNZ     r3,|L1.19736|
004d12  f06f000d          MVN      r0,#0xd
                  |L1.19734|
;;;196      LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
;;;197      LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
;;;198    
;;;199      if (buf->ptr == NULL) {
;;;200        return ERR_BUF;
;;;201      }
;;;202      *dataptr = buf->ptr->payload;
;;;203      *len = buf->ptr->len;
;;;204      return ERR_OK;
;;;205    }
004d16  4770              BX       lr
                  |L1.19736|
004d18  bf00              NOP                            ;195
004d1a  bf00              NOP                            ;196
004d1c  b911              CBNZ     r1,|L1.19748|
004d1e  f06f000d          MVN      r0,#0xd               ;196
004d22  e7f8              B        |L1.19734|
                  |L1.19748|
004d24  bf00              NOP                            ;196
004d26  bf00              NOP                            ;197
004d28  b912              CBNZ     r2,|L1.19760|
004d2a  f06f000d          MVN      r0,#0xd               ;197
004d2e  e7f2              B        |L1.19734|
                  |L1.19760|
004d30  bf00              NOP                            ;197
004d32  6858              LDR      r0,[r3,#4]            ;199
004d34  b910              CBNZ     r0,|L1.19772|
004d36  f06f0001          MVN      r0,#1                 ;200
004d3a  e7ec              B        |L1.19734|
                  |L1.19772|
004d3c  6858              LDR      r0,[r3,#4]            ;202
004d3e  6840              LDR      r0,[r0,#4]            ;202
004d40  6008              STR      r0,[r1,#0]            ;202
004d42  6858              LDR      r0,[r3,#4]            ;203
004d44  8940              LDRH     r0,[r0,#0xa]          ;203
004d46  8010              STRH     r0,[r2,#0]            ;203
004d48  2000              MOVS     r0,#0                 ;204
004d4a  e7e4              B        |L1.19734|
;;;206    
                          ENDP

                  netbuf_next PROC
;;;217    s8_t
;;;218    netbuf_next(struct netbuf *buf)
004d4c  4601              MOV      r1,r0
;;;219    {
;;;220      LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
004d4e  bf00              NOP      
004d50  b911              CBNZ     r1,|L1.19800|
004d52  f04f30ff          MOV      r0,#0xffffffff
                  |L1.19798|
;;;221      if (buf->ptr->next == NULL) {
;;;222        return -1;
;;;223      }
;;;224      buf->ptr = buf->ptr->next;
;;;225      if (buf->ptr->next == NULL) {
;;;226        return 1;
;;;227      }
;;;228      return 0;
;;;229    }
004d56  4770              BX       lr
                  |L1.19800|
004d58  bf00              NOP                            ;220
004d5a  6848              LDR      r0,[r1,#4]            ;221
004d5c  6800              LDR      r0,[r0,#0]            ;221
004d5e  b910              CBNZ     r0,|L1.19814|
004d60  f04f30ff          MOV      r0,#0xffffffff        ;222
004d64  e7f7              B        |L1.19798|
                  |L1.19814|
004d66  6848              LDR      r0,[r1,#4]            ;224
004d68  6800              LDR      r0,[r0,#0]            ;224
004d6a  6048              STR      r0,[r1,#4]            ;224
004d6c  6848              LDR      r0,[r1,#4]            ;225
004d6e  6800              LDR      r0,[r0,#0]            ;225
004d70  b908              CBNZ     r0,|L1.19830|
004d72  2001              MOVS     r0,#1                 ;226
004d74  e7ef              B        |L1.19798|
                  |L1.19830|
004d76  2000              MOVS     r0,#0                 ;228
004d78  e7ed              B        |L1.19798|
;;;230    
                          ENDP

                  netbuf_first PROC
;;;238    void
;;;239    netbuf_first(struct netbuf *buf)
004d7a  bf00              NOP      
;;;240    {
;;;241      LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
004d7c  b900              CBNZ     r0,|L1.19840|
                  |L1.19838|
;;;242      buf->ptr = buf->p;
;;;243    }
004d7e  4770              BX       lr
                  |L1.19840|
004d80  bf00              NOP                            ;241
004d82  6801              LDR      r1,[r0,#0]            ;242
004d84  6041              STR      r1,[r0,#4]            ;242
004d86  bf00              NOP      
004d88  e7f9              B        |L1.19838|
;;;244    
                          ENDP

                  sys_untimeout PROC
;;;320    void
;;;321    sys_untimeout(sys_timeout_handler handler, void *arg)
004d8a  e92d41f0          PUSH     {r4-r8,lr}
;;;322    {
004d8e  4606              MOV      r6,r0
004d90  460f              MOV      r7,r1
;;;323      struct sys_timeo *prev_t, *t;
;;;324    
;;;325      if (next_timeout == NULL) {
004d92  489c              LDR      r0,|L1.20484|
004d94  6800              LDR      r0,[r0,#0]  ; next_timeout
004d96  b908              CBNZ     r0,|L1.19868|
                  |L1.19864|
;;;326        return;
;;;327      }
;;;328    
;;;329      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
;;;330        if ((t->h == handler) && (t->arg == arg)) {
;;;331          /* We have a match */
;;;332          /* Unlink from previous in list */
;;;333          if (prev_t == NULL) {
;;;334            next_timeout = t->next;
;;;335          } else {
;;;336            prev_t->next = t->next;
;;;337          }
;;;338          /* If not the last one, add time of this one back to next */
;;;339          if (t->next != NULL) {
;;;340            t->next->time += t->time;
;;;341          }
;;;342          memp_free(MEMP_SYS_TIMEOUT, t);
;;;343          return;
;;;344        }
;;;345      }
;;;346      return;
;;;347    }
004d98  e8bd81f0          POP      {r4-r8,pc}
                  |L1.19868|
004d9c  4899              LDR      r0,|L1.20484|
004d9e  6804              LDR      r4,[r0,#0]            ;329  ; next_timeout
004da0  2500              MOVS     r5,#0                 ;329
004da2  e01b              B        |L1.19932|
                  |L1.19876|
004da4  68a0              LDR      r0,[r4,#8]            ;330
004da6  42b0              CMP      r0,r6                 ;330
004da8  d116              BNE      |L1.19928|
004daa  68e0              LDR      r0,[r4,#0xc]          ;330
004dac  42b8              CMP      r0,r7                 ;330
004dae  d113              BNE      |L1.19928|
004db0  b91d              CBNZ     r5,|L1.19898|
004db2  4994              LDR      r1,|L1.20484|
004db4  6820              LDR      r0,[r4,#0]            ;334
004db6  6008              STR      r0,[r1,#0]            ;334  ; next_timeout
004db8  e001              B        |L1.19902|
                  |L1.19898|
004dba  6820              LDR      r0,[r4,#0]            ;336
004dbc  6028              STR      r0,[r5,#0]            ;336
                  |L1.19902|
004dbe  6820              LDR      r0,[r4,#0]            ;339
004dc0  b128              CBZ      r0,|L1.19918|
004dc2  6820              LDR      r0,[r4,#0]            ;340
004dc4  6840              LDR      r0,[r0,#4]            ;340
004dc6  6861              LDR      r1,[r4,#4]            ;340
004dc8  4408              ADD      r0,r0,r1              ;340
004dca  6821              LDR      r1,[r4,#0]            ;340
004dcc  6048              STR      r0,[r1,#4]            ;340
                  |L1.19918|
004dce  4621              MOV      r1,r4                 ;342
004dd0  200a              MOVS     r0,#0xa               ;342
004dd2  f7fffffe          BL       memp_free
004dd6  e7df              B        |L1.19864|
                  |L1.19928|
004dd8  4625              MOV      r5,r4                 ;329
004dda  6824              LDR      r4,[r4,#0]            ;329
                  |L1.19932|
004ddc  2c00              CMP      r4,#0                 ;329
004dde  d1e1              BNE      |L1.19876|
004de0  bf00              NOP                            ;346
004de2  e7d9              B        |L1.19864|
;;;348    
                          ENDP

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
004de4  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
004de8  4606              MOV      r6,r0
004dea  460f              MOV      r7,r1
004dec  4690              MOV      r8,r2
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
004dee  2200              MOVS     r2,#0
004df0  2124              MOVS     r1,#0x24
004df2  2001              MOVS     r0,#1
004df4  f7fffffe          BL       pbuf_alloc
004df8  4605              MOV      r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
004dfa  b91d              CBNZ     r5,|L1.19972|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
004dfc  bf00              NOP      
004dfe  bf00              NOP      
                  |L1.19968|
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
;;;336      pbuf_free(q);
;;;337    }
004e00  e8bd83fe          POP      {r1-r9,pc}
                  |L1.19972|
004e04  bf00              NOP                            ;306
004e06  bf00              NOP                            ;306
004e08  f8d69004          LDR      r9,[r6,#4]            ;309
004e0c  bf00              NOP                            ;310
004e0e  bf00              NOP                            ;310
004e10  bf00              NOP                            ;311
004e12  bf00              NOP                            ;311
004e14  bf00              NOP                            ;312
004e16  bf00              NOP                            ;312
004e18  bf00              NOP                            ;313
004e1a  bf00              NOP                            ;313
004e1c  bf00              NOP                            ;314
004e1e  bf00              NOP                            ;314
004e20  686c              LDR      r4,[r5,#4]            ;316
004e22  7027              STRB     r7,[r4,#0]            ;317
004e24  f8848001          STRB     r8,[r4,#1]            ;318
004e28  2000              MOVS     r0,#0                 ;319
004e2a  80a0              STRH     r0,[r4,#4]            ;319
004e2c  80e0              STRH     r0,[r4,#6]            ;320
004e2e  6871              LDR      r1,[r6,#4]            ;323
004e30  686a              LDR      r2,[r5,#4]            ;323
004e32  f1020008          ADD      r0,r2,#8              ;323
004e36  221c              MOVS     r2,#0x1c              ;323
004e38  f7fffffe          BL       __aeabi_memcpy
004e3c  2000              MOVS     r0,#0                 ;327
004e3e  8060              STRH     r0,[r4,#2]            ;327
004e40  8969              LDRH     r1,[r5,#0xa]          ;328
004e42  4620              MOV      r0,r4                 ;328
004e44  f7fffffe          BL       inet_chksum
004e48  8060              STRH     r0,[r4,#2]            ;328
004e4a  486f              LDR      r0,|L1.20488|
004e4c  f8b00048          LDRH     r0,[r0,#0x48]         ;329  ; lwip_stats
004e50  1c40              ADDS     r0,r0,#1              ;329
004e52  496d              LDR      r1,|L1.20488|
004e54  f8a10048          STRH     r0,[r1,#0x48]         ;329
004e58  f8d9000c          LDR      r0,[r9,#0xc]          ;334
004e5c  9002              STR      r0,[sp,#8]            ;334
004e5e  2001              MOVS     r0,#1                 ;335
004e60  2100              MOVS     r1,#0                 ;335
004e62  23ff              MOVS     r3,#0xff              ;335
004e64  aa02              ADD      r2,sp,#8              ;335
004e66  e9cd1000          STRD     r1,r0,[sp,#0]         ;335
004e6a  4628              MOV      r0,r5                 ;335
004e6c  f7fffffe          BL       ip_output
004e70  4628              MOV      r0,r5                 ;336
004e72  f7fffffe          BL       pbuf_free
004e76  bf00              NOP      
004e78  e7c2              B        |L1.19968|
;;;338    
                          ENDP

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
004e7a  b570              PUSH     {r4-r6,lr}
;;;262    {
004e7c  4605              MOV      r5,r0
004e7e  460c              MOV      r4,r1
;;;263      icmp_send_response(p, ICMP_DUR, t);
004e80  4622              MOV      r2,r4
004e82  2103              MOVS     r1,#3
004e84  4628              MOV      r0,r5
004e86  f7fffffe          BL       icmp_send_response
;;;264    }
004e8a  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  ip4_addr_isbroadcast PROC
;;;54     u8_t
;;;55     ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
004e8c  b518              PUSH     {r3,r4,lr}
;;;56     {
004e8e  4602              MOV      r2,r0
;;;57       ip_addr_t ipaddr;
;;;58       ip4_addr_set_u32(&ipaddr, addr);
004e90  9200              STR      r2,[sp,#0]
;;;59     
;;;60       /* all ones (broadcast) or all zeroes (old skool broadcast) */
;;;61       if ((~addr == IPADDR_ANY) ||
004e92  43d0              MVNS     r0,r2
004e94  d000              BEQ      |L1.20120|
;;;62           (addr == IPADDR_ANY)) {
004e96  b90a              CBNZ     r2,|L1.20124|
                  |L1.20120|
;;;63         return 1;
004e98  2001              MOVS     r0,#1
                  |L1.20122|
;;;64       /* no broadcast support on this network interface? */
;;;65       } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
;;;66         /* the given address cannot be a broadcast address
;;;67          * nor can we check against any broadcast addresses */
;;;68         return 0;
;;;69       /* address matches network interface address exactly? => no broadcast */
;;;70       } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
;;;71         return 0;
;;;72       /*  on the same (sub) network... */
;;;73       } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
;;;74              /* ...and host identifier bits are all ones? =>... */
;;;75               && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
;;;76                (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
;;;77         /* => network broadcast address */
;;;78         return 1;
;;;79       } else {
;;;80         return 0;
;;;81       }
;;;82     }
004e9a  bd18              POP      {r3,r4,pc}
                  |L1.20124|
004e9c  f8910031          LDRB     r0,[r1,#0x31]         ;65
004ea0  f0100f02          TST      r0,#2                 ;65
004ea4  d101              BNE      |L1.20138|
004ea6  2000              MOVS     r0,#0                 ;68
004ea8  e7f7              B        |L1.20122|
                  |L1.20138|
004eaa  6848              LDR      r0,[r1,#4]            ;70
004eac  4290              CMP      r0,r2                 ;70
004eae  d101              BNE      |L1.20148|
004eb0  2000              MOVS     r0,#0                 ;71
004eb2  e7f2              B        |L1.20122|
                  |L1.20148|
004eb4  9800              LDR      r0,[sp,#0]            ;73
004eb6  688b              LDR      r3,[r1,#8]            ;73
004eb8  4018              ANDS     r0,r0,r3              ;73
004eba  e9d13401          LDRD     r3,r4,[r1,#4]         ;73
004ebe  4023              ANDS     r3,r3,r4              ;73
004ec0  4298              CMP      r0,r3                 ;73
004ec2  d108              BNE      |L1.20182|
004ec4  6888              LDR      r0,[r1,#8]            ;75
004ec6  ea220000          BIC      r0,r2,r0              ;75
004eca  688c              LDR      r4,[r1,#8]            ;75
004ecc  43e3              MVNS     r3,r4                 ;75
004ece  4298              CMP      r0,r3                 ;75
004ed0  d101              BNE      |L1.20182|
004ed2  2001              MOVS     r0,#1                 ;78
004ed4  e7e1              B        |L1.20122|
                  |L1.20182|
004ed6  2000              MOVS     r0,#0                 ;80
004ed8  e7df              B        |L1.20122|
;;;83     
                          ENDP

                  igmp_delaying_member PROC
;;;714    static void
;;;715    igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
004eda  b570              PUSH     {r4-r6,lr}
;;;716    {
004edc  4604              MOV      r4,r0
004ede  460d              MOV      r5,r1
;;;717      if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
004ee0  7b60              LDRB     r0,[r4,#0xd]
004ee2  2802              CMP      r0,#2
004ee4  d007              BEQ      |L1.20214|
;;;718         ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
004ee6  7b60              LDRB     r0,[r4,#0xd]
004ee8  2801              CMP      r0,#1
004eea  d10a              BNE      |L1.20226|
;;;719          ((group->timer == 0) || (maxresp < group->timer)))) {
004eec  89e0              LDRH     r0,[r4,#0xe]
004eee  b110              CBZ      r0,|L1.20214|
004ef0  89e0              LDRH     r0,[r4,#0xe]
004ef2  42a8              CMP      r0,r5
004ef4  dd05              BLE      |L1.20226|
                  |L1.20214|
;;;720        igmp_start_timer(group, maxresp);
004ef6  4629              MOV      r1,r5
004ef8  4620              MOV      r0,r4
004efa  f7fffffe          BL       igmp_start_timer
;;;721        group->group_state = IGMP_GROUP_DELAYING_MEMBER;
004efe  2001              MOVS     r0,#1
004f00  7360              STRB     r0,[r4,#0xd]
                  |L1.20226|
;;;722      }
;;;723    }
004f02  bd70              POP      {r4-r6,pc}
;;;724    
                          ENDP

                  igmp_input PROC
;;;388    void
;;;389    igmp_input(struct pbuf *p, struct netif *inp, ip_addr_t *dest)
004f04  e92d4ff8          PUSH     {r3-r11,lr}
;;;390    {
004f08  4607              MOV      r7,r0
004f0a  4689              MOV      r9,r1
004f0c  4690              MOV      r8,r2
;;;391      struct ip_hdr *    iphdr;
;;;392      struct igmp_msg*   igmp;
;;;393      struct igmp_group* group;
;;;394      struct igmp_group* groupref;
;;;395    
;;;396      IGMP_STATS_INC(igmp.recv);
004f0e  483e              LDR      r0,|L1.20488|
004f10  f8b00062          LDRH     r0,[r0,#0x62]
004f14  1c40              ADDS     r0,r0,#1
004f16  b281              UXTH     r1,r0
004f18  483b              LDR      r0,|L1.20488|
004f1a  f8a01062          STRH     r1,[r0,#0x62]
;;;397    
;;;398      /* Note that the length CAN be greater than 8 but only 8 are used - All are included in the checksum */    
;;;399      iphdr = (struct ip_hdr *)p->payload;
004f1e  f8d7a004          LDR      r10,[r7,#4]
;;;400      if (pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4)) || (p->len < IGMP_MINLEN)) {
004f22  f89a0000          LDRB     r0,[r10,#0]
004f26  0700              LSLS     r0,r0,#28
004f28  0e80              LSRS     r0,r0,#26
004f2a  4241              RSBS     r1,r0,#0
004f2c  4638              MOV      r0,r7
004f2e  f7fffffe          BL       pbuf_header
004f32  b910              CBNZ     r0,|L1.20282|
004f34  8978              LDRH     r0,[r7,#0xa]
004f36  2808              CMP      r0,#8
004f38  da0e              BGE      |L1.20312|
                  |L1.20282|
;;;401        pbuf_free(p);
004f3a  4638              MOV      r0,r7
004f3c  f7fffffe          BL       pbuf_free
;;;402        IGMP_STATS_INC(igmp.lenerr);
004f40  4831              LDR      r0,|L1.20488|
004f42  f8b00068          LDRH     r0,[r0,#0x68]
004f46  1c40              ADDS     r0,r0,#1
004f48  b281              UXTH     r1,r0
004f4a  482f              LDR      r0,|L1.20488|
004f4c  f8a01068          STRH     r1,[r0,#0x68]
;;;403        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: length error\n"));
004f50  bf00              NOP      
004f52  bf00              NOP      
                  |L1.20308|
;;;404        return;
;;;405      }
;;;406    
;;;407      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: message from "));
;;;408      ip_addr_debug_print(IGMP_DEBUG, &(iphdr->src));
;;;409      LWIP_DEBUGF(IGMP_DEBUG, (" to address "));
;;;410      ip_addr_debug_print(IGMP_DEBUG, &(iphdr->dest));
;;;411      LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", inp));
;;;412    
;;;413      /* Now calculate and check the checksum */
;;;414      igmp = (struct igmp_msg *)p->payload;
;;;415      if (inet_chksum(igmp, p->len)) {
;;;416        pbuf_free(p);
;;;417        IGMP_STATS_INC(igmp.chkerr);
;;;418        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: checksum error\n"));
;;;419        return;
;;;420      }
;;;421    
;;;422      /* Packet is ok so find an existing group */
;;;423      group = igmp_lookfor_group(inp, dest); /* use the destination IP address of incoming packet */
;;;424      
;;;425      /* If group can be found or create... */
;;;426      if (!group) {
;;;427        pbuf_free(p);
;;;428        IGMP_STATS_INC(igmp.drop);
;;;429        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP frame not for us\n"));
;;;430        return;
;;;431      }
;;;432    
;;;433      /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
;;;434      switch (igmp->igmp_msgtype) {
;;;435       case IGMP_MEMB_QUERY: {
;;;436         /* IGMP_MEMB_QUERY to the "all systems" address ? */
;;;437         if ((ip_addr_cmp(dest, &allsystems)) && ip_addr_isany(&igmp->igmp_group_address)) {
;;;438           /* THIS IS THE GENERAL QUERY */
;;;439           LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: General IGMP_MEMB_QUERY on \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
;;;440    
;;;441           if (igmp->igmp_maxresp == 0) {
;;;442             IGMP_STATS_INC(igmp.rx_v1);
;;;443             LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\n"));
;;;444             igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
;;;445           } else {
;;;446             IGMP_STATS_INC(igmp.rx_general);
;;;447           }
;;;448    
;;;449           groupref = igmp_group_list;
;;;450           while (groupref) {
;;;451             /* Do not send messages on the all systems group address! */
;;;452             if ((groupref->netif == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {
;;;453               igmp_delaying_member(groupref, igmp->igmp_maxresp);
;;;454             }
;;;455             groupref = groupref->next;
;;;456           }
;;;457         } else {
;;;458           /* IGMP_MEMB_QUERY to a specific group ? */
;;;459           if (!ip_addr_isany(&igmp->igmp_group_address)) {
;;;460             LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_MEMB_QUERY to a specific group "));
;;;461             ip_addr_debug_print(IGMP_DEBUG, &igmp->igmp_group_address);
;;;462             if (ip_addr_cmp(dest, &allsystems)) {
;;;463               ip_addr_t groupaddr;
;;;464               LWIP_DEBUGF(IGMP_DEBUG, (" using \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
;;;465               /* we first need to re-look for the group since we used dest last time */
;;;466               ip_addr_copy(groupaddr, igmp->igmp_group_address);
;;;467               group = igmp_lookfor_group(inp, &groupaddr);
;;;468             } else {
;;;469               LWIP_DEBUGF(IGMP_DEBUG, (" with the group address as destination [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
;;;470             }
;;;471    
;;;472             if (group != NULL) {
;;;473               IGMP_STATS_INC(igmp.rx_group);
;;;474               igmp_delaying_member(group, igmp->igmp_maxresp);
;;;475             } else {
;;;476               IGMP_STATS_INC(igmp.drop);
;;;477             }
;;;478           } else {
;;;479             IGMP_STATS_INC(igmp.proterr);
;;;480           }
;;;481         }
;;;482         break;
;;;483       }
;;;484       case IGMP_V2_MEMB_REPORT: {
;;;485         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_V2_MEMB_REPORT\n"));
;;;486         IGMP_STATS_INC(igmp.rx_report);
;;;487         if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
;;;488           /* This is on a specific group we have already looked up */
;;;489           group->timer = 0; /* stopped */
;;;490           group->group_state = IGMP_GROUP_IDLE_MEMBER;
;;;491           group->last_reporter_flag = 0;
;;;492         }
;;;493         break;
;;;494       }
;;;495       default: {
;;;496         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: unexpected msg %d in state %d on group %p on if %p\n",
;;;497           igmp->igmp_msgtype, group->group_state, &group, group->netif));
;;;498         IGMP_STATS_INC(igmp.proterr);
;;;499         break;
;;;500       }
;;;501      }
;;;502    
;;;503      pbuf_free(p);
;;;504      return;
;;;505    }
004f54  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.20312|
004f58  bf00              NOP                            ;407
004f5a  bf00              NOP                            ;407
004f5c  bf00              NOP                            ;408
004f5e  bf00              NOP                            ;408
004f60  bf00              NOP                            ;409
004f62  bf00              NOP                            ;409
004f64  bf00              NOP                            ;410
004f66  bf00              NOP                            ;410
004f68  bf00              NOP                            ;411
004f6a  bf00              NOP                            ;411
004f6c  687c              LDR      r4,[r7,#4]            ;414
004f6e  8979              LDRH     r1,[r7,#0xa]          ;415
004f70  4620              MOV      r0,r4                 ;415
004f72  f7fffffe          BL       inet_chksum
004f76  b168              CBZ      r0,|L1.20372|
004f78  4638              MOV      r0,r7                 ;416
004f7a  f7fffffe          BL       pbuf_free
004f7e  4822              LDR      r0,|L1.20488|
004f80  f8b00066          LDRH     r0,[r0,#0x66]         ;417
004f84  1c40              ADDS     r0,r0,#1              ;417
004f86  b281              UXTH     r1,r0                 ;417
004f88  481f              LDR      r0,|L1.20488|
004f8a  f8a01066          STRH     r1,[r0,#0x66]         ;417
004f8e  bf00              NOP                            ;418
004f90  bf00              NOP                            ;418
004f92  e7df              B        |L1.20308|
                  |L1.20372|
004f94  4641              MOV      r1,r8                 ;423
004f96  4648              MOV      r0,r9                 ;423
004f98  f7fffffe          BL       igmp_lookfor_group
004f9c  4605              MOV      r5,r0                 ;423
004f9e  b96d              CBNZ     r5,|L1.20412|
004fa0  4638              MOV      r0,r7                 ;427
004fa2  f7fffffe          BL       pbuf_free
004fa6  4818              LDR      r0,|L1.20488|
004fa8  f8b00064          LDRH     r0,[r0,#0x64]         ;428
004fac  1c40              ADDS     r0,r0,#1              ;428
004fae  b281              UXTH     r1,r0                 ;428
004fb0  4815              LDR      r0,|L1.20488|
004fb2  f8a01064          STRH     r1,[r0,#0x64]         ;428
004fb6  bf00              NOP                            ;429
004fb8  bf00              NOP                            ;429
004fba  e7cb              B        |L1.20308|
                  |L1.20412|
004fbc  7820              LDRB     r0,[r4,#0]            ;434
004fbe  2811              CMP      r0,#0x11              ;434
004fc0  d002              BEQ      |L1.20424|
004fc2  2816              CMP      r0,#0x16              ;434
004fc4  d171              BNE      |L1.20650|
004fc6  e07b              B        |L1.20672|
                  |L1.20424|
004fc8  4910              LDR      r1,|L1.20492|
004fca  f8d80000          LDR      r0,[r8,#0]            ;437
004fce  6809              LDR      r1,[r1,#0]            ;437  ; allsystems
004fd0  4288              CMP      r0,r1                 ;437
004fd2  d139              BNE      |L1.20552|
004fd4  1d20              ADDS     r0,r4,#4              ;437
004fd6  d001              BEQ      |L1.20444|
004fd8  6860              LDR      r0,[r4,#4]            ;437
004fda  bba0              CBNZ     r0,|L1.20550|
                  |L1.20444|
004fdc  bf00              NOP                            ;439
004fde  bf00              NOP                            ;439
004fe0  7860              LDRB     r0,[r4,#1]            ;441
004fe2  b9a8              CBNZ     r0,|L1.20496|
004fe4  4808              LDR      r0,|L1.20488|
004fe6  f8b0006e          LDRH     r0,[r0,#0x6e]         ;442
004fea  1c40              ADDS     r0,r0,#1              ;442
004fec  b281              UXTH     r1,r0                 ;442
004fee  4806              LDR      r0,|L1.20488|
004ff0  f8a0106e          STRH     r1,[r0,#0x6e]         ;442
004ff4  bf00              NOP                            ;443
004ff6  bf00              NOP                            ;443
004ff8  200a              MOVS     r0,#0xa               ;444
004ffa  7060              STRB     r0,[r4,#1]            ;444
004ffc  e010              B        |L1.20512|
004ffe  0000              DCW      0x0000
                  |L1.20480|
                          DCD      err_strerr
                  |L1.20484|
                          DCD      next_timeout
                  |L1.20488|
                          DCD      lwip_stats
                  |L1.20492|
                          DCD      allsystems
                  |L1.20496|
005010  48fe              LDR      r0,|L1.21516|
005012  f8b00072          LDRH     r0,[r0,#0x72]         ;446
005016  1c40              ADDS     r0,r0,#1              ;446
005018  b281              UXTH     r1,r0                 ;446
00501a  48fc              LDR      r0,|L1.21516|
00501c  f8a01072          STRH     r1,[r0,#0x72]         ;446
                  |L1.20512|
005020  48fb              LDR      r0,|L1.21520|
005022  6806              LDR      r6,[r0,#0]            ;449  ; igmp_group_list
005024  e00c              B        |L1.20544|
                  |L1.20518|
005026  6870              LDR      r0,[r6,#4]            ;452
005028  4548              CMP      r0,r9                 ;452
00502a  d108              BNE      |L1.20542|
00502c  49f9              LDR      r1,|L1.21524|
00502e  68b0              LDR      r0,[r6,#8]            ;452
005030  6809              LDR      r1,[r1,#0]            ;452  ; allsystems
005032  4288              CMP      r0,r1                 ;452
005034  d003              BEQ      |L1.20542|
005036  7861              LDRB     r1,[r4,#1]            ;453
005038  4630              MOV      r0,r6                 ;453
00503a  f7fffffe          BL       igmp_delaying_member
                  |L1.20542|
00503e  6836              LDR      r6,[r6,#0]            ;455
                  |L1.20544|
005040  2e00              CMP      r6,#0                 ;450
005042  d1f0              BNE      |L1.20518|
005044  e03b              B        |L1.20670|
                  |L1.20550|
005046  e7ff              B        |L1.20552|
                  |L1.20552|
005048  1d20              ADDS     r0,r4,#4              ;459
00504a  d030              BEQ      |L1.20654|
00504c  6860              LDR      r0,[r4,#4]            ;459
00504e  b368              CBZ      r0,|L1.20652|
005050  bf00              NOP                            ;460
005052  bf00              NOP                            ;460
005054  bf00              NOP                            ;461
005056  bf00              NOP                            ;461
005058  49ee              LDR      r1,|L1.21524|
00505a  f8d80000          LDR      r0,[r8,#0]            ;462
00505e  6809              LDR      r1,[r1,#0]            ;462  ; allsystems
005060  4288              CMP      r0,r1                 ;462
005062  d109              BNE      |L1.20600|
005064  bf00              NOP                            ;464
005066  bf00              NOP                            ;464
005068  6860              LDR      r0,[r4,#4]            ;466
00506a  9000              STR      r0,[sp,#0]            ;466
00506c  4669              MOV      r1,sp                 ;467
00506e  4648              MOV      r0,r9                 ;467
005070  f7fffffe          BL       igmp_lookfor_group
005074  4605              MOV      r5,r0                 ;467
005076  e001              B        |L1.20604|
                  |L1.20600|
005078  bf00              NOP                            ;469
00507a  bf00              NOP                            ;469
                  |L1.20604|
00507c  b165              CBZ      r5,|L1.20632|
00507e  48e3              LDR      r0,|L1.21516|
005080  f8b00070          LDRH     r0,[r0,#0x70]         ;473
005084  1c40              ADDS     r0,r0,#1              ;473
005086  b281              UXTH     r1,r0                 ;473
005088  48e0              LDR      r0,|L1.21516|
00508a  f8a01070          STRH     r1,[r0,#0x70]         ;473
00508e  7861              LDRB     r1,[r4,#1]            ;474
005090  4628              MOV      r0,r5                 ;474
005092  f7fffffe          BL       igmp_delaying_member
005096  e012              B        |L1.20670|
                  |L1.20632|
005098  48dc              LDR      r0,|L1.21516|
00509a  f8b00064          LDRH     r0,[r0,#0x64]         ;476
00509e  1c40              ADDS     r0,r0,#1              ;476
0050a0  b281              UXTH     r1,r0                 ;476
0050a2  48da              LDR      r0,|L1.21516|
0050a4  f8a01064          STRH     r1,[r0,#0x64]         ;476
0050a8  e009              B        |L1.20670|
                  |L1.20650|
0050aa  e01d              B        |L1.20712|
                  |L1.20652|
0050ac  e7ff              B        |L1.20654|
                  |L1.20654|
0050ae  48d7              LDR      r0,|L1.21516|
0050b0  f8b0006c          LDRH     r0,[r0,#0x6c]         ;479
0050b4  1c40              ADDS     r0,r0,#1              ;479
0050b6  b281              UXTH     r1,r0                 ;479
0050b8  48d4              LDR      r0,|L1.21516|
0050ba  f8a0106c          STRH     r1,[r0,#0x6c]         ;479
                  |L1.20670|
0050be  e01e              B        |L1.20734|
                  |L1.20672|
0050c0  bf00              NOP                            ;485
0050c2  bf00              NOP                            ;485
0050c4  48d1              LDR      r0,|L1.21516|
0050c6  f8b00074          LDRH     r0,[r0,#0x74]         ;486
0050ca  1c40              ADDS     r0,r0,#1              ;486
0050cc  b281              UXTH     r1,r0                 ;486
0050ce  48cf              LDR      r0,|L1.21516|
0050d0  f8a01074          STRH     r1,[r0,#0x74]         ;486
0050d4  7b68              LDRB     r0,[r5,#0xd]          ;487
0050d6  2801              CMP      r0,#1                 ;487
0050d8  d105              BNE      |L1.20710|
0050da  2000              MOVS     r0,#0                 ;489
0050dc  81e8              STRH     r0,[r5,#0xe]          ;489
0050de  2002              MOVS     r0,#2                 ;490
0050e0  7368              STRB     r0,[r5,#0xd]          ;490
0050e2  2000              MOVS     r0,#0                 ;491
0050e4  7328              STRB     r0,[r5,#0xc]          ;491
                  |L1.20710|
0050e6  e00a              B        |L1.20734|
                  |L1.20712|
0050e8  bf00              NOP                            ;496
0050ea  bf00              NOP                            ;496
0050ec  48c7              LDR      r0,|L1.21516|
0050ee  f8b0006c          LDRH     r0,[r0,#0x6c]         ;498
0050f2  1c40              ADDS     r0,r0,#1              ;498
0050f4  b281              UXTH     r1,r0                 ;498
0050f6  48c5              LDR      r0,|L1.21516|
0050f8  f8a0106c          STRH     r1,[r0,#0x6c]         ;498
0050fc  bf00              NOP                            ;499
                  |L1.20734|
0050fe  bf00              NOP                            ;482
005100  4638              MOV      r0,r7                 ;503
005102  f7fffffe          BL       pbuf_free
005106  bf00              NOP                            ;504
005108  e724              B        |L1.20308|
;;;506    
                          ENDP

                  inet_chksum_pbuf PROC
;;;408    u16_t
;;;409    inet_chksum_pbuf(struct pbuf *p)
00510a  e92d41f0          PUSH     {r4-r8,lr}
;;;410    {
00510e  4606              MOV      r6,r0
;;;411      u32_t acc;
;;;412      struct pbuf *q;
;;;413      u8_t swapped;
;;;414    
;;;415      acc = 0;
005110  2400              MOVS     r4,#0
;;;416      swapped = 0;
005112  2700              MOVS     r7,#0
;;;417      for(q = p; q != NULL; q = q->next) {
005114  4635              MOV      r5,r6
005116  e017              B        |L1.20808|
                  |L1.20760|
;;;418        acc += LWIP_CHKSUM(q->payload, q->len);
005118  8969              LDRH     r1,[r5,#0xa]
00511a  6868              LDR      r0,[r5,#4]
00511c  f7fffffe          BL       lwip_standard_chksum
005120  4404              ADD      r4,r4,r0
;;;419        acc = FOLD_U32T(acc);
005122  b2a0              UXTH     r0,r4
005124  eb004414          ADD      r4,r0,r4,LSR #16
;;;420        if (q->len % 2 != 0) {
005128  8968              LDRH     r0,[r5,#0xa]
00512a  eb0071d0          ADD      r1,r0,r0,LSR #31
00512e  1049              ASRS     r1,r1,#1
005130  ebb00141          SUBS     r1,r0,r1,LSL #1
005134  d007              BEQ      |L1.20806|
;;;421          swapped = 1 - swapped;
005136  f1c70001          RSB      r0,r7,#1
00513a  b2c7              UXTB     r7,r0
;;;422          acc = SWAP_BYTES_IN_WORD(acc);
00513c  b2e0              UXTB     r0,r4
00513e  f3c42107          UBFX     r1,r4,#8,#8
005142  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.20806|
005146  682d              LDR      r5,[r5,#0]            ;417
                  |L1.20808|
005148  2d00              CMP      r5,#0                 ;417
00514a  d1e5              BNE      |L1.20760|
;;;423        }
;;;424      }
;;;425    
;;;426      if (swapped) {
00514c  b127              CBZ      r7,|L1.20824|
;;;427        acc = SWAP_BYTES_IN_WORD(acc);
00514e  b2e0              UXTB     r0,r4
005150  f3c42107          UBFX     r1,r4,#8,#8
005154  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.20824|
;;;428      }
;;;429      return (u16_t)~(acc & 0xffffUL);
005158  43e0              MVNS     r0,r4
00515a  b280              UXTH     r0,r0
;;;430    }
00515c  e8bd81f0          POP      {r4-r8,pc}
;;;431    
                          ENDP

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
005160  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
005164  4604              MOV      r4,r0
005166  4689              MOV      r9,r1
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
005168  48a8              LDR      r0,|L1.21516|
00516a  f8b0004a          LDRH     r0,[r0,#0x4a]
00516e  1c40              ADDS     r0,r0,#1
005170  b281              UXTH     r1,r0
005172  48a6              LDR      r0,|L1.21516|
005174  f8a0104a          STRH     r1,[r0,#0x4a]
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
005178  6865              LDR      r5,[r4,#4]
;;;92       hlen = IPH_HL(iphdr) * 4;
00517a  7828              LDRB     r0,[r5,#0]
00517c  0700              LSLS     r0,r0,#28
00517e  ea4f6890          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
005182  f1c80100          RSB      r1,r8,#0
005186  4620              MOV      r0,r4
005188  f7fffffe          BL       pbuf_header
00518c  b910              CBNZ     r0,|L1.20884|
00518e  8920              LDRH     r0,[r4,#8]
005190  2804              CMP      r0,#4
005192  d202              BCS      |L1.20890|
                  |L1.20884|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
005194  bf00              NOP      
005196  bf00              NOP      
;;;95         goto lenerr;
005198  e0c5              B        |L1.21286|
                  |L1.20890|
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
00519a  6860              LDR      r0,[r4,#4]
00519c  f890a000          LDRB     r10,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
0051a0  6860              LDR      r0,[r4,#4]
0051a2  f890b001          LDRB     r11,[r0,#1]
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
0051a6  f1ba0f00          CMP      r10,#0
0051aa  d003              BEQ      |L1.20916|
0051ac  f1ba0f08          CMP      r10,#8
0051b0  d174              BNE      |L1.21148|
0051b2  e000              B        |L1.20918|
                  |L1.20916|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
0051b4  e0b2              B        |L1.21276|
                  |L1.20918|
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
0051b6  2601              MOVS     r6,#1
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
0051b8  4897              LDR      r0,|L1.21528|
0051ba  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
0051bc  f00000f0          AND      r0,r0,#0xf0
0051c0  28e0              CMP      r0,#0xe0
0051c2  d100              BNE      |L1.20934|
;;;114            accepted = 0;
0051c4  2600              MOVS     r6,#0
                  |L1.20934|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
0051c6  4994              LDR      r1,|L1.21528|
0051c8  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
0051ca  4649              MOV      r1,r9
0051cc  f7fffffe          BL       ip4_addr_isbroadcast
0051d0  b100              CBZ      r0,|L1.20948|
;;;120            accepted = 0;
0051d2  2600              MOVS     r6,#0
                  |L1.20948|
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
0051d4  b976              CBNZ     r6,|L1.20980|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
0051d6  bf00              NOP      
0051d8  bf00              NOP      
;;;126            ICMP_STATS_INC(icmp.err);
0051da  488c              LDR      r0,|L1.21516|
0051dc  f8b0005c          LDRH     r0,[r0,#0x5c]
0051e0  1c40              ADDS     r0,r0,#1
0051e2  b281              UXTH     r1,r0
0051e4  4889              LDR      r0,|L1.21516|
0051e6  f8a0105c          STRH     r1,[r0,#0x5c]
;;;127            pbuf_free(p);
0051ea  4620              MOV      r0,r4
0051ec  f7fffffe          BL       pbuf_free
                  |L1.20976|
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
0051f0  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.20980|
0051f4  bf00              NOP                            ;132
0051f6  bf00              NOP                            ;132
0051f8  8920              LDRH     r0,[r4,#8]            ;133
0051fa  2808              CMP      r0,#8                 ;133
0051fc  d202              BCS      |L1.20996|
0051fe  bf00              NOP                            ;134
005200  bf00              NOP                            ;134
005202  e090              B        |L1.21286|
                  |L1.20996|
005204  4620              MOV      r0,r4                 ;137
005206  f7fffffe          BL       inet_chksum_pbuf
00520a  b168              CBZ      r0,|L1.21032|
00520c  bf00              NOP                            ;138
00520e  bf00              NOP                            ;138
005210  4620              MOV      r0,r4                 ;139
005212  f7fffffe          BL       pbuf_free
005216  487d              LDR      r0,|L1.21516|
005218  f8b00050          LDRH     r0,[r0,#0x50]         ;140
00521c  1c40              ADDS     r0,r0,#1              ;140
00521e  b281              UXTH     r1,r0                 ;140
005220  487a              LDR      r0,|L1.21516|
005222  f8a01050          STRH     r1,[r0,#0x50]         ;140
005226  e7e3              B        |L1.20976|
                  |L1.21032|
005228  2124              MOVS     r1,#0x24              ;145
00522a  4620              MOV      r0,r4                 ;145
00522c  f7fffffe          BL       pbuf_header
005230  b358              CBZ      r0,|L1.21130|
005232  4641              MOV      r1,r8                 ;151
005234  4620              MOV      r0,r4                 ;151
005236  f7fffffe          BL       pbuf_header
00523a  b110              CBZ      r0,|L1.21058|
00523c  bf00              NOP                            ;152
00523e  bf00              NOP                            ;152
005240  e07d              B        |L1.21310|
                  |L1.21058|
005242  8921              LDRH     r1,[r4,#8]            ;156
005244  2200              MOVS     r2,#0                 ;156
005246  2002              MOVS     r0,#2                 ;156
005248  f7fffffe          BL       pbuf_alloc
00524c  4606              MOV      r6,r0                 ;156
00524e  b916              CBNZ     r6,|L1.21078|
005250  bf00              NOP                            ;158
005252  bf00              NOP                            ;158
005254  e073              B        |L1.21310|
                  |L1.21078|
005256  bf00              NOP                            ;161
005258  bf00              NOP                            ;161
00525a  4621              MOV      r1,r4                 ;164
00525c  4630              MOV      r0,r6                 ;164
00525e  f7fffffe          BL       pbuf_copy
005262  b110              CBZ      r0,|L1.21098|
005264  bf00              NOP                            ;165
005266  bf00              NOP                            ;165
005268  e069              B        |L1.21310|
                  |L1.21098|
00526a  6875              LDR      r5,[r6,#4]            ;168
00526c  f1c80000          RSB      r0,r8,#0              ;170
005270  b201              SXTH     r1,r0                 ;170
005272  4630              MOV      r0,r6                 ;170
005274  f7fffffe          BL       pbuf_header
005278  b110              CBZ      r0,|L1.21120|
00527a  bf00              NOP                            ;171
00527c  bf00              NOP                            ;171
00527e  e05e              B        |L1.21310|
                  |L1.21120|
005280  4620              MOV      r0,r4                 ;175
005282  f7fffffe          BL       pbuf_free
005286  4634              MOV      r4,r6                 ;177
005288  e009              B        |L1.21150|
                  |L1.21130|
00528a  f06f0123          MVN      r1,#0x23              ;180
00528e  4620              MOV      r0,r4                 ;180
005290  f7fffffe          BL       pbuf_header
005294  b118              CBZ      r0,|L1.21150|
005296  bf00              NOP                            ;181
005298  bf00              NOP                            ;181
00529a  e050              B        |L1.21310|
                  |L1.21148|
00529c  e02c              B        |L1.21240|
                  |L1.21150|
00529e  6867              LDR      r7,[r4,#4]            ;189
0052a0  485d              LDR      r0,|L1.21528|
0052a2  6800              LDR      r0,[r0,#0]            ;190  ; current_iphdr_dest
0052a4  60e8              STR      r0,[r5,#0xc]          ;190
0052a6  485d              LDR      r0,|L1.21532|
0052a8  6800              LDR      r0,[r0,#0]            ;191  ; current_iphdr_src
0052aa  6128              STR      r0,[r5,#0x10]         ;191
0052ac  2000              MOVS     r0,#0                 ;192
0052ae  7038              STRB     r0,[r7,#0]            ;192
0052b0  8078              STRH     r0,[r7,#2]            ;201
0052b2  20ff              MOVS     r0,#0xff              ;205
0052b4  7228              STRB     r0,[r5,#8]            ;205
0052b6  2000              MOVS     r0,#0                 ;206
0052b8  8168              STRH     r0,[r5,#0xa]          ;206
0052ba  4854              LDR      r0,|L1.21516|
0052bc  f8b00048          LDRH     r0,[r0,#0x48]         ;211  ; lwip_stats
0052c0  1c40              ADDS     r0,r0,#1              ;211
0052c2  4952              LDR      r1,|L1.21516|
0052c4  f8a10048          STRH     r0,[r1,#0x48]         ;211
0052c8  4641              MOV      r1,r8                 ;217
0052ca  4620              MOV      r0,r4                 ;217
0052cc  f7fffffe          BL       pbuf_header
0052d0  b108              CBZ      r0,|L1.21206|
0052d2  bf00              NOP                            ;218
0052d4  e00f              B        |L1.21238|
                  |L1.21206|
0052d6  2001              MOVS     r0,#1                 ;222
0052d8  2100              MOVS     r1,#0                 ;222
0052da  23ff              MOVS     r3,#0xff              ;222
0052dc  460a              MOV      r2,r1                 ;222
0052de  e9cd0901          STRD     r0,r9,[sp,#4]         ;222
0052e2  9100              STR      r1,[sp,#0]            ;222
0052e4  494c              LDR      r1,|L1.21528|
0052e6  4620              MOV      r0,r4                 ;222
0052e8  f7fffffe          BL       ip_output_if
0052ec  4606              MOV      r6,r0                 ;222
0052ee  b10e              CBZ      r6,|L1.21236|
0052f0  bf00              NOP                            ;225
0052f2  bf00              NOP                            ;225
                  |L1.21236|
0052f4  bf00              NOP                            ;227
                  |L1.21238|
0052f6  e011              B        |L1.21276|
                  |L1.21240|
0052f8  bf00              NOP                            ;230
0052fa  bf00              NOP                            ;230
0052fc  4843              LDR      r0,|L1.21516|
0052fe  f8b00058          LDRH     r0,[r0,#0x58]         ;232
005302  1c40              ADDS     r0,r0,#1              ;232
005304  b281              UXTH     r1,r0                 ;232
005306  4841              LDR      r0,|L1.21516|
005308  f8a01058          STRH     r1,[r0,#0x58]         ;232
00530c  f8b0004e          LDRH     r0,[r0,#0x4e]         ;233
005310  1c40              ADDS     r0,r0,#1              ;233
005312  b281              UXTH     r1,r0                 ;233
005314  483d              LDR      r0,|L1.21516|
005316  f8a0104e          STRH     r1,[r0,#0x4e]         ;233
00531a  bf00              NOP                            ;102
                  |L1.21276|
00531c  bf00              NOP                            ;106
00531e  4620              MOV      r0,r4                 ;235
005320  f7fffffe          BL       pbuf_free
005324  e764              B        |L1.20976|
                  |L1.21286|
005326  4620              MOV      r0,r4                 ;238
005328  f7fffffe          BL       pbuf_free
00532c  4837              LDR      r0,|L1.21516|
00532e  f8b00052          LDRH     r0,[r0,#0x52]         ;239
005332  1c40              ADDS     r0,r0,#1              ;239
005334  b281              UXTH     r1,r0                 ;239
005336  4835              LDR      r0,|L1.21516|
005338  f8a01052          STRH     r1,[r0,#0x52]         ;239
00533c  e758              B        |L1.20976|
                  |L1.21310|
00533e  4620              MOV      r0,r4                 ;244
005340  f7fffffe          BL       pbuf_free
005344  4831              LDR      r0,|L1.21516|
005346  f8b0005c          LDRH     r0,[r0,#0x5c]         ;245
00534a  1c40              ADDS     r0,r0,#1              ;245
00534c  b281              UXTH     r1,r0                 ;245
00534e  482f              LDR      r0,|L1.21516|
005350  f8a0105c          STRH     r1,[r0,#0x5c]         ;245
005354  bf00              NOP                            ;247
005356  e74b              B        |L1.20976|
;;;250    
                          ENDP

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
005358  e92d5ff0          PUSH     {r4-r12,lr}
;;;370    {
00535c  4682              MOV      r10,r0
00535e  460d              MOV      r5,r1
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
005360  1ce8              ADDS     r0,r5,#3
005362  f0200503          BIC      r5,r0,#3
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
005366  2d0c              CMP      r5,#0xc
005368  d200              BCS      |L1.21356|
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
00536a  250c              MOVS     r5,#0xc
                  |L1.21356|
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
00536c  f5b53f80          CMP      r5,#0x10000
005370  d902              BLS      |L1.21368|
;;;387        return NULL;
005372  2000              MOVS     r0,#0
                  |L1.21364|
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;409      if (newsize > size) {
;;;410        /* not supported */
;;;411        return NULL;
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
005374  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.21368|
005378  bf00              NOP                            ;390
00537a  bf00              NOP                            ;390
00537c  4828              LDR      r0,|L1.21536|
00537e  6800              LDR      r0,[r0,#0]            ;393  ; ram
005380  4582              CMP      r10,r0                ;393
005382  d303              BCC      |L1.21388|
005384  4827              LDR      r0,|L1.21540|
005386  6800              LDR      r0,[r0,#0]            ;393  ; ram_end
005388  4582              CMP      r10,r0                ;393
00538a  d311              BCC      |L1.21424|
                  |L1.21388|
00538c  bf00              NOP                            ;395
00538e  bf00              NOP                            ;395
005390  f7fffffe          BL       sys_arch_protect
005394  4683              MOV      r11,r0                ;397
005396  481d              LDR      r0,|L1.21516|
005398  f8b000be          LDRH     r0,[r0,#0xbe]         ;398
00539c  1c40              ADDS     r0,r0,#1              ;398
00539e  b281              UXTH     r1,r0                 ;398
0053a0  481a              LDR      r0,|L1.21516|
0053a2  f8a010be          STRH     r1,[r0,#0xbe]         ;398
0053a6  4658              MOV      r0,r11                ;399
0053a8  f7fffffe          BL       sys_arch_unprotect
0053ac  4650              MOV      r0,r10                ;400
0053ae  e7e1              B        |L1.21364|
                  |L1.21424|
0053b0  f1aa070c          SUB      r7,r10,#0xc           ;403
0053b4  481a              LDR      r0,|L1.21536|
0053b6  6800              LDR      r0,[r0,#0]            ;405  ; ram
0053b8  eba70900          SUB      r9,r7,r0              ;405
0053bc  6838              LDR      r0,[r7,#0]            ;407
0053be  eba00009          SUB      r0,r0,r9              ;407
0053c2  f1a0080c          SUB      r8,r0,#0xc            ;407
0053c6  bf00              NOP                            ;408
0053c8  bf00              NOP                            ;408
0053ca  4545              CMP      r5,r8                 ;409
0053cc  d901              BLS      |L1.21458|
0053ce  2000              MOVS     r0,#0                 ;411
0053d0  e7d0              B        |L1.21364|
                  |L1.21458|
0053d2  4545              CMP      r5,r8                 ;413
0053d4  d101              BNE      |L1.21466|
0053d6  4650              MOV      r0,r10                ;415
0053d8  e7cc              B        |L1.21364|
                  |L1.21466|
0053da  2100              MOVS     r1,#0                 ;419
0053dc  4812              LDR      r0,|L1.21544|
0053de  f7fffffe          BL       sys_arch_sem_wait
0053e2  490f              LDR      r1,|L1.21536|
0053e4  6838              LDR      r0,[r7,#0]            ;421
0053e6  6809              LDR      r1,[r1,#0]            ;421  ; ram
0053e8  1844              ADDS     r4,r0,r1              ;421
0053ea  7a20              LDRB     r0,[r4,#8]            ;422
0053ec  bbd8              CBNZ     r0,|L1.21606|
0053ee  6820              LDR      r0,[r4,#0]            ;426
0053f0  f109010c          ADD      r1,r9,#0xc            ;428
0053f4  194e              ADDS     r6,r1,r5              ;428
0053f6  490d              LDR      r1,|L1.21548|
0053f8  6809              LDR      r1,[r1,#0]            ;429  ; lfree
0053fa  42a1              CMP      r1,r4                 ;429
0053fc  d104              BNE      |L1.21512|
0053fe  4908              LDR      r1,|L1.21536|
005400  6809              LDR      r1,[r1,#0]            ;430  ; ram
005402  4431              ADD      r1,r1,r6              ;430
005404  4a09              LDR      r2,|L1.21548|
005406  6011              STR      r1,[r2,#0]            ;430  ; lfree
                  |L1.21512|
005408  4905              LDR      r1,|L1.21536|
00540a  e011              B        |L1.21552|
                  |L1.21516|
                          DCD      lwip_stats
                  |L1.21520|
                          DCD      igmp_group_list
                  |L1.21524|
                          DCD      allsystems
                  |L1.21528|
                          DCD      current_iphdr_dest
                  |L1.21532|
                          DCD      current_iphdr_src
                  |L1.21536|
                          DCD      ||ram||
                  |L1.21540|
                          DCD      ram_end
                  |L1.21544|
                          DCD      mem_mutex
                  |L1.21548|
                          DCD      lfree
                  |L1.21552|
005430  6809              LDR      r1,[r1,#0]            ;432  ; ram
005432  198c              ADDS     r4,r1,r6              ;432
005434  2100              MOVS     r1,#0                 ;433
005436  7221              STRB     r1,[r4,#8]            ;433
005438  6020              STR      r0,[r4,#0]            ;435
00543a  f8c49004          STR      r9,[r4,#4]            ;437
00543e  603e              STR      r6,[r7,#0]            ;439
005440  6821              LDR      r1,[r4,#0]            ;443
005442  f5b13f80          CMP      r1,#0x10000           ;443
005446  d004              BEQ      |L1.21586|
005448  4afe              LDR      r2,|L1.22596|
00544a  6821              LDR      r1,[r4,#0]            ;444
00544c  6812              LDR      r2,[r2,#0]            ;444  ; ram
00544e  4411              ADD      r1,r1,r2              ;444
005450  604e              STR      r6,[r1,#4]            ;444
                  |L1.21586|
005452  49fd              LDR      r1,|L1.22600|
005454  f8d110b4          LDR      r1,[r1,#0xb4]         ;446
005458  eba80205          SUB      r2,r8,r5              ;446
00545c  1a8a              SUBS     r2,r1,r2              ;446
00545e  49fa              LDR      r1,|L1.22600|
005460  f8c120b4          STR      r2,[r1,#0xb4]         ;446
005464  e029              B        |L1.21690|
                  |L1.21606|
005466  e7ff              B        |L1.21608|
                  |L1.21608|
005468  f1050018          ADD      r0,r5,#0x18           ;448
00546c  4540              CMP      r0,r8                 ;448
00546e  d824              BHI      |L1.21690|
005470  f109000c          ADD      r0,r9,#0xc            ;456
005474  1946              ADDS     r6,r0,r5              ;456
005476  48f3              LDR      r0,|L1.22596|
005478  6800              LDR      r0,[r0,#0]            ;457  ; ram
00547a  1984              ADDS     r4,r0,r6              ;457
00547c  48f3              LDR      r0,|L1.22604|
00547e  6800              LDR      r0,[r0,#0]            ;458  ; lfree
005480  4284              CMP      r4,r0                 ;458
005482  d201              BCS      |L1.21640|
005484  48f1              LDR      r0,|L1.22604|
005486  6004              STR      r4,[r0,#0]            ;459  ; lfree
                  |L1.21640|
005488  2000              MOVS     r0,#0                 ;461
00548a  7220              STRB     r0,[r4,#8]            ;461
00548c  6838              LDR      r0,[r7,#0]            ;462
00548e  6020              STR      r0,[r4,#0]            ;462
005490  f8c49004          STR      r9,[r4,#4]            ;463
005494  603e              STR      r6,[r7,#0]            ;464
005496  6820              LDR      r0,[r4,#0]            ;465
005498  f5b03f80          CMP      r0,#0x10000           ;465
00549c  d004              BEQ      |L1.21672|
00549e  49e9              LDR      r1,|L1.22596|
0054a0  6820              LDR      r0,[r4,#0]            ;466
0054a2  6809              LDR      r1,[r1,#0]            ;466  ; ram
0054a4  4408              ADD      r0,r0,r1              ;466
0054a6  6046              STR      r6,[r0,#4]            ;466
                  |L1.21672|
0054a8  48e7              LDR      r0,|L1.22600|
0054aa  f8d000b4          LDR      r0,[r0,#0xb4]         ;468
0054ae  eba80105          SUB      r1,r8,r5              ;468
0054b2  1a41              SUBS     r1,r0,r1              ;468
0054b4  48e4              LDR      r0,|L1.22600|
0054b6  f8c010b4          STR      r1,[r0,#0xb4]         ;468
                  |L1.21690|
0054ba  48e5              LDR      r0,|L1.22608|
0054bc  f7fffffe          BL       sys_sem_signal
0054c0  4650              MOV      r0,r10                ;481
0054c2  e757              B        |L1.21364|
;;;483    
                          ENDP

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
0054c4  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
0054c8  4606              MOV      r6,r0
0054ca  460f              MOV      r7,r1
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
0054cc  bf00              NOP      
0054ce  bf00              NOP      
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
0054d0  bf00              NOP      
0054d2  bf00              NOP      
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
0054d4  8930              LDRH     r0,[r6,#8]
0054d6  42b8              CMP      r0,r7
0054d8  dc01              BGT      |L1.21726|
                  |L1.21722|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;461        q->tot_len += (u16_t)grow;
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
0054da  e8bd81f0          POP      {r4-r8,pc}
                  |L1.21726|
0054de  8930              LDRH     r0,[r6,#8]            ;450
0054e0  eba70800          SUB      r8,r7,r0              ;450
0054e4  463d              MOV      r5,r7                 ;453
0054e6  4634              MOV      r4,r6                 ;454
0054e8  e00a              B        |L1.21760|
                  |L1.21738|
0054ea  8960              LDRH     r0,[r4,#0xa]          ;458
0054ec  1a28              SUBS     r0,r5,r0              ;458
0054ee  b285              UXTH     r5,r0                 ;458
0054f0  bf00              NOP                            ;460
0054f2  bf00              NOP                            ;460
0054f4  8920              LDRH     r0,[r4,#8]            ;461
0054f6  4440              ADD      r0,r0,r8              ;461
0054f8  8120              STRH     r0,[r4,#8]            ;461
0054fa  6824              LDR      r4,[r4,#0]            ;463
0054fc  bf00              NOP                            ;464
0054fe  bf00              NOP                            ;464
                  |L1.21760|
005500  8960              LDRH     r0,[r4,#0xa]          ;456
005502  42a8              CMP      r0,r5                 ;456
005504  dbf1              BLT      |L1.21738|
005506  7b20              LDRB     r0,[r4,#0xc]          ;471
005508  b960              CBNZ     r0,|L1.21796|
00550a  8960              LDRH     r0,[r4,#0xa]          ;471
00550c  42a8              CMP      r0,r5                 ;471
00550e  d009              BEQ      |L1.21796|
005510  88a0              LDRH     r0,[r4,#4]            ;473
005512  1b00              SUBS     r0,r0,r4              ;473
005514  b280              UXTH     r0,r0                 ;473
005516  1941              ADDS     r1,r0,r5              ;473
005518  4620              MOV      r0,r4                 ;473
00551a  f7fffffe          BL       mem_trim
00551e  4604              MOV      r4,r0                 ;473
005520  bf00              NOP                            ;474
005522  bf00              NOP                            ;474
                  |L1.21796|
005524  8165              STRH     r5,[r4,#0xa]          ;477
005526  8960              LDRH     r0,[r4,#0xa]          ;478
005528  8120              STRH     r0,[r4,#8]            ;478
00552a  6820              LDR      r0,[r4,#0]            ;481
00552c  b110              CBZ      r0,|L1.21812|
00552e  6820              LDR      r0,[r4,#0]            ;483
005530  f7fffffe          BL       pbuf_free
                  |L1.21812|
005534  2000              MOVS     r0,#0                 ;486
005536  6020              STR      r0,[r4,#0]            ;486
005538  bf00              NOP      
00553a  e7ce              B        |L1.21722|
;;;489    
                          ENDP

                  tcp_seg_copy PROC
;;;1178   struct tcp_seg *
;;;1179   tcp_seg_copy(struct tcp_seg *seg)
00553c  b570              PUSH     {r4-r6,lr}
;;;1180   {
00553e  4605              MOV      r5,r0
;;;1181     struct tcp_seg *cseg;
;;;1182   
;;;1183     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
005540  2004              MOVS     r0,#4
005542  f7fffffe          BL       memp_malloc
005546  4604              MOV      r4,r0
;;;1184     if (cseg == NULL) {
005548  b90c              CBNZ     r4,|L1.21838|
;;;1185       return NULL;
00554a  2000              MOVS     r0,#0
                  |L1.21836|
;;;1186     }
;;;1187     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
;;;1188     pbuf_ref(cseg->p);
;;;1189     return cseg;
;;;1190   }
00554c  bd70              POP      {r4-r6,pc}
                  |L1.21838|
00554e  2214              MOVS     r2,#0x14              ;1187
005550  4629              MOV      r1,r5                 ;1187
005552  4620              MOV      r0,r4                 ;1187
005554  f7fffffe          BL       __aeabi_memcpy4
005558  6860              LDR      r0,[r4,#4]            ;1188
00555a  f7fffffe          BL       pbuf_ref
00555e  4620              MOV      r0,r4                 ;1189
005560  e7f4              B        |L1.21836|
;;;1191   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  tcp_oos_insert_segment PROC
;;;800    static void
;;;801    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
005562  b570              PUSH     {r4-r6,lr}
;;;802    {
005564  4605              MOV      r5,r0
005566  460c              MOV      r4,r1
;;;803      struct tcp_seg *old_seg;
;;;804    
;;;805      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
005568  6929              LDR      r1,[r5,#0x10]
00556a  8988              LDRH     r0,[r1,#0xc]
00556c  f7fffffe          BL       lwip_ntohs
005570  f0100f01          TST      r0,#1
005574  d004              BEQ      |L1.21888|
;;;806        /* received segment overlaps all following segments */
;;;807        tcp_segs_free(next);
005576  4620              MOV      r0,r4
005578  f7fffffe          BL       tcp_segs_free
;;;808        next = NULL;
00557c  2400              MOVS     r4,#0
00557e  e033              B        |L1.21992|
                  |L1.21888|
;;;809      }
;;;810      else {
;;;811        /* delete some following segments
;;;812           oos queue may have segments with FIN flag */
;;;813        while (next &&
005580  e013              B        |L1.21930|
                  |L1.21890|
;;;814               TCP_SEQ_GEQ((seqno + cseg->len),
;;;815                          (next->tcphdr->seqno + next->len))) {
;;;816          /* cseg with FIN already processed */
;;;817          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
005582  6921              LDR      r1,[r4,#0x10]
005584  8988              LDRH     r0,[r1,#0xc]
005586  f7fffffe          BL       lwip_ntohs
00558a  f0100f01          TST      r0,#1
00558e  d007              BEQ      |L1.21920|
;;;818            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
005590  2001              MOVS     r0,#1
005592  f7fffffe          BL       lwip_htons
005596  6929              LDR      r1,[r5,#0x10]
005598  8989              LDRH     r1,[r1,#0xc]
00559a  4308              ORRS     r0,r0,r1
00559c  6929              LDR      r1,[r5,#0x10]
00559e  8188              STRH     r0,[r1,#0xc]
                  |L1.21920|
;;;819          }
;;;820          old_seg = next;
0055a0  4626              MOV      r6,r4
;;;821          next = next->next;
0055a2  6824              LDR      r4,[r4,#0]
;;;822          tcp_seg_free(old_seg);
0055a4  4630              MOV      r0,r6
0055a6  f7fffffe          BL       tcp_seg_free
                  |L1.21930|
0055aa  b14c              CBZ      r4,|L1.21952|
0055ac  6920              LDR      r0,[r4,#0x10]         ;814
0055ae  6840              LDR      r0,[r0,#4]            ;814
0055b0  8921              LDRH     r1,[r4,#8]            ;814
0055b2  4408              ADD      r0,r0,r1              ;814
0055b4  8929              LDRH     r1,[r5,#8]            ;814
0055b6  4aa7              LDR      r2,|L1.22612|
0055b8  6812              LDR      r2,[r2,#0]            ;814  ; seqno
0055ba  4411              ADD      r1,r1,r2              ;814
0055bc  1a08              SUBS     r0,r1,r0              ;814
0055be  d5e0              BPL      |L1.21890|
                  |L1.21952|
;;;823        }
;;;824        if (next &&
0055c0  b194              CBZ      r4,|L1.21992|
;;;825            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
0055c2  8928              LDRH     r0,[r5,#8]
0055c4  49a3              LDR      r1,|L1.22612|
0055c6  6809              LDR      r1,[r1,#0]  ; seqno
0055c8  4408              ADD      r0,r0,r1
0055ca  6921              LDR      r1,[r4,#0x10]
0055cc  6849              LDR      r1,[r1,#4]
0055ce  1a40              SUBS     r0,r0,r1
0055d0  2800              CMP      r0,#0
0055d2  dd09              BLE      |L1.21992|
;;;826          /* We need to trim the incoming segment. */
;;;827          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
0055d4  6920              LDR      r0,[r4,#0x10]
0055d6  8880              LDRH     r0,[r0,#4]
0055d8  499e              LDR      r1,|L1.22612|
0055da  8809              LDRH     r1,[r1,#0]  ; seqno
0055dc  1a40              SUBS     r0,r0,r1
0055de  8128              STRH     r0,[r5,#8]
;;;828          pbuf_realloc(cseg->p, cseg->len);
0055e0  8929              LDRH     r1,[r5,#8]
0055e2  6868              LDR      r0,[r5,#4]
0055e4  f7fffffe          BL       pbuf_realloc
                  |L1.21992|
;;;829        }
;;;830      }
;;;831      cseg->next = next;
0055e8  602c              STR      r4,[r5,#0]
;;;832    }
0055ea  bd70              POP      {r4-r6,pc}
;;;833    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
0055ec  b5f0              PUSH     {r4-r7,lr}
;;;1276   {
0055ee  4604              MOV      r4,r0
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
0055f0  6f20              LDR      r0,[r4,#0x70]
0055f2  b900              CBNZ     r0,|L1.22006|
                  |L1.22004|
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
;;;1290     while (*cur_seg &&
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
;;;1293     }
;;;1294     seg->next = *cur_seg;
;;;1295     *cur_seg = seg;
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
0055f4  bdf0              POP      {r4-r7,pc}
                  |L1.22006|
0055f6  6f25              LDR      r5,[r4,#0x70]         ;1286
0055f8  6828              LDR      r0,[r5,#0]            ;1287
0055fa  6720              STR      r0,[r4,#0x70]         ;1287
0055fc  f104066c          ADD      r6,r4,#0x6c           ;1289
005600  e000              B        |L1.22020|
                  |L1.22018|
005602  6836              LDR      r6,[r6,#0]            ;1292
                  |L1.22020|
005604  6830              LDR      r0,[r6,#0]            ;1290
005606  b158              CBZ      r0,|L1.22048|
005608  6831              LDR      r1,[r6,#0]            ;1291
00560a  6909              LDR      r1,[r1,#0x10]         ;1291
00560c  6848              LDR      r0,[r1,#4]            ;1291
00560e  f7fffffe          BL       lwip_ntohl
005612  4607              MOV      r7,r0                 ;1291
005614  6929              LDR      r1,[r5,#0x10]         ;1291
005616  6848              LDR      r0,[r1,#4]            ;1291
005618  f7fffffe          BL       lwip_ntohl
00561c  1a38              SUBS     r0,r7,r0              ;1291
00561e  d4f0              BMI      |L1.22018|
                  |L1.22048|
005620  6830              LDR      r0,[r6,#0]            ;1294
005622  6028              STR      r0,[r5,#0]            ;1294
005624  6035              STR      r5,[r6,#0]            ;1295
005626  6828              LDR      r0,[r5,#0]            ;1297
005628  b910              CBNZ     r0,|L1.22064|
00562a  2000              MOVS     r0,#0                 ;1299
00562c  f8a4006a          STRH     r0,[r4,#0x6a]         ;1299
                  |L1.22064|
005630  f8940046          LDRB     r0,[r4,#0x46]         ;1303
005634  1c40              ADDS     r0,r0,#1              ;1303
005636  f8840046          STRB     r0,[r4,#0x46]         ;1303
00563a  2000              MOVS     r0,#0                 ;1306
00563c  63a0              STR      r0,[r4,#0x38]         ;1306
00563e  bf00              NOP      
005640  e7d8              B        |L1.22004|
;;;1313   
                          ENDP

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
005642  b510              PUSH     {r4,lr}
;;;1322   {
005644  4604              MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
005646  6f20              LDR      r0,[r4,#0x70]
005648  b3b0              CBZ      r0,|L1.22200|
00564a  7fa0              LDRB     r0,[r4,#0x1e]
00564c  f0100f04          TST      r0,#4
005650  d132              BNE      |L1.22200|
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
005652  bf00              NOP      
005654  bf00              NOP      
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
005656  4620              MOV      r0,r4
005658  f7fffffe          BL       tcp_rexmit
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
00565c  f8b4004c          LDRH     r0,[r4,#0x4c]
005660  f8b41060          LDRH     r1,[r4,#0x60]
005664  4288              CMP      r0,r1
005666  dd07              BLE      |L1.22136|
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
005668  f8b40060          LDRH     r0,[r4,#0x60]
00566c  eb0071d0          ADD      r1,r0,r0,LSR #31
005670  1049              ASRS     r1,r1,#1
005672  f8a4104e          STRH     r1,[r4,#0x4e]
005676  e006              B        |L1.22150|
                  |L1.22136|
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
005678  f8b4004c          LDRH     r0,[r4,#0x4c]
00567c  eb0071d0          ADD      r1,r0,r0,LSR #31
005680  1049              ASRS     r1,r1,#1
005682  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L1.22150|
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
005686  f8b4004e          LDRH     r0,[r4,#0x4e]
00568a  8ee1              LDRH     r1,[r4,#0x36]
00568c  0049              LSLS     r1,r1,#1
00568e  4288              CMP      r0,r1
005690  da06              BGE      |L1.22176|
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
005692  bf00              NOP      
005694  bf00              NOP      
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
005696  8ee0              LDRH     r0,[r4,#0x36]
005698  0440              LSLS     r0,r0,#17
00569a  0c00              LSRS     r0,r0,#16
00569c  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L1.22176|
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
0056a0  f8b4004e          LDRH     r0,[r4,#0x4e]
0056a4  8ee1              LDRH     r1,[r4,#0x36]
0056a6  2203              MOVS     r2,#3
0056a8  fb020001          MLA      r0,r2,r1,r0
0056ac  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1350       pcb->flags |= TF_INFR;
0056b0  7fa0              LDRB     r0,[r4,#0x1e]
0056b2  f0400004          ORR      r0,r0,#4
0056b6  77a0              STRB     r0,[r4,#0x1e]
                  |L1.22200|
;;;1351     } 
;;;1352   }
0056b8  bd10              POP      {r4,pc}
;;;1353   
                          ENDP

                  tcp_receive PROC
;;;847    static void
;;;848    tcp_receive(struct tcp_pcb *pcb)
0056ba  e92d4ffe          PUSH     {r1-r11,lr}
;;;849    {
0056be  4604              MOV      r4,r0
;;;850      struct tcp_seg *next;
;;;851    #if TCP_QUEUE_OOSEQ
;;;852      struct tcp_seg *prev, *cseg;
;;;853    #endif /* TCP_QUEUE_OOSEQ */
;;;854      struct pbuf *p;
;;;855      s32_t off;
;;;856      s16_t m;
;;;857      u32_t right_wnd_edge;
;;;858      u16_t new_tot_len;
;;;859      int found_dupack = 0;
0056c0  2000              MOVS     r0,#0
0056c2  9001              STR      r0,[sp,#4]
;;;860    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;861      u32_t ooseq_blen;
;;;862      u16_t ooseq_qlen;
;;;863    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;864    
;;;865      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
0056c4  bf00              NOP      
0056c6  bf00              NOP      
;;;866    
;;;867      if (flags & TCP_ACK) {
0056c8  4863              LDR      r0,|L1.22616|
0056ca  7800              LDRB     r0,[r0,#0]  ; flags
0056cc  f0100f10          TST      r0,#0x10
0056d0  d07e              BEQ      |L1.22480|
;;;868        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
0056d2  f8b40060          LDRH     r0,[r4,#0x60]
0056d6  6da1              LDR      r1,[r4,#0x58]
0056d8  eb000b01          ADD      r11,r0,r1
;;;869    
;;;870        /* Update window. */
;;;871        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
0056dc  495d              LDR      r1,|L1.22612|
0056de  6d60              LDR      r0,[r4,#0x54]
0056e0  6809              LDR      r1,[r1,#0]  ; seqno
0056e2  1a40              SUBS     r0,r0,r1
0056e4  d415              BMI      |L1.22290|
;;;872           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
0056e6  495b              LDR      r1,|L1.22612|
0056e8  6d60              LDR      r0,[r4,#0x54]
0056ea  6809              LDR      r1,[r1,#0]  ; seqno
0056ec  4288              CMP      r0,r1
0056ee  d104              BNE      |L1.22266|
0056f0  495a              LDR      r1,|L1.22620|
0056f2  6da0              LDR      r0,[r4,#0x58]
0056f4  6809              LDR      r1,[r1,#0]  ; ackno
0056f6  1a40              SUBS     r0,r0,r1
0056f8  d40b              BMI      |L1.22290|
                  |L1.22266|
;;;873           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
0056fa  4958              LDR      r1,|L1.22620|
0056fc  6da0              LDR      r0,[r4,#0x58]
0056fe  6809              LDR      r1,[r1,#0]  ; ackno
005700  4288              CMP      r0,r1
005702  d133              BNE      |L1.22380|
005704  4856              LDR      r0,|L1.22624|
005706  6800              LDR      r0,[r0,#0]  ; tcphdr
005708  89c0              LDRH     r0,[r0,#0xe]
00570a  f8b41060          LDRH     r1,[r4,#0x60]
00570e  4288              CMP      r0,r1
005710  dd2c              BLE      |L1.22380|
                  |L1.22290|
;;;874          pcb->snd_wnd = tcphdr->wnd;
005712  4853              LDR      r0,|L1.22624|
005714  6800              LDR      r0,[r0,#0]  ; tcphdr
005716  89c0              LDRH     r0,[r0,#0xe]
005718  f8a40060          STRH     r0,[r4,#0x60]
;;;875          /* keep track of the biggest window announced by the remote host to calculate
;;;876             the maximum segment size */
;;;877          if (pcb->snd_wnd_max < tcphdr->wnd) {
00571c  f8b40062          LDRH     r0,[r4,#0x62]
005720  494f              LDR      r1,|L1.22624|
005722  6809              LDR      r1,[r1,#0]  ; tcphdr
005724  89c9              LDRH     r1,[r1,#0xe]
005726  4288              CMP      r0,r1
005728  da04              BGE      |L1.22324|
;;;878            pcb->snd_wnd_max = tcphdr->wnd;
00572a  484d              LDR      r0,|L1.22624|
00572c  6800              LDR      r0,[r0,#0]  ; tcphdr
00572e  89c0              LDRH     r0,[r0,#0xe]
005730  f8a40062          STRH     r0,[r4,#0x62]
                  |L1.22324|
;;;879          }
;;;880          pcb->snd_wl1 = seqno;
005734  4847              LDR      r0,|L1.22612|
005736  6800              LDR      r0,[r0,#0]  ; seqno
005738  6560              STR      r0,[r4,#0x54]
;;;881          pcb->snd_wl2 = ackno;
00573a  4848              LDR      r0,|L1.22620|
00573c  6800              LDR      r0,[r0,#0]  ; ackno
00573e  65a0              STR      r0,[r4,#0x58]
;;;882          if (pcb->snd_wnd == 0) {
005740  f8b40060          LDRH     r0,[r4,#0x60]
005744  b948              CBNZ     r0,|L1.22362|
;;;883            if (pcb->persist_backoff == 0) {
005746  f8940095          LDRB     r0,[r4,#0x95]
00574a  b968              CBNZ     r0,|L1.22376|
;;;884              /* start persist timer */
;;;885              pcb->persist_cnt = 0;
00574c  2000              MOVS     r0,#0
00574e  f8840094          STRB     r0,[r4,#0x94]
;;;886              pcb->persist_backoff = 1;
005752  2001              MOVS     r0,#1
005754  f8840095          STRB     r0,[r4,#0x95]
005758  e006              B        |L1.22376|
                  |L1.22362|
;;;887            }
;;;888          } else if (pcb->persist_backoff > 0) {
00575a  f8940095          LDRB     r0,[r4,#0x95]
00575e  2800              CMP      r0,#0
005760  dd02              BLE      |L1.22376|
;;;889            /* stop persist timer */
;;;890              pcb->persist_backoff = 0;
005762  2000              MOVS     r0,#0
005764  f8840095          STRB     r0,[r4,#0x95]
                  |L1.22376|
;;;891          }
;;;892          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
005768  bf00              NOP      
00576a  bf00              NOP      
                  |L1.22380|
;;;893    #if TCP_WND_DEBUG
;;;894        } else {
;;;895          if (pcb->snd_wnd != tcphdr->wnd) {
;;;896            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;897                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;898                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;899                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;900          }
;;;901    #endif /* TCP_WND_DEBUG */
;;;902        }
;;;903    
;;;904        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;905         * duplicate ack if:
;;;906         * 1) It doesn't ACK new data 
;;;907         * 2) length of received packet is zero (i.e. no payload) 
;;;908         * 3) the advertised window hasn't changed 
;;;909         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;910         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;911         * 
;;;912         * If it passes all five, should process as a dupack: 
;;;913         * a) dupacks < 3: do nothing 
;;;914         * b) dupacks == 3: fast retransmit 
;;;915         * c) dupacks > 3: increase cwnd 
;;;916         * 
;;;917         * If it only passes 1-3, should reset dupack counter (and add to
;;;918         * stats, which we don't do in lwIP)
;;;919         *
;;;920         * If it only passes 1, should reset dupack counter
;;;921         *
;;;922         */
;;;923    
;;;924        /* Clause 1 */
;;;925        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
00576c  493b              LDR      r1,|L1.22620|
00576e  6ca0              LDR      r0,[r4,#0x48]
005770  6809              LDR      r1,[r1,#0]  ; ackno
005772  1a08              SUBS     r0,r1,r0
005774  2800              CMP      r0,#0
005776  dc47              BGT      |L1.22536|
;;;926          pcb->acked = 0;
005778  2000              MOVS     r0,#0
00577a  f8a40064          STRH     r0,[r4,#0x64]
;;;927          /* Clause 2 */
;;;928          if (tcplen == 0) {
00577e  4839              LDR      r0,|L1.22628|
005780  8800              LDRH     r0,[r0,#0]  ; tcplen
005782  bb30              CBNZ     r0,|L1.22482|
;;;929            /* Clause 3 */
;;;930            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
005784  f8b41060          LDRH     r1,[r4,#0x60]
005788  6da0              LDR      r0,[r4,#0x58]
00578a  4408              ADD      r0,r0,r1
00578c  4558              CMP      r0,r11
00578e  d135              BNE      |L1.22524|
;;;931              /* Clause 4 */
;;;932              if (pcb->rtime >= 0) {
005790  f9b40034          LDRSH    r0,[r4,#0x34]
005794  2800              CMP      r0,#0
005796  db31              BLT      |L1.22524|
;;;933                /* Clause 5 */
;;;934                if (pcb->lastack == ackno) {
005798  4930              LDR      r1,|L1.22620|
00579a  6ca0              LDR      r0,[r4,#0x48]
00579c  6809              LDR      r1,[r1,#0]  ; ackno
00579e  4288              CMP      r0,r1
0057a0  d12c              BNE      |L1.22524|
;;;935                  found_dupack = 1;
0057a2  2001              MOVS     r0,#1
0057a4  9001              STR      r0,[sp,#4]
;;;936                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0057a6  f8940047          LDRB     r0,[r4,#0x47]
0057aa  1c40              ADDS     r0,r0,#1
0057ac  b2c0              UXTB     r0,r0
0057ae  f8941047          LDRB     r1,[r4,#0x47]
0057b2  4288              CMP      r0,r1
0057b4  dd04              BLE      |L1.22464|
;;;937                    ++pcb->dupacks;
0057b6  f8940047          LDRB     r0,[r4,#0x47]
0057ba  1c40              ADDS     r0,r0,#1
0057bc  f8840047          STRB     r0,[r4,#0x47]
                  |L1.22464|
;;;938                  }
;;;939                  if (pcb->dupacks > 3) {
0057c0  f8940047          LDRB     r0,[r4,#0x47]
0057c4  2803              CMP      r0,#3
0057c6  dd12              BLE      |L1.22510|
;;;940                    /* Inflate the congestion window, but not if it means that
;;;941                       the value overflows. */
;;;942                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0057c8  f8b4004c          LDRH     r0,[r4,#0x4c]
0057cc  8ee1              LDRH     r1,[r4,#0x36]
0057ce  e001              B        |L1.22484|
                  |L1.22480|
0057d0  e17e              B        |L1.23248|
                  |L1.22482|
0057d2  e00b              B        |L1.22508|
                  |L1.22484|
0057d4  4408              ADD      r0,r0,r1
0057d6  b280              UXTH     r0,r0
0057d8  f8b4104c          LDRH     r1,[r4,#0x4c]
0057dc  4288              CMP      r0,r1
0057de  dd0d              BLE      |L1.22524|
;;;943                      pcb->cwnd += pcb->mss;
0057e0  f8b4004c          LDRH     r0,[r4,#0x4c]
0057e4  8ee1              LDRH     r1,[r4,#0x36]
0057e6  4408              ADD      r0,r0,r1
0057e8  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.22508|
0057ec  e006              B        |L1.22524|
                  |L1.22510|
;;;944                    }
;;;945                  } else if (pcb->dupacks == 3) {
0057ee  f8940047          LDRB     r0,[r4,#0x47]
0057f2  2803              CMP      r0,#3
0057f4  d102              BNE      |L1.22524|
;;;946                    /* Do fast retransmit */
;;;947                    tcp_rexmit_fast(pcb);
0057f6  4620              MOV      r0,r4
0057f8  f7fffffe          BL       tcp_rexmit_fast
                  |L1.22524|
;;;948                  }
;;;949                }
;;;950              }
;;;951            }
;;;952          }
;;;953          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;954           * count of consecutive duplicate acks */
;;;955          if (!found_dupack) {
0057fc  9801              LDR      r0,[sp,#4]
0057fe  2800              CMP      r0,#0
005800  d101              BNE      |L1.22534|
;;;956            pcb->dupacks = 0;
005802  f8840047          STRB     r0,[r4,#0x47]
                  |L1.22534|
005806  e0d1              B        |L1.22956|
                  |L1.22536|
;;;957          }
;;;958        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
005808  6ca0              LDR      r0,[r4,#0x48]
00580a  f1000001          ADD      r0,r0,#1
00580e  4913              LDR      r1,|L1.22620|
005810  6809              LDR      r1,[r1,#0]  ; ackno
005812  1a08              SUBS     r0,r1,r0
005814  d471              BMI      |L1.22778|
005816  4911              LDR      r1,|L1.22620|
005818  6d20              LDR      r0,[r4,#0x50]
00581a  6809              LDR      r1,[r1,#0]  ; ackno
00581c  1a08              SUBS     r0,r1,r0
00581e  2800              CMP      r0,#0
005820  dc6b              BGT      |L1.22778|
;;;959          /* We come here when the ACK acknowledges new data. */
;;;960    
;;;961          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;962             in fast retransmit. Also reset the congestion window to the
;;;963             slow start threshold. */
;;;964          if (pcb->flags & TF_INFR) {
005822  7fa0              LDRB     r0,[r4,#0x1e]
005824  f0100f04          TST      r0,#4
005828  d007              BEQ      |L1.22586|
;;;965            pcb->flags &= ~TF_INFR;
00582a  7fa0              LDRB     r0,[r4,#0x1e]
00582c  f0200004          BIC      r0,r0,#4
005830  77a0              STRB     r0,[r4,#0x1e]
;;;966            pcb->cwnd = pcb->ssthresh;
005832  f8b4004e          LDRH     r0,[r4,#0x4e]
005836  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.22586|
;;;967          }
;;;968    
;;;969          /* Reset the number of retransmissions. */
;;;970          pcb->nrtx = 0;
00583a  2000              MOVS     r0,#0
00583c  f1040428          ADD      r4,r4,#0x28
005840  77a0              STRB     r0,[r4,#0x1e]
;;;971    
;;;972          /* Reset the retransmission time-out. */
;;;973          pcb->rto = (pcb->sa >> 3) + pcb->sv;
005842  e011              B        |L1.22632|
                  |L1.22596|
                          DCD      ||ram||
                  |L1.22600|
                          DCD      lwip_stats
                  |L1.22604|
                          DCD      lfree
                  |L1.22608|
                          DCD      mem_mutex
                  |L1.22612|
                          DCD      seqno
                  |L1.22616|
                          DCD      flags
                  |L1.22620|
                          DCD      ackno
                  |L1.22624|
                          DCD      tcphdr
                  |L1.22628|
                          DCD      tcplen
                  |L1.22632|
005868  8b60              LDRH     r0,[r4,#0x1a]
00586a  f9b41018          LDRSH    r1,[r4,#0x18]
00586e  eb0000e1          ADD      r0,r0,r1,ASR #3
005872  b200              SXTH     r0,r0
005874  83a0              STRH     r0,[r4,#0x1c]
;;;974    
;;;975          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;976          pcb->acked = (u16_t)(ackno - pcb->lastack);
005876  8c20              LDRH     r0,[r4,#0x20]
005878  49fe              LDR      r1,|L1.23668|
00587a  8809              LDRH     r1,[r1,#0]  ; ackno
00587c  eba10000          SUB      r0,r1,r0
005880  87a0              STRH     r0,[r4,#0x3c]
;;;977    
;;;978          pcb->snd_buf += pcb->acked;
005882  8fe0              LDRH     r0,[r4,#0x3e]
005884  8fa1              LDRH     r1,[r4,#0x3c]
005886  4408              ADD      r0,r0,r1
005888  87e0              STRH     r0,[r4,#0x3e]
;;;979    
;;;980          /* Reset the fast retransmit variables. */
;;;981          pcb->dupacks = 0;
00588a  f04f0000          MOV      r0,#0
00588e  77e0              STRB     r0,[r4,#0x1f]
;;;982          pcb->lastack = ackno;
005890  48f8              LDR      r0,|L1.23668|
005892  6800              LDR      r0,[r0,#0]  ; ackno
005894  6220              STR      r0,[r4,#0x20]
;;;983    
;;;984          /* Update the congestion control variables (cwnd and
;;;985             ssthresh). */
;;;986          if (pcb->state >= ESTABLISHED) {
005896  f8140c10          LDRB     r0,[r4,#-0x10]
00589a  f1a40428          SUB      r4,r4,#0x28
00589e  2804              CMP      r0,#4
0058a0  db28              BLT      |L1.22772|
;;;987            if (pcb->cwnd < pcb->ssthresh) {
0058a2  f8b4004c          LDRH     r0,[r4,#0x4c]
0058a6  f8b4104e          LDRH     r1,[r4,#0x4e]
0058aa  4288              CMP      r0,r1
0058ac  da10              BGE      |L1.22736|
;;;988              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0058ae  f8b4004c          LDRH     r0,[r4,#0x4c]
0058b2  8ee1              LDRH     r1,[r4,#0x36]
0058b4  4408              ADD      r0,r0,r1
0058b6  b280              UXTH     r0,r0
0058b8  f8b4104c          LDRH     r1,[r4,#0x4c]
0058bc  4288              CMP      r0,r1
0058be  dd05              BLE      |L1.22732|
;;;989                pcb->cwnd += pcb->mss;
0058c0  f8b4004c          LDRH     r0,[r4,#0x4c]
0058c4  8ee1              LDRH     r1,[r4,#0x36]
0058c6  4408              ADD      r0,r0,r1
0058c8  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.22732|
;;;990              }
;;;991              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
0058cc  bf00              NOP      
0058ce  e011              B        |L1.22772|
                  |L1.22736|
;;;992            } else {
;;;993              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
0058d0  f8341f36          LDRH     r1,[r4,#0x36]!
0058d4  4349              MULS     r1,r1,r1
0058d6  8ae2              LDRH     r2,[r4,#0x16]
0058d8  fb91f1f2          SDIV     r1,r1,r2
0058dc  4411              ADD      r1,r1,r2
0058de  b288              UXTH     r0,r1
;;;994              if (new_cwnd > pcb->cwnd) {
0058e0  8ae1              LDRH     r1,[r4,#0x16]
0058e2  f1a40436          SUB      r4,r4,#0x36
0058e6  4281              CMP      r1,r0
0058e8  da01              BGE      |L1.22766|
;;;995                pcb->cwnd = new_cwnd;
0058ea  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L1.22766|
;;;996              }
;;;997              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
0058ee  bf00              NOP      
0058f0  bf00              NOP      
;;;998            }
0058f2  bf00              NOP      
                  |L1.22772|
;;;999          }
;;;1000         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
0058f4  bf00              NOP      
0058f6  bf00              NOP      
;;;1001                                       ackno,
;;;1002                                       pcb->unacked != NULL?
;;;1003                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1004                                       pcb->unacked != NULL?
;;;1005                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1006   
;;;1007         /* Remove segment from the unacknowledged list if the incoming
;;;1008            ACK acknowlegdes them. */
;;;1009         while (pcb->unacked != NULL &&
0058f8  e02e              B        |L1.22872|
                  |L1.22778|
0058fa  e054              B        |L1.22950|
                  |L1.22780|
;;;1010                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1011                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1012           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
0058fc  bf00              NOP      
0058fe  bf00              NOP      
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1014                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1015                                         TCP_TCPLEN(pcb->unacked)));
;;;1016   
;;;1017           next = pcb->unacked;
005900  6f25              LDR      r5,[r4,#0x70]
;;;1018           pcb->unacked = pcb->unacked->next;
005902  6f20              LDR      r0,[r4,#0x70]
005904  6800              LDR      r0,[r0,#0]
005906  6720              STR      r0,[r4,#0x70]
;;;1019   
;;;1020           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
005908  bf00              NOP      
00590a  bf00              NOP      
;;;1021           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00590c  bf00              NOP      
00590e  6868              LDR      r0,[r5,#4]
005910  f7fffffe          BL       pbuf_clen
005914  bf00              NOP      
;;;1022           /* Prevent ACK for FIN to generate a sent event */
;;;1023           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
005916  f8b40064          LDRH     r0,[r4,#0x64]
00591a  b158              CBZ      r0,|L1.22836|
00591c  6929              LDR      r1,[r5,#0x10]
00591e  8988              LDRH     r0,[r1,#0xc]
005920  f7fffffe          BL       lwip_ntohs
005924  f0100f01          TST      r0,#1
005928  d004              BEQ      |L1.22836|
;;;1024             pcb->acked--;
00592a  f8b40064          LDRH     r0,[r4,#0x64]
00592e  1e40              SUBS     r0,r0,#1
005930  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.22836|
;;;1025           }
;;;1026   
;;;1027           pcb->snd_queuelen -= pbuf_clen(next->p);
005934  6868              LDR      r0,[r5,#4]
005936  f7fffffe          BL       pbuf_clen
00593a  f8b41068          LDRH     r1,[r4,#0x68]
00593e  1a08              SUBS     r0,r1,r0
005940  f8a40068          STRH     r0,[r4,#0x68]
;;;1028           tcp_seg_free(next);
005944  4628              MOV      r0,r5
005946  f7fffffe          BL       tcp_seg_free
;;;1029   
;;;1030           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
00594a  bf00              NOP      
00594c  bf00              NOP      
;;;1031           if (pcb->snd_queuelen != 0) {
00594e  f8b40068          LDRH     r0,[r4,#0x68]
005952  b108              CBZ      r0,|L1.22872|
;;;1032             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
005954  bf00              NOP      
005956  bf00              NOP      
                  |L1.22872|
005958  6f20              LDR      r0,[r4,#0x70]         ;1009
00595a  b1c8              CBZ      r0,|L1.22928|
00595c  6f21              LDR      r1,[r4,#0x70]         ;1010
00595e  6909              LDR      r1,[r1,#0x10]         ;1010
005960  6848              LDR      r0,[r1,#4]            ;1010
005962  f7fffffe          BL       lwip_ntohl
005966  4603              MOV      r3,r0                 ;1010
005968  6f21              LDR      r1,[r4,#0x70]         ;1010
00596a  6909              LDR      r1,[r1,#0x10]         ;1010
00596c  8988              LDRH     r0,[r1,#0xc]          ;1010
00596e  f7fffffe          BL       lwip_ntohs
005972  f0100f03          TST      r0,#3                 ;1010
005976  d001              BEQ      |L1.22908|
005978  2001              MOVS     r0,#1                 ;1010
00597a  e000              B        |L1.22910|
                  |L1.22908|
00597c  2000              MOVS     r0,#0                 ;1010
                  |L1.22910|
00597e  6f21              LDR      r1,[r4,#0x70]         ;1010
005980  8909              LDRH     r1,[r1,#8]            ;1010
005982  4408              ADD      r0,r0,r1              ;1010
005984  4418              ADD      r0,r0,r3              ;1010
005986  49bb              LDR      r1,|L1.23668|
005988  6809              LDR      r1,[r1,#0]            ;1010  ; ackno
00598a  1a40              SUBS     r0,r0,r1              ;1010
00598c  2800              CMP      r0,#0                 ;1010
00598e  ddb5              BLE      |L1.22780|
                  |L1.22928|
;;;1033                         pcb->unsent != NULL);
;;;1034           }
;;;1035         }
;;;1036   
;;;1037         /* If there's nothing left to acknowledge, stop the retransmit
;;;1038            timer, otherwise reset it to start again */
;;;1039         if(pcb->unacked == NULL)
005990  6f20              LDR      r0,[r4,#0x70]
005992  b918              CBNZ     r0,|L1.22940|
;;;1040           pcb->rtime = -1;
005994  f04f30ff          MOV      r0,#0xffffffff
005998  86a0              STRH     r0,[r4,#0x34]
00599a  e001              B        |L1.22944|
                  |L1.22940|
;;;1041         else
;;;1042           pcb->rtime = 0;
00599c  2000              MOVS     r0,#0
00599e  86a0              STRH     r0,[r4,#0x34]
                  |L1.22944|
;;;1043   
;;;1044         pcb->polltmr = 0;
0059a0  2000              MOVS     r0,#0
0059a2  77e0              STRB     r0,[r4,#0x1f]
0059a4  e002              B        |L1.22956|
                  |L1.22950|
;;;1045       } else {
;;;1046         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1047         pcb->acked = 0;
0059a6  2000              MOVS     r0,#0
0059a8  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.22956|
;;;1048       }
;;;1049   
;;;1050       /* We go through the ->unsent list to see if any of the segments
;;;1051          on the list are acknowledged by the ACK. This may seem
;;;1052          strange since an "unsent" segment shouldn't be acked. The
;;;1053          rationale is that lwIP puts all outstanding segments on the
;;;1054          ->unsent list after a retransmission, so these segments may
;;;1055          in fact have been sent once. */
;;;1056       while (pcb->unsent != NULL &&
0059ac  e032              B        |L1.23060|
                  |L1.22958|
;;;1057              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1058                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1059         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
0059ae  bf00              NOP      
0059b0  bf00              NOP      
;;;1060                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1061                                       TCP_TCPLEN(pcb->unsent)));
;;;1062   
;;;1063         next = pcb->unsent;
0059b2  6ee5              LDR      r5,[r4,#0x6c]
;;;1064         pcb->unsent = pcb->unsent->next;
0059b4  6ee0              LDR      r0,[r4,#0x6c]
0059b6  6800              LDR      r0,[r0,#0]
0059b8  66e0              STR      r0,[r4,#0x6c]
;;;1065   #if TCP_OVERSIZE
;;;1066         if (pcb->unsent == NULL) {
0059ba  6ee0              LDR      r0,[r4,#0x6c]
0059bc  b910              CBNZ     r0,|L1.22980|
;;;1067           pcb->unsent_oversize = 0;
0059be  2000              MOVS     r0,#0
0059c0  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L1.22980|
;;;1068         }
;;;1069   #endif /* TCP_OVERSIZE */ 
;;;1070         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
0059c4  bf00              NOP      
0059c6  bf00              NOP      
;;;1071         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
0059c8  bf00              NOP      
0059ca  6868              LDR      r0,[r5,#4]
0059cc  f7fffffe          BL       pbuf_clen
0059d0  bf00              NOP      
;;;1072         /* Prevent ACK for FIN to generate a sent event */
;;;1073         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
0059d2  f8b40064          LDRH     r0,[r4,#0x64]
0059d6  b158              CBZ      r0,|L1.23024|
0059d8  6929              LDR      r1,[r5,#0x10]
0059da  8988              LDRH     r0,[r1,#0xc]
0059dc  f7fffffe          BL       lwip_ntohs
0059e0  f0100f01          TST      r0,#1
0059e4  d004              BEQ      |L1.23024|
;;;1074           pcb->acked--;
0059e6  f8b40064          LDRH     r0,[r4,#0x64]
0059ea  1e40              SUBS     r0,r0,#1
0059ec  f8a40064          STRH     r0,[r4,#0x64]
                  |L1.23024|
;;;1075         }
;;;1076         pcb->snd_queuelen -= pbuf_clen(next->p);
0059f0  6868              LDR      r0,[r5,#4]
0059f2  f7fffffe          BL       pbuf_clen
0059f6  f8b41068          LDRH     r1,[r4,#0x68]
0059fa  1a08              SUBS     r0,r1,r0
0059fc  f8a40068          STRH     r0,[r4,#0x68]
;;;1077         tcp_seg_free(next);
005a00  4628              MOV      r0,r5
005a02  f7fffffe          BL       tcp_seg_free
;;;1078         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
005a06  bf00              NOP      
005a08  bf00              NOP      
;;;1079         if (pcb->snd_queuelen != 0) {
005a0a  f8b40068          LDRH     r0,[r4,#0x68]
005a0e  b108              CBZ      r0,|L1.23060|
;;;1080           LWIP_ASSERT("tcp_receive: valid queue length",
005a10  bf00              NOP      
005a12  bf00              NOP      
                  |L1.23060|
005a14  6ee0              LDR      r0,[r4,#0x6c]         ;1056
005a16  b1f0              CBZ      r0,|L1.23126|
005a18  6ee1              LDR      r1,[r4,#0x6c]         ;1057
005a1a  6909              LDR      r1,[r1,#0x10]         ;1057
005a1c  6848              LDR      r0,[r1,#4]            ;1057
005a1e  f7fffffe          BL       lwip_ntohl
005a22  4603              MOV      r3,r0                 ;1057
005a24  6ee1              LDR      r1,[r4,#0x6c]         ;1057
005a26  6909              LDR      r1,[r1,#0x10]         ;1057
005a28  8988              LDRH     r0,[r1,#0xc]          ;1057
005a2a  f7fffffe          BL       lwip_ntohs
005a2e  f0100f03          TST      r0,#3                 ;1057
005a32  d001              BEQ      |L1.23096|
005a34  2001              MOVS     r0,#1                 ;1057
005a36  e000              B        |L1.23098|
                  |L1.23096|
005a38  2000              MOVS     r0,#0                 ;1057
                  |L1.23098|
005a3a  6ee1              LDR      r1,[r4,#0x6c]         ;1057
005a3c  8909              LDRH     r1,[r1,#8]            ;1057
005a3e  4408              ADD      r0,r0,r1              ;1057
005a40  4418              ADD      r0,r0,r3              ;1057
005a42  498c              LDR      r1,|L1.23668|
005a44  6809              LDR      r1,[r1,#0]            ;1057  ; ackno
005a46  1a08              SUBS     r0,r1,r0              ;1057
005a48  d405              BMI      |L1.23126|
005a4a  498a              LDR      r1,|L1.23668|
005a4c  6d20              LDR      r0,[r4,#0x50]         ;1057
005a4e  6809              LDR      r1,[r1,#0]            ;1057  ; ackno
005a50  1a08              SUBS     r0,r1,r0              ;1057
005a52  2800              CMP      r0,#0                 ;1057
005a54  ddab              BLE      |L1.22958|
                  |L1.23126|
;;;1081             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1082         }
;;;1083       }
;;;1084       /* End of ACK for new data processing. */
;;;1085   
;;;1086       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
005a56  bf00              NOP      
005a58  bf00              NOP      
;;;1087                                   pcb->rttest, pcb->rtseq, ackno));
;;;1088   
;;;1089       /* RTT estimation calculations. This is done by checking if the
;;;1090          incoming segment acknowledges the segment we use to take a
;;;1091          round-trip time measurement. */
;;;1092       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
005a5a  6ba0              LDR      r0,[r4,#0x38]
005a5c  b3c0              CBZ      r0,|L1.23248|
005a5e  4985              LDR      r1,|L1.23668|
005a60  6be0              LDR      r0,[r4,#0x3c]
005a62  6809              LDR      r1,[r1,#0]  ; ackno
005a64  1a40              SUBS     r0,r0,r1
005a66  d533              BPL      |L1.23248|
;;;1093         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1094            and a round-trip shouldn't be that long... */
;;;1095         m = (s16_t)(tcp_ticks - pcb->rttest);
005a68  8f20              LDRH     r0,[r4,#0x38]
005a6a  4983              LDR      r1,|L1.23672|
005a6c  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
005a6e  1a08              SUBS     r0,r1,r0
005a70  fa0ffa80          SXTH     r10,r0
;;;1096   
;;;1097         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
005a74  bf00              NOP      
005a76  bf00              NOP      
;;;1098                                     m, m * TCP_SLOW_INTERVAL));
;;;1099   
;;;1100         /* This is taken directly from VJs original code in his paper */
;;;1101         m = m - (pcb->sa >> 3);
005a78  f9340f40          LDRSH    r0,[r4,#0x40]!
005a7c  ebaa00e0          SUB      r0,r10,r0,ASR #3
005a80  fa0ffa80          SXTH     r10,r0
;;;1102         pcb->sa += m;
005a84  8820              LDRH     r0,[r4,#0]
005a86  4450              ADD      r0,r0,r10
005a88  b200              SXTH     r0,r0
005a8a  f8240940          STRH     r0,[r4],#-0x40
;;;1103         if (m < 0) {
005a8e  f1ba0f00          CMP      r10,#0
005a92  da03              BGE      |L1.23196|
;;;1104           m = -m;
005a94  f1ca0000          RSB      r0,r10,#0
005a98  fa0ffa80          SXTH     r10,r0
                  |L1.23196|
;;;1105         }
;;;1106         m = m - (pcb->sv >> 2);
005a9c  f1040440          ADD      r4,r4,#0x40
005aa0  f9b40002          LDRSH    r0,[r4,#2]
005aa4  ebaa00a0          SUB      r0,r10,r0,ASR #2
005aa8  fa0ffa80          SXTH     r10,r0
;;;1107         pcb->sv += m;
005aac  8860              LDRH     r0,[r4,#2]
005aae  4450              ADD      r0,r0,r10
005ab0  b200              SXTH     r0,r0
005ab2  8060              STRH     r0,[r4,#2]
;;;1108         pcb->rto = (pcb->sa >> 3) + pcb->sv;
005ab4  8860              LDRH     r0,[r4,#2]
005ab6  f9b41000          LDRSH    r1,[r4,#0]
005aba  eb0000e1          ADD      r0,r0,r1,ASR #3
005abe  b200              SXTH     r0,r0
005ac0  80a0              STRH     r0,[r4,#4]
005ac2  f1a40440          SUB      r4,r4,#0x40
;;;1109   
;;;1110         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
005ac6  bf00              NOP      
005ac8  bf00              NOP      
;;;1111                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1112   
;;;1113         pcb->rttest = 0;
005aca  f04f0000          MOV      r0,#0
005ace  63a0              STR      r0,[r4,#0x38]
                  |L1.23248|
;;;1114       }
;;;1115     }
;;;1116   
;;;1117     /* If the incoming segment contains data, we must process it
;;;1118        further unless the pcb already received a FIN.
;;;1119        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1120        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1121     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
005ad0  486a              LDR      r0,|L1.23676|
005ad2  8800              LDRH     r0,[r0,#0]  ; tcplen
005ad4  2800              CMP      r0,#0
005ad6  dd7d              BLE      |L1.23508|
005ad8  7e20              LDRB     r0,[r4,#0x18]
005ada  2807              CMP      r0,#7
005adc  da7a              BGE      |L1.23508|
;;;1122       /* This code basically does three things:
;;;1123   
;;;1124       +) If the incoming segment contains data that is the next
;;;1125       in-sequence data, this data is passed to the application. This
;;;1126       might involve trimming the first edge of the data. The rcv_nxt
;;;1127       variable and the advertised window are adjusted.
;;;1128   
;;;1129       +) If the incoming segment has data that is above the next
;;;1130       sequence number expected (->rcv_nxt), the segment is placed on
;;;1131       the ->ooseq queue. This is done by finding the appropriate
;;;1132       place in the ->ooseq queue (which is ordered by sequence
;;;1133       number) and trim the segment in both ends if needed. An
;;;1134       immediate ACK is sent to indicate that we received an
;;;1135       out-of-sequence segment.
;;;1136   
;;;1137       +) Finally, we check if the first segment on the ->ooseq queue
;;;1138       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1139       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1140       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1141       segments that are now on sequence are chained onto the
;;;1142       incoming segment so that we only need to call the application
;;;1143       once.
;;;1144       */
;;;1145   
;;;1146       /* First, we check if we must trim the first edge. We have to do
;;;1147          this if the sequence number of the incoming segment is less
;;;1148          than rcv_nxt, and the sequence number plus the length of the
;;;1149          segment is larger than rcv_nxt. */
;;;1150       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1151             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1152       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
005ade  4868              LDR      r0,|L1.23680|
005ae0  6aa1              LDR      r1,[r4,#0x28]
005ae2  6800              LDR      r0,[r0,#0]  ; seqno
005ae4  f1000001          ADD      r0,r0,#1
005ae8  1a08              SUBS     r0,r1,r0
005aea  d456              BMI      |L1.23450|
005aec  4864              LDR      r0,|L1.23680|
005aee  6aa1              LDR      r1,[r4,#0x28]
005af0  6800              LDR      r0,[r0,#0]  ; seqno
005af2  4a62              LDR      r2,|L1.23676|
005af4  8812              LDRH     r2,[r2,#0]  ; tcplen
005af6  4410              ADD      r0,r0,r2
005af8  1e40              SUBS     r0,r0,#1
005afa  1a08              SUBS     r0,r1,r0
005afc  2800              CMP      r0,#0
005afe  dc4c              BGT      |L1.23450|
;;;1153         /* Trimming the first edge is done by pushing the payload
;;;1154            pointer in the pbuf downwards. This is somewhat tricky since
;;;1155            we do not want to discard the full contents of the pbuf up to
;;;1156            the new starting point of the data since we have to keep the
;;;1157            TCP header which is present in the first pbuf in the chain.
;;;1158   
;;;1159            What is done is really quite a nasty hack: the first pbuf in
;;;1160            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1161            able to deallocate the whole pbuf, we cannot change this
;;;1162            inseg.p pointer to point to any of the later pbufs in the
;;;1163            chain. Instead, we point the ->payload pointer in the first
;;;1164            pbuf to data in one of the later pbufs. We also set the
;;;1165            inseg.data pointer to point to the right place. This way, the
;;;1166            ->p pointer will still point to the first pbuf, but the
;;;1167            ->p->payload pointer will point to data in another pbuf.
;;;1168   
;;;1169            After we are done with adjusting the pbuf pointers we must
;;;1170            adjust the ->data pointer in the seg and the segment
;;;1171            length.*/
;;;1172   
;;;1173         off = pcb->rcv_nxt - seqno;
005b00  495f              LDR      r1,|L1.23680|
005b02  6aa0              LDR      r0,[r4,#0x28]
005b04  6809              LDR      r1,[r1,#0]  ; seqno
005b06  eba00901          SUB      r9,r0,r1
;;;1174         p = inseg.p;
005b0a  485e              LDR      r0,|L1.23684|
005b0c  f8d08004          LDR      r8,[r0,#4]  ; inseg
;;;1175         LWIP_ASSERT("inseg.p != NULL", inseg.p);
005b10  bf00              NOP      
005b12  bf00              NOP      
;;;1176         LWIP_ASSERT("insane offset!", (off < 0x7fff));
005b14  bf00              NOP      
005b16  bf00              NOP      
;;;1177         if (inseg.p->len < off) {
005b18  6840              LDR      r0,[r0,#4]  ; inseg
005b1a  8940              LDRH     r0,[r0,#0xa]
005b1c  4548              CMP      r0,r9
005b1e  da22              BGE      |L1.23398|
;;;1178           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
005b20  bf00              NOP      
005b22  bf00              NOP      
;;;1179           new_tot_len = (u16_t)(inseg.p->tot_len - off);
005b24  4857              LDR      r0,|L1.23684|
005b26  6840              LDR      r0,[r0,#4]  ; inseg
005b28  8900              LDRH     r0,[r0,#8]
005b2a  eba00009          SUB      r0,r0,r9
005b2e  b280              UXTH     r0,r0
005b30  9002              STR      r0,[sp,#8]
;;;1180           while (p->len < off) {
005b32  e00b              B        |L1.23372|
                  |L1.23348|
;;;1181             off -= p->len;
005b34  f8b8000a          LDRH     r0,[r8,#0xa]
005b38  eba90900          SUB      r9,r9,r0
;;;1182             /* KJM following line changed (with addition of new_tot_len var)
;;;1183                to fix bug #9076
;;;1184                inseg.p->tot_len -= p->len; */
;;;1185             p->tot_len = new_tot_len;
005b3c  9802              LDR      r0,[sp,#8]
005b3e  f8a80008          STRH     r0,[r8,#8]
;;;1186             p->len = 0;
005b42  2000              MOVS     r0,#0
005b44  f8a8000a          STRH     r0,[r8,#0xa]
;;;1187             p = p->next;
005b48  f8d88000          LDR      r8,[r8,#0]
                  |L1.23372|
005b4c  f8b8000a          LDRH     r0,[r8,#0xa]          ;1180
005b50  4548              CMP      r0,r9                 ;1180
005b52  dbef              BLT      |L1.23348|
;;;1188           }
;;;1189           if(pbuf_header(p, (s16_t)-off)) {
005b54  f1c90000          RSB      r0,r9,#0
005b58  b201              SXTH     r1,r0
005b5a  4640              MOV      r0,r8
005b5c  f7fffffe          BL       pbuf_header
005b60  b158              CBZ      r0,|L1.23418|
;;;1190             /* Do we need to cope with this failing?  Assert for now */
;;;1191             LWIP_ASSERT("pbuf_header failed", 0);
005b62  bf00              NOP      
005b64  e009              B        |L1.23418|
                  |L1.23398|
;;;1192           }
;;;1193         } else {
;;;1194           if(pbuf_header(inseg.p, (s16_t)-off)) {
005b66  4947              LDR      r1,|L1.23684|
005b68  6848              LDR      r0,[r1,#4]  ; inseg
005b6a  f1c90100          RSB      r1,r9,#0
005b6e  b209              SXTH     r1,r1
005b70  f7fffffe          BL       pbuf_header
005b74  b108              CBZ      r0,|L1.23418|
;;;1195             /* Do we need to cope with this failing?  Assert for now */
;;;1196             LWIP_ASSERT("pbuf_header failed", 0);
005b76  bf00              NOP      
005b78  bf00              NOP      
                  |L1.23418|
;;;1197           }
;;;1198         }
;;;1199         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
005b7a  4842              LDR      r0,|L1.23684|
005b7c  8900              LDRH     r0,[r0,#8]  ; inseg
005b7e  8d21              LDRH     r1,[r4,#0x28]
005b80  4a3f              LDR      r2,|L1.23680|
005b82  8812              LDRH     r2,[r2,#0]  ; seqno
005b84  1a89              SUBS     r1,r1,r2
005b86  1a40              SUBS     r0,r0,r1
005b88  493e              LDR      r1,|L1.23684|
005b8a  8108              STRH     r0,[r1,#8]
;;;1200         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
005b8c  493c              LDR      r1,|L1.23680|
005b8e  6aa0              LDR      r0,[r4,#0x28]
005b90  6008              STR      r0,[r1,#0]  ; seqno
005b92  493c              LDR      r1,|L1.23684|
005b94  6909              LDR      r1,[r1,#0x10]  ; inseg
005b96  6048              STR      r0,[r1,#4]
005b98  e00c              B        |L1.23476|
                  |L1.23450|
;;;1201       }
;;;1202       else {
;;;1203         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
005b9a  4939              LDR      r1,|L1.23680|
005b9c  6aa0              LDR      r0,[r4,#0x28]
005b9e  6809              LDR      r1,[r1,#0]  ; seqno
005ba0  1a08              SUBS     r0,r1,r0
005ba2  d507              BPL      |L1.23476|
;;;1204           /* the whole segment is < rcv_nxt */
;;;1205           /* must be a duplicate of a packet that has already been correctly handled */
;;;1206   
;;;1207           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
005ba4  bf00              NOP      
005ba6  bf00              NOP      
;;;1208           tcp_ack_now(pcb);
005ba8  bf00              NOP      
005baa  7fa0              LDRB     r0,[r4,#0x1e]
005bac  f0400002          ORR      r0,r0,#2
005bb0  77a0              STRB     r0,[r4,#0x1e]
005bb2  bf00              NOP      
                  |L1.23476|
;;;1209         }
;;;1210       }
;;;1211   
;;;1212       /* The sequence number must be within the window (above rcv_nxt
;;;1213          and below rcv_nxt + rcv_wnd) in order to be further
;;;1214          processed. */
;;;1215       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
005bb4  4932              LDR      r1,|L1.23680|
005bb6  6aa0              LDR      r0,[r4,#0x28]
005bb8  6809              LDR      r1,[r1,#0]  ; seqno
005bba  1a08              SUBS     r0,r1,r0
005bbc  d459              BMI      |L1.23666|
005bbe  8da1              LDRH     r1,[r4,#0x2c]
005bc0  6aa0              LDR      r0,[r4,#0x28]
005bc2  4408              ADD      r0,r0,r1
005bc4  1e40              SUBS     r0,r0,#1
005bc6  492e              LDR      r1,|L1.23680|
005bc8  6809              LDR      r1,[r1,#0]  ; seqno
005bca  1a08              SUBS     r0,r1,r0
005bcc  2800              CMP      r0,#0
005bce  dc50              BGT      |L1.23666|
;;;1216                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1217         if (pcb->rcv_nxt == seqno) {
005bd0  492b              LDR      r1,|L1.23680|
005bd2  e000              B        |L1.23510|
                  |L1.23508|
005bd4  e287              B        |L1.24806|
                  |L1.23510|
005bd6  6aa0              LDR      r0,[r4,#0x28]
005bd8  6809              LDR      r1,[r1,#0]  ; seqno
005bda  4288              CMP      r0,r1
005bdc  d171              BNE      |L1.23746|
;;;1218           /* The incoming segment is the next in sequence. We check if
;;;1219              we have to trim the end of the segment and update rcv_nxt
;;;1220              and pass the data to the application. */
;;;1221           tcplen = TCP_TCPLEN(&inseg);
005bde  4929              LDR      r1,|L1.23684|
005be0  6909              LDR      r1,[r1,#0x10]  ; inseg
005be2  8988              LDRH     r0,[r1,#0xc]
005be4  f7fffffe          BL       lwip_ntohs
005be8  f0100f03          TST      r0,#3
005bec  d001              BEQ      |L1.23538|
005bee  2001              MOVS     r0,#1
005bf0  e000              B        |L1.23540|
                  |L1.23538|
005bf2  2000              MOVS     r0,#0
                  |L1.23540|
005bf4  4923              LDR      r1,|L1.23684|
005bf6  8909              LDRH     r1,[r1,#8]  ; inseg
005bf8  4408              ADD      r0,r0,r1
005bfa  4920              LDR      r1,|L1.23676|
005bfc  8008              STRH     r0,[r1,#0]
;;;1222   
;;;1223           if (tcplen > pcb->rcv_wnd) {
005bfe  8da0              LDRH     r0,[r4,#0x2c]
005c00  8809              LDRH     r1,[r1,#0]  ; tcplen
005c02  4288              CMP      r0,r1
005c04  da4f              BGE      |L1.23718|
;;;1224             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
005c06  bf00              NOP      
005c08  bf00              NOP      
;;;1225                         ("tcp_receive: other end overran receive window"
;;;1226                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1227                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1228             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
005c0a  491e              LDR      r1,|L1.23684|
005c0c  6909              LDR      r1,[r1,#0x10]  ; inseg
005c0e  8988              LDRH     r0,[r1,#0xc]
005c10  f7fffffe          BL       lwip_ntohs
005c14  f0100f01          TST      r0,#1
005c18  d013              BEQ      |L1.23618|
;;;1229               /* Must remove the FIN from the header as we're trimming 
;;;1230                * that byte of sequence-space from the packet */
;;;1231               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
005c1a  491a              LDR      r1,|L1.23684|
005c1c  6909              LDR      r1,[r1,#0x10]  ; inseg
005c1e  8988              LDRH     r0,[r1,#0xc]
005c20  f7fffffe          BL       lwip_ntohs
005c24  f000033e          AND      r3,r0,#0x3e
005c28  4618              MOV      r0,r3
005c2a  f7fffffe          BL       lwip_htons
005c2e  4915              LDR      r1,|L1.23684|
005c30  6909              LDR      r1,[r1,#0x10]  ; inseg
005c32  8989              LDRH     r1,[r1,#0xc]
005c34  f24c02ff          MOV      r2,#0xc0ff
005c38  4011              ANDS     r1,r1,r2
005c3a  4308              ORRS     r0,r0,r1
005c3c  4911              LDR      r1,|L1.23684|
005c3e  6909              LDR      r1,[r1,#0x10]  ; inseg
005c40  8188              STRH     r0,[r1,#0xc]
                  |L1.23618|
;;;1232             }
;;;1233             /* Adjust length of segment to fit in the window. */
;;;1234             inseg.len = pcb->rcv_wnd;
005c42  8da0              LDRH     r0,[r4,#0x2c]
005c44  490f              LDR      r1,|L1.23684|
005c46  8108              STRH     r0,[r1,#8]
;;;1235             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
005c48  6909              LDR      r1,[r1,#0x10]  ; inseg
005c4a  8988              LDRH     r0,[r1,#0xc]
005c4c  f7fffffe          BL       lwip_ntohs
005c50  f0100f02          TST      r0,#2
005c54  d004              BEQ      |L1.23648|
;;;1236               inseg.len -= 1;
005c56  480b              LDR      r0,|L1.23684|
005c58  8900              LDRH     r0,[r0,#8]  ; inseg
005c5a  1e40              SUBS     r0,r0,#1
005c5c  4909              LDR      r1,|L1.23684|
005c5e  8108              STRH     r0,[r1,#8]
                  |L1.23648|
;;;1237             }
;;;1238             pbuf_realloc(inseg.p, inseg.len);
005c60  4a08              LDR      r2,|L1.23684|
005c62  8911              LDRH     r1,[r2,#8]  ; inseg
005c64  6850              LDR      r0,[r2,#4]  ; inseg
005c66  f7fffffe          BL       pbuf_realloc
;;;1239             tcplen = TCP_TCPLEN(&inseg);
005c6a  4906              LDR      r1,|L1.23684|
005c6c  6909              LDR      r1,[r1,#0x10]  ; inseg
005c6e  8988              LDRH     r0,[r1,#0xc]
005c70  e00a              B        |L1.23688|
                  |L1.23666|
005c72  e234              B        |L1.24798|
                  |L1.23668|
                          DCD      ackno
                  |L1.23672|
                          DCD      tcp_ticks
                  |L1.23676|
                          DCD      tcplen
                  |L1.23680|
                          DCD      seqno
                  |L1.23684|
                          DCD      inseg
                  |L1.23688|
005c88  f7fffffe          BL       lwip_ntohs
005c8c  f0100f03          TST      r0,#3
005c90  d001              BEQ      |L1.23702|
005c92  2001              MOVS     r0,#1
005c94  e000              B        |L1.23704|
                  |L1.23702|
005c96  2000              MOVS     r0,#0
                  |L1.23704|
005c98  49fe              LDR      r1,|L1.24724|
005c9a  8909              LDRH     r1,[r1,#8]  ; inseg
005c9c  4408              ADD      r0,r0,r1
005c9e  49fe              LDR      r1,|L1.24728|
005ca0  8008              STRH     r0,[r1,#0]
;;;1240             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
005ca2  bf00              NOP      
005ca4  bf00              NOP      
                  |L1.23718|
;;;1241                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1242           }
;;;1243   #if TCP_QUEUE_OOSEQ
;;;1244           /* Received in-sequence data, adjust ooseq data if:
;;;1245              - FIN has been received or
;;;1246              - inseq overlaps with ooseq */
;;;1247           if (pcb->ooseq != NULL) {
005ca6  6f60              LDR      r0,[r4,#0x74]
005ca8  2800              CMP      r0,#0
005caa  d017              BEQ      |L1.23772|
;;;1248             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
005cac  49f9              LDR      r1,|L1.24724|
005cae  6909              LDR      r1,[r1,#0x10]  ; inseg
005cb0  8988              LDRH     r0,[r1,#0xc]
005cb2  f7fffffe          BL       lwip_ntohs
005cb6  f0100f01          TST      r0,#1
005cba  d010              BEQ      |L1.23774|
;;;1249               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
005cbc  bf00              NOP      
005cbe  bf00              NOP      
;;;1250                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1251               /* Received in-order FIN means anything that was received
;;;1252                * out of order must now have been received in-order, so
;;;1253                * bin the ooseq queue */
;;;1254               while (pcb->ooseq != NULL) {
005cc0  e009              B        |L1.23766|
                  |L1.23746|
005cc2  e11e              B        |L1.24322|
                  |L1.23748|
;;;1255                 struct tcp_seg *old_ooseq = pcb->ooseq;
005cc4  6f60              LDR      r0,[r4,#0x74]
005cc6  9000              STR      r0,[sp,#0]
;;;1256                 pcb->ooseq = pcb->ooseq->next;
005cc8  6f60              LDR      r0,[r4,#0x74]
005cca  6800              LDR      r0,[r0,#0]
005ccc  6760              STR      r0,[r4,#0x74]
;;;1257                 tcp_seg_free(old_ooseq);
005cce  9800              LDR      r0,[sp,#0]
005cd0  f7fffffe          BL       tcp_seg_free
;;;1258               }
005cd4  bf00              NOP      
                  |L1.23766|
005cd6  6f60              LDR      r0,[r4,#0x74]         ;1254
005cd8  2800              CMP      r0,#0                 ;1254
005cda  d1f3              BNE      |L1.23748|
                  |L1.23772|
005cdc  e071              B        |L1.24002|
                  |L1.23774|
;;;1259             } else {
;;;1260               next = pcb->ooseq;
005cde  6f65              LDR      r5,[r4,#0x74]
;;;1261               /* Remove all segments on ooseq that are covered by inseg already.
;;;1262                * FIN is copied from ooseq to inseg if present. */
;;;1263               while (next &&
005ce0  e02d              B        |L1.23870|
                  |L1.23778|
;;;1264                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1265                                  next->tcphdr->seqno + next->len)) {
;;;1266                 /* inseg cannot have FIN here (already processed above) */
;;;1267                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
005ce2  6929              LDR      r1,[r5,#0x10]
005ce4  8988              LDRH     r0,[r1,#0xc]
005ce6  f7fffffe          BL       lwip_ntohs
005cea  f0100f01          TST      r0,#1
005cee  d021              BEQ      |L1.23860|
;;;1268                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
005cf0  49e8              LDR      r1,|L1.24724|
005cf2  6909              LDR      r1,[r1,#0x10]  ; inseg
005cf4  8988              LDRH     r0,[r1,#0xc]
005cf6  f7fffffe          BL       lwip_ntohs
005cfa  f0100f02          TST      r0,#2
005cfe  d119              BNE      |L1.23860|
;;;1269                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
005d00  2001              MOVS     r0,#1
005d02  f7fffffe          BL       lwip_htons
005d06  49e3              LDR      r1,|L1.24724|
005d08  6909              LDR      r1,[r1,#0x10]  ; inseg
005d0a  8989              LDRH     r1,[r1,#0xc]
005d0c  4308              ORRS     r0,r0,r1
005d0e  49e1              LDR      r1,|L1.24724|
005d10  6909              LDR      r1,[r1,#0x10]  ; inseg
005d12  8188              STRH     r0,[r1,#0xc]
;;;1270                   tcplen = TCP_TCPLEN(&inseg);
005d14  49df              LDR      r1,|L1.24724|
005d16  6909              LDR      r1,[r1,#0x10]  ; inseg
005d18  8988              LDRH     r0,[r1,#0xc]
005d1a  f7fffffe          BL       lwip_ntohs
005d1e  f0100f03          TST      r0,#3
005d22  d001              BEQ      |L1.23848|
005d24  2001              MOVS     r0,#1
005d26  e000              B        |L1.23850|
                  |L1.23848|
005d28  2000              MOVS     r0,#0
                  |L1.23850|
005d2a  49da              LDR      r1,|L1.24724|
005d2c  8909              LDRH     r1,[r1,#8]  ; inseg
005d2e  4408              ADD      r0,r0,r1
005d30  49d9              LDR      r1,|L1.24728|
005d32  8008              STRH     r0,[r1,#0]
                  |L1.23860|
;;;1271                 }
;;;1272                 prev = next;
005d34  462f              MOV      r7,r5
;;;1273                 next = next->next;
005d36  682d              LDR      r5,[r5,#0]
;;;1274                 tcp_seg_free(prev);
005d38  4638              MOV      r0,r7
005d3a  f7fffffe          BL       tcp_seg_free
                  |L1.23870|
005d3e  b155              CBZ      r5,|L1.23894|
005d40  6928              LDR      r0,[r5,#0x10]         ;1264
005d42  6840              LDR      r0,[r0,#4]            ;1264
005d44  8929              LDRH     r1,[r5,#8]            ;1264
005d46  4401              ADD      r1,r1,r0              ;1264
005d48  48d4              LDR      r0,|L1.24732|
005d4a  6800              LDR      r0,[r0,#0]            ;1264  ; seqno
005d4c  4ad2              LDR      r2,|L1.24728|
005d4e  8812              LDRH     r2,[r2,#0]            ;1264  ; tcplen
005d50  4410              ADD      r0,r0,r2              ;1264
005d52  1a40              SUBS     r0,r0,r1              ;1264
005d54  d5c5              BPL      |L1.23778|
                  |L1.23894|
;;;1275               }
;;;1276               /* Now trim right side of inseg if it overlaps with the first
;;;1277                * segment on ooseq */
;;;1278               if (next &&
005d56  b39d              CBZ      r5,|L1.24000|
;;;1279                   TCP_SEQ_GT(seqno + tcplen,
005d58  48d0              LDR      r0,|L1.24732|
005d5a  6800              LDR      r0,[r0,#0]  ; seqno
005d5c  49ce              LDR      r1,|L1.24728|
005d5e  8809              LDRH     r1,[r1,#0]  ; tcplen
005d60  4408              ADD      r0,r0,r1
005d62  6929              LDR      r1,[r5,#0x10]
005d64  6849              LDR      r1,[r1,#4]
005d66  1a40              SUBS     r0,r0,r1
005d68  2800              CMP      r0,#0
005d6a  dd29              BLE      |L1.24000|
;;;1280                              next->tcphdr->seqno)) {
;;;1281                 /* inseg cannot have FIN here (already processed above) */
;;;1282                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
005d6c  6928              LDR      r0,[r5,#0x10]
005d6e  8880              LDRH     r0,[r0,#4]
005d70  49ca              LDR      r1,|L1.24732|
005d72  8809              LDRH     r1,[r1,#0]  ; seqno
005d74  1a40              SUBS     r0,r0,r1
005d76  49c7              LDR      r1,|L1.24724|
005d78  8108              STRH     r0,[r1,#8]
;;;1283                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
005d7a  6909              LDR      r1,[r1,#0x10]  ; inseg
005d7c  8988              LDRH     r0,[r1,#0xc]
005d7e  f7fffffe          BL       lwip_ntohs
005d82  f0100f02          TST      r0,#2
005d86  d004              BEQ      |L1.23954|
;;;1284                   inseg.len -= 1;
005d88  48c2              LDR      r0,|L1.24724|
005d8a  8900              LDRH     r0,[r0,#8]  ; inseg
005d8c  1e40              SUBS     r0,r0,#1
005d8e  49c1              LDR      r1,|L1.24724|
005d90  8108              STRH     r0,[r1,#8]
                  |L1.23954|
;;;1285                 }
;;;1286                 pbuf_realloc(inseg.p, inseg.len);
005d92  4ac0              LDR      r2,|L1.24724|
005d94  8911              LDRH     r1,[r2,#8]  ; inseg
005d96  6850              LDR      r0,[r2,#4]  ; inseg
005d98  f7fffffe          BL       pbuf_realloc
;;;1287                 tcplen = TCP_TCPLEN(&inseg);
005d9c  49bd              LDR      r1,|L1.24724|
005d9e  6909              LDR      r1,[r1,#0x10]  ; inseg
005da0  8988              LDRH     r0,[r1,#0xc]
005da2  f7fffffe          BL       lwip_ntohs
005da6  f0100f03          TST      r0,#3
005daa  d001              BEQ      |L1.23984|
005dac  2001              MOVS     r0,#1
005dae  e000              B        |L1.23986|
                  |L1.23984|
005db0  2000              MOVS     r0,#0
                  |L1.23986|
005db2  49b8              LDR      r1,|L1.24724|
005db4  8909              LDRH     r1,[r1,#8]  ; inseg
005db6  4408              ADD      r0,r0,r1
005db8  49b7              LDR      r1,|L1.24728|
005dba  8008              STRH     r0,[r1,#0]
;;;1288                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
005dbc  bf00              NOP      
005dbe  bf00              NOP      
                  |L1.24000|
;;;1289                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1290               }
;;;1291               pcb->ooseq = next;
005dc0  6765              STR      r5,[r4,#0x74]
                  |L1.24002|
;;;1292             }
;;;1293           }
;;;1294   #endif /* TCP_QUEUE_OOSEQ */
;;;1295   
;;;1296           pcb->rcv_nxt = seqno + tcplen;
005dc2  48b6              LDR      r0,|L1.24732|
005dc4  6800              LDR      r0,[r0,#0]  ; seqno
005dc6  49b4              LDR      r1,|L1.24728|
005dc8  8809              LDRH     r1,[r1,#0]  ; tcplen
005dca  4408              ADD      r0,r0,r1
005dcc  62a0              STR      r0,[r4,#0x28]
;;;1297   
;;;1298           /* Update the receiver's (our) window. */
;;;1299           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
005dce  bf00              NOP      
005dd0  bf00              NOP      
;;;1300           pcb->rcv_wnd -= tcplen;
005dd2  8da0              LDRH     r0,[r4,#0x2c]
005dd4  49b0              LDR      r1,|L1.24728|
005dd6  8809              LDRH     r1,[r1,#0]  ; tcplen
005dd8  1a40              SUBS     r0,r0,r1
005dda  85a0              STRH     r0,[r4,#0x2c]
;;;1301   
;;;1302           tcp_update_rcv_ann_wnd(pcb);
005ddc  4620              MOV      r0,r4
005dde  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1303   
;;;1304           /* If there is data in the segment, we make preparations to
;;;1305              pass this up to the application. The ->recv_data variable
;;;1306              is used for holding the pbuf that goes to the
;;;1307              application. The code for reassembling out-of-sequence data
;;;1308              chains its data on this pbuf as well.
;;;1309   
;;;1310              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1311              be used to indicate to the application that the remote side has
;;;1312              closed its end of the connection. */
;;;1313           if (inseg.p->tot_len > 0) {
005de2  48ac              LDR      r0,|L1.24724|
005de4  6840              LDR      r0,[r0,#4]  ; inseg
005de6  8900              LDRH     r0,[r0,#8]
005de8  2800              CMP      r0,#0
005dea  dd06              BLE      |L1.24058|
;;;1314             recv_data = inseg.p;
005dec  48a9              LDR      r0,|L1.24724|
005dee  6840              LDR      r0,[r0,#4]  ; inseg
005df0  49ab              LDR      r1,|L1.24736|
005df2  6008              STR      r0,[r1,#0]  ; recv_data
;;;1315             /* Since this pbuf now is the responsibility of the
;;;1316                application, we delete our reference to it so that we won't
;;;1317                (mistakingly) deallocate it. */
;;;1318             inseg.p = NULL;
005df4  2000              MOVS     r0,#0
005df6  49a7              LDR      r1,|L1.24724|
005df8  6048              STR      r0,[r1,#4]  ; inseg
                  |L1.24058|
;;;1319           }
;;;1320           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
005dfa  49a6              LDR      r1,|L1.24724|
005dfc  6909              LDR      r1,[r1,#0x10]  ; inseg
005dfe  8988              LDRH     r0,[r1,#0xc]
005e00  f7fffffe          BL       lwip_ntohs
005e04  f0100f01          TST      r0,#1
005e08  d007              BEQ      |L1.24090|
;;;1321             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
005e0a  bf00              NOP      
005e0c  bf00              NOP      
;;;1322             recv_flags |= TF_GOT_FIN;
005e0e  48a5              LDR      r0,|L1.24740|
005e10  7800              LDRB     r0,[r0,#0]  ; recv_flags
005e12  f0400020          ORR      r0,r0,#0x20
005e16  49a3              LDR      r1,|L1.24740|
005e18  7008              STRB     r0,[r1,#0]
                  |L1.24090|
;;;1323           }
;;;1324   
;;;1325   #if TCP_QUEUE_OOSEQ
;;;1326           /* We now check if we have segments on the ->ooseq queue that
;;;1327              are now in sequence. */
;;;1328           while (pcb->ooseq != NULL &&
005e1a  e057              B        |L1.24268|
                  |L1.24092|
;;;1329                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1330   
;;;1331             cseg = pcb->ooseq;
005e1c  6f66              LDR      r6,[r4,#0x74]
;;;1332             seqno = pcb->ooseq->tcphdr->seqno;
005e1e  6f60              LDR      r0,[r4,#0x74]
005e20  6900              LDR      r0,[r0,#0x10]
005e22  6840              LDR      r0,[r0,#4]
005e24  499d              LDR      r1,|L1.24732|
005e26  6008              STR      r0,[r1,#0]  ; seqno
;;;1333   
;;;1334             pcb->rcv_nxt += TCP_TCPLEN(cseg);
005e28  6931              LDR      r1,[r6,#0x10]
005e2a  8988              LDRH     r0,[r1,#0xc]
005e2c  f7fffffe          BL       lwip_ntohs
005e30  f0100f03          TST      r0,#3
005e34  d001              BEQ      |L1.24122|
005e36  2001              MOVS     r0,#1
005e38  e000              B        |L1.24124|
                  |L1.24122|
005e3a  2000              MOVS     r0,#0
                  |L1.24124|
005e3c  8931              LDRH     r1,[r6,#8]
005e3e  4408              ADD      r0,r0,r1
005e40  6aa1              LDR      r1,[r4,#0x28]
005e42  4408              ADD      r0,r0,r1
005e44  62a0              STR      r0,[r4,#0x28]
;;;1335             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
005e46  bf00              NOP      
005e48  6931              LDR      r1,[r6,#0x10]
005e4a  8988              LDRH     r0,[r1,#0xc]
005e4c  f7fffffe          BL       lwip_ntohs
005e50  bf00              NOP      
;;;1336                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1337             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
005e52  6931              LDR      r1,[r6,#0x10]
005e54  8988              LDRH     r0,[r1,#0xc]
005e56  f7fffffe          BL       lwip_ntohs
005e5a  f0100f03          TST      r0,#3
005e5e  d001              BEQ      |L1.24164|
005e60  2001              MOVS     r0,#1
005e62  e000              B        |L1.24166|
                  |L1.24164|
005e64  2000              MOVS     r0,#0
                  |L1.24166|
005e66  8931              LDRH     r1,[r6,#8]
005e68  4408              ADD      r0,r0,r1
005e6a  8da1              LDRH     r1,[r4,#0x2c]
005e6c  1a08              SUBS     r0,r1,r0
005e6e  85a0              STRH     r0,[r4,#0x2c]
;;;1338   
;;;1339             tcp_update_rcv_ann_wnd(pcb);
005e70  4620              MOV      r0,r4
005e72  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1340   
;;;1341             if (cseg->p->tot_len > 0) {
005e76  6870              LDR      r0,[r6,#4]
005e78  8900              LDRH     r0,[r0,#8]
005e7a  2800              CMP      r0,#0
005e7c  dd0d              BLE      |L1.24218|
;;;1342               /* Chain this pbuf onto the pbuf that we will pass to
;;;1343                  the application. */
;;;1344               if (recv_data) {
005e7e  4888              LDR      r0,|L1.24736|
005e80  6800              LDR      r0,[r0,#0]  ; recv_data
005e82  b128              CBZ      r0,|L1.24208|
;;;1345                 pbuf_cat(recv_data, cseg->p);
005e84  4886              LDR      r0,|L1.24736|
005e86  6871              LDR      r1,[r6,#4]
005e88  6800              LDR      r0,[r0,#0]  ; recv_data
005e8a  f7fffffe          BL       pbuf_cat
005e8e  e002              B        |L1.24214|
                  |L1.24208|
;;;1346               } else {
;;;1347                 recv_data = cseg->p;
005e90  4983              LDR      r1,|L1.24736|
005e92  6870              LDR      r0,[r6,#4]
005e94  6008              STR      r0,[r1,#0]  ; recv_data
                  |L1.24214|
;;;1348               }
;;;1349               cseg->p = NULL;
005e96  2000              MOVS     r0,#0
005e98  6070              STR      r0,[r6,#4]
                  |L1.24218|
;;;1350             }
;;;1351             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
005e9a  6931              LDR      r1,[r6,#0x10]
005e9c  8988              LDRH     r0,[r1,#0xc]
005e9e  f7fffffe          BL       lwip_ntohs
005ea2  f0100f01          TST      r0,#1
005ea6  d00c              BEQ      |L1.24258|
;;;1352               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
005ea8  bf00              NOP      
005eaa  bf00              NOP      
;;;1353               recv_flags |= TF_GOT_FIN;
005eac  487d              LDR      r0,|L1.24740|
005eae  7800              LDRB     r0,[r0,#0]  ; recv_flags
005eb0  f0400020          ORR      r0,r0,#0x20
005eb4  497b              LDR      r1,|L1.24740|
005eb6  7008              STRB     r0,[r1,#0]
;;;1354               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
005eb8  7e20              LDRB     r0,[r4,#0x18]
005eba  2804              CMP      r0,#4
005ebc  d101              BNE      |L1.24258|
;;;1355                 pcb->state = CLOSE_WAIT;
005ebe  2007              MOVS     r0,#7
005ec0  7620              STRB     r0,[r4,#0x18]
                  |L1.24258|
;;;1356               } 
;;;1357             }
;;;1358   
;;;1359             pcb->ooseq = cseg->next;
005ec2  6830              LDR      r0,[r6,#0]
005ec4  6760              STR      r0,[r4,#0x74]
;;;1360             tcp_seg_free(cseg);
005ec6  4630              MOV      r0,r6
005ec8  f7fffffe          BL       tcp_seg_free
                  |L1.24268|
005ecc  6f60              LDR      r0,[r4,#0x74]         ;1328
005ece  b128              CBZ      r0,|L1.24284|
005ed0  6f60              LDR      r0,[r4,#0x74]         ;1329
005ed2  6900              LDR      r0,[r0,#0x10]         ;1329
005ed4  6840              LDR      r0,[r0,#4]            ;1329
005ed6  6aa1              LDR      r1,[r4,#0x28]         ;1329
005ed8  4288              CMP      r0,r1                 ;1329
005eda  d09f              BEQ      |L1.24092|
                  |L1.24284|
;;;1361           }
;;;1362   #endif /* TCP_QUEUE_OOSEQ */
;;;1363   
;;;1364   
;;;1365           /* Acknowledge the segment(s). */
;;;1366           tcp_ack(pcb);
005edc  bf00              NOP      
005ede  7fa0              LDRB     r0,[r4,#0x1e]
005ee0  f0100f01          TST      r0,#1
005ee4  d008              BEQ      |L1.24312|
005ee6  7fa0              LDRB     r0,[r4,#0x1e]
005ee8  f0200001          BIC      r0,r0,#1
005eec  77a0              STRB     r0,[r4,#0x1e]
005eee  7fa0              LDRB     r0,[r4,#0x1e]
005ef0  f0400002          ORR      r0,r0,#2
005ef4  77a0              STRB     r0,[r4,#0x1e]
005ef6  e003              B        |L1.24320|
                  |L1.24312|
005ef8  7fa0              LDRB     r0,[r4,#0x1e]
005efa  f0400001          ORR      r0,r0,#1
005efe  77a0              STRB     r0,[r4,#0x1e]
                  |L1.24320|
005f00  e105              B        |L1.24846|
                  |L1.24322|
;;;1367   
;;;1368         } else {
;;;1369           /* We get here if the incoming segment is out-of-sequence. */
;;;1370           tcp_send_empty_ack(pcb);
005f02  4620              MOV      r0,r4
005f04  f7fffffe          BL       tcp_send_empty_ack
;;;1371   #if TCP_QUEUE_OOSEQ
;;;1372           /* We queue the segment on the ->ooseq queue. */
;;;1373           if (pcb->ooseq == NULL) {
005f08  6f60              LDR      r0,[r4,#0x74]
005f0a  b920              CBNZ     r0,|L1.24342|
;;;1374             pcb->ooseq = tcp_seg_copy(&inseg);
005f0c  4861              LDR      r0,|L1.24724|
005f0e  f7fffffe          BL       tcp_seg_copy
005f12  6760              STR      r0,[r4,#0x74]
005f14  e0fb              B        |L1.24846|
                  |L1.24342|
;;;1375           } else {
;;;1376             /* If the queue is not empty, we walk through the queue and
;;;1377                try to find a place where the sequence number of the
;;;1378                incoming segment is between the sequence numbers of the
;;;1379                previous and the next segment on the ->ooseq queue. That is
;;;1380                the place where we put the incoming segment. If needed, we
;;;1381                trim the second edges of the previous and the incoming
;;;1382                segment so that it will fit into the sequence.
;;;1383   
;;;1384                If the incoming segment has the same sequence number as a
;;;1385                segment on the ->ooseq queue, we discard the segment that
;;;1386                contains less data. */
;;;1387   
;;;1388             prev = NULL;
005f16  2700              MOVS     r7,#0
;;;1389             for(next = pcb->ooseq; next != NULL; next = next->next) {
005f18  6f65              LDR      r5,[r4,#0x74]
005f1a  e0dc              B        |L1.24790|
                  |L1.24348|
;;;1390               if (seqno == next->tcphdr->seqno) {
005f1c  6928              LDR      r0,[r5,#0x10]
005f1e  6840              LDR      r0,[r0,#4]
005f20  495e              LDR      r1,|L1.24732|
005f22  6809              LDR      r1,[r1,#0]  ; seqno
005f24  4288              CMP      r0,r1
005f26  d113              BNE      |L1.24400|
;;;1391                 /* The sequence number of the incoming segment is the
;;;1392                    same as the sequence number of the segment on
;;;1393                    ->ooseq. We check the lengths to see which one to
;;;1394                    discard. */
;;;1395                 if (inseg.len > next->len) {
005f28  485a              LDR      r0,|L1.24724|
005f2a  8900              LDRH     r0,[r0,#8]  ; inseg
005f2c  8929              LDRH     r1,[r5,#8]
005f2e  4288              CMP      r0,r1
005f30  dd0d              BLE      |L1.24398|
;;;1396                   /* The incoming segment is larger than the old
;;;1397                      segment. We replace some segments with the new
;;;1398                      one. */
;;;1399                   cseg = tcp_seg_copy(&inseg);
005f32  4858              LDR      r0,|L1.24724|
005f34  f7fffffe          BL       tcp_seg_copy
005f38  4606              MOV      r6,r0
;;;1400                   if (cseg != NULL) {
005f3a  b13e              CBZ      r6,|L1.24396|
;;;1401                     if (prev != NULL) {
005f3c  b10f              CBZ      r7,|L1.24386|
;;;1402                       prev->next = cseg;
005f3e  603e              STR      r6,[r7,#0]
005f40  e000              B        |L1.24388|
                  |L1.24386|
;;;1403                     } else {
;;;1404                       pcb->ooseq = cseg;
005f42  6766              STR      r6,[r4,#0x74]
                  |L1.24388|
;;;1405                     }
;;;1406                     tcp_oos_insert_segment(cseg, next);
005f44  4629              MOV      r1,r5
005f46  4630              MOV      r0,r6
005f48  f7fffffe          BL       tcp_oos_insert_segment
                  |L1.24396|
;;;1407                   }
;;;1408                   break;
005f4c  e0c6              B        |L1.24796|
                  |L1.24398|
;;;1409                 } else {
;;;1410                   /* Either the lenghts are the same or the incoming
;;;1411                      segment was smaller than the old one; in either
;;;1412                      case, we ditch the incoming segment. */
;;;1413                   break;
005f4e  e0c5              B        |L1.24796|
                  |L1.24400|
;;;1414                 }
;;;1415               } else {
;;;1416                 if (prev == NULL) {
005f50  b987              CBNZ     r7,|L1.24436|
;;;1417                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
005f52  6928              LDR      r0,[r5,#0x10]
005f54  6840              LDR      r0,[r0,#4]
005f56  4951              LDR      r1,|L1.24732|
005f58  6809              LDR      r1,[r1,#0]  ; seqno
005f5a  1a08              SUBS     r0,r1,r0
005f5c  d538              BPL      |L1.24528|
;;;1418                     /* The sequence number of the incoming segment is lower
;;;1419                        than the sequence number of the first segment on the
;;;1420                        queue. We put the incoming segment first on the
;;;1421                        queue. */
;;;1422                     cseg = tcp_seg_copy(&inseg);
005f5e  484d              LDR      r0,|L1.24724|
005f60  f7fffffe          BL       tcp_seg_copy
005f64  4606              MOV      r6,r0
;;;1423                     if (cseg != NULL) {
005f66  b126              CBZ      r6,|L1.24434|
;;;1424                       pcb->ooseq = cseg;
005f68  6766              STR      r6,[r4,#0x74]
;;;1425                       tcp_oos_insert_segment(cseg, next);
005f6a  4629              MOV      r1,r5
005f6c  4630              MOV      r0,r6
005f6e  f7fffffe          BL       tcp_oos_insert_segment
                  |L1.24434|
;;;1426                     }
;;;1427                     break;
005f72  e0b3              B        |L1.24796|
                  |L1.24436|
;;;1428                   }
;;;1429                 } else {
;;;1430                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1431                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1432                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
005f74  6938              LDR      r0,[r7,#0x10]
005f76  6840              LDR      r0,[r0,#4]
005f78  f1000001          ADD      r0,r0,#1
005f7c  4947              LDR      r1,|L1.24732|
005f7e  6809              LDR      r1,[r1,#0]  ; seqno
005f80  1a08              SUBS     r0,r1,r0
005f82  d425              BMI      |L1.24528|
005f84  6928              LDR      r0,[r5,#0x10]
005f86  6840              LDR      r0,[r0,#4]
005f88  1e40              SUBS     r0,r0,#1
005f8a  4944              LDR      r1,|L1.24732|
005f8c  6809              LDR      r1,[r1,#0]  ; seqno
005f8e  1a08              SUBS     r0,r1,r0
005f90  2800              CMP      r0,#0
005f92  dc1d              BGT      |L1.24528|
;;;1433                     /* The sequence number of the incoming segment is in
;;;1434                        between the sequence numbers of the previous and
;;;1435                        the next segment on ->ooseq. We trim trim the previous
;;;1436                        segment, delete next segments that included in received segment
;;;1437                        and trim received, if needed. */
;;;1438                     cseg = tcp_seg_copy(&inseg);
005f94  483f              LDR      r0,|L1.24724|
005f96  f7fffffe          BL       tcp_seg_copy
005f9a  4606              MOV      r6,r0
;;;1439                     if (cseg != NULL) {
005f9c  b1be              CBZ      r6,|L1.24526|
;;;1440                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
005f9e  6938              LDR      r0,[r7,#0x10]
005fa0  6840              LDR      r0,[r0,#4]
005fa2  8939              LDRH     r1,[r7,#8]
005fa4  4408              ADD      r0,r0,r1
005fa6  493d              LDR      r1,|L1.24732|
005fa8  6809              LDR      r1,[r1,#0]  ; seqno
005faa  1a40              SUBS     r0,r0,r1
005fac  2800              CMP      r0,#0
005fae  dd09              BLE      |L1.24516|
;;;1441                         /* We need to trim the prev segment. */
;;;1442                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
005fb0  6938              LDR      r0,[r7,#0x10]
005fb2  8880              LDRH     r0,[r0,#4]
005fb4  4939              LDR      r1,|L1.24732|
005fb6  8809              LDRH     r1,[r1,#0]  ; seqno
005fb8  1a08              SUBS     r0,r1,r0
005fba  8138              STRH     r0,[r7,#8]
;;;1443                         pbuf_realloc(prev->p, prev->len);
005fbc  8939              LDRH     r1,[r7,#8]
005fbe  6878              LDR      r0,[r7,#4]
005fc0  f7fffffe          BL       pbuf_realloc
                  |L1.24516|
;;;1444                       }
;;;1445                       prev->next = cseg;
005fc4  603e              STR      r6,[r7,#0]
;;;1446                       tcp_oos_insert_segment(cseg, next);
005fc6  4629              MOV      r1,r5
005fc8  4630              MOV      r0,r6
005fca  f7fffffe          BL       tcp_oos_insert_segment
                  |L1.24526|
;;;1447                     }
;;;1448                     break;
005fce  e085              B        |L1.24796|
                  |L1.24528|
;;;1449                   }
;;;1450                 }
;;;1451                 /* If the "next" segment is the last segment on the
;;;1452                    ooseq queue, we add the incoming segment to the end
;;;1453                    of the list. */
;;;1454                 if (next->next == NULL &&
005fd0  6828              LDR      r0,[r5,#0]
005fd2  bbe8              CBNZ     r0,|L1.24656|
;;;1455                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
005fd4  6928              LDR      r0,[r5,#0x10]
005fd6  6840              LDR      r0,[r0,#4]
005fd8  4930              LDR      r1,|L1.24732|
005fda  6809              LDR      r1,[r1,#0]  ; seqno
005fdc  1a08              SUBS     r0,r1,r0
005fde  2800              CMP      r0,#0
005fe0  dd77              BLE      |L1.24786|
;;;1456                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
005fe2  6929              LDR      r1,[r5,#0x10]
005fe4  8988              LDRH     r0,[r1,#0xc]
005fe6  f7fffffe          BL       lwip_ntohs
005fea  f0100f01          TST      r0,#1
005fee  d000              BEQ      |L1.24562|
;;;1457                     /* segment "next" already contains all data */
;;;1458                     break;
005ff0  e074              B        |L1.24796|
                  |L1.24562|
;;;1459                   }
;;;1460                   next->next = tcp_seg_copy(&inseg);
005ff2  4828              LDR      r0,|L1.24724|
005ff4  f7fffffe          BL       tcp_seg_copy
005ff8  6028              STR      r0,[r5,#0]
;;;1461                   if (next->next != NULL) {
005ffa  6828              LDR      r0,[r5,#0]
005ffc  b348              CBZ      r0,|L1.24658|
;;;1462                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
005ffe  6928              LDR      r0,[r5,#0x10]
006000  6840              LDR      r0,[r0,#4]
006002  8929              LDRH     r1,[r5,#8]
006004  4408              ADD      r0,r0,r1
006006  4925              LDR      r1,|L1.24732|
006008  6809              LDR      r1,[r1,#0]  ; seqno
00600a  1a40              SUBS     r0,r0,r1
00600c  2800              CMP      r0,#0
00600e  dd09              BLE      |L1.24612|
;;;1463                       /* We need to trim the last segment. */
;;;1464                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
006010  6928              LDR      r0,[r5,#0x10]
006012  8880              LDRH     r0,[r0,#4]
006014  4921              LDR      r1,|L1.24732|
006016  8809              LDRH     r1,[r1,#0]  ; seqno
006018  1a08              SUBS     r0,r1,r0
00601a  8128              STRH     r0,[r5,#8]
;;;1465                       pbuf_realloc(next->p, next->len);
00601c  8929              LDRH     r1,[r5,#8]
00601e  6868              LDR      r0,[r5,#4]
006020  f7fffffe          BL       pbuf_realloc
                  |L1.24612|
;;;1466                     }
;;;1467                     /* check if the remote side overruns our receive window */
;;;1468                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
006024  8da1              LDRH     r1,[r4,#0x2c]
006026  6aa0              LDR      r0,[r4,#0x28]
006028  4401              ADD      r1,r1,r0
00602a  481b              LDR      r0,|L1.24728|
00602c  8800              LDRH     r0,[r0,#0]  ; tcplen
00602e  4a1b              LDR      r2,|L1.24732|
006030  6812              LDR      r2,[r2,#0]  ; seqno
006032  4410              ADD      r0,r0,r2
006034  4281              CMP      r1,r0
006036  d24b              BCS      |L1.24784|
;;;1469                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
006038  bf00              NOP      
00603a  bf00              NOP      
;;;1470                                   ("tcp_receive: other end overran receive window"
;;;1471                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1472                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1473                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
00603c  6829              LDR      r1,[r5,#0]
00603e  6909              LDR      r1,[r1,#0x10]
006040  8988              LDRH     r0,[r1,#0xc]
006042  f7fffffe          BL       lwip_ntohs
006046  f0100f01          TST      r0,#1
00604a  d016              BEQ      |L1.24698|
;;;1474                         /* Must remove the FIN from the header as we're trimming 
;;;1475                          * that byte of sequence-space from the packet */
;;;1476                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
00604c  6829              LDR      r1,[r5,#0]
00604e  e001              B        |L1.24660|
                  |L1.24656|
006050  e03f              B        |L1.24786|
                  |L1.24658|
006052  e03d              B        |L1.24784|
                  |L1.24660|
006054  6909              LDR      r1,[r1,#0x10]
006056  8988              LDRH     r0,[r1,#0xc]
006058  f7fffffe          BL       lwip_ntohs
00605c  f000033e          AND      r3,r0,#0x3e
006060  4618              MOV      r0,r3
006062  f7fffffe          BL       lwip_htons
006066  6829              LDR      r1,[r5,#0]
006068  6909              LDR      r1,[r1,#0x10]
00606a  8989              LDRH     r1,[r1,#0xc]
00606c  f24c02ff          MOV      r2,#0xc0ff
006070  4011              ANDS     r1,r1,r2
006072  4308              ORRS     r0,r0,r1
006074  6829              LDR      r1,[r5,#0]
006076  6909              LDR      r1,[r1,#0x10]
006078  8188              STRH     r0,[r1,#0xc]
                  |L1.24698|
;;;1477                       }
;;;1478                       /* Adjust length of segment to fit in the window. */
;;;1479                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
00607a  8d20              LDRH     r0,[r4,#0x28]
00607c  8da1              LDRH     r1,[r4,#0x2c]
00607e  4408              ADD      r0,r0,r1
006080  4906              LDR      r1,|L1.24732|
006082  8809              LDRH     r1,[r1,#0]  ; seqno
006084  1a40              SUBS     r0,r0,r1
006086  6829              LDR      r1,[r5,#0]
006088  8108              STRH     r0,[r1,#8]
;;;1480                       pbuf_realloc(next->next->p, next->next->len);
00608a  682a              LDR      r2,[r5,#0]
00608c  8911              LDRH     r1,[r2,#8]
00608e  6850              LDR      r0,[r2,#4]
006090  e00a              B        |L1.24744|
006092  0000              DCW      0x0000
                  |L1.24724|
                          DCD      inseg
                  |L1.24728|
                          DCD      tcplen
                  |L1.24732|
                          DCD      seqno
                  |L1.24736|
                          DCD      recv_data
                  |L1.24740|
                          DCD      recv_flags
                  |L1.24744|
0060a8  f7fffffe          BL       pbuf_realloc
;;;1481                       tcplen = TCP_TCPLEN(next->next);
0060ac  6829              LDR      r1,[r5,#0]
0060ae  6909              LDR      r1,[r1,#0x10]
0060b0  8988              LDRH     r0,[r1,#0xc]
0060b2  f7fffffe          BL       lwip_ntohs
0060b6  f0100f03          TST      r0,#3
0060ba  d001              BEQ      |L1.24768|
0060bc  2001              MOVS     r0,#1
0060be  e000              B        |L1.24770|
                  |L1.24768|
0060c0  2000              MOVS     r0,#0
                  |L1.24770|
0060c2  6829              LDR      r1,[r5,#0]
0060c4  8909              LDRH     r1,[r1,#8]
0060c6  4408              ADD      r0,r0,r1
0060c8  49f5              LDR      r1,|L1.25760|
0060ca  8008              STRH     r0,[r1,#0]
;;;1482                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0060cc  bf00              NOP      
0060ce  bf00              NOP      
                  |L1.24784|
;;;1483                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1484                     }
;;;1485                   }
;;;1486                   break;
0060d0  e004              B        |L1.24796|
                  |L1.24786|
;;;1487                 }
;;;1488               }
;;;1489               prev = next;
0060d2  462f              MOV      r7,r5
0060d4  682d              LDR      r5,[r5,#0]            ;1389
                  |L1.24790|
0060d6  2d00              CMP      r5,#0                 ;1389
0060d8  f47faf20          BNE      |L1.24348|
                  |L1.24796|
0060dc  e017              B        |L1.24846|
                  |L1.24798|
;;;1490             }
;;;1491           }
;;;1492   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1493           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1494              and throw away everything above that limit. */
;;;1495           ooseq_blen = 0;
;;;1496           ooseq_qlen = 0;
;;;1497           prev = NULL;
;;;1498           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1499             struct pbuf *p = next->p;
;;;1500             ooseq_blen += p->tot_len;
;;;1501             ooseq_qlen += pbuf_clen(p);
;;;1502             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1503                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1504                /* too much ooseq data, dump this and everything after it */
;;;1505                tcp_segs_free(next);
;;;1506                if (prev == NULL) {
;;;1507                  /* first ooseq segment is too much, dump the whole queue */
;;;1508                  pcb->ooseq = NULL;
;;;1509                } else {
;;;1510                  /* just dump 'next' and everything after it */
;;;1511                  prev->next = NULL;
;;;1512                }
;;;1513                break;
;;;1514             }
;;;1515           }
;;;1516   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1517   #endif /* TCP_QUEUE_OOSEQ */
;;;1518         }
;;;1519       } else {
;;;1520         /* The incoming segment is not withing the window. */
;;;1521         tcp_send_empty_ack(pcb);
0060de  4620              MOV      r0,r4
0060e0  f7fffffe          BL       tcp_send_empty_ack
0060e4  e013              B        |L1.24846|
                  |L1.24806|
;;;1522       }
;;;1523     } else {
;;;1524       /* Segments with length 0 is taken care of here. Segments that
;;;1525          fall out of the window are ACKed. */
;;;1526       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1527         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1528       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
0060e6  49ef              LDR      r1,|L1.25764|
0060e8  6aa0              LDR      r0,[r4,#0x28]
0060ea  6809              LDR      r1,[r1,#0]  ; seqno
0060ec  1a08              SUBS     r0,r1,r0
0060ee  d408              BMI      |L1.24834|
0060f0  8da1              LDRH     r1,[r4,#0x2c]
0060f2  6aa0              LDR      r0,[r4,#0x28]
0060f4  4408              ADD      r0,r0,r1
0060f6  1e40              SUBS     r0,r0,#1
0060f8  49ea              LDR      r1,|L1.25764|
0060fa  6809              LDR      r1,[r1,#0]  ; seqno
0060fc  1a08              SUBS     r0,r1,r0
0060fe  2800              CMP      r0,#0
006100  dd05              BLE      |L1.24846|
                  |L1.24834|
;;;1529         tcp_ack_now(pcb);
006102  bf00              NOP      
006104  7fa0              LDRB     r0,[r4,#0x1e]
006106  f0400002          ORR      r0,r0,#2
00610a  77a0              STRB     r0,[r4,#0x1e]
00610c  bf00              NOP      
                  |L1.24846|
;;;1530       }
;;;1531     }
;;;1532   }
00610e  e8bd8ffe          POP      {r1-r11,pc}
;;;1533   
                          ENDP

                  tcp_parseopt PROC
;;;1542   static void
;;;1543   tcp_parseopt(struct tcp_pcb *pcb)
006112  e92d41f0          PUSH     {r4-r8,lr}
;;;1544   {
006116  4607              MOV      r7,r0
;;;1545     u16_t c, max_c;
;;;1546     u16_t mss;
;;;1547     u8_t *opts, opt;
;;;1548   #if LWIP_TCP_TIMESTAMPS
;;;1549     u32_t tsval;
;;;1550   #endif
;;;1551   
;;;1552     opts = (u8_t *)tcphdr + TCP_HLEN;
006118  48e3              LDR      r0,|L1.25768|
00611a  6800              LDR      r0,[r0,#0]  ; tcphdr
00611c  f1000414          ADD      r4,r0,#0x14
;;;1553   
;;;1554     /* Parse the TCP MSS option, if present. */
;;;1555     if(TCPH_HDRLEN(tcphdr) > 0x5) {
006120  49e1              LDR      r1,|L1.25768|
006122  6809              LDR      r1,[r1,#0]  ; tcphdr
006124  8988              LDRH     r0,[r1,#0xc]
006126  f7fffffe          BL       lwip_ntohs
00612a  2105              MOVS     r1,#5
00612c  ebb13f20          CMP      r1,r0,ASR #12
006130  da51              BGE      |L1.25046|
;;;1556       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
006132  49dd              LDR      r1,|L1.25768|
006134  6809              LDR      r1,[r1,#0]  ; tcphdr
006136  8988              LDRH     r0,[r1,#0xc]
006138  f7fffffe          BL       lwip_ntohs
00613c  2105              MOVS     r1,#5
00613e  ebc13020          RSB      r0,r1,r0,ASR #12
006142  f64f71ff          MOV      r1,#0xffff
006146  ea010580          AND      r5,r1,r0,LSL #2
;;;1557       for (c = 0; c < max_c; ) {
00614a  2300              MOVS     r3,#0
00614c  e041              B        |L1.25042|
                  |L1.24910|
;;;1558         opt = opts[c];
00614e  f8148003          LDRB     r8,[r4,r3]
;;;1559         switch (opt) {
006152  f1b80f00          CMP      r8,#0
006156  d006              BEQ      |L1.24934|
006158  f1b80f01          CMP      r8,#1
00615c  d007              BEQ      |L1.24942|
00615e  f1b80f02          CMP      r8,#2
006162  d128              BNE      |L1.25014|
006164  e008              B        |L1.24952|
                  |L1.24934|
;;;1560         case 0x00:
;;;1561           /* End of options. */
;;;1562           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
006166  bf00              NOP      
006168  bf00              NOP      
                  |L1.24938|
;;;1563           return;
;;;1564         case 0x01:
;;;1565           /* NOP option. */
;;;1566           ++c;
;;;1567           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1568           break;
;;;1569         case 0x02:
;;;1570           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1571           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1572             /* Bad length */
;;;1573             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1574             return;
;;;1575           }
;;;1576           /* An MSS option with the right option length. */
;;;1577           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1578           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1579           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1580           /* Advance to next option */
;;;1581           c += 0x04;
;;;1582           break;
;;;1583   #if LWIP_TCP_TIMESTAMPS
;;;1584         case 0x08:
;;;1585           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1586           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1587             /* Bad length */
;;;1588             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1589             return;
;;;1590           }
;;;1591           /* TCP timestamp option with valid length */
;;;1592           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1593             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1594           if (flags & TCP_SYN) {
;;;1595             pcb->ts_recent = ntohl(tsval);
;;;1596             pcb->flags |= TF_TIMESTAMP;
;;;1597           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1598             pcb->ts_recent = ntohl(tsval);
;;;1599           }
;;;1600           /* Advance to next option */
;;;1601           c += 0x0A;
;;;1602           break;
;;;1603   #endif
;;;1604         default:
;;;1605           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1606           if (opts[c + 1] == 0) {
;;;1607             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1608             /* If the length field is zero, the options are malformed
;;;1609                and we don't process them further. */
;;;1610             return;
;;;1611           }
;;;1612           /* All other options have a length field, so that we easily
;;;1613              can skip past them. */
;;;1614           c += opts[c + 1];
;;;1615         }
;;;1616       }
;;;1617     }
;;;1618   }
00616a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.24942|
00616e  1c58              ADDS     r0,r3,#1              ;1566
006170  b283              UXTH     r3,r0                 ;1566
006172  bf00              NOP                            ;1567
006174  bf00              NOP                            ;1567
006176  e02b              B        |L1.25040|
                  |L1.24952|
006178  bf00              NOP                            ;1570
00617a  bf00              NOP                            ;1570
00617c  1c58              ADDS     r0,r3,#1              ;1571
00617e  5c20              LDRB     r0,[r4,r0]            ;1571
006180  2804              CMP      r0,#4                 ;1571
006182  d102              BNE      |L1.24970|
006184  1d18              ADDS     r0,r3,#4              ;1571
006186  42a8              CMP      r0,r5                 ;1571
006188  dd02              BLE      |L1.24976|
                  |L1.24970|
00618a  bf00              NOP                            ;1573
00618c  bf00              NOP                            ;1573
00618e  e7ec              B        |L1.24938|
                  |L1.24976|
006190  1cd8              ADDS     r0,r3,#3              ;1577
006192  5c21              LDRB     r1,[r4,r0]            ;1577
006194  1c98              ADDS     r0,r3,#2              ;1577
006196  5c20              LDRB     r0,[r4,r0]            ;1577
006198  ea412600          ORR      r6,r1,r0,LSL #8       ;1577
00619c  f24050dc          MOV      r0,#0x5dc             ;1579
0061a0  4286              CMP      r6,r0                 ;1579
0061a2  dc00              BGT      |L1.24998|
0061a4  b916              CBNZ     r6,|L1.25004|
                  |L1.24998|
0061a6  f24050dc          MOV      r0,#0x5dc             ;1579
0061aa  e000              B        |L1.25006|
                  |L1.25004|
0061ac  4630              MOV      r0,r6                 ;1579
                  |L1.25006|
0061ae  86f8              STRH     r0,[r7,#0x36]         ;1579
0061b0  1d18              ADDS     r0,r3,#4              ;1581
0061b2  b283              UXTH     r3,r0                 ;1581
0061b4  e00c              B        |L1.25040|
                  |L1.25014|
0061b6  bf00              NOP                            ;1605
0061b8  bf00              NOP                            ;1605
0061ba  1c58              ADDS     r0,r3,#1              ;1606
0061bc  5c20              LDRB     r0,[r4,r0]            ;1606
0061be  b910              CBNZ     r0,|L1.25030|
0061c0  bf00              NOP                            ;1607
0061c2  bf00              NOP                            ;1607
0061c4  e7d1              B        |L1.24938|
                  |L1.25030|
0061c6  1c58              ADDS     r0,r3,#1              ;1614
0061c8  5c20              LDRB     r0,[r4,r0]            ;1614
0061ca  4418              ADD      r0,r0,r3              ;1614
0061cc  b283              UXTH     r3,r0                 ;1614
0061ce  bf00              NOP                            ;1559
                  |L1.25040|
0061d0  bf00              NOP                            ;1568
                  |L1.25042|
0061d2  42ab              CMP      r3,r5                 ;1557
0061d4  dbbb              BLT      |L1.24910|
                  |L1.25046|
0061d6  bf00              NOP      
0061d8  e7c7              B        |L1.24938|
;;;1619   
                          ENDP

                  tcp_process PROC
;;;575    static err_t
;;;576    tcp_process(struct tcp_pcb *pcb)
0061da  e92d41fc          PUSH     {r2-r8,lr}
;;;577    {
0061de  4604              MOV      r4,r0
;;;578      struct tcp_seg *rseg;
;;;579      u8_t acceptable = 0;
0061e0  f04f0800          MOV      r8,#0
;;;580      err_t err;
;;;581    
;;;582      err = ERR_OK;
0061e4  2600              MOVS     r6,#0
;;;583    
;;;584      /* Process incoming RST segments. */
;;;585      if (flags & TCP_RST) {
0061e6  48b1              LDR      r0,|L1.25772|
0061e8  7800              LDRB     r0,[r0,#0]  ; flags
0061ea  f0100f04          TST      r0,#4
0061ee  d034              BEQ      |L1.25178|
;;;586        /* First, determine if the reset is acceptable. */
;;;587        if (pcb->state == SYN_SENT) {
0061f0  7e20              LDRB     r0,[r4,#0x18]
0061f2  2802              CMP      r0,#2
0061f4  d107              BNE      |L1.25094|
;;;588          if (ackno == pcb->snd_nxt) {
0061f6  49ae              LDR      r1,|L1.25776|
0061f8  6d20              LDR      r0,[r4,#0x50]
0061fa  6809              LDR      r1,[r1,#0]  ; ackno
0061fc  4288              CMP      r0,r1
0061fe  d111              BNE      |L1.25124|
;;;589            acceptable = 1;
006200  f04f0801          MOV      r8,#1
006204  e00e              B        |L1.25124|
                  |L1.25094|
;;;590          }
;;;591        } else {
;;;592          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
006206  49a7              LDR      r1,|L1.25764|
006208  6aa0              LDR      r0,[r4,#0x28]
00620a  6809              LDR      r1,[r1,#0]  ; seqno
00620c  1a08              SUBS     r0,r1,r0
00620e  d409              BMI      |L1.25124|
006210  8da1              LDRH     r1,[r4,#0x2c]
006212  6aa0              LDR      r0,[r4,#0x28]
006214  4408              ADD      r0,r0,r1
006216  49a3              LDR      r1,|L1.25764|
006218  6809              LDR      r1,[r1,#0]  ; seqno
00621a  1a08              SUBS     r0,r1,r0
00621c  2800              CMP      r0,#0
00621e  dc01              BGT      |L1.25124|
;;;593                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;594            acceptable = 1;
006220  f04f0801          MOV      r8,#1
                  |L1.25124|
;;;595          }
;;;596        }
;;;597    
;;;598        if (acceptable) {
006224  f1b80f00          CMP      r8,#0
006228  d011              BEQ      |L1.25166|
;;;599          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
00622a  bf00              NOP      
00622c  bf00              NOP      
;;;600          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
00622e  bf00              NOP      
006230  bf00              NOP      
;;;601          recv_flags |= TF_RESET;
006232  48a0              LDR      r0,|L1.25780|
006234  7800              LDRB     r0,[r0,#0]  ; recv_flags
006236  f0400008          ORR      r0,r0,#8
00623a  499e              LDR      r1,|L1.25780|
00623c  7008              STRB     r0,[r1,#0]
;;;602          pcb->flags &= ~TF_ACK_DELAY;
00623e  7fa0              LDRB     r0,[r4,#0x1e]
006240  f0200001          BIC      r0,r0,#1
006244  77a0              STRB     r0,[r4,#0x1e]
;;;603          return ERR_RST;
006246  f06f000a          MVN      r0,#0xa
                  |L1.25162|
;;;604        } else {
;;;605          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;606           seqno, pcb->rcv_nxt));
;;;607          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;608           seqno, pcb->rcv_nxt));
;;;609          return ERR_OK;
;;;610        }
;;;611      }
;;;612    
;;;613      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;614        /* Cope with new connection attempt after remote end crashed */
;;;615        tcp_ack_now(pcb);
;;;616        return ERR_OK;
;;;617      }
;;;618      
;;;619      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;620        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;621        pcb->tmr = tcp_ticks;
;;;622      }
;;;623      pcb->keep_cnt_sent = 0;
;;;624    
;;;625      tcp_parseopt(pcb);
;;;626    
;;;627      /* Do different things depending on the TCP state. */
;;;628      switch (pcb->state) {
;;;629      case SYN_SENT:
;;;630        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;631         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;632        /* received SYN ACK with expected sequence number? */
;;;633        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;634            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;635          pcb->snd_buf++;
;;;636          pcb->rcv_nxt = seqno + 1;
;;;637          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;638          pcb->lastack = ackno;
;;;639          pcb->snd_wnd = tcphdr->wnd;
;;;640          pcb->snd_wnd_max = tcphdr->wnd;
;;;641          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;642          pcb->state = ESTABLISHED;
;;;643    
;;;644    #if TCP_CALCULATE_EFF_SEND_MSS
;;;645          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;646    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;647    
;;;648          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;649           * but for the default value of pcb->mss) */
;;;650          pcb->ssthresh = pcb->mss * 10;
;;;651    
;;;652          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;653          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;654          --pcb->snd_queuelen;
;;;655          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;656          rseg = pcb->unacked;
;;;657          pcb->unacked = rseg->next;
;;;658          tcp_seg_free(rseg);
;;;659    
;;;660          /* If there's nothing left to acknowledge, stop the retransmit
;;;661             timer, otherwise reset it to start again */
;;;662          if(pcb->unacked == NULL)
;;;663            pcb->rtime = -1;
;;;664          else {
;;;665            pcb->rtime = 0;
;;;666            pcb->nrtx = 0;
;;;667          }
;;;668    
;;;669          /* Call the user specified function to call when sucessfully
;;;670           * connected. */
;;;671          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;672          if (err == ERR_ABRT) {
;;;673            return ERR_ABRT;
;;;674          }
;;;675          tcp_ack_now(pcb);
;;;676        }
;;;677        /* received ACK? possibly a half-open connection */
;;;678        else if (flags & TCP_ACK) {
;;;679          /* send a RST to bring the other side in a non-synchronized state. */
;;;680          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;681            tcphdr->dest, tcphdr->src);
;;;682        }
;;;683        break;
;;;684      case SYN_RCVD:
;;;685        if (flags & TCP_ACK) {
;;;686          /* expected ACK number? */
;;;687          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;688            u16_t old_cwnd;
;;;689            pcb->state = ESTABLISHED;
;;;690            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;691    #if LWIP_CALLBACK_API
;;;692            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;693    #endif
;;;694            /* Call the accept function. */
;;;695            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;696            if (err != ERR_OK) {
;;;697              /* If the accept function returns with an error, we abort
;;;698               * the connection. */
;;;699              /* Already aborted? */
;;;700              if (err != ERR_ABRT) {
;;;701                tcp_abort(pcb);
;;;702              }
;;;703              return ERR_ABRT;
;;;704            }
;;;705            old_cwnd = pcb->cwnd;
;;;706            /* If there was any data contained within this ACK,
;;;707             * we'd better pass it on to the application as well. */
;;;708            tcp_receive(pcb);
;;;709    
;;;710            /* Prevent ACK for SYN to generate a sent event */
;;;711            if (pcb->acked != 0) {
;;;712              pcb->acked--;
;;;713            }
;;;714    
;;;715            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;716    
;;;717            if (recv_flags & TF_GOT_FIN) {
;;;718              tcp_ack_now(pcb);
;;;719              pcb->state = CLOSE_WAIT;
;;;720            }
;;;721          } else {
;;;722            /* incorrect ACK number, send RST */
;;;723            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;724                    tcphdr->dest, tcphdr->src);
;;;725          }
;;;726        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;727          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;728          tcp_rexmit(pcb);
;;;729        }
;;;730        break;
;;;731      case CLOSE_WAIT:
;;;732        /* FALLTHROUGH */
;;;733      case ESTABLISHED:
;;;734        tcp_receive(pcb);
;;;735        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;736          tcp_ack_now(pcb);
;;;737          pcb->state = CLOSE_WAIT;
;;;738        }
;;;739        break;
;;;740      case FIN_WAIT_1:
;;;741        tcp_receive(pcb);
;;;742        if (recv_flags & TF_GOT_FIN) {
;;;743          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;744            LWIP_DEBUGF(TCP_DEBUG,
;;;745              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;746            tcp_ack_now(pcb);
;;;747            tcp_pcb_purge(pcb);
;;;748            TCP_RMV_ACTIVE(pcb);
;;;749            pcb->state = TIME_WAIT;
;;;750            TCP_REG(&tcp_tw_pcbs, pcb);
;;;751          } else {
;;;752            tcp_ack_now(pcb);
;;;753            pcb->state = CLOSING;
;;;754          }
;;;755        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;756          pcb->state = FIN_WAIT_2;
;;;757        }
;;;758        break;
;;;759      case FIN_WAIT_2:
;;;760        tcp_receive(pcb);
;;;761        if (recv_flags & TF_GOT_FIN) {
;;;762          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;763          tcp_ack_now(pcb);
;;;764          tcp_pcb_purge(pcb);
;;;765          TCP_RMV_ACTIVE(pcb);
;;;766          pcb->state = TIME_WAIT;
;;;767          TCP_REG(&tcp_tw_pcbs, pcb);
;;;768        }
;;;769        break;
;;;770      case CLOSING:
;;;771        tcp_receive(pcb);
;;;772        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;773          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;774          tcp_pcb_purge(pcb);
;;;775          TCP_RMV_ACTIVE(pcb);
;;;776          pcb->state = TIME_WAIT;
;;;777          TCP_REG(&tcp_tw_pcbs, pcb);
;;;778        }
;;;779        break;
;;;780      case LAST_ACK:
;;;781        tcp_receive(pcb);
;;;782        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;783          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;784          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;785          recv_flags |= TF_CLOSED;
;;;786        }
;;;787        break;
;;;788      default:
;;;789        break;
;;;790      }
;;;791      return ERR_OK;
;;;792    }
00624a  e8bd81fc          POP      {r2-r8,pc}
                  |L1.25166|
00624e  bf00              NOP                            ;605
006250  bf00              NOP                            ;605
006252  bf00              NOP                            ;607
006254  bf00              NOP                            ;607
006256  2000              MOVS     r0,#0                 ;609
006258  e7f7              B        |L1.25162|
                  |L1.25178|
00625a  4894              LDR      r0,|L1.25772|
00625c  7800              LDRB     r0,[r0,#0]            ;613  ; flags
00625e  f0100f02          TST      r0,#2                 ;613
006262  d00d              BEQ      |L1.25216|
006264  7e20              LDRB     r0,[r4,#0x18]         ;613
006266  2802              CMP      r0,#2                 ;613
006268  d00a              BEQ      |L1.25216|
00626a  7e20              LDRB     r0,[r4,#0x18]         ;613
00626c  2803              CMP      r0,#3                 ;613
00626e  d007              BEQ      |L1.25216|
006270  bf00              NOP                            ;615
006272  7fa0              LDRB     r0,[r4,#0x1e]         ;615
006274  f0400002          ORR      r0,r0,#2              ;615
006278  77a0              STRB     r0,[r4,#0x1e]         ;615
00627a  bf00              NOP                            ;615
00627c  2000              MOVS     r0,#0                 ;616
00627e  e7e4              B        |L1.25162|
                  |L1.25216|
006280  7fa0              LDRB     r0,[r4,#0x1e]         ;619
006282  f0100f10          TST      r0,#0x10              ;619
006286  d102              BNE      |L1.25230|
006288  488b              LDR      r0,|L1.25784|
00628a  6800              LDR      r0,[r0,#0]            ;621  ; tcp_ticks
00628c  6260              STR      r0,[r4,#0x24]         ;621
                  |L1.25230|
00628e  2000              MOVS     r0,#0                 ;623
006290  f8840096          STRB     r0,[r4,#0x96]         ;623
006294  4620              MOV      r0,r4                 ;625
006296  f7fffffe          BL       tcp_parseopt
00629a  7e20              LDRB     r0,[r4,#0x18]         ;628
00629c  1e80              SUBS     r0,r0,#2              ;628
00629e  2808              CMP      r0,#8                 ;628
0062a0  d27c              BCS      |L1.25500|
0062a2  e8dff000          TBB      [pc,r0]               ;628
0062a6  04a4              DCB      0x04,0xa4
0062a8  fbfaf9f8          DCB      0xfb,0xfa,0xf9,0xf8
0062ac  f7f6              DCB      0xf7,0xf6
0062ae  bf00              NOP                            ;630
0062b0  bf00              NOP                            ;630
0062b2  487e              LDR      r0,|L1.25772|
0062b4  7800              LDRB     r0,[r0,#0]            ;633  ; flags
0062b6  f0100f10          TST      r0,#0x10              ;633
0062ba  d07f              BEQ      |L1.25532|
0062bc  487b              LDR      r0,|L1.25772|
0062be  7800              LDRB     r0,[r0,#0]            ;633  ; flags
0062c0  f0100f02          TST      r0,#2                 ;633
0062c4  d07a              BEQ      |L1.25532|
0062c6  6f21              LDR      r1,[r4,#0x70]         ;634
0062c8  6909              LDR      r1,[r1,#0x10]         ;634
0062ca  6848              LDR      r0,[r1,#4]            ;634
0062cc  f7fffffe          BL       lwip_ntohl
0062d0  1c40              ADDS     r0,r0,#1              ;634
0062d2  4977              LDR      r1,|L1.25776|
0062d4  6809              LDR      r1,[r1,#0]            ;634  ; ackno
0062d6  4288              CMP      r0,r1                 ;634
0062d8  d170              BNE      |L1.25532|
0062da  f1040428          ADD      r4,r4,#0x28           ;635
0062de  8fe0              LDRH     r0,[r4,#0x3e]         ;635
0062e0  f1000001          ADD      r0,r0,#1              ;635
0062e4  87e0              STRH     r0,[r4,#0x3e]         ;635
0062e6  486f              LDR      r0,|L1.25764|
0062e8  6800              LDR      r0,[r0,#0]            ;636  ; seqno
0062ea  f1000001          ADD      r0,r0,#1              ;636
0062ee  6020              STR      r0,[r4,#0]            ;636
0062f0  6820              LDR      r0,[r4,#0]            ;637
0062f2  60a0              STR      r0,[r4,#8]            ;637
0062f4  486e              LDR      r0,|L1.25776|
0062f6  6800              LDR      r0,[r0,#0]            ;638  ; ackno
0062f8  6220              STR      r0,[r4,#0x20]         ;638
0062fa  486b              LDR      r0,|L1.25768|
0062fc  6800              LDR      r0,[r0,#0]            ;639  ; tcphdr
0062fe  89c0              LDRH     r0,[r0,#0xe]          ;639
006300  8720              STRH     r0,[r4,#0x38]         ;639
006302  4869              LDR      r0,|L1.25768|
006304  6800              LDR      r0,[r0,#0]            ;640  ; tcphdr
006306  89c0              LDRH     r0,[r0,#0xe]          ;640
006308  8760              STRH     r0,[r4,#0x3a]         ;640
00630a  4866              LDR      r0,|L1.25764|
00630c  6800              LDR      r0,[r0,#0]            ;641  ; seqno
00630e  f1a00001          SUB      r0,r0,#1              ;641
006312  62e0              STR      r0,[r4,#0x2c]         ;641
006314  f04f0004          MOV      r0,#4                 ;642
006318  f8040c10          STRB     r0,[r4,#-0x10]        ;642
00631c  89e0              LDRH     r0,[r4,#0xe]          ;645
00631e  f1a40428          SUB      r4,r4,#0x28           ;645
006322  f1040104          ADD      r1,r4,#4              ;645
006326  f7fffffe          BL       tcp_eff_send_mss
00632a  86e0              STRH     r0,[r4,#0x36]         ;645
00632c  8ee0              LDRH     r0,[r4,#0x36]         ;650
00632e  eb000080          ADD      r0,r0,r0,LSL #2       ;650
006332  f64f71ff          MOV      r1,#0xffff            ;650
006336  ea010040          AND      r0,r1,r0,LSL #1       ;650
00633a  f8a4004e          STRH     r0,[r4,#0x4e]         ;650
00633e  f8b4004c          LDRH     r0,[r4,#0x4c]         ;652
006342  2801              CMP      r0,#1                 ;652
006344  d102              BNE      |L1.25420|
006346  8ee0              LDRH     r0,[r4,#0x36]         ;652
006348  0040              LSLS     r0,r0,#1              ;652
00634a  e000              B        |L1.25422|
                  |L1.25420|
00634c  8ee0              LDRH     r0,[r4,#0x36]         ;652
                  |L1.25422|
00634e  f8a4004c          STRH     r0,[r4,#0x4c]         ;652
006352  bf00              NOP                            ;653
006354  bf00              NOP                            ;653
006356  f8b40068          LDRH     r0,[r4,#0x68]         ;654
00635a  1e40              SUBS     r0,r0,#1              ;654
00635c  f8a40068          STRH     r0,[r4,#0x68]         ;654
006360  bf00              NOP                            ;655
006362  bf00              NOP                            ;655
006364  6f25              LDR      r5,[r4,#0x70]         ;656
006366  6828              LDR      r0,[r5,#0]            ;657
006368  6720              STR      r0,[r4,#0x70]         ;657
00636a  4628              MOV      r0,r5                 ;658
00636c  f7fffffe          BL       tcp_seg_free
006370  6f20              LDR      r0,[r4,#0x70]         ;662
006372  b918              CBNZ     r0,|L1.25468|
006374  f04f30ff          MOV      r0,#0xffffffff        ;663
006378  86a0              STRH     r0,[r4,#0x34]         ;663
00637a  e003              B        |L1.25476|
                  |L1.25468|
00637c  2000              MOVS     r0,#0                 ;665
00637e  86a0              STRH     r0,[r4,#0x34]         ;665
006380  f8840046          STRB     r0,[r4,#0x46]         ;666
                  |L1.25476|
006384  bf00              NOP                            ;671
006386  f8d40084          LDR      r0,[r4,#0x84]         ;671
00638a  b148              CBZ      r0,|L1.25504|
00638c  2200              MOVS     r2,#0                 ;671
00638e  4621              MOV      r1,r4                 ;671
006390  f8d43084          LDR      r3,[r4,#0x84]         ;671
006394  6920              LDR      r0,[r4,#0x10]         ;671
006396  4798              BLX      r3                    ;671
006398  4606              MOV      r6,r0                 ;671
00639a  e002              B        |L1.25506|
                  |L1.25500|
00639c  e1dc              B        |L1.26456|
00639e  e00d              B        |L1.25532|
                  |L1.25504|
0063a0  2600              MOVS     r6,#0                 ;671
                  |L1.25506|
0063a2  bf00              NOP                            ;671
0063a4  f116000a          ADDS     r0,r6,#0xa            ;672
0063a8  d102              BNE      |L1.25520|
0063aa  f06f0009          MVN      r0,#9                 ;673
0063ae  e74c              B        |L1.25162|
                  |L1.25520|
0063b0  bf00              NOP                            ;675
0063b2  7fa0              LDRB     r0,[r4,#0x1e]         ;675
0063b4  f0400002          ORR      r0,r0,#2              ;675
0063b8  77a0              STRB     r0,[r4,#0x1e]         ;675
0063ba  e017              B        |L1.25580|
                  |L1.25532|
0063bc  483b              LDR      r0,|L1.25772|
0063be  7800              LDRB     r0,[r0,#0]            ;678  ; flags
0063c0  f0100f10          TST      r0,#0x10              ;678
0063c4  d012              BEQ      |L1.25580|
0063c6  4838              LDR      r0,|L1.25768|
0063c8  6800              LDR      r0,[r0,#0]            ;680  ; tcphdr
0063ca  8800              LDRH     r0,[r0,#0]            ;680
0063cc  4936              LDR      r1,|L1.25768|
0063ce  6809              LDR      r1,[r1,#0]            ;680  ; tcphdr
0063d0  8849              LDRH     r1,[r1,#2]            ;680
0063d2  e9cd1000          STRD     r1,r0,[sp,#0]         ;680
0063d6  4833              LDR      r0,|L1.25764|
0063d8  6800              LDR      r0,[r0,#0]            ;680  ; seqno
0063da  4a31              LDR      r2,|L1.25760|
0063dc  8812              LDRH     r2,[r2,#0]            ;680  ; tcplen
0063de  1881              ADDS     r1,r0,r2              ;680
0063e0  4b36              LDR      r3,|L1.25788|
0063e2  4a37              LDR      r2,|L1.25792|
0063e4  4832              LDR      r0,|L1.25776|
0063e6  6800              LDR      r0,[r0,#0]            ;680  ; ackno
0063e8  f7fffffe          BL       tcp_rst
                  |L1.25580|
0063ec  e1b5              B        |L1.26458|
0063ee  482f              LDR      r0,|L1.25772|
0063f0  7800              LDRB     r0,[r0,#0]            ;685  ; flags
0063f2  f0100f10          TST      r0,#0x10              ;685
0063f6  d079              BEQ      |L1.25836|
0063f8  6ca0              LDR      r0,[r4,#0x48]         ;687
0063fa  f1000001          ADD      r0,r0,#1              ;687
0063fe  492c              LDR      r1,|L1.25776|
006400  6809              LDR      r1,[r1,#0]            ;687  ; ackno
006402  1a08              SUBS     r0,r1,r0              ;687
006404  d45e              BMI      |L1.25796|
006406  492a              LDR      r1,|L1.25776|
006408  6d20              LDR      r0,[r4,#0x50]         ;687
00640a  6809              LDR      r1,[r1,#0]            ;687  ; ackno
00640c  1a08              SUBS     r0,r1,r0              ;687
00640e  2800              CMP      r0,#0                 ;687
006410  dc58              BGT      |L1.25796|
006412  2004              MOVS     r0,#4                 ;689
006414  7620              STRB     r0,[r4,#0x18]         ;689
006416  bf00              NOP                            ;690
006418  bf00              NOP                            ;690
00641a  bf00              NOP                            ;692
00641c  bf00              NOP                            ;692
00641e  bf00              NOP                            ;695
006420  6960              LDR      r0,[r4,#0x14]         ;695
006422  b130              CBZ      r0,|L1.25650|
006424  2200              MOVS     r2,#0                 ;695
006426  4621              MOV      r1,r4                 ;695
006428  e9d40304          LDRD     r0,r3,[r4,#0x10]      ;695
00642c  4798              BLX      r3                    ;695
00642e  4606              MOV      r6,r0                 ;695
006430  e001              B        |L1.25654|
                  |L1.25650|
006432  f06f060d          MVN      r6,#0xd               ;695
                  |L1.25654|
006436  bf00              NOP                            ;695
006438  b146              CBZ      r6,|L1.25676|
00643a  f116000a          ADDS     r0,r6,#0xa            ;700
00643e  d002              BEQ      |L1.25670|
006440  4620              MOV      r0,r4                 ;701
006442  f7fffffe          BL       tcp_abort
                  |L1.25670|
006446  f06f0009          MVN      r0,#9                 ;703
00644a  e6fe              B        |L1.25162|
                  |L1.25676|
00644c  f8b4704c          LDRH     r7,[r4,#0x4c]         ;705
006450  4620              MOV      r0,r4                 ;708
006452  f7fffffe          BL       tcp_receive
006456  f8b40064          LDRH     r0,[r4,#0x64]         ;711
00645a  b120              CBZ      r0,|L1.25702|
00645c  f8b40064          LDRH     r0,[r4,#0x64]         ;712
006460  1e40              SUBS     r0,r0,#1              ;712
006462  f8a40064          STRH     r0,[r4,#0x64]         ;712
                  |L1.25702|
006466  2f01              CMP      r7,#1                 ;715
006468  d102              BNE      |L1.25712|
00646a  8ee0              LDRH     r0,[r4,#0x36]         ;715
00646c  0040              LSLS     r0,r0,#1              ;715
00646e  e000              B        |L1.25714|
                  |L1.25712|
006470  8ee0              LDRH     r0,[r4,#0x36]         ;715
                  |L1.25714|
006472  f8a4004c          STRH     r0,[r4,#0x4c]         ;715
006476  480f              LDR      r0,|L1.25780|
006478  7800              LDRB     r0,[r0,#0]            ;717  ; recv_flags
00647a  f0100f20          TST      r0,#0x20              ;717
00647e  d007              BEQ      |L1.25744|
006480  bf00              NOP                            ;718
006482  7fa0              LDRB     r0,[r4,#0x1e]         ;718
006484  f0400002          ORR      r0,r0,#2              ;718
006488  77a0              STRB     r0,[r4,#0x1e]         ;718
00648a  bf00              NOP                            ;718
00648c  2007              MOVS     r0,#7                 ;719
00648e  7620              STRB     r0,[r4,#0x18]         ;719
                  |L1.25744|
006490  e03a              B        |L1.25864|
006492  e14b              B        |L1.26412|
006494  e100              B        |L1.26264|
006496  e038              B        |L1.25866|
006498  e0b3              B        |L1.26114|
00649a  e048              B        |L1.25902|
00649c  e036              B        |L1.25868|
00649e  e025              B        |L1.25836|
                  |L1.25760|
                          DCD      tcplen
                  |L1.25764|
                          DCD      seqno
                  |L1.25768|
                          DCD      tcphdr
                  |L1.25772|
                          DCD      flags
                  |L1.25776|
                          DCD      ackno
                  |L1.25780|
                          DCD      recv_flags
                  |L1.25784|
                          DCD      tcp_ticks
                  |L1.25788|
                          DCD      current_iphdr_src
                  |L1.25792|
                          DCD      current_iphdr_dest
                  |L1.25796|
0064c4  48fa              LDR      r0,|L1.26800|
0064c6  6800              LDR      r0,[r0,#0]            ;723  ; tcphdr
0064c8  8800              LDRH     r0,[r0,#0]            ;723
0064ca  49f9              LDR      r1,|L1.26800|
0064cc  6809              LDR      r1,[r1,#0]            ;723  ; tcphdr
0064ce  8849              LDRH     r1,[r1,#2]            ;723
0064d0  e9cd1000          STRD     r1,r0,[sp,#0]         ;723
0064d4  48f7              LDR      r0,|L1.26804|
0064d6  6800              LDR      r0,[r0,#0]            ;723  ; seqno
0064d8  4af7              LDR      r2,|L1.26808|
0064da  8812              LDRH     r2,[r2,#0]            ;723  ; tcplen
0064dc  1881              ADDS     r1,r0,r2              ;723
0064de  4bf7              LDR      r3,|L1.26812|
0064e0  4af7              LDR      r2,|L1.26816|
0064e2  48f8              LDR      r0,|L1.26820|
0064e4  6800              LDR      r0,[r0,#0]            ;723  ; ackno
0064e6  f7fffffe          BL       tcp_rst
0064ea  e00d              B        |L1.25864|
                  |L1.25836|
0064ec  48f6              LDR      r0,|L1.26824|
0064ee  7800              LDRB     r0,[r0,#0]            ;726  ; flags
0064f0  f0100f02          TST      r0,#2                 ;726
0064f4  d008              BEQ      |L1.25864|
0064f6  6aa0              LDR      r0,[r4,#0x28]         ;726
0064f8  1e40              SUBS     r0,r0,#1              ;726
0064fa  49ee              LDR      r1,|L1.26804|
0064fc  6809              LDR      r1,[r1,#0]            ;726  ; seqno
0064fe  4288              CMP      r0,r1                 ;726
006500  d102              BNE      |L1.25864|
006502  4620              MOV      r0,r4                 ;728
006504  f7fffffe          BL       tcp_rexmit
                  |L1.25864|
006508  e127              B        |L1.26458|
                  |L1.25866|
00650a  bf00              NOP                            ;733
                  |L1.25868|
00650c  4620              MOV      r0,r4                 ;734
00650e  f7fffffe          BL       tcp_receive
006512  48ee              LDR      r0,|L1.26828|
006514  7800              LDRB     r0,[r0,#0]            ;735  ; recv_flags
006516  f0100f20          TST      r0,#0x20              ;735
00651a  d007              BEQ      |L1.25900|
00651c  bf00              NOP                            ;736
00651e  7fa0              LDRB     r0,[r4,#0x1e]         ;736
006520  f0400002          ORR      r0,r0,#2              ;736
006524  77a0              STRB     r0,[r4,#0x1e]         ;736
006526  bf00              NOP                            ;736
006528  2007              MOVS     r0,#7                 ;737
00652a  7620              STRB     r0,[r4,#0x18]         ;737
                  |L1.25900|
00652c  e115              B        |L1.26458|
                  |L1.25902|
00652e  4620              MOV      r0,r4                 ;741
006530  f7fffffe          BL       tcp_receive
006534  48e5              LDR      r0,|L1.26828|
006536  7800              LDRB     r0,[r0,#0]            ;742  ; recv_flags
006538  f0100f20          TST      r0,#0x20              ;742
00653c  d054              BEQ      |L1.26088|
00653e  48e2              LDR      r0,|L1.26824|
006540  7800              LDRB     r0,[r0,#0]            ;743  ; flags
006542  f0100f10          TST      r0,#0x10              ;743
006546  d046              BEQ      |L1.26070|
006548  49de              LDR      r1,|L1.26820|
00654a  6d20              LDR      r0,[r4,#0x50]         ;743
00654c  6809              LDR      r1,[r1,#0]            ;743  ; ackno
00654e  4288              CMP      r0,r1                 ;743
006550  d141              BNE      |L1.26070|
006552  bf00              NOP                            ;744
006554  bf00              NOP                            ;744
006556  bf00              NOP                            ;746
006558  7fa0              LDRB     r0,[r4,#0x1e]         ;746
00655a  f0400002          ORR      r0,r0,#2              ;746
00655e  77a0              STRB     r0,[r4,#0x1e]         ;746
006560  bf00              NOP                            ;746
006562  4620              MOV      r0,r4                 ;747
006564  f7fffffe          BL       tcp_pcb_purge
006568  bf00              NOP                            ;748
00656a  bf00              NOP                            ;748
00656c  48d8              LDR      r0,|L1.26832|
00656e  6800              LDR      r0,[r0,#0]            ;748  ; tcp_active_pcbs
006570  42a0              CMP      r0,r4                 ;748
006572  d105              BNE      |L1.25984|
006574  48d6              LDR      r0,|L1.26832|
006576  6800              LDR      r0,[r0,#0]            ;748  ; tcp_active_pcbs
006578  68c0              LDR      r0,[r0,#0xc]          ;748
00657a  49d5              LDR      r1,|L1.26832|
00657c  6008              STR      r0,[r1,#0]            ;748  ; tcp_active_pcbs
00657e  e018              B        |L1.26034|
                  |L1.25984|
006580  48d3              LDR      r0,|L1.26832|
006582  6800              LDR      r0,[r0,#0]            ;748  ; tcp_active_pcbs
006584  49d3              LDR      r1,|L1.26836|
006586  6008              STR      r0,[r1,#0]            ;748  ; tcp_tmp_pcb
006588  e00e              B        |L1.26024|
                  |L1.25994|
00658a  48d2              LDR      r0,|L1.26836|
00658c  6800              LDR      r0,[r0,#0]            ;748  ; tcp_tmp_pcb
00658e  68c0              LDR      r0,[r0,#0xc]          ;748
006590  42a0              CMP      r0,r4                 ;748
006592  d104              BNE      |L1.26014|
006594  49cf              LDR      r1,|L1.26836|
006596  68e0              LDR      r0,[r4,#0xc]          ;748
006598  6809              LDR      r1,[r1,#0]            ;748  ; tcp_tmp_pcb
00659a  60c8              STR      r0,[r1,#0xc]          ;748
00659c  e008              B        |L1.26032|
                  |L1.26014|
00659e  48cd              LDR      r0,|L1.26836|
0065a0  6800              LDR      r0,[r0,#0]            ;748  ; tcp_tmp_pcb
0065a2  68c0              LDR      r0,[r0,#0xc]          ;748
0065a4  49cb              LDR      r1,|L1.26836|
0065a6  6008              STR      r0,[r1,#0]            ;748  ; tcp_tmp_pcb
                  |L1.26024|
0065a8  48ca              LDR      r0,|L1.26836|
0065aa  6800              LDR      r0,[r0,#0]            ;748  ; tcp_tmp_pcb
0065ac  2800              CMP      r0,#0                 ;748
0065ae  d1ec              BNE      |L1.25994|
                  |L1.26032|
0065b0  bf00              NOP                            ;748
                  |L1.26034|
0065b2  2000              MOVS     r0,#0                 ;748
0065b4  60e0              STR      r0,[r4,#0xc]          ;748
0065b6  bf00              NOP                            ;748
0065b8  2001              MOVS     r0,#1                 ;748
0065ba  49c7              LDR      r1,|L1.26840|
0065bc  7008              STRB     r0,[r1,#0]            ;748
0065be  bf00              NOP                            ;748
0065c0  200a              MOVS     r0,#0xa               ;749
0065c2  7620              STRB     r0,[r4,#0x18]         ;749
0065c4  bf00              NOP                            ;750
0065c6  48c5              LDR      r0,|L1.26844|
0065c8  6800              LDR      r0,[r0,#0]            ;750  ; tcp_tw_pcbs
0065ca  60e0              STR      r0,[r4,#0xc]          ;750
0065cc  48c3              LDR      r0,|L1.26844|
0065ce  6004              STR      r4,[r0,#0]            ;750  ; tcp_tw_pcbs
0065d0  f7fffffe          BL       tcp_timer_needed
0065d4  e014              B        |L1.26112|
                  |L1.26070|
0065d6  bf00              NOP                            ;752
0065d8  7fa0              LDRB     r0,[r4,#0x1e]         ;752
0065da  f0400002          ORR      r0,r0,#2              ;752
0065de  77a0              STRB     r0,[r4,#0x1e]         ;752
0065e0  bf00              NOP                            ;752
0065e2  2008              MOVS     r0,#8                 ;753
0065e4  7620              STRB     r0,[r4,#0x18]         ;753
0065e6  e00b              B        |L1.26112|
                  |L1.26088|
0065e8  48b7              LDR      r0,|L1.26824|
0065ea  7800              LDRB     r0,[r0,#0]            ;755  ; flags
0065ec  f0100f10          TST      r0,#0x10              ;755
0065f0  d006              BEQ      |L1.26112|
0065f2  49b4              LDR      r1,|L1.26820|
0065f4  6d20              LDR      r0,[r4,#0x50]         ;755
0065f6  6809              LDR      r1,[r1,#0]            ;755  ; ackno
0065f8  4288              CMP      r0,r1                 ;755
0065fa  d101              BNE      |L1.26112|
0065fc  2006              MOVS     r0,#6                 ;756
0065fe  7620              STRB     r0,[r4,#0x18]         ;756
                  |L1.26112|
006600  e0ab              B        |L1.26458|
                  |L1.26114|
006602  4620              MOV      r0,r4                 ;760
006604  f7fffffe          BL       tcp_receive
006608  48b0              LDR      r0,|L1.26828|
00660a  7800              LDRB     r0,[r0,#0]            ;761  ; recv_flags
00660c  f0100f20          TST      r0,#0x20              ;761
006610  d041              BEQ      |L1.26262|
006612  bf00              NOP                            ;762
006614  bf00              NOP                            ;762
006616  bf00              NOP                            ;763
006618  7fa0              LDRB     r0,[r4,#0x1e]         ;763
00661a  f0400002          ORR      r0,r0,#2              ;763
00661e  77a0              STRB     r0,[r4,#0x1e]         ;763
006620  bf00              NOP                            ;763
006622  4620              MOV      r0,r4                 ;764
006624  f7fffffe          BL       tcp_pcb_purge
006628  bf00              NOP                            ;765
00662a  bf00              NOP                            ;765
00662c  48a8              LDR      r0,|L1.26832|
00662e  6800              LDR      r0,[r0,#0]            ;765  ; tcp_active_pcbs
006630  42a0              CMP      r0,r4                 ;765
006632  d105              BNE      |L1.26176|
006634  48a6              LDR      r0,|L1.26832|
006636  6800              LDR      r0,[r0,#0]            ;765  ; tcp_active_pcbs
006638  68c0              LDR      r0,[r0,#0xc]          ;765
00663a  49a5              LDR      r1,|L1.26832|
00663c  6008              STR      r0,[r1,#0]            ;765  ; tcp_active_pcbs
00663e  e018              B        |L1.26226|
                  |L1.26176|
006640  48a3              LDR      r0,|L1.26832|
006642  6800              LDR      r0,[r0,#0]            ;765  ; tcp_active_pcbs
006644  49a3              LDR      r1,|L1.26836|
006646  6008              STR      r0,[r1,#0]            ;765  ; tcp_tmp_pcb
006648  e00e              B        |L1.26216|
                  |L1.26186|
00664a  48a2              LDR      r0,|L1.26836|
00664c  6800              LDR      r0,[r0,#0]            ;765  ; tcp_tmp_pcb
00664e  68c0              LDR      r0,[r0,#0xc]          ;765
006650  42a0              CMP      r0,r4                 ;765
006652  d104              BNE      |L1.26206|
006654  499f              LDR      r1,|L1.26836|
006656  68e0              LDR      r0,[r4,#0xc]          ;765
006658  6809              LDR      r1,[r1,#0]            ;765  ; tcp_tmp_pcb
00665a  60c8              STR      r0,[r1,#0xc]          ;765
00665c  e008              B        |L1.26224|
                  |L1.26206|
00665e  489d              LDR      r0,|L1.26836|
006660  6800              LDR      r0,[r0,#0]            ;765  ; tcp_tmp_pcb
006662  68c0              LDR      r0,[r0,#0xc]          ;765
006664  499b              LDR      r1,|L1.26836|
006666  6008              STR      r0,[r1,#0]            ;765  ; tcp_tmp_pcb
                  |L1.26216|
006668  489a              LDR      r0,|L1.26836|
00666a  6800              LDR      r0,[r0,#0]            ;765  ; tcp_tmp_pcb
00666c  2800              CMP      r0,#0                 ;765
00666e  d1ec              BNE      |L1.26186|
                  |L1.26224|
006670  bf00              NOP                            ;765
                  |L1.26226|
006672  2000              MOVS     r0,#0                 ;765
006674  60e0              STR      r0,[r4,#0xc]          ;765
006676  bf00              NOP                            ;765
006678  2001              MOVS     r0,#1                 ;765
00667a  4997              LDR      r1,|L1.26840|
00667c  7008              STRB     r0,[r1,#0]            ;765
00667e  bf00              NOP                            ;765
006680  200a              MOVS     r0,#0xa               ;766
006682  7620              STRB     r0,[r4,#0x18]         ;766
006684  bf00              NOP                            ;767
006686  4895              LDR      r0,|L1.26844|
006688  6800              LDR      r0,[r0,#0]            ;767  ; tcp_tw_pcbs
00668a  60e0              STR      r0,[r4,#0xc]          ;767
00668c  4893              LDR      r0,|L1.26844|
00668e  6004              STR      r4,[r0,#0]            ;767  ; tcp_tw_pcbs
006690  f7fffffe          BL       tcp_timer_needed
006694  bf00              NOP                            ;767
                  |L1.26262|
006696  e060              B        |L1.26458|
                  |L1.26264|
006698  4620              MOV      r0,r4                 ;771
00669a  f7fffffe          BL       tcp_receive
00669e  488a              LDR      r0,|L1.26824|
0066a0  7800              LDRB     r0,[r0,#0]            ;772  ; flags
0066a2  f0100f10          TST      r0,#0x10              ;772
0066a6  d040              BEQ      |L1.26410|
0066a8  4986              LDR      r1,|L1.26820|
0066aa  6d20              LDR      r0,[r4,#0x50]         ;772
0066ac  6809              LDR      r1,[r1,#0]            ;772  ; ackno
0066ae  4288              CMP      r0,r1                 ;772
0066b0  d13b              BNE      |L1.26410|
0066b2  bf00              NOP                            ;773
0066b4  bf00              NOP                            ;773
0066b6  4620              MOV      r0,r4                 ;774
0066b8  f7fffffe          BL       tcp_pcb_purge
0066bc  bf00              NOP                            ;775
0066be  bf00              NOP                            ;775
0066c0  4883              LDR      r0,|L1.26832|
0066c2  6800              LDR      r0,[r0,#0]            ;775  ; tcp_active_pcbs
0066c4  42a0              CMP      r0,r4                 ;775
0066c6  d105              BNE      |L1.26324|
0066c8  4881              LDR      r0,|L1.26832|
0066ca  6800              LDR      r0,[r0,#0]            ;775  ; tcp_active_pcbs
0066cc  68c0              LDR      r0,[r0,#0xc]          ;775
0066ce  4980              LDR      r1,|L1.26832|
0066d0  6008              STR      r0,[r1,#0]            ;775  ; tcp_active_pcbs
0066d2  e018              B        |L1.26374|
                  |L1.26324|
0066d4  487e              LDR      r0,|L1.26832|
0066d6  6800              LDR      r0,[r0,#0]            ;775  ; tcp_active_pcbs
0066d8  497e              LDR      r1,|L1.26836|
0066da  6008              STR      r0,[r1,#0]            ;775  ; tcp_tmp_pcb
0066dc  e00e              B        |L1.26364|
                  |L1.26334|
0066de  487d              LDR      r0,|L1.26836|
0066e0  6800              LDR      r0,[r0,#0]            ;775  ; tcp_tmp_pcb
0066e2  68c0              LDR      r0,[r0,#0xc]          ;775
0066e4  42a0              CMP      r0,r4                 ;775
0066e6  d104              BNE      |L1.26354|
0066e8  497a              LDR      r1,|L1.26836|
0066ea  68e0              LDR      r0,[r4,#0xc]          ;775
0066ec  6809              LDR      r1,[r1,#0]            ;775  ; tcp_tmp_pcb
0066ee  60c8              STR      r0,[r1,#0xc]          ;775
0066f0  e008              B        |L1.26372|
                  |L1.26354|
0066f2  4878              LDR      r0,|L1.26836|
0066f4  6800              LDR      r0,[r0,#0]            ;775  ; tcp_tmp_pcb
0066f6  68c0              LDR      r0,[r0,#0xc]          ;775
0066f8  4976              LDR      r1,|L1.26836|
0066fa  6008              STR      r0,[r1,#0]            ;775  ; tcp_tmp_pcb
                  |L1.26364|
0066fc  4875              LDR      r0,|L1.26836|
0066fe  6800              LDR      r0,[r0,#0]            ;775  ; tcp_tmp_pcb
006700  2800              CMP      r0,#0                 ;775
006702  d1ec              BNE      |L1.26334|
                  |L1.26372|
006704  bf00              NOP                            ;775
                  |L1.26374|
006706  2000              MOVS     r0,#0                 ;775
006708  60e0              STR      r0,[r4,#0xc]          ;775
00670a  bf00              NOP                            ;775
00670c  2001              MOVS     r0,#1                 ;775
00670e  4972              LDR      r1,|L1.26840|
006710  7008              STRB     r0,[r1,#0]            ;775
006712  bf00              NOP                            ;775
006714  200a              MOVS     r0,#0xa               ;776
006716  7620              STRB     r0,[r4,#0x18]         ;776
006718  bf00              NOP                            ;777
00671a  4870              LDR      r0,|L1.26844|
00671c  6800              LDR      r0,[r0,#0]            ;777  ; tcp_tw_pcbs
00671e  60e0              STR      r0,[r4,#0xc]          ;777
006720  486e              LDR      r0,|L1.26844|
006722  6004              STR      r4,[r0,#0]            ;777  ; tcp_tw_pcbs
006724  f7fffffe          BL       tcp_timer_needed
006728  bf00              NOP                            ;777
                  |L1.26410|
00672a  e016              B        |L1.26458|
                  |L1.26412|
00672c  4620              MOV      r0,r4                 ;781
00672e  f7fffffe          BL       tcp_receive
006732  4865              LDR      r0,|L1.26824|
006734  7800              LDRB     r0,[r0,#0]            ;782  ; flags
006736  f0100f10          TST      r0,#0x10              ;782
00673a  d00c              BEQ      |L1.26454|
00673c  4961              LDR      r1,|L1.26820|
00673e  6d20              LDR      r0,[r4,#0x50]         ;782
006740  6809              LDR      r1,[r1,#0]            ;782  ; ackno
006742  4288              CMP      r0,r1                 ;782
006744  d107              BNE      |L1.26454|
006746  bf00              NOP                            ;783
006748  bf00              NOP                            ;783
00674a  4860              LDR      r0,|L1.26828|
00674c  7800              LDRB     r0,[r0,#0]            ;785  ; recv_flags
00674e  f0400010          ORR      r0,r0,#0x10           ;785
006752  495e              LDR      r1,|L1.26828|
006754  7008              STRB     r0,[r1,#0]            ;785
                  |L1.26454|
006756  e000              B        |L1.26458|
                  |L1.26456|
006758  bf00              NOP                            ;789
                  |L1.26458|
00675a  bf00              NOP                            ;683
00675c  2000              MOVS     r0,#0                 ;791
00675e  e574              B        |L1.25162|
;;;793    
                          ENDP

                  tcp_listen_input PROC
;;;440    static err_t
;;;441    tcp_listen_input(struct tcp_pcb_listen *pcb)
006760  b57c              PUSH     {r2-r6,lr}
;;;442    {
006762  4605              MOV      r5,r0
;;;443      struct tcp_pcb *npcb;
;;;444      err_t rc;
;;;445    
;;;446      if (flags & TCP_RST) {
006764  4858              LDR      r0,|L1.26824|
006766  7800              LDRB     r0,[r0,#0]  ; flags
006768  f0100f04          TST      r0,#4
00676c  d001              BEQ      |L1.26482|
;;;447        /* An incoming RST should be ignored. Return. */
;;;448        return ERR_OK;
00676e  2000              MOVS     r0,#0
                  |L1.26480|
;;;449      }
;;;450    
;;;451      /* In the LISTEN state, we check for incoming SYN segments,
;;;452         creates a new PCB, and responds with a SYN|ACK. */
;;;453      if (flags & TCP_ACK) {
;;;454        /* For incoming segments with the ACK flag set, respond with a
;;;455           RST. */
;;;456        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;457        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;458          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;459      } else if (flags & TCP_SYN) {
;;;460        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;461    #if TCP_LISTEN_BACKLOG
;;;462        if (pcb->accepts_pending >= pcb->backlog) {
;;;463          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;464          return ERR_ABRT;
;;;465        }
;;;466    #endif /* TCP_LISTEN_BACKLOG */
;;;467        npcb = tcp_alloc(pcb->prio);
;;;468        /* If a new PCB could not be created (probably due to lack of memory),
;;;469           we don't do anything, but rely on the sender will retransmit the
;;;470           SYN at a time when we have more memory available. */
;;;471        if (npcb == NULL) {
;;;472          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;473          TCP_STATS_INC(tcp.memerr);
;;;474          return ERR_MEM;
;;;475        }
;;;476    #if TCP_LISTEN_BACKLOG
;;;477        pcb->accepts_pending++;
;;;478    #endif /* TCP_LISTEN_BACKLOG */
;;;479        /* Set up the new PCB. */
;;;480        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
;;;481        npcb->local_port = pcb->local_port;
;;;482        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
;;;483        npcb->remote_port = tcphdr->src;
;;;484        npcb->state = SYN_RCVD;
;;;485        npcb->rcv_nxt = seqno + 1;
;;;486        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;487        npcb->snd_wnd = tcphdr->wnd;
;;;488        npcb->snd_wnd_max = tcphdr->wnd;
;;;489        npcb->ssthresh = npcb->snd_wnd;
;;;490        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;491        npcb->callback_arg = pcb->callback_arg;
;;;492    #if LWIP_CALLBACK_API
;;;493        npcb->accept = pcb->accept;
;;;494    #endif /* LWIP_CALLBACK_API */
;;;495        /* inherit socket options */
;;;496        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;497        /* Register the new PCB so that we can begin receiving segments
;;;498           for it. */
;;;499        TCP_REG_ACTIVE(npcb);
;;;500    
;;;501        /* Parse any options in the SYN. */
;;;502        tcp_parseopt(npcb);
;;;503    #if TCP_CALCULATE_EFF_SEND_MSS
;;;504        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
;;;505    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;506    
;;;507        snmp_inc_tcppassiveopens();
;;;508    
;;;509        /* Send a SYN|ACK together with the MSS option. */
;;;510        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;511        if (rc != ERR_OK) {
;;;512          tcp_abandon(npcb, 0);
;;;513          return rc;
;;;514        }
;;;515        return tcp_output(npcb);
;;;516      }
;;;517      return ERR_OK;
;;;518    }
006770  bd7c              POP      {r2-r6,pc}
                  |L1.26482|
006772  4855              LDR      r0,|L1.26824|
006774  7800              LDRB     r0,[r0,#0]            ;453  ; flags
006776  f0100f10          TST      r0,#0x10              ;453
00677a  d015              BEQ      |L1.26536|
00677c  bf00              NOP                            ;456
00677e  bf00              NOP                            ;456
006780  484b              LDR      r0,|L1.26800|
006782  6800              LDR      r0,[r0,#0]            ;457  ; tcphdr
006784  8800              LDRH     r0,[r0,#0]            ;457
006786  494a              LDR      r1,|L1.26800|
006788  6809              LDR      r1,[r1,#0]            ;457  ; tcphdr
00678a  8849              LDRH     r1,[r1,#2]            ;457
00678c  e9cd1000          STRD     r1,r0,[sp,#0]         ;457
006790  4848              LDR      r0,|L1.26804|
006792  6800              LDR      r0,[r0,#0]            ;457  ; seqno
006794  4a48              LDR      r2,|L1.26808|
006796  8812              LDRH     r2,[r2,#0]            ;457  ; tcplen
006798  1881              ADDS     r1,r0,r2              ;457
00679a  4b48              LDR      r3,|L1.26812|
00679c  4a48              LDR      r2,|L1.26816|
00679e  4849              LDR      r0,|L1.26820|
0067a0  6800              LDR      r0,[r0,#0]            ;457  ; ackno
0067a2  f7fffffe          BL       tcp_rst
0067a6  e078              B        |L1.26778|
                  |L1.26536|
0067a8  4847              LDR      r0,|L1.26824|
0067aa  7800              LDRB     r0,[r0,#0]            ;459  ; flags
0067ac  f0100f02          TST      r0,#2                 ;459
0067b0  d073              BEQ      |L1.26778|
0067b2  bf00              NOP                            ;460
0067b4  bf00              NOP                            ;460
0067b6  7f68              LDRB     r0,[r5,#0x1d]         ;462
0067b8  7f29              LDRB     r1,[r5,#0x1c]         ;462
0067ba  4288              CMP      r0,r1                 ;462
0067bc  db04              BLT      |L1.26568|
0067be  bf00              NOP                            ;463
0067c0  bf00              NOP                            ;463
0067c2  f06f0009          MVN      r0,#9                 ;464
0067c6  e7d3              B        |L1.26480|
                  |L1.26568|
0067c8  7e68              LDRB     r0,[r5,#0x19]         ;467
0067ca  f7fffffe          BL       tcp_alloc
0067ce  4604              MOV      r4,r0                 ;467
0067d0  b964              CBNZ     r4,|L1.26604|
0067d2  bf00              NOP                            ;472
0067d4  bf00              NOP                            ;472
0067d6  4842              LDR      r0,|L1.26848|
0067d8  f8b000a0          LDRH     r0,[r0,#0xa0]         ;473
0067dc  1c40              ADDS     r0,r0,#1              ;473
0067de  b281              UXTH     r1,r0                 ;473
0067e0  483f              LDR      r0,|L1.26848|
0067e2  f8a010a0          STRH     r1,[r0,#0xa0]         ;473
0067e6  f04f30ff          MOV      r0,#0xffffffff        ;474
0067ea  e7c1              B        |L1.26480|
                  |L1.26604|
0067ec  7f68              LDRB     r0,[r5,#0x1d]         ;477
0067ee  1c40              ADDS     r0,r0,#1              ;477
0067f0  7768              STRB     r0,[r5,#0x1d]         ;477
0067f2  4833              LDR      r0,|L1.26816|
0067f4  6800              LDR      r0,[r0,#0]            ;480  ; current_iphdr_dest
0067f6  6020              STR      r0,[r4,#0]            ;480
0067f8  8b68              LDRH     r0,[r5,#0x1a]         ;481
0067fa  8360              STRH     r0,[r4,#0x1a]         ;481
0067fc  482f              LDR      r0,|L1.26812|
0067fe  6800              LDR      r0,[r0,#0]            ;482  ; current_iphdr_src
006800  6060              STR      r0,[r4,#4]            ;482
006802  482b              LDR      r0,|L1.26800|
006804  6800              LDR      r0,[r0,#0]            ;483  ; tcphdr
006806  8800              LDRH     r0,[r0,#0]            ;483
006808  83a0              STRH     r0,[r4,#0x1c]         ;483
00680a  2003              MOVS     r0,#3                 ;484
00680c  7620              STRB     r0,[r4,#0x18]         ;484
00680e  4829              LDR      r0,|L1.26804|
006810  6800              LDR      r0,[r0,#0]            ;485  ; seqno
006812  1c40              ADDS     r0,r0,#1              ;485
006814  62a0              STR      r0,[r4,#0x28]         ;485
006816  6aa0              LDR      r0,[r4,#0x28]         ;486
006818  6320              STR      r0,[r4,#0x30]         ;486
00681a  4825              LDR      r0,|L1.26800|
00681c  6800              LDR      r0,[r0,#0]            ;487  ; tcphdr
00681e  89c0              LDRH     r0,[r0,#0xe]          ;487
006820  f8a40060          STRH     r0,[r4,#0x60]         ;487
006824  4822              LDR      r0,|L1.26800|
006826  6800              LDR      r0,[r0,#0]            ;488  ; tcphdr
006828  89c0              LDRH     r0,[r0,#0xe]          ;488
00682a  f8a40062          STRH     r0,[r4,#0x62]         ;488
00682e  f8b40060          LDRH     r0,[r4,#0x60]         ;489
006832  f8a4004e          STRH     r0,[r4,#0x4e]         ;489
006836  481f              LDR      r0,|L1.26804|
006838  6800              LDR      r0,[r0,#0]            ;490  ; seqno
00683a  1e40              SUBS     r0,r0,#1              ;490
00683c  6560              STR      r0,[r4,#0x54]         ;490
00683e  6928              LDR      r0,[r5,#0x10]         ;491
006840  6120              STR      r0,[r4,#0x10]         ;491
006842  6968              LDR      r0,[r5,#0x14]         ;493
006844  6160              STR      r0,[r4,#0x14]         ;493
006846  7a28              LDRB     r0,[r5,#8]            ;496
006848  f000008c          AND      r0,r0,#0x8c           ;496
00684c  7220              STRB     r0,[r4,#8]            ;496
00684e  bf00              NOP                            ;499
006850  bf00              NOP                            ;499
006852  481f              LDR      r0,|L1.26832|
006854  6800              LDR      r0,[r0,#0]            ;499  ; tcp_active_pcbs
006856  60e0              STR      r0,[r4,#0xc]          ;499
006858  481d              LDR      r0,|L1.26832|
00685a  6004              STR      r4,[r0,#0]            ;499  ; tcp_active_pcbs
00685c  f7fffffe          BL       tcp_timer_needed
006860  bf00              NOP                            ;499
006862  2001              MOVS     r0,#1                 ;499
006864  491c              LDR      r1,|L1.26840|
006866  7008              STRB     r0,[r1,#0]            ;499
006868  bf00              NOP                            ;499
00686a  4620              MOV      r0,r4                 ;502
00686c  f7fffffe          BL       tcp_parseopt
006870  8ee0              LDRH     r0,[r4,#0x36]         ;504
006872  1d21              ADDS     r1,r4,#4              ;504
006874  f7fffffe          BL       tcp_eff_send_mss
006878  86e0              STRH     r0,[r4,#0x36]         ;504
00687a  2112              MOVS     r1,#0x12              ;510
00687c  4620              MOV      r0,r4                 ;510
00687e  f7fffffe          BL       tcp_enqueue_flags
006882  4606              MOV      r6,r0                 ;510
006884  b12e              CBZ      r6,|L1.26770|
006886  2100              MOVS     r1,#0                 ;512
006888  4620              MOV      r0,r4                 ;512
00688a  f7fffffe          BL       tcp_abandon
00688e  4630              MOV      r0,r6                 ;513
006890  e76e              B        |L1.26480|
                  |L1.26770|
006892  4620              MOV      r0,r4                 ;515
006894  f7fffffe          BL       tcp_output
006898  e76a              B        |L1.26480|
                  |L1.26778|
00689a  2000              MOVS     r0,#0                 ;517
00689c  e768              B        |L1.26480|
;;;519    
                          ENDP

                  tcp_timewait_input PROC
;;;529    static err_t
;;;530    tcp_timewait_input(struct tcp_pcb *pcb)
00689e  b51c              PUSH     {r2-r4,lr}
;;;531    {
0068a0  4604              MOV      r4,r0
;;;532      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;533      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;534       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;535       *   acceptable since we only send ACKs)
;;;536       * - second check the RST bit (... return) */
;;;537      if (flags & TCP_RST)  {
0068a2  4809              LDR      r0,|L1.26824|
0068a4  7800              LDRB     r0,[r0,#0]  ; flags
0068a6  f0100f04          TST      r0,#4
0068aa  d01b              BEQ      |L1.26852|
;;;538        return ERR_OK;
0068ac  2000              MOVS     r0,#0
;;;539      }
;;;540      /* - fourth, check the SYN bit, */
;;;541      if (flags & TCP_SYN) {
;;;542        /* If an incoming segment is not acceptable, an acknowledgment
;;;543           should be sent in reply */
;;;544        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;545          /* If the SYN is in the window it is an error, send a reset */
;;;546          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;547            tcphdr->dest, tcphdr->src);
;;;548          return ERR_OK;
;;;549        }
;;;550      } else if (flags & TCP_FIN) {
;;;551        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;552             Restart the 2 MSL time-wait timeout.*/
;;;553        pcb->tmr = tcp_ticks;
;;;554      }
;;;555    
;;;556      if ((tcplen > 0))  {
;;;557        /* Acknowledge data, FIN or out-of-window SYN */
;;;558        pcb->flags |= TF_ACK_NOW;
;;;559        return tcp_output(pcb);
;;;560      }
;;;561      return ERR_OK;
;;;562    }
0068ae  bd1c              POP      {r2-r4,pc}
                  |L1.26800|
                          DCD      tcphdr
                  |L1.26804|
                          DCD      seqno
                  |L1.26808|
                          DCD      tcplen
                  |L1.26812|
                          DCD      current_iphdr_src
                  |L1.26816|
                          DCD      current_iphdr_dest
                  |L1.26820|
                          DCD      ackno
                  |L1.26824|
                          DCD      flags
                  |L1.26828|
                          DCD      recv_flags
                  |L1.26832|
                          DCD      tcp_active_pcbs
                  |L1.26836|
                          DCD      tcp_tmp_pcb
                  |L1.26840|
                          DCD      tcp_active_pcbs_changed
                  |L1.26844|
                          DCD      tcp_tw_pcbs
                  |L1.26848|
                          DCD      lwip_stats
                  |L1.26852|
0068e4  48fd              LDR      r0,|L1.27868|
0068e6  7800              LDRB     r0,[r0,#0]            ;541  ; flags
0068e8  f0100f02          TST      r0,#2                 ;541
0068ec  d021              BEQ      |L1.26930|
0068ee  49fc              LDR      r1,|L1.27872|
0068f0  6aa0              LDR      r0,[r4,#0x28]         ;544
0068f2  6809              LDR      r1,[r1,#0]            ;544  ; seqno
0068f4  1a08              SUBS     r0,r1,r0              ;544
0068f6  d424              BMI      |L1.26946|
0068f8  8da1              LDRH     r1,[r4,#0x2c]         ;544
0068fa  6aa0              LDR      r0,[r4,#0x28]         ;544
0068fc  4408              ADD      r0,r0,r1              ;544
0068fe  49f8              LDR      r1,|L1.27872|
006900  6809              LDR      r1,[r1,#0]            ;544  ; seqno
006902  1a08              SUBS     r0,r1,r0              ;544
006904  2800              CMP      r0,#0                 ;544
006906  dc1c              BGT      |L1.26946|
006908  48f6              LDR      r0,|L1.27876|
00690a  6800              LDR      r0,[r0,#0]            ;546  ; tcphdr
00690c  8800              LDRH     r0,[r0,#0]            ;546
00690e  49f5              LDR      r1,|L1.27876|
006910  6809              LDR      r1,[r1,#0]            ;546  ; tcphdr
006912  8849              LDRH     r1,[r1,#2]            ;546
006914  e9cd1000          STRD     r1,r0,[sp,#0]         ;546
006918  48f1              LDR      r0,|L1.27872|
00691a  6800              LDR      r0,[r0,#0]            ;546  ; seqno
00691c  4af2              LDR      r2,|L1.27880|
00691e  8812              LDRH     r2,[r2,#0]            ;546  ; tcplen
006920  1881              ADDS     r1,r0,r2              ;546
006922  4bf2              LDR      r3,|L1.27884|
006924  4af2              LDR      r2,|L1.27888|
006926  48f3              LDR      r0,|L1.27892|
006928  6800              LDR      r0,[r0,#0]            ;546  ; ackno
00692a  f7fffffe          BL       tcp_rst
00692e  2000              MOVS     r0,#0                 ;548
                  |L1.26928|
006930  bd1c              POP      {r2-r4,pc}
                  |L1.26930|
006932  48ea              LDR      r0,|L1.27868|
006934  7800              LDRB     r0,[r0,#0]            ;550  ; flags
006936  f0100f01          TST      r0,#1                 ;550
00693a  d002              BEQ      |L1.26946|
00693c  48ee              LDR      r0,|L1.27896|
00693e  6800              LDR      r0,[r0,#0]            ;553  ; tcp_ticks
006940  6260              STR      r0,[r4,#0x24]         ;553
                  |L1.26946|
006942  48e9              LDR      r0,|L1.27880|
006944  8800              LDRH     r0,[r0,#0]            ;556  ; tcplen
006946  2800              CMP      r0,#0                 ;556
006948  dd07              BLE      |L1.26970|
00694a  7fa0              LDRB     r0,[r4,#0x1e]         ;558
00694c  f0400002          ORR      r0,r0,#2              ;558
006950  77a0              STRB     r0,[r4,#0x1e]         ;558
006952  4620              MOV      r0,r4                 ;559
006954  f7fffffe          BL       tcp_output
006958  e7ea              B        |L1.26928|
                  |L1.26970|
00695a  2000              MOVS     r0,#0                 ;561
00695c  e7e8              B        |L1.26928|
;;;563    
                          ENDP

                  tcp_input PROC
;;;92     void
;;;93     tcp_input(struct pbuf *p, struct netif *inp)
00695e  e92d47fc          PUSH     {r2-r10,lr}
;;;94     {
006962  4606              MOV      r6,r0
006964  468a              MOV      r10,r1
;;;95       struct tcp_pcb *pcb, *prev;
;;;96       struct tcp_pcb_listen *lpcb;
;;;97     #if SO_REUSE
;;;98       struct tcp_pcb *lpcb_prev = NULL;
;;;99       struct tcp_pcb_listen *lpcb_any = NULL;
;;;100    #endif /* SO_REUSE */
;;;101      u8_t hdrlen;
;;;102      err_t err;
;;;103    
;;;104      PERF_START;
;;;105    
;;;106      TCP_STATS_INC(tcp.recv);
006966  48e5              LDR      r0,|L1.27900|
006968  f8b00096          LDRH     r0,[r0,#0x96]
00696c  1c40              ADDS     r0,r0,#1
00696e  b281              UXTH     r1,r0
006970  48e2              LDR      r0,|L1.27900|
006972  f8a01096          STRH     r1,[r0,#0x96]
;;;107      snmp_inc_tcpinsegs();
;;;108    
;;;109      iphdr = (struct ip_hdr *)p->payload;
006976  49e2              LDR      r1,|L1.27904|
006978  6870              LDR      r0,[r6,#4]
00697a  6008              STR      r0,[r1,#0]  ; iphdr
;;;110      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
00697c  48e0              LDR      r0,|L1.27904|
00697e  6871              LDR      r1,[r6,#4]
006980  6800              LDR      r0,[r0,#0]  ; iphdr
006982  7800              LDRB     r0,[r0,#0]
006984  f000000f          AND      r0,r0,#0xf
006988  eb010080          ADD      r0,r1,r0,LSL #2
00698c  49d5              LDR      r1,|L1.27876|
00698e  6008              STR      r0,[r1,#0]  ; tcphdr
;;;111    
;;;112    #if TCP_INPUT_DEBUG
;;;113      tcp_debug_print(tcphdr);
;;;114    #endif
;;;115    
;;;116      /* remove header from payload */
;;;117      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
006990  48db              LDR      r0,|L1.27904|
006992  6800              LDR      r0,[r0,#0]  ; iphdr
006994  7800              LDRB     r0,[r0,#0]
006996  0700              LSLS     r0,r0,#28
006998  0e80              LSRS     r0,r0,#26
00699a  4241              RSBS     r1,r0,#0
00699c  4630              MOV      r0,r6
00699e  f7fffffe          BL       pbuf_header
0069a2  b910              CBNZ     r0,|L1.27050|
0069a4  8930              LDRH     r0,[r6,#8]
0069a6  2814              CMP      r0,#0x14
0069a8  d20a              BCS      |L1.27072|
                  |L1.27050|
;;;118        /* drop short packets */
;;;119        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
0069aa  bf00              NOP      
0069ac  bf00              NOP      
;;;120        TCP_STATS_INC(tcp.lenerr);
0069ae  48d3              LDR      r0,|L1.27900|
0069b0  f8b0009e          LDRH     r0,[r0,#0x9e]
0069b4  1c40              ADDS     r0,r0,#1
0069b6  b281              UXTH     r1,r0
0069b8  48d0              LDR      r0,|L1.27900|
0069ba  f8a0109e          STRH     r1,[r0,#0x9e]
;;;121        goto dropped;
0069be  e244              B        |L1.28234|
                  |L1.27072|
;;;122      }
;;;123    
;;;124      /* Don't even process incoming broadcasts/multicasts. */
;;;125      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
0069c0  49cb              LDR      r1,|L1.27888|
0069c2  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
0069c4  4651              MOV      r1,r10
0069c6  f7fffffe          BL       ip4_addr_isbroadcast
0069ca  b928              CBNZ     r0,|L1.27096|
;;;126          ip_addr_ismulticast(&current_iphdr_dest)) {
0069cc  48c8              LDR      r0,|L1.27888|
0069ce  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
0069d0  f00000f0          AND      r0,r0,#0xf0
0069d4  28e0              CMP      r0,#0xe0
0069d6  d108              BNE      |L1.27114|
                  |L1.27096|
;;;127        TCP_STATS_INC(tcp.proterr);
0069d8  48c8              LDR      r0,|L1.27900|
0069da  f8b000a4          LDRH     r0,[r0,#0xa4]
0069de  1c40              ADDS     r0,r0,#1
0069e0  b281              UXTH     r1,r0
0069e2  48c6              LDR      r0,|L1.27900|
0069e4  f8a010a4          STRH     r1,[r0,#0xa4]
;;;128        goto dropped;
0069e8  e22f              B        |L1.28234|
                  |L1.27114|
;;;129      }
;;;130    
;;;131    #if CHECKSUM_CHECK_TCP
;;;132      /* Verify TCP checksum. */
;;;133      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;134          IP_PROTO_TCP, p->tot_len) != 0) {
;;;135          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;136            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;137          IP_PROTO_TCP, p->tot_len)));
;;;138    #if TCP_DEBUG
;;;139        tcp_debug_print(tcphdr);
;;;140    #endif /* TCP_DEBUG */
;;;141        TCP_STATS_INC(tcp.chkerr);
;;;142        goto dropped;
;;;143      }
;;;144    #endif
;;;145    
;;;146      /* Move the payload pointer in the pbuf so that it points to the
;;;147         TCP data instead of the TCP header. */
;;;148      hdrlen = TCPH_HDRLEN(tcphdr);
0069ea  49be              LDR      r1,|L1.27876|
0069ec  6809              LDR      r1,[r1,#0]  ; tcphdr
0069ee  8988              LDRH     r0,[r1,#0xc]
0069f0  f7fffffe          BL       lwip_ntohs
0069f4  ea4f3920          ASR      r9,r0,#12
;;;149      if(pbuf_header(p, -(hdrlen * 4))){
0069f8  ea4f0089          LSL      r0,r9,#2
0069fc  4241              RSBS     r1,r0,#0
0069fe  4630              MOV      r0,r6
006a00  f7fffffe          BL       pbuf_header
006a04  b150              CBZ      r0,|L1.27164|
;;;150        /* drop short packets */
;;;151        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
006a06  bf00              NOP      
006a08  bf00              NOP      
;;;152        TCP_STATS_INC(tcp.lenerr);
006a0a  48bc              LDR      r0,|L1.27900|
006a0c  f8b0009e          LDRH     r0,[r0,#0x9e]
006a10  1c40              ADDS     r0,r0,#1
006a12  b281              UXTH     r1,r0
006a14  48b9              LDR      r0,|L1.27900|
006a16  f8a0109e          STRH     r1,[r0,#0x9e]
;;;153        goto dropped;
006a1a  e216              B        |L1.28234|
                  |L1.27164|
;;;154      }
;;;155    
;;;156      /* Convert fields in TCP header to host byte order. */
;;;157      tcphdr->src = ntohs(tcphdr->src);
006a1c  49b1              LDR      r1,|L1.27876|
006a1e  6809              LDR      r1,[r1,#0]  ; tcphdr
006a20  8808              LDRH     r0,[r1,#0]
006a22  f7fffffe          BL       lwip_ntohs
006a26  49af              LDR      r1,|L1.27876|
006a28  6809              LDR      r1,[r1,#0]  ; tcphdr
006a2a  8008              STRH     r0,[r1,#0]
;;;158      tcphdr->dest = ntohs(tcphdr->dest);
006a2c  49ad              LDR      r1,|L1.27876|
006a2e  6809              LDR      r1,[r1,#0]  ; tcphdr
006a30  8848              LDRH     r0,[r1,#2]
006a32  f7fffffe          BL       lwip_ntohs
006a36  49ab              LDR      r1,|L1.27876|
006a38  6809              LDR      r1,[r1,#0]  ; tcphdr
006a3a  8048              STRH     r0,[r1,#2]
;;;159      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
006a3c  49a9              LDR      r1,|L1.27876|
006a3e  6809              LDR      r1,[r1,#0]  ; tcphdr
006a40  6848              LDR      r0,[r1,#4]
006a42  f7fffffe          BL       lwip_ntohl
006a46  49a7              LDR      r1,|L1.27876|
006a48  6809              LDR      r1,[r1,#0]  ; tcphdr
006a4a  6048              STR      r0,[r1,#4]
006a4c  49a4              LDR      r1,|L1.27872|
006a4e  6008              STR      r0,[r1,#0]  ; seqno
;;;160      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
006a50  49a4              LDR      r1,|L1.27876|
006a52  6809              LDR      r1,[r1,#0]  ; tcphdr
006a54  6888              LDR      r0,[r1,#8]
006a56  f7fffffe          BL       lwip_ntohl
006a5a  49a2              LDR      r1,|L1.27876|
006a5c  6809              LDR      r1,[r1,#0]  ; tcphdr
006a5e  6088              STR      r0,[r1,#8]
006a60  49a4              LDR      r1,|L1.27892|
006a62  6008              STR      r0,[r1,#0]  ; ackno
;;;161      tcphdr->wnd = ntohs(tcphdr->wnd);
006a64  499f              LDR      r1,|L1.27876|
006a66  6809              LDR      r1,[r1,#0]  ; tcphdr
006a68  89c8              LDRH     r0,[r1,#0xe]
006a6a  f7fffffe          BL       lwip_ntohs
006a6e  499d              LDR      r1,|L1.27876|
006a70  6809              LDR      r1,[r1,#0]  ; tcphdr
006a72  81c8              STRH     r0,[r1,#0xe]
;;;162    
;;;163      flags = TCPH_FLAGS(tcphdr);
006a74  499b              LDR      r1,|L1.27876|
006a76  6809              LDR      r1,[r1,#0]  ; tcphdr
006a78  8988              LDRH     r0,[r1,#0xc]
006a7a  f7fffffe          BL       lwip_ntohs
006a7e  f000003f          AND      r0,r0,#0x3f
006a82  4996              LDR      r1,|L1.27868|
006a84  7008              STRB     r0,[r1,#0]
;;;164      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
006a86  8930              LDRH     r0,[r6,#8]
006a88  7809              LDRB     r1,[r1,#0]  ; flags
006a8a  f0110f03          TST      r1,#3
006a8e  d001              BEQ      |L1.27284|
006a90  2101              MOVS     r1,#1
006a92  e000              B        |L1.27286|
                  |L1.27284|
006a94  2100              MOVS     r1,#0
                  |L1.27286|
006a96  4408              ADD      r0,r0,r1
006a98  4993              LDR      r1,|L1.27880|
006a9a  8008              STRH     r0,[r1,#0]
;;;165    
;;;166      /* Demultiplex an incoming segment. First, we check if it is destined
;;;167         for an active connection. */
;;;168      prev = NULL;
006a9c  2700              MOVS     r7,#0
;;;169    
;;;170      
;;;171      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
006a9e  4899              LDR      r0,|L1.27908|
006aa0  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
006aa2  e02a              B        |L1.27386|
                  |L1.27300|
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
006aa4  bf00              NOP      
006aa6  bf00              NOP      
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
006aa8  bf00              NOP      
006aaa  bf00              NOP      
;;;174        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
006aac  bf00              NOP      
006aae  bf00              NOP      
;;;175        if (pcb->remote_port == tcphdr->src &&
006ab0  8ba0              LDRH     r0,[r4,#0x1c]
006ab2  498c              LDR      r1,|L1.27876|
006ab4  6809              LDR      r1,[r1,#0]  ; tcphdr
006ab6  8809              LDRH     r1,[r1,#0]
006ab8  4288              CMP      r0,r1
006aba  d11c              BNE      |L1.27382|
;;;176           pcb->local_port == tcphdr->dest &&
006abc  8b60              LDRH     r0,[r4,#0x1a]
006abe  4989              LDR      r1,|L1.27876|
006ac0  6809              LDR      r1,[r1,#0]  ; tcphdr
006ac2  8849              LDRH     r1,[r1,#2]
006ac4  4288              CMP      r0,r1
006ac6  d116              BNE      |L1.27382|
;;;177           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
006ac8  4988              LDR      r1,|L1.27884|
006aca  6860              LDR      r0,[r4,#4]
006acc  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
006ace  4288              CMP      r0,r1
006ad0  d111              BNE      |L1.27382|
;;;178           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
006ad2  4987              LDR      r1,|L1.27888|
006ad4  6820              LDR      r0,[r4,#0]
006ad6  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
006ad8  4288              CMP      r0,r1
006ada  d10c              BNE      |L1.27382|
;;;179    
;;;180          /* Move this PCB to the front of the list so that subsequent
;;;181             lookups will be faster (we exploit locality in TCP segment
;;;182             arrivals). */
;;;183          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
006adc  bf00              NOP      
006ade  bf00              NOP      
;;;184          if (prev != NULL) {
006ae0  b137              CBZ      r7,|L1.27376|
;;;185            prev->next = pcb->next;
006ae2  68e0              LDR      r0,[r4,#0xc]
006ae4  60f8              STR      r0,[r7,#0xc]
;;;186            pcb->next = tcp_active_pcbs;
006ae6  4887              LDR      r0,|L1.27908|
006ae8  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
006aea  60e0              STR      r0,[r4,#0xc]
;;;187            tcp_active_pcbs = pcb;
006aec  4885              LDR      r0,|L1.27908|
006aee  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.27376|
;;;188          }
;;;189          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
006af0  bf00              NOP      
006af2  bf00              NOP      
;;;190          break;
006af4  e003              B        |L1.27390|
                  |L1.27382|
;;;191        }
;;;192        prev = pcb;
006af6  4627              MOV      r7,r4
006af8  68e4              LDR      r4,[r4,#0xc]          ;171
                  |L1.27386|
006afa  2c00              CMP      r4,#0                 ;171
006afc  d1d2              BNE      |L1.27300|
                  |L1.27390|
006afe  bf00              NOP                            ;190
;;;193      }
;;;194    
;;;195      if (pcb == NULL) {
006b00  2c00              CMP      r4,#0
006b02  d151              BNE      |L1.27560|
;;;196        /* If it did not go to an active connection, we check the connections
;;;197           in the TIME-WAIT state. */
;;;198        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
006b04  4880              LDR      r0,|L1.27912|
006b06  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
006b08  e022              B        |L1.27472|
                  |L1.27402|
;;;199          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
006b0a  bf00              NOP      
006b0c  bf00              NOP      
;;;200          if (pcb->remote_port == tcphdr->src &&
006b0e  8ba0              LDRH     r0,[r4,#0x1c]
006b10  4974              LDR      r1,|L1.27876|
006b12  6809              LDR      r1,[r1,#0]  ; tcphdr
006b14  8809              LDRH     r1,[r1,#0]
006b16  4288              CMP      r0,r1
006b18  d119              BNE      |L1.27470|
;;;201             pcb->local_port == tcphdr->dest &&
006b1a  8b60              LDRH     r0,[r4,#0x1a]
006b1c  4971              LDR      r1,|L1.27876|
006b1e  6809              LDR      r1,[r1,#0]  ; tcphdr
006b20  8849              LDRH     r1,[r1,#2]
006b22  4288              CMP      r0,r1
006b24  d113              BNE      |L1.27470|
;;;202             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
006b26  4971              LDR      r1,|L1.27884|
006b28  6860              LDR      r0,[r4,#4]
006b2a  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
006b2c  4288              CMP      r0,r1
006b2e  d10e              BNE      |L1.27470|
;;;203             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
006b30  496f              LDR      r1,|L1.27888|
006b32  6820              LDR      r0,[r4,#0]
006b34  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
006b36  4288              CMP      r0,r1
006b38  d109              BNE      |L1.27470|
;;;204            /* We don't really care enough to move this PCB to the front
;;;205               of the list since we are not very likely to receive that
;;;206               many segments for connections in TIME-WAIT. */
;;;207            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
006b3a  bf00              NOP      
006b3c  bf00              NOP      
;;;208            tcp_timewait_input(pcb);
006b3e  4620              MOV      r0,r4
006b40  f7fffffe          BL       tcp_timewait_input
;;;209            pbuf_free(p);
006b44  4630              MOV      r0,r6
006b46  f7fffffe          BL       pbuf_free
                  |L1.27466|
;;;210            return;
;;;211          }
;;;212        }
;;;213    
;;;214        /* Finally, if we still did not get a match, we check all PCBs that
;;;215           are LISTENing for incoming connections. */
;;;216        prev = NULL;
;;;217        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;218          if (lpcb->local_port == tcphdr->dest) {
;;;219    #if SO_REUSE
;;;220            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;221              /* found an exact match */
;;;222              break;
;;;223            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;224              /* found an ANY-match */
;;;225              lpcb_any = lpcb;
;;;226              lpcb_prev = prev;
;;;227            }
;;;228    #else /* SO_REUSE */
;;;229            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;230                ip_addr_isany(&(lpcb->local_ip))) {
;;;231              /* found a match */
;;;232              break;
;;;233            }
;;;234    #endif /* SO_REUSE */
;;;235          }
;;;236          prev = (struct tcp_pcb *)lpcb;
;;;237        }
;;;238    #if SO_REUSE
;;;239        /* first try specific local IP */
;;;240        if (lpcb == NULL) {
;;;241          /* only pass to ANY if no specific local IP has been found */
;;;242          lpcb = lpcb_any;
;;;243          prev = lpcb_prev;
;;;244        }
;;;245    #endif /* SO_REUSE */
;;;246        if (lpcb != NULL) {
;;;247          /* Move this PCB to the front of the list so that subsequent
;;;248             lookups will be faster (we exploit locality in TCP segment
;;;249             arrivals). */
;;;250          if (prev != NULL) {
;;;251            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;252                  /* our successor is the remainder of the listening list */
;;;253            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;254                  /* put this listening pcb at the head of the listening list */
;;;255            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;256          }
;;;257        
;;;258          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;259          tcp_listen_input(lpcb);
;;;260          pbuf_free(p);
;;;261          return;
;;;262        }
;;;263      }
;;;264    
;;;265    #if TCP_INPUT_DEBUG
;;;266      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;267      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;268      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;269    #endif /* TCP_INPUT_DEBUG */
;;;270    
;;;271    
;;;272      if (pcb != NULL) {
;;;273        /* The incoming segment belongs to a connection. */
;;;274    #if TCP_INPUT_DEBUG
;;;275    #if TCP_DEBUG
;;;276        tcp_debug_print_state(pcb->state);
;;;277    #endif /* TCP_DEBUG */
;;;278    #endif /* TCP_INPUT_DEBUG */
;;;279    
;;;280        /* Set up a tcp_seg structure. */
;;;281        inseg.next = NULL;
;;;282        inseg.len = p->tot_len;
;;;283        inseg.p = p;
;;;284        inseg.tcphdr = tcphdr;
;;;285    
;;;286        recv_data = NULL;
;;;287        recv_flags = 0;
;;;288    
;;;289        if (flags & TCP_PSH) {
;;;290          p->flags |= PBUF_FLAG_PUSH;
;;;291        }
;;;292    
;;;293        /* If there is data which was previously "refused" by upper layer */
;;;294        if (pcb->refused_data != NULL) {
;;;295          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;296            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;297            /* pcb has been aborted or refused data is still refused and the new
;;;298               segment contains data */
;;;299            TCP_STATS_INC(tcp.drop);
;;;300            snmp_inc_tcpinerrs();
;;;301            goto aborted;
;;;302          }
;;;303        }
;;;304        tcp_input_pcb = pcb;
;;;305        err = tcp_process(pcb);
;;;306        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;307           and that the pcb has been freed. If so, we don't do anything. */
;;;308        if (err != ERR_ABRT) {
;;;309          if (recv_flags & TF_RESET) {
;;;310            /* TF_RESET means that the connection was reset by the other
;;;311               end. We then call the error callback to inform the
;;;312               application that the connection is dead before we
;;;313               deallocate the PCB. */
;;;314            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;315            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;316            memp_free(MEMP_TCP_PCB, pcb);
;;;317          } else if (recv_flags & TF_CLOSED) {
;;;318            /* The connection has been closed and we will deallocate the
;;;319               PCB. */
;;;320            if (!(pcb->flags & TF_RXCLOSED)) {
;;;321              /* Connection closed although the application has only shut down the
;;;322                 tx side: call the PCB's err callback and indicate the closure to
;;;323                 ensure the application doesn't continue using the PCB. */
;;;324              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;325            }
;;;326            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;327            memp_free(MEMP_TCP_PCB, pcb);
;;;328          } else {
;;;329            err = ERR_OK;
;;;330            /* If the application has registered a "sent" function to be
;;;331               called when new send buffer space is available, we call it
;;;332               now. */
;;;333            if (pcb->acked > 0) {
;;;334              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;335              if (err == ERR_ABRT) {
;;;336                goto aborted;
;;;337              }
;;;338            }
;;;339    
;;;340            if (recv_data != NULL) {
;;;341              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;342              if (pcb->flags & TF_RXCLOSED) {
;;;343                /* received data although already closed -> abort (send RST) to
;;;344                   notify the remote host that not all data has been processed */
;;;345                pbuf_free(recv_data);
;;;346                tcp_abort(pcb);
;;;347                goto aborted;
;;;348              }
;;;349    
;;;350              /* Notify application that data has been received. */
;;;351              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;352              if (err == ERR_ABRT) {
;;;353                goto aborted;
;;;354              }
;;;355    
;;;356              /* If the upper layer can't receive this data, store it */
;;;357              if (err != ERR_OK) {
;;;358                pcb->refused_data = recv_data;
;;;359                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;360              }
;;;361            }
;;;362    
;;;363            /* If a FIN segment was received, we call the callback
;;;364               function with a NULL buffer to indicate EOF. */
;;;365            if (recv_flags & TF_GOT_FIN) {
;;;366              if (pcb->refused_data != NULL) {
;;;367                /* Delay this if we have refused data. */
;;;368                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;369              } else {
;;;370                /* correct rcv_wnd as the application won't call tcp_recved()
;;;371                   for the FIN's seqno */
;;;372                if (pcb->rcv_wnd != TCP_WND) {
;;;373                  pcb->rcv_wnd++;
;;;374                }
;;;375                TCP_EVENT_CLOSED(pcb, err);
;;;376                if (err == ERR_ABRT) {
;;;377                  goto aborted;
;;;378                }
;;;379              }
;;;380            }
;;;381    
;;;382            tcp_input_pcb = NULL;
;;;383            /* Try to send something out. */
;;;384            tcp_output(pcb);
;;;385    #if TCP_INPUT_DEBUG
;;;386    #if TCP_DEBUG
;;;387            tcp_debug_print_state(pcb->state);
;;;388    #endif /* TCP_DEBUG */
;;;389    #endif /* TCP_INPUT_DEBUG */
;;;390          }
;;;391        }
;;;392        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;393           Below this line, 'pcb' may not be dereferenced! */
;;;394    aborted:
;;;395        tcp_input_pcb = NULL;
;;;396        recv_data = NULL;
;;;397    
;;;398        /* give up our reference to inseg.p */
;;;399        if (inseg.p != NULL)
;;;400        {
;;;401          pbuf_free(inseg.p);
;;;402          inseg.p = NULL;
;;;403        }
;;;404      } else {
;;;405    
;;;406        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;407           sender. */
;;;408        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;409        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;410          TCP_STATS_INC(tcp.proterr);
;;;411          TCP_STATS_INC(tcp.drop);
;;;412          tcp_rst(ackno, seqno + tcplen,
;;;413            ip_current_dest_addr(), ip_current_src_addr(),
;;;414            tcphdr->dest, tcphdr->src);
;;;415        }
;;;416        pbuf_free(p);
;;;417      }
;;;418    
;;;419      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;420      PERF_STOP("tcp_input");
;;;421      return;
;;;422    dropped:
;;;423      TCP_STATS_INC(tcp.drop);
;;;424      snmp_inc_tcpinerrs();
;;;425      pbuf_free(p);
;;;426    }
006b4a  e8bd87fc          POP      {r2-r10,pc}
                  |L1.27470|
006b4e  68e4              LDR      r4,[r4,#0xc]          ;198
                  |L1.27472|
006b50  2c00              CMP      r4,#0                 ;198
006b52  d1da              BNE      |L1.27402|
006b54  2700              MOVS     r7,#0                 ;216
006b56  486d              LDR      r0,|L1.27916|
006b58  6805              LDR      r5,[r0,#0]            ;217  ; tcp_listen_pcbs
006b5a  e010              B        |L1.27518|
                  |L1.27484|
006b5c  8b68              LDRH     r0,[r5,#0x1a]         ;218
006b5e  4961              LDR      r1,|L1.27876|
006b60  6809              LDR      r1,[r1,#0]            ;218  ; tcphdr
006b62  8849              LDRH     r1,[r1,#2]            ;218
006b64  4288              CMP      r0,r1                 ;218
006b66  d108              BNE      |L1.27514|
006b68  4961              LDR      r1,|L1.27888|
006b6a  6828              LDR      r0,[r5,#0]            ;229
006b6c  6809              LDR      r1,[r1,#0]            ;229  ; current_iphdr_dest
006b6e  4288              CMP      r0,r1                 ;229
006b70  d002              BEQ      |L1.27512|
006b72  b10d              CBZ      r5,|L1.27512|
006b74  6828              LDR      r0,[r5,#0]            ;230
006b76  b900              CBNZ     r0,|L1.27514|
                  |L1.27512|
006b78  e003              B        |L1.27522|
                  |L1.27514|
006b7a  462f              MOV      r7,r5                 ;236
006b7c  68ed              LDR      r5,[r5,#0xc]          ;217
                  |L1.27518|
006b7e  2d00              CMP      r5,#0                 ;217
006b80  d1ec              BNE      |L1.27484|
                  |L1.27522|
006b82  bf00              NOP                            ;232
006b84  b185              CBZ      r5,|L1.27560|
006b86  b137              CBZ      r7,|L1.27542|
006b88  68e8              LDR      r0,[r5,#0xc]          ;251
006b8a  60f8              STR      r0,[r7,#0xc]          ;251
006b8c  485f              LDR      r0,|L1.27916|
006b8e  6800              LDR      r0,[r0,#0]            ;253  ; tcp_listen_pcbs
006b90  60e8              STR      r0,[r5,#0xc]          ;253
006b92  485e              LDR      r0,|L1.27916|
006b94  6005              STR      r5,[r0,#0]            ;255  ; tcp_listen_pcbs
                  |L1.27542|
006b96  bf00              NOP                            ;258
006b98  bf00              NOP                            ;258
006b9a  4628              MOV      r0,r5                 ;259
006b9c  f7fffffe          BL       tcp_listen_input
006ba0  4630              MOV      r0,r6                 ;260
006ba2  f7fffffe          BL       pbuf_free
006ba6  e7d0              B        |L1.27466|
                  |L1.27560|
006ba8  2c00              CMP      r4,#0                 ;272
006baa  d07d              BEQ      |L1.27816|
006bac  2000              MOVS     r0,#0                 ;281
006bae  4958              LDR      r1,|L1.27920|
006bb0  6008              STR      r0,[r1,#0]            ;281  ; inseg
006bb2  8930              LDRH     r0,[r6,#8]            ;282
006bb4  8108              STRH     r0,[r1,#8]            ;282
006bb6  4608              MOV      r0,r1                 ;283
006bb8  6046              STR      r6,[r0,#4]            ;283  ; inseg
006bba  484a              LDR      r0,|L1.27876|
006bbc  6800              LDR      r0,[r0,#0]            ;284  ; tcphdr
006bbe  6108              STR      r0,[r1,#0x10]         ;284  ; inseg
006bc0  2000              MOVS     r0,#0                 ;286
006bc2  4954              LDR      r1,|L1.27924|
006bc4  6008              STR      r0,[r1,#0]            ;286  ; recv_data
006bc6  4954              LDR      r1,|L1.27928|
006bc8  7008              STRB     r0,[r1,#0]            ;287
006bca  4844              LDR      r0,|L1.27868|
006bcc  7800              LDRB     r0,[r0,#0]            ;289  ; flags
006bce  f0100f08          TST      r0,#8                 ;289
006bd2  d003              BEQ      |L1.27612|
006bd4  7b70              LDRB     r0,[r6,#0xd]          ;290
006bd6  f0400001          ORR      r0,r0,#1              ;290
006bda  7370              STRB     r0,[r6,#0xd]          ;290
                  |L1.27612|
006bdc  6fa0              LDR      r0,[r4,#0x78]         ;294
006bde  b198              CBZ      r0,|L1.27656|
006be0  4620              MOV      r0,r4                 ;295
006be2  f7fffffe          BL       tcp_process_refused_data
006be6  300a              ADDS     r0,r0,#0xa            ;295
006be8  d005              BEQ      |L1.27638|
006bea  6fa0              LDR      r0,[r4,#0x78]         ;296
006bec  b160              CBZ      r0,|L1.27656|
006bee  483e              LDR      r0,|L1.27880|
006bf0  8800              LDRH     r0,[r0,#0]            ;296  ; tcplen
006bf2  2800              CMP      r0,#0                 ;296
006bf4  dd08              BLE      |L1.27656|
                  |L1.27638|
006bf6  4841              LDR      r0,|L1.27900|
006bf8  f8b0009a          LDRH     r0,[r0,#0x9a]         ;299
006bfc  1c40              ADDS     r0,r0,#1              ;299
006bfe  b281              UXTH     r1,r0                 ;299
006c00  483e              LDR      r0,|L1.27900|
006c02  f8a0109a          STRH     r1,[r0,#0x9a]         ;299
006c06  e0de              B        |L1.28102|
                  |L1.27656|
006c08  4844              LDR      r0,|L1.27932|
006c0a  6004              STR      r4,[r0,#0]            ;304  ; tcp_input_pcb
006c0c  4620              MOV      r0,r4                 ;305
006c0e  f7fffffe          BL       tcp_process
006c12  4680              MOV      r8,r0                 ;305
006c14  f118000a          ADDS     r0,r8,#0xa            ;308
006c18  d017              BEQ      |L1.27722|
006c1a  483f              LDR      r0,|L1.27928|
006c1c  7800              LDRB     r0,[r0,#0]            ;309  ; recv_flags
006c1e  f0100f08          TST      r0,#8                 ;309
006c22  d013              BEQ      |L1.27724|
006c24  bf00              NOP                            ;314
006c26  f8d4008c          LDR      r0,[r4,#0x8c]         ;314
006c2a  b128              CBZ      r0,|L1.27704|
006c2c  f06f010a          MVN      r1,#0xa               ;314
006c30  f8d4208c          LDR      r2,[r4,#0x8c]         ;314
006c34  6920              LDR      r0,[r4,#0x10]         ;314
006c36  4790              BLX      r2                    ;314
                  |L1.27704|
006c38  bf00              NOP                            ;314
006c3a  4621              MOV      r1,r4                 ;315
006c3c  4831              LDR      r0,|L1.27908|
006c3e  f7fffffe          BL       tcp_pcb_remove
006c42  4621              MOV      r1,r4                 ;316
006c44  2002              MOVS     r0,#2                 ;316
006c46  f7fffffe          BL       memp_free
                  |L1.27722|
006c4a  e0bb              B        |L1.28100|
                  |L1.27724|
006c4c  4832              LDR      r0,|L1.27928|
006c4e  7800              LDRB     r0,[r0,#0]            ;317  ; recv_flags
006c50  f0100f10          TST      r0,#0x10              ;317
006c54  d017              BEQ      |L1.27782|
006c56  7fa0              LDRB     r0,[r4,#0x1e]         ;320
006c58  f0100f10          TST      r0,#0x10              ;320
006c5c  d10a              BNE      |L1.27764|
006c5e  bf00              NOP                            ;324
006c60  f8d4008c          LDR      r0,[r4,#0x8c]         ;324
006c64  b128              CBZ      r0,|L1.27762|
006c66  f06f010b          MVN      r1,#0xb               ;324
006c6a  f8d4208c          LDR      r2,[r4,#0x8c]         ;324
006c6e  6920              LDR      r0,[r4,#0x10]         ;324
006c70  4790              BLX      r2                    ;324
                  |L1.27762|
006c72  bf00              NOP                            ;324
                  |L1.27764|
006c74  4621              MOV      r1,r4                 ;326
006c76  4823              LDR      r0,|L1.27908|
006c78  f7fffffe          BL       tcp_pcb_remove
006c7c  4621              MOV      r1,r4                 ;327
006c7e  2002              MOVS     r0,#2                 ;327
006c80  f7fffffe          BL       memp_free
006c84  e09e              B        |L1.28100|
                  |L1.27782|
006c86  f04f0800          MOV      r8,#0                 ;329
006c8a  f8b40064          LDRH     r0,[r4,#0x64]         ;333
006c8e  2800              CMP      r0,#0                 ;333
006c90  dd12              BLE      |L1.27832|
006c92  bf00              NOP                            ;334
006c94  6fe0              LDR      r0,[r4,#0x7c]         ;334
006c96  b140              CBZ      r0,|L1.27818|
006c98  f8b42064          LDRH     r2,[r4,#0x64]         ;334
006c9c  4621              MOV      r1,r4                 ;334
006c9e  6fe3              LDR      r3,[r4,#0x7c]         ;334
006ca0  6920              LDR      r0,[r4,#0x10]         ;334
006ca2  4798              BLX      r3                    ;334
006ca4  4680              MOV      r8,r0                 ;334
006ca6  e002              B        |L1.27822|
                  |L1.27816|
006ca8  e09d              B        |L1.28134|
                  |L1.27818|
006caa  f04f0800          MOV      r8,#0                 ;334
                  |L1.27822|
006cae  bf00              NOP                            ;334
006cb0  f118000a          ADDS     r0,r8,#0xa            ;335
006cb4  d100              BNE      |L1.27832|
006cb6  e086              B        |L1.28102|
                  |L1.27832|
006cb8  4816              LDR      r0,|L1.27924|
006cba  6800              LDR      r0,[r0,#0]            ;340  ; recv_data
006cbc  b168              CBZ      r0,|L1.27866|
006cbe  bf00              NOP                            ;341
006cc0  bf00              NOP                            ;341
006cc2  7fa0              LDRB     r0,[r4,#0x1e]         ;342
006cc4  f0100f10          TST      r0,#0x10              ;342
006cc8  d02a              BEQ      |L1.27936|
006cca  4812              LDR      r0,|L1.27924|
006ccc  6800              LDR      r0,[r0,#0]            ;345  ; recv_data
006cce  f7fffffe          BL       pbuf_free
006cd2  4620              MOV      r0,r4                 ;346
006cd4  f7fffffe          BL       tcp_abort
006cd8  e075              B        |L1.28102|
                  |L1.27866|
006cda  e044              B        |L1.28006|
                  |L1.27868|
                          DCD      flags
                  |L1.27872|
                          DCD      seqno
                  |L1.27876|
                          DCD      tcphdr
                  |L1.27880|
                          DCD      tcplen
                  |L1.27884|
                          DCD      current_iphdr_src
                  |L1.27888|
                          DCD      current_iphdr_dest
                  |L1.27892|
                          DCD      ackno
                  |L1.27896|
                          DCD      tcp_ticks
                  |L1.27900|
                          DCD      lwip_stats
                  |L1.27904|
                          DCD      iphdr
                  |L1.27908|
                          DCD      tcp_active_pcbs
                  |L1.27912|
                          DCD      tcp_tw_pcbs
                  |L1.27916|
                          DCD      tcp_listen_pcbs
                  |L1.27920|
                          DCD      inseg
                  |L1.27924|
                          DCD      recv_data
                  |L1.27928|
                          DCD      recv_flags
                  |L1.27932|
                          DCD      tcp_input_pcb
                  |L1.27936|
006d20  bf00              NOP                            ;351
006d22  f8d40080          LDR      r0,[r4,#0x80]         ;351
006d26  b148              CBZ      r0,|L1.27964|
006d28  2300              MOVS     r3,#0                 ;351
006d2a  49fc              LDR      r1,|L1.28956|
006d2c  f8d4c080          LDR      r12,[r4,#0x80]        ;351
006d30  6920              LDR      r0,[r4,#0x10]         ;351
006d32  680a              LDR      r2,[r1,#0]            ;351  ; recv_data
006d34  4621              MOV      r1,r4                 ;351
006d36  47e0              BLX      r12                   ;351
006d38  4680              MOV      r8,r0                 ;351
006d3a  e007              B        |L1.27980|
                  |L1.27964|
006d3c  2300              MOVS     r3,#0                 ;351
006d3e  48f7              LDR      r0,|L1.28956|
006d40  4621              MOV      r1,r4                 ;351
006d42  6802              LDR      r2,[r0,#0]            ;351  ; recv_data
006d44  4618              MOV      r0,r3                 ;351
006d46  f7fffffe          BL       tcp_recv_null
006d4a  4680              MOV      r8,r0                 ;351
                  |L1.27980|
006d4c  bf00              NOP                            ;351
006d4e  f118000a          ADDS     r0,r8,#0xa            ;352
006d52  d100              BNE      |L1.27990|
006d54  e037              B        |L1.28102|
                  |L1.27990|
006d56  f1b80f00          CMP      r8,#0                 ;357
006d5a  d004              BEQ      |L1.28006|
006d5c  48ef              LDR      r0,|L1.28956|
006d5e  6800              LDR      r0,[r0,#0]            ;358  ; recv_data
006d60  67a0              STR      r0,[r4,#0x78]         ;358
006d62  bf00              NOP                            ;359
006d64  bf00              NOP                            ;359
                  |L1.28006|
006d66  48ee              LDR      r0,|L1.28960|
006d68  7800              LDRB     r0,[r0,#0]            ;365  ; recv_flags
006d6a  f0100f20          TST      r0,#0x20              ;365
006d6e  d023              BEQ      |L1.28088|
006d70  6fa0              LDR      r0,[r4,#0x78]         ;366
006d72  b130              CBZ      r0,|L1.28034|
006d74  6fa0              LDR      r0,[r4,#0x78]         ;368
006d76  7b40              LDRB     r0,[r0,#0xd]          ;368
006d78  f0400020          ORR      r0,r0,#0x20           ;368
006d7c  6fa1              LDR      r1,[r4,#0x78]         ;368
006d7e  7348              STRB     r0,[r1,#0xd]          ;368
006d80  e01a              B        |L1.28088|
                  |L1.28034|
006d82  8da0              LDRH     r0,[r4,#0x2c]         ;372
006d84  f5b05f80          CMP      r0,#0x1000            ;372
006d88  d002              BEQ      |L1.28048|
006d8a  8da0              LDRH     r0,[r4,#0x2c]         ;373
006d8c  1c40              ADDS     r0,r0,#1              ;373
006d8e  85a0              STRH     r0,[r4,#0x2c]         ;373
                  |L1.28048|
006d90  bf00              NOP                            ;375
006d92  f8d40080          LDR      r0,[r4,#0x80]         ;375
006d96  b140              CBZ      r0,|L1.28074|
006d98  2300              MOVS     r3,#0                 ;375
006d9a  461a              MOV      r2,r3                 ;375
006d9c  4621              MOV      r1,r4                 ;375
006d9e  f8d4c080          LDR      r12,[r4,#0x80]        ;375
006da2  6920              LDR      r0,[r4,#0x10]         ;375
006da4  47e0              BLX      r12                   ;375
006da6  4680              MOV      r8,r0                 ;375
006da8  e001              B        |L1.28078|
                  |L1.28074|
006daa  f04f0800          MOV      r8,#0                 ;375
                  |L1.28078|
006dae  bf00              NOP                            ;375
006db0  f118000a          ADDS     r0,r8,#0xa            ;376
006db4  d100              BNE      |L1.28088|
006db6  e006              B        |L1.28102|
                  |L1.28088|
006db8  2000              MOVS     r0,#0                 ;382
006dba  49da              LDR      r1,|L1.28964|
006dbc  6008              STR      r0,[r1,#0]            ;382  ; tcp_input_pcb
006dbe  4620              MOV      r0,r4                 ;384
006dc0  f7fffffe          BL       tcp_output
                  |L1.28100|
006dc4  bf00              NOP                            ;394
                  |L1.28102|
006dc6  2000              MOVS     r0,#0                 ;395
006dc8  49d6              LDR      r1,|L1.28964|
006dca  6008              STR      r0,[r1,#0]            ;395  ; tcp_input_pcb
006dcc  49d3              LDR      r1,|L1.28956|
006dce  6008              STR      r0,[r1,#0]            ;396  ; recv_data
006dd0  48d5              LDR      r0,|L1.28968|
006dd2  6840              LDR      r0,[r0,#4]            ;399  ; inseg
006dd4  b3b0              CBZ      r0,|L1.28228|
006dd6  49d4              LDR      r1,|L1.28968|
006dd8  6848              LDR      r0,[r1,#4]            ;401  ; inseg
006dda  f7fffffe          BL       pbuf_free
006dde  2000              MOVS     r0,#0                 ;402
006de0  49d1              LDR      r1,|L1.28968|
006de2  6048              STR      r0,[r1,#4]            ;402  ; inseg
006de4  e02e              B        |L1.28228|
                  |L1.28134|
006de6  bf00              NOP                            ;408
006de8  bf00              NOP                            ;408
006dea  49d0              LDR      r1,|L1.28972|
006dec  6809              LDR      r1,[r1,#0]            ;409  ; tcphdr
006dee  8988              LDRH     r0,[r1,#0xc]          ;409
006df0  f7fffffe          BL       lwip_ntohs
006df4  f0100f04          TST      r0,#4                 ;409
006df8  d121              BNE      |L1.28222|
006dfa  48cd              LDR      r0,|L1.28976|
006dfc  f8b000a4          LDRH     r0,[r0,#0xa4]         ;410
006e00  1c40              ADDS     r0,r0,#1              ;410
006e02  b281              UXTH     r1,r0                 ;410
006e04  48ca              LDR      r0,|L1.28976|
006e06  f8a010a4          STRH     r1,[r0,#0xa4]         ;410
006e0a  f8b0009a          LDRH     r0,[r0,#0x9a]         ;411
006e0e  1c40              ADDS     r0,r0,#1              ;411
006e10  b281              UXTH     r1,r0                 ;411
006e12  48c7              LDR      r0,|L1.28976|
006e14  f8a0109a          STRH     r1,[r0,#0x9a]         ;411
006e18  48c4              LDR      r0,|L1.28972|
006e1a  6800              LDR      r0,[r0,#0]            ;412  ; tcphdr
006e1c  8800              LDRH     r0,[r0,#0]            ;412
006e1e  49c3              LDR      r1,|L1.28972|
006e20  6809              LDR      r1,[r1,#0]            ;412  ; tcphdr
006e22  8849              LDRH     r1,[r1,#2]            ;412
006e24  e9cd1000          STRD     r1,r0,[sp,#0]         ;412
006e28  48c2              LDR      r0,|L1.28980|
006e2a  6800              LDR      r0,[r0,#0]            ;412  ; seqno
006e2c  4ac2              LDR      r2,|L1.28984|
006e2e  8812              LDRH     r2,[r2,#0]            ;412  ; tcplen
006e30  1881              ADDS     r1,r0,r2              ;412
006e32  4bc2              LDR      r3,|L1.28988|
006e34  4ac2              LDR      r2,|L1.28992|
006e36  48c3              LDR      r0,|L1.28996|
006e38  6800              LDR      r0,[r0,#0]            ;412  ; ackno
006e3a  f7fffffe          BL       tcp_rst
                  |L1.28222|
006e3e  4630              MOV      r0,r6                 ;416
006e40  f7fffffe          BL       pbuf_free
                  |L1.28228|
006e44  bf00              NOP                            ;419
006e46  bf00              NOP                            ;419
006e48  e67f              B        |L1.27466|
                  |L1.28234|
006e4a  48b9              LDR      r0,|L1.28976|
006e4c  f8b0009a          LDRH     r0,[r0,#0x9a]         ;423
006e50  1c40              ADDS     r0,r0,#1              ;423
006e52  b281              UXTH     r1,r0                 ;423
006e54  48b6              LDR      r0,|L1.28976|
006e56  f8a0109a          STRH     r1,[r0,#0x9a]         ;423
006e5a  4630              MOV      r0,r6                 ;425
006e5c  f7fffffe          BL       pbuf_free
006e60  bf00              NOP      
006e62  e672              B        |L1.27466|
;;;427    
                          ENDP

                  udp_input PROC
;;;150    void
;;;151    udp_input(struct pbuf *p, struct netif *inp)
006e64  e92d5fff          PUSH     {r0-r12,lr}
;;;152    {
006e68  4606              MOV      r6,r0
006e6a  460d              MOV      r5,r1
;;;153      struct udp_hdr *udphdr;
;;;154      struct udp_pcb *pcb, *prev;
;;;155      struct udp_pcb *uncon_pcb;
;;;156      struct ip_hdr *iphdr;
;;;157      u16_t src, dest;
;;;158      u8_t local_match;
;;;159      u8_t broadcast;
;;;160    
;;;161      PERF_START;
;;;162    
;;;163      UDP_STATS_INC(udp.recv);
006e6c  48b0              LDR      r0,|L1.28976|
006e6e  f8b0007e          LDRH     r0,[r0,#0x7e]
006e72  1c40              ADDS     r0,r0,#1
006e74  b281              UXTH     r1,r0
006e76  48ae              LDR      r0,|L1.28976|
006e78  f8a0107e          STRH     r1,[r0,#0x7e]
;;;164    
;;;165      iphdr = (struct ip_hdr *)p->payload;
006e7c  6870              LDR      r0,[r6,#4]
006e7e  9002              STR      r0,[sp,#8]
;;;166    
;;;167      /* Check minimum length (IP header + UDP header)
;;;168       * and move payload pointer to UDP header */
;;;169      if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
006e80  8931              LDRH     r1,[r6,#8]
006e82  9802              LDR      r0,[sp,#8]
006e84  7800              LDRB     r0,[r0,#0]
006e86  f000000f          AND      r0,r0,#0xf
006e8a  2208              MOVS     r2,#8
006e8c  eb020080          ADD      r0,r2,r0,LSL #2
006e90  4281              CMP      r1,r0
006e92  db08              BLT      |L1.28326|
006e94  9802              LDR      r0,[sp,#8]
006e96  7800              LDRB     r0,[r0,#0]
006e98  0700              LSLS     r0,r0,#28
006e9a  0e80              LSRS     r0,r0,#26
006e9c  4241              RSBS     r1,r0,#0
006e9e  4630              MOV      r0,r6
006ea0  f7fffffe          BL       pbuf_header
006ea4  b1a0              CBZ      r0,|L1.28368|
                  |L1.28326|
;;;170        /* drop short packets */
;;;171        LWIP_DEBUGF(UDP_DEBUG,
006ea6  bf00              NOP      
006ea8  bf00              NOP      
;;;172                    ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
;;;173        UDP_STATS_INC(udp.lenerr);
006eaa  48a1              LDR      r0,|L1.28976|
006eac  f8b00086          LDRH     r0,[r0,#0x86]
006eb0  1c40              ADDS     r0,r0,#1
006eb2  b281              UXTH     r1,r0
006eb4  489e              LDR      r0,|L1.28976|
006eb6  f8a01086          STRH     r1,[r0,#0x86]
;;;174        UDP_STATS_INC(udp.drop);
006eba  f8b00082          LDRH     r0,[r0,#0x82]
006ebe  1c40              ADDS     r0,r0,#1
006ec0  b281              UXTH     r1,r0
006ec2  489b              LDR      r0,|L1.28976|
006ec4  f8a01082          STRH     r1,[r0,#0x82]
;;;175        snmp_inc_udpinerrors();
;;;176        pbuf_free(p);
006ec8  4630              MOV      r0,r6
006eca  f7fffffe          BL       pbuf_free
;;;177        goto end;
006ece  e0ef              B        |L1.28848|
                  |L1.28368|
;;;178      }
;;;179    
;;;180      udphdr = (struct udp_hdr *)p->payload;
006ed0  f8d6b004          LDR      r11,[r6,#4]
;;;181    
;;;182      /* is broadcast packet ? */
;;;183      broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
006ed4  499a              LDR      r1,|L1.28992|
006ed6  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
006ed8  4629              MOV      r1,r5
006eda  f7fffffe          BL       ip4_addr_isbroadcast
006ede  4607              MOV      r7,r0
;;;184    
;;;185      LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
006ee0  bf00              NOP      
006ee2  bf00              NOP      
;;;186    
;;;187      /* convert src and dest ports to host byte order */
;;;188      src = ntohs(udphdr->src);
006ee4  f8bb0000          LDRH     r0,[r11,#0]
006ee8  f7fffffe          BL       lwip_ntohs
006eec  4681              MOV      r9,r0
;;;189      dest = ntohs(udphdr->dest);
006eee  f8bb0002          LDRH     r0,[r11,#2]
006ef2  f7fffffe          BL       lwip_ntohs
006ef6  4682              MOV      r10,r0
;;;190    
;;;191      udp_debug_print(udphdr);
;;;192    
;;;193      /* print the UDP source and destination */
;;;194      LWIP_DEBUGF(UDP_DEBUG,
006ef8  bf00              NOP      
006efa  bf00              NOP      
;;;195                  ("udp (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") <-- "
;;;196                   "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;197                   ip4_addr1_16(&iphdr->dest), ip4_addr2_16(&iphdr->dest),
;;;198                   ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
;;;199                   ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
;;;200                   ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));
;;;201    
;;;202    #if LWIP_DHCP
;;;203      pcb = NULL;
006efc  2400              MOVS     r4,#0
;;;204      /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
;;;205         the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
;;;206      if (dest == DHCP_CLIENT_PORT) {
006efe  f1ba0f44          CMP      r10,#0x44
006f02  d11b              BNE      |L1.28476|
;;;207        /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
;;;208        if (src == DHCP_SERVER_PORT) {
006f04  f1b90f43          CMP      r9,#0x43
006f08  d176              BNE      |L1.28664|
;;;209          if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
006f0a  6a28              LDR      r0,[r5,#0x20]
006f0c  2800              CMP      r0,#0
006f0e  d073              BEQ      |L1.28664|
006f10  6a28              LDR      r0,[r5,#0x20]
006f12  6840              LDR      r0,[r0,#4]
006f14  2800              CMP      r0,#0
006f16  d06f              BEQ      |L1.28664|
;;;210            /* accept the packe if 
;;;211               (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
;;;212               - inp->dhcp->pcb->remote == ANY or iphdr->src */
;;;213            if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
006f18  6a28              LDR      r0,[r5,#0x20]
006f1a  6840              LDR      r0,[r0,#4]
006f1c  1d00              ADDS     r0,r0,#4
006f1e  d00a              BEQ      |L1.28470|
006f20  6a28              LDR      r0,[r5,#0x20]
006f22  6840              LDR      r0,[r0,#4]
006f24  6840              LDR      r0,[r0,#4]
006f26  b130              CBZ      r0,|L1.28470|
;;;214               ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
006f28  6a28              LDR      r0,[r5,#0x20]
006f2a  6840              LDR      r0,[r0,#4]
006f2c  6840              LDR      r0,[r0,#4]
006f2e  4983              LDR      r1,|L1.28988|
006f30  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
006f32  4288              CMP      r0,r1
006f34  d160              BNE      |L1.28664|
                  |L1.28470|
;;;215              pcb = inp->dhcp->pcb;
006f36  6a28              LDR      r0,[r5,#0x20]
006f38  6844              LDR      r4,[r0,#4]
006f3a  e05d              B        |L1.28664|
                  |L1.28476|
;;;216            }
;;;217          }
;;;218        }
;;;219      } else
;;;220    #endif /* LWIP_DHCP */
;;;221      {
;;;222        prev = NULL;
006f3c  f04f0800          MOV      r8,#0
;;;223        local_match = 0;
006f40  2000              MOVS     r0,#0
006f42  9001              STR      r0,[sp,#4]
;;;224        uncon_pcb = NULL;
006f44  9003              STR      r0,[sp,#0xc]
;;;225        /* Iterate through the UDP pcb list for a matching pcb.
;;;226         * 'Perfect match' pcbs (connected to the remote port & ip address) are
;;;227         * preferred. If no perfect match is found, the first unconnected pcb that
;;;228         * matches the local port and ip address gets the datagram. */
;;;229        for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
006f46  4880              LDR      r0,|L1.29000|
006f48  6804              LDR      r4,[r0,#0]  ; udp_pcbs
006f4a  e050              B        |L1.28654|
                  |L1.28492|
;;;230          local_match = 0;
006f4c  2000              MOVS     r0,#0
006f4e  9001              STR      r0,[sp,#4]
;;;231          /* print the PCB local and remote address */
;;;232          LWIP_DEBUGF(UDP_DEBUG,
006f50  bf00              NOP      
006f52  bf00              NOP      
;;;233                      ("pcb (%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F") --- "
;;;234                       "(%"U16_F".%"U16_F".%"U16_F".%"U16_F", %"U16_F")\n",
;;;235                       ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
;;;236                       ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
;;;237                       ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;238                       ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));
;;;239    
;;;240          /* compare PCB local addr+port to UDP destination addr+port */
;;;241          if (pcb->local_port == dest) {
006f54  8a60              LDRH     r0,[r4,#0x12]
006f56  4550              CMP      r0,r10
006f58  d124              BNE      |L1.28580|
;;;242            if (
006f5a  b917              CBNZ     r7,|L1.28514|
;;;243               (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
006f5c  b1cc              CBZ      r4,|L1.28562|
006f5e  6820              LDR      r0,[r4,#0]
006f60  b1b8              CBZ      r0,|L1.28562|
                  |L1.28514|
;;;244               ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
006f62  4977              LDR      r1,|L1.28992|
006f64  6820              LDR      r0,[r4,#0]
006f66  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
006f68  4288              CMP      r0,r1
006f6a  d012              BEQ      |L1.28562|
;;;245    #if LWIP_IGMP
;;;246               ip_addr_ismulticast(&current_iphdr_dest) ||
006f6c  4874              LDR      r0,|L1.28992|
006f6e  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
006f70  f00000f0          AND      r0,r0,#0xf0
006f74  28e0              CMP      r0,#0xe0
006f76  d00c              BEQ      |L1.28562|
;;;247    #endif /* LWIP_IGMP */
;;;248    #if IP_SOF_BROADCAST_RECV
;;;249                (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
;;;250                 (ip_addr_isany(&pcb->local_ip) ||
;;;251                  ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
;;;252    #else /* IP_SOF_BROADCAST_RECV */
;;;253                (broadcast &&
006f78  b1a7              CBZ      r7,|L1.28580|
;;;254                 (ip_addr_isany(&pcb->local_ip) ||
006f7a  b154              CBZ      r4,|L1.28562|
006f7c  6820              LDR      r0,[r4,#0]
006f7e  b140              CBZ      r0,|L1.28562|
;;;255                  ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
006f80  6820              LDR      r0,[r4,#0]
006f82  68a9              LDR      r1,[r5,#8]
006f84  4008              ANDS     r0,r0,r1
006f86  496e              LDR      r1,|L1.28992|
006f88  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
006f8a  68aa              LDR      r2,[r5,#8]
006f8c  4011              ANDS     r1,r1,r2
006f8e  4288              CMP      r0,r1
006f90  d108              BNE      |L1.28580|
                  |L1.28562|
;;;256    #endif /* IP_SOF_BROADCAST_RECV */ 
;;;257              local_match = 1;
006f92  2001              MOVS     r0,#1
006f94  9001              STR      r0,[sp,#4]
;;;258              if ((uncon_pcb == NULL) && 
006f96  9803              LDR      r0,[sp,#0xc]
006f98  b920              CBNZ     r0,|L1.28580|
;;;259                  ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
006f9a  7c20              LDRB     r0,[r4,#0x10]
006f9c  f0100f04          TST      r0,#4
006fa0  d100              BNE      |L1.28580|
;;;260                /* the first unconnected matching PCB */
;;;261                uncon_pcb = pcb;
006fa2  9403              STR      r4,[sp,#0xc]
                  |L1.28580|
;;;262              }
;;;263            }
;;;264          }
;;;265          /* compare PCB remote addr+port to UDP source addr+port */
;;;266          if ((local_match != 0) &&
006fa4  9801              LDR      r0,[sp,#4]
006fa6  b300              CBZ      r0,|L1.28650|
;;;267              (pcb->remote_port == src) &&
006fa8  8aa0              LDRH     r0,[r4,#0x14]
006faa  4548              CMP      r0,r9
006fac  d11d              BNE      |L1.28650|
;;;268              (ip_addr_isany(&pcb->remote_ip) ||
006fae  1d20              ADDS     r0,r4,#4
006fb0  d006              BEQ      |L1.28608|
006fb2  6860              LDR      r0,[r4,#4]
006fb4  b120              CBZ      r0,|L1.28608|
;;;269               ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
006fb6  4961              LDR      r1,|L1.28988|
006fb8  6860              LDR      r0,[r4,#4]
006fba  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
006fbc  4288              CMP      r0,r1
006fbe  d114              BNE      |L1.28650|
                  |L1.28608|
;;;270            /* the first fully matching PCB */
;;;271            if (prev != NULL) {
006fc0  f1b80f00          CMP      r8,#0
006fc4  d008              BEQ      |L1.28632|
;;;272              /* move the pcb to the front of udp_pcbs so that is
;;;273                 found faster next time */
;;;274              prev->next = pcb->next;
006fc6  68e0              LDR      r0,[r4,#0xc]
006fc8  f8c8000c          STR      r0,[r8,#0xc]
;;;275              pcb->next = udp_pcbs;
006fcc  485e              LDR      r0,|L1.29000|
006fce  6800              LDR      r0,[r0,#0]  ; udp_pcbs
006fd0  60e0              STR      r0,[r4,#0xc]
;;;276              udp_pcbs = pcb;
006fd2  485d              LDR      r0,|L1.29000|
006fd4  6004              STR      r4,[r0,#0]  ; udp_pcbs
006fd6  e007              B        |L1.28648|
                  |L1.28632|
;;;277            } else {
;;;278              UDP_STATS_INC(udp.cachehit);
006fd8  4855              LDR      r0,|L1.28976|
006fda  f8b00092          LDRH     r0,[r0,#0x92]
006fde  1c40              ADDS     r0,r0,#1
006fe0  b281              UXTH     r1,r0
006fe2  4853              LDR      r0,|L1.28976|
006fe4  f8a01092          STRH     r1,[r0,#0x92]
                  |L1.28648|
;;;279            }
;;;280            break;
006fe8  e003              B        |L1.28658|
                  |L1.28650|
;;;281          }
;;;282          prev = pcb;
006fea  46a0              MOV      r8,r4
006fec  68e4              LDR      r4,[r4,#0xc]          ;229
                  |L1.28654|
006fee  2c00              CMP      r4,#0                 ;229
006ff0  d1ac              BNE      |L1.28492|
                  |L1.28658|
006ff2  bf00              NOP                            ;280
;;;283        }
;;;284        /* no fully matching pcb found? then look for an unconnected pcb */
;;;285        if (pcb == NULL) {
006ff4  b904              CBNZ     r4,|L1.28664|
;;;286          pcb = uncon_pcb;
006ff6  9c03              LDR      r4,[sp,#0xc]
                  |L1.28664|
;;;287        }
;;;288      }
;;;289    
;;;290      /* Check checksum if this is a match or if it was directed at us. */
;;;291      if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
006ff8  b924              CBNZ     r4,|L1.28676|
006ffa  4951              LDR      r1,|L1.28992|
006ffc  6868              LDR      r0,[r5,#4]
006ffe  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
007000  4288              CMP      r0,r1
007002  d151              BNE      |L1.28840|
                  |L1.28676|
;;;292        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
007004  bf00              NOP      
007006  bf00              NOP      
;;;293    #if LWIP_UDPLITE
;;;294        if (IPH_PROTO(iphdr) == IP_PROTO_UDPLITE) {
;;;295          /* Do the UDP Lite checksum */
;;;296    #if CHECKSUM_CHECK_UDP
;;;297          u16_t chklen = ntohs(udphdr->len);
;;;298          if (chklen < sizeof(struct udp_hdr)) {
;;;299            if (chklen == 0) {
;;;300              /* For UDP-Lite, checksum length of 0 means checksum
;;;301                 over the complete packet (See RFC 3828 chap. 3.1) */
;;;302              chklen = p->tot_len;
;;;303            } else {
;;;304              /* At least the UDP-Lite header must be covered by the
;;;305                 checksum! (Again, see RFC 3828 chap. 3.1) */
;;;306              UDP_STATS_INC(udp.chkerr);
;;;307              UDP_STATS_INC(udp.drop);
;;;308              snmp_inc_udpinerrors();
;;;309              pbuf_free(p);
;;;310              goto end;
;;;311            }
;;;312          }
;;;313          if (inet_chksum_pseudo_partial(p, &current_iphdr_src, &current_iphdr_dest,
;;;314                                 IP_PROTO_UDPLITE, p->tot_len, chklen) != 0) {
;;;315           LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;316                       ("udp_input: UDP Lite datagram discarded due to failing checksum\n"));
;;;317            UDP_STATS_INC(udp.chkerr);
;;;318            UDP_STATS_INC(udp.drop);
;;;319            snmp_inc_udpinerrors();
;;;320            pbuf_free(p);
;;;321            goto end;
;;;322          }
;;;323    #endif /* CHECKSUM_CHECK_UDP */
;;;324        } else
;;;325    #endif /* LWIP_UDPLITE */
;;;326        {
;;;327    #if CHECKSUM_CHECK_UDP
;;;328          if (udphdr->chksum != 0) {
;;;329            if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;330                                   IP_PROTO_UDP, p->tot_len) != 0) {
;;;331              LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;332                          ("udp_input: UDP datagram discarded due to failing checksum\n"));
;;;333              UDP_STATS_INC(udp.chkerr);
;;;334              UDP_STATS_INC(udp.drop);
;;;335              snmp_inc_udpinerrors();
;;;336              pbuf_free(p);
;;;337              goto end;
;;;338            }
;;;339          }
;;;340    #endif /* CHECKSUM_CHECK_UDP */
;;;341        }
;;;342        if(pbuf_header(p, -UDP_HLEN)) {
007008  f06f0107          MVN      r1,#7
00700c  4630              MOV      r0,r6
00700e  f7fffffe          BL       pbuf_header
007012  b168              CBZ      r0,|L1.28720|
;;;343          /* Can we cope with this failing? Just assert for now */
;;;344          LWIP_ASSERT("pbuf_header failed\n", 0);
007014  bf00              NOP      
007016  bf00              NOP      
;;;345          UDP_STATS_INC(udp.drop);
007018  4845              LDR      r0,|L1.28976|
00701a  f8b00082          LDRH     r0,[r0,#0x82]
00701e  1c40              ADDS     r0,r0,#1
007020  b281              UXTH     r1,r0
007022  4843              LDR      r0,|L1.28976|
007024  f8a01082          STRH     r1,[r0,#0x82]
;;;346          snmp_inc_udpinerrors();
;;;347          pbuf_free(p);
007028  4630              MOV      r0,r6
00702a  f7fffffe          BL       pbuf_free
;;;348          goto end;
00702e  e03f              B        |L1.28848|
                  |L1.28720|
;;;349        }
;;;350        if (pcb != NULL) {
007030  b174              CBZ      r4,|L1.28752|
;;;351          snmp_inc_udpindatagrams();
;;;352    #if SO_REUSE && SO_REUSE_RXTOALL
;;;353          if ((broadcast || ip_addr_ismulticast(&current_iphdr_dest)) &&
;;;354              ip_get_option(pcb, SOF_REUSEADDR)) {
;;;355            /* pass broadcast- or multicast packets to all multicast pcbs
;;;356               if SOF_REUSEADDR is set on the first match */
;;;357            struct udp_pcb *mpcb;
;;;358            u8_t p_header_changed = 0;
;;;359            for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
;;;360              if (mpcb != pcb) {
;;;361                /* compare PCB local addr+port to UDP destination addr+port */
;;;362                if ((mpcb->local_port == dest) &&
;;;363                    ((!broadcast && ip_addr_isany(&mpcb->local_ip)) ||
;;;364                     ip_addr_cmp(&(mpcb->local_ip), &current_iphdr_dest) ||
;;;365    #if LWIP_IGMP
;;;366                     ip_addr_ismulticast(&current_iphdr_dest) ||
;;;367    #endif /* LWIP_IGMP */
;;;368    #if IP_SOF_BROADCAST_RECV
;;;369                     (broadcast && ip_get_option(mpcb, SOF_BROADCAST)))) {
;;;370    #else  /* IP_SOF_BROADCAST_RECV */
;;;371                     (broadcast))) {
;;;372    #endif /* IP_SOF_BROADCAST_RECV */
;;;373                  /* pass a copy of the packet to all local matches */
;;;374                  if (mpcb->recv != NULL) {
;;;375                    struct pbuf *q;
;;;376                    /* for that, move payload to IP header again */
;;;377                    if (p_header_changed == 0) {
;;;378                      pbuf_header(p, (s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;379                      p_header_changed = 1;
;;;380                    }
;;;381                    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;382                    if (q != NULL) {
;;;383                      err_t err = pbuf_copy(q, p);
;;;384                      if (err == ERR_OK) {
;;;385                        /* move payload to UDP data */
;;;386                        pbuf_header(q, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;387                        mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
;;;388                      }
;;;389                    }
;;;390                  }
;;;391                }
;;;392              }
;;;393            }
;;;394            if (p_header_changed) {
;;;395              /* and move payload to UDP data again */
;;;396              pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
;;;397            }
;;;398          }
;;;399    #endif /* SO_REUSE && SO_REUSE_RXTOALL */
;;;400          /* callback */
;;;401          if (pcb->recv != NULL) {
007032  69e0              LDR      r0,[r4,#0x1c]
007034  b140              CBZ      r0,|L1.28744|
;;;402            /* now the recv function is responsible for freeing p */
;;;403            pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
007036  f8cd9000          STR      r9,[sp,#0]
00703a  4b40              LDR      r3,|L1.28988|
00703c  4632              MOV      r2,r6
00703e  4621              MOV      r1,r4
007040  e9d4c007          LDRD     r12,r0,[r4,#0x1c]
007044  47e0              BLX      r12
007046  e032              B        |L1.28846|
                  |L1.28744|
;;;404          } else {
;;;405            /* no recv function registered? then we have to free the pbuf! */
;;;406            pbuf_free(p);
007048  4630              MOV      r0,r6
00704a  f7fffffe          BL       pbuf_free
;;;407            goto end;
00704e  e02f              B        |L1.28848|
                  |L1.28752|
;;;408          }
;;;409        } else {
;;;410          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
007050  bf00              NOP      
007052  bf00              NOP      
;;;411    
;;;412    #if LWIP_ICMP
;;;413          /* No match was found, send ICMP destination port unreachable unless
;;;414             destination address was broadcast/multicast. */
;;;415          if (!broadcast &&
007054  b9af              CBNZ     r7,|L1.28802|
;;;416              !ip_addr_ismulticast(&current_iphdr_dest)) {
007056  483a              LDR      r0,|L1.28992|
007058  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
00705a  f00000f0          AND      r0,r0,#0xf0
00705e  28e0              CMP      r0,#0xe0
007060  d00f              BEQ      |L1.28802|
;;;417            /* move payload pointer back to ip header */
;;;418            pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
007062  9802              LDR      r0,[sp,#8]
007064  7800              LDRB     r0,[r0,#0]
007066  f000000f          AND      r0,r0,#0xf
00706a  2208              MOVS     r2,#8
00706c  eb020180          ADD      r1,r2,r0,LSL #2
007070  4630              MOV      r0,r6
007072  f7fffffe          BL       pbuf_header
;;;419            LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
007076  bf00              NOP      
007078  bf00              NOP      
;;;420            icmp_dest_unreach(p, ICMP_DUR_PORT);
00707a  2103              MOVS     r1,#3
00707c  4630              MOV      r0,r6
00707e  f7fffffe          BL       icmp_dest_unreach
                  |L1.28802|
;;;421          }
;;;422    #endif /* LWIP_ICMP */
;;;423          UDP_STATS_INC(udp.proterr);
007082  482b              LDR      r0,|L1.28976|
007084  f8b0008c          LDRH     r0,[r0,#0x8c]
007088  1c40              ADDS     r0,r0,#1
00708a  b281              UXTH     r1,r0
00708c  4828              LDR      r0,|L1.28976|
00708e  f8a0108c          STRH     r1,[r0,#0x8c]
;;;424          UDP_STATS_INC(udp.drop);
007092  f8b00082          LDRH     r0,[r0,#0x82]
007096  1c40              ADDS     r0,r0,#1
007098  b281              UXTH     r1,r0
00709a  4825              LDR      r0,|L1.28976|
00709c  f8a01082          STRH     r1,[r0,#0x82]
;;;425          snmp_inc_udpnoports();
;;;426          pbuf_free(p);
0070a0  4630              MOV      r0,r6
0070a2  f7fffffe          BL       pbuf_free
0070a6  e002              B        |L1.28846|
                  |L1.28840|
;;;427        }
;;;428      } else {
;;;429        pbuf_free(p);
0070a8  4630              MOV      r0,r6
0070aa  f7fffffe          BL       pbuf_free
                  |L1.28846|
;;;430      }
;;;431    end:
0070ae  bf00              NOP      
                  |L1.28848|
;;;432      PERF_STOP("udp_input");
;;;433    }
0070b0  e8bd9fff          POP      {r0-r12,pc}
;;;434    
                          ENDP

                  raw_input PROC
;;;75     u8_t
;;;76     raw_input(struct pbuf *p, struct netif *inp)
0070b4  e92d47f0          PUSH     {r4-r10,lr}
;;;77     {
0070b8  4605              MOV      r5,r0
0070ba  468a              MOV      r10,r1
;;;78       struct raw_pcb *pcb, *prev;
;;;79       struct ip_hdr *iphdr;
;;;80       s16_t proto;
;;;81       u8_t eaten = 0;
0070bc  2700              MOVS     r7,#0
;;;82     
;;;83       LWIP_UNUSED_ARG(inp);
;;;84     
;;;85       iphdr = (struct ip_hdr *)p->payload;
0070be  f8d58004          LDR      r8,[r5,#4]
;;;86       proto = IPH_PROTO(iphdr);
0070c2  f8989009          LDRB     r9,[r8,#9]
;;;87     
;;;88       prev = NULL;
0070c6  2600              MOVS     r6,#0
;;;89       pcb = raw_pcbs;
0070c8  4820              LDR      r0,|L1.29004|
0070ca  6804              LDR      r4,[r0,#0]  ; raw_pcbs
;;;90       /* loop through all raw pcbs until the packet is eaten by one */
;;;91       /* this allows multiple pcbs to match against the packet by design */
;;;92       while ((eaten == 0) && (pcb != NULL)) {
0070cc  e01f              B        |L1.28942|
                  |L1.28878|
;;;93         if ((pcb->protocol == proto) &&
0070ce  7c20              LDRB     r0,[r4,#0x10]
0070d0  4548              CMP      r0,r9
0070d2  d11a              BNE      |L1.28938|
;;;94             (ip_addr_isany(&pcb->local_ip) ||
0070d4  b134              CBZ      r4,|L1.28900|
0070d6  6820              LDR      r0,[r4,#0]
0070d8  b120              CBZ      r0,|L1.28900|
;;;95              ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
0070da  4919              LDR      r1,|L1.28992|
0070dc  6820              LDR      r0,[r4,#0]
0070de  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
0070e0  4288              CMP      r0,r1
0070e2  d112              BNE      |L1.28938|
                  |L1.28900|
;;;96     #if IP_SOF_BROADCAST_RECV
;;;97           /* broadcast filter? */
;;;98           if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
;;;99     #endif /* IP_SOF_BROADCAST_RECV */
;;;100          {
;;;101            /* receive callback function available? */
;;;102            if (pcb->recv != NULL) {
0070e4  6960              LDR      r0,[r4,#0x14]
0070e6  b180              CBZ      r0,|L1.28938|
;;;103              /* the receive callback function did not eat the packet? */
;;;104              if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
0070e8  4b14              LDR      r3,|L1.28988|
0070ea  462a              MOV      r2,r5
0070ec  4621              MOV      r1,r4
0070ee  e9d4c005          LDRD     r12,r0,[r4,#0x14]
0070f2  47e0              BLX      r12
0070f4  b148              CBZ      r0,|L1.28938|
;;;105                /* receive function ate the packet */
;;;106                p = NULL;
0070f6  2500              MOVS     r5,#0
;;;107                eaten = 1;
0070f8  2701              MOVS     r7,#1
;;;108                if (prev != NULL) {
0070fa  b136              CBZ      r6,|L1.28938|
;;;109                /* move the pcb to the front of raw_pcbs so that is
;;;110                   found faster next time */
;;;111                  prev->next = pcb->next;
0070fc  68e0              LDR      r0,[r4,#0xc]
0070fe  60f0              STR      r0,[r6,#0xc]
;;;112                  pcb->next = raw_pcbs;
007100  4812              LDR      r0,|L1.29004|
007102  6800              LDR      r0,[r0,#0]  ; raw_pcbs
007104  60e0              STR      r0,[r4,#0xc]
;;;113                  raw_pcbs = pcb;
007106  4811              LDR      r0,|L1.29004|
007108  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L1.28938|
;;;114                }
;;;115              }
;;;116            }
;;;117            /* no receive callback function was set for this raw PCB */
;;;118          }
;;;119          /* drop the packet */
;;;120        }
;;;121        prev = pcb;
00710a  4626              MOV      r6,r4
;;;122        pcb = pcb->next;
00710c  68e4              LDR      r4,[r4,#0xc]
                  |L1.28942|
00710e  b90f              CBNZ     r7,|L1.28948|
007110  2c00              CMP      r4,#0                 ;92
007112  d1dc              BNE      |L1.28878|
                  |L1.28948|
;;;123      }
;;;124      return eaten;
007114  4638              MOV      r0,r7
;;;125    }
007116  e8bd87f0          POP      {r4-r10,pc}
00711a  0000              DCW      0x0000
                  |L1.28956|
                          DCD      recv_data
                  |L1.28960|
                          DCD      recv_flags
                  |L1.28964|
                          DCD      tcp_input_pcb
                  |L1.28968|
                          DCD      inseg
                  |L1.28972|
                          DCD      tcphdr
                  |L1.28976|
                          DCD      lwip_stats
                  |L1.28980|
                          DCD      seqno
                  |L1.28984|
                          DCD      tcplen
                  |L1.28988|
                          DCD      current_iphdr_src
                  |L1.28992|
                          DCD      current_iphdr_dest
                  |L1.28996|
                          DCD      ackno
                  |L1.29000|
                          DCD      udp_pcbs
                  |L1.29004|
                          DCD      raw_pcbs
                          ENDP

                  ip_input PROC
;;;304    err_t
;;;305    ip_input(struct pbuf *p, struct netif *inp)
007150  e92d5ff0          PUSH     {r4-r12,lr}
;;;306    {
007154  4607              MOV      r7,r0
007156  460e              MOV      r6,r1
;;;307      struct ip_hdr *iphdr;
;;;308      struct netif *netif;
;;;309      u16_t iphdr_hlen;
;;;310      u16_t iphdr_len;
;;;311    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;312      int check_ip_src=1;
007158  f04f0a01          MOV      r10,#1
;;;313    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;314    
;;;315      IP_STATS_INC(ip.recv);
00715c  48fe              LDR      r0,|L1.30040|
00715e  8e40              LDRH     r0,[r0,#0x32]
007160  1c40              ADDS     r0,r0,#1
007162  b281              UXTH     r1,r0
007164  48fc              LDR      r0,|L1.30040|
007166  8641              STRH     r1,[r0,#0x32]
;;;316      snmp_inc_ipinreceives();
;;;317    
;;;318      /* identify the IP header */
;;;319      iphdr = (struct ip_hdr *)p->payload;
007168  687d              LDR      r5,[r7,#4]
;;;320      if (IPH_V(iphdr) != 4) {
00716a  7828              LDRB     r0,[r5,#0]
00716c  2104              MOVS     r1,#4
00716e  ebb11f20          CMP      r1,r0,ASR #4
007172  d014              BEQ      |L1.29086|
;;;321        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
007174  bf00              NOP      
007176  bf00              NOP      
;;;322        ip_debug_print(p);
;;;323        pbuf_free(p);
007178  4638              MOV      r0,r7
00717a  f7fffffe          BL       pbuf_free
;;;324        IP_STATS_INC(ip.err);
00717e  48f6              LDR      r0,|L1.30040|
007180  f8b00044          LDRH     r0,[r0,#0x44]
007184  1c40              ADDS     r0,r0,#1
007186  b281              UXTH     r1,r0
007188  48f3              LDR      r0,|L1.30040|
00718a  f8a01044          STRH     r1,[r0,#0x44]
;;;325        IP_STATS_INC(ip.drop);
00718e  8ec0              LDRH     r0,[r0,#0x36]
007190  1c40              ADDS     r0,r0,#1
007192  b281              UXTH     r1,r0
007194  48f0              LDR      r0,|L1.30040|
007196  86c1              STRH     r1,[r0,#0x36]
;;;326        snmp_inc_ipinhdrerrors();
;;;327        return ERR_OK;
007198  2000              MOVS     r0,#0
                  |L1.29082|
;;;328      }
;;;329    
;;;330    #ifdef LWIP_HOOK_IP4_INPUT
;;;331      if (LWIP_HOOK_IP4_INPUT(p, inp)) {
;;;332        /* the packet has been eaten */
;;;333        return ERR_OK;
;;;334      }
;;;335    #endif
;;;336    
;;;337      /* obtain IP header length in number of 32-bit words */
;;;338      iphdr_hlen = IPH_HL(iphdr);
;;;339      /* calculate IP header length in bytes */
;;;340      iphdr_hlen *= 4;
;;;341      /* obtain ip length in bytes */
;;;342      iphdr_len = ntohs(IPH_LEN(iphdr));
;;;343    
;;;344      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;345      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
;;;346        if (iphdr_hlen > p->len) {
;;;347          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;348            ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;349            iphdr_hlen, p->len));
;;;350        }
;;;351        if (iphdr_len > p->tot_len) {
;;;352          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;353            ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
;;;354            iphdr_len, p->tot_len));
;;;355        }
;;;356        /* free (drop) packet pbufs */
;;;357        pbuf_free(p);
;;;358        IP_STATS_INC(ip.lenerr);
;;;359        IP_STATS_INC(ip.drop);
;;;360        snmp_inc_ipindiscards();
;;;361        return ERR_OK;
;;;362      }
;;;363    
;;;364      /* verify checksum */
;;;365    #if CHECKSUM_CHECK_IP
;;;366      if (inet_chksum(iphdr, iphdr_hlen) != 0) {
;;;367    
;;;368        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;369          ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;370        ip_debug_print(p);
;;;371        pbuf_free(p);
;;;372        IP_STATS_INC(ip.chkerr);
;;;373        IP_STATS_INC(ip.drop);
;;;374        snmp_inc_ipinhdrerrors();
;;;375        return ERR_OK;
;;;376      }
;;;377    #endif
;;;378    
;;;379      /* Trim pbuf. This should have been done at the netif layer,
;;;380       * but we'll do it anyway just to be sure that its done. */
;;;381      pbuf_realloc(p, iphdr_len);
;;;382    
;;;383      /* copy IP addresses to aligned ip_addr_t */
;;;384      ip_addr_copy(current_iphdr_dest, iphdr->dest);
;;;385      ip_addr_copy(current_iphdr_src, iphdr->src);
;;;386    
;;;387      /* match packet against an interface, i.e. is this packet for us? */
;;;388    #if LWIP_IGMP
;;;389      if (ip_addr_ismulticast(&current_iphdr_dest)) {
;;;390        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &current_iphdr_dest))) {
;;;391          netif = inp;
;;;392        } else {
;;;393          netif = NULL;
;;;394        }
;;;395      } else
;;;396    #endif /* LWIP_IGMP */
;;;397      {
;;;398        /* start trying with inp. if that's not acceptable, start walking the
;;;399           list of configured netifs.
;;;400           'first' is used as a boolean to mark whether we started walking the list */
;;;401        int first = 1;
;;;402        netif = inp;
;;;403        do {
;;;404          LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;405              ip4_addr_get_u32(&iphdr->dest), ip4_addr_get_u32(&netif->ip_addr),
;;;406              ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
;;;407              ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
;;;408              ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));
;;;409    
;;;410          /* interface is up and configured? */
;;;411          if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
;;;412            /* unicast to this interface address? */
;;;413            if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
;;;414                /* or broadcast on this interface network address? */
;;;415                ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
;;;416              LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
;;;417                  netif->name[0], netif->name[1]));
;;;418              /* break out of for loop */
;;;419              break;
;;;420            }
;;;421    #if LWIP_AUTOIP
;;;422            /* connections to link-local addresses must persist after changing
;;;423               the netif's address (RFC3927 ch. 1.9) */
;;;424            if ((netif->autoip != NULL) &&
;;;425                ip_addr_cmp(&current_iphdr_dest, &(netif->autoip->llipaddr))) {
;;;426              LWIP_DEBUGF(IP_DEBUG, ("ip_input: LLA packet accepted on interface %c%c\n",
;;;427                  netif->name[0], netif->name[1]));
;;;428              /* break out of for loop */
;;;429              break;
;;;430            }
;;;431    #endif /* LWIP_AUTOIP */
;;;432          }
;;;433          if (first) {
;;;434            first = 0;
;;;435            netif = netif_list;
;;;436          } else {
;;;437            netif = netif->next;
;;;438          }
;;;439          if (netif == inp) {
;;;440            netif = netif->next;
;;;441          }
;;;442        } while(netif != NULL);
;;;443      }
;;;444    
;;;445    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;446      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;447       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;448       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;449       *
;;;450       * If you want to accept private broadcast communication while a netif is down,
;;;451       * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
;;;452       *
;;;453       * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
;;;454       */
;;;455      if (netif == NULL) {
;;;456        /* remote port is DHCP server? */
;;;457        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
;;;458          struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
;;;459          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
;;;460            ntohs(udphdr->dest)));
;;;461          if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
;;;462            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
;;;463            netif = inp;
;;;464            check_ip_src = 0;
;;;465          }
;;;466        }
;;;467      }
;;;468    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;469    
;;;470      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;471    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;472      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
;;;473      if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
;;;474    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;475      {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
;;;476             (ip_addr_ismulticast(&current_iphdr_src))) {
;;;477          /* packet source is not valid */
;;;478          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
;;;479          /* free (drop) packet pbufs */
;;;480          pbuf_free(p);
;;;481          IP_STATS_INC(ip.drop);
;;;482          snmp_inc_ipinaddrerrors();
;;;483          snmp_inc_ipindiscards();
;;;484          return ERR_OK;
;;;485        }
;;;486      }
;;;487    
;;;488      /* packet not for us? */
;;;489      if (netif == NULL) {
;;;490        /* packet not for us, route or discard */
;;;491        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: packet not for us.\n"));
;;;492    #if IP_FORWARD
;;;493        /* non-broadcast packet? */
;;;494        if (!ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
;;;495          /* try to forward IP packet on (other) interfaces */
;;;496          ip_forward(p, iphdr, inp);
;;;497        } else
;;;498    #endif /* IP_FORWARD */
;;;499        {
;;;500          snmp_inc_ipinaddrerrors();
;;;501          snmp_inc_ipindiscards();
;;;502        }
;;;503        pbuf_free(p);
;;;504        return ERR_OK;
;;;505      }
;;;506      /* packet consists of multiple fragments? */
;;;507      if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
;;;508    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;509        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
;;;510          ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
;;;511        /* reassemble the packet*/
;;;512        p = ip_reass(p);
;;;513        /* packet not fully reassembled yet? */
;;;514        if (p == NULL) {
;;;515          return ERR_OK;
;;;516        }
;;;517        iphdr = (struct ip_hdr *)p->payload;
;;;518    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;519        pbuf_free(p);
;;;520        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;521          ntohs(IPH_OFFSET(iphdr))));
;;;522        IP_STATS_INC(ip.opterr);
;;;523        IP_STATS_INC(ip.drop);
;;;524        /* unsupported protocol feature */
;;;525        snmp_inc_ipinunknownprotos();
;;;526        return ERR_OK;
;;;527    #endif /* IP_REASSEMBLY */
;;;528      }
;;;529    
;;;530    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;531    
;;;532    #if LWIP_IGMP
;;;533      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;534      if((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;535    #else
;;;536      if (iphdr_hlen > IP_HLEN) {
;;;537    #endif /* LWIP_IGMP */
;;;538        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;539        pbuf_free(p);
;;;540        IP_STATS_INC(ip.opterr);
;;;541        IP_STATS_INC(ip.drop);
;;;542        /* unsupported protocol feature */
;;;543        snmp_inc_ipinunknownprotos();
;;;544        return ERR_OK;
;;;545      }
;;;546    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;547    
;;;548      /* send to upper layers */
;;;549      LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
;;;550      ip_debug_print(p);
;;;551      LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;552    
;;;553      current_netif = inp;
;;;554      current_header = iphdr;
;;;555    
;;;556    #if LWIP_RAW
;;;557      /* raw input did not eat the packet? */
;;;558      if (raw_input(p, inp) == 0)
;;;559    #endif /* LWIP_RAW */
;;;560      {
;;;561        switch (IPH_PROTO(iphdr)) {
;;;562    #if LWIP_UDP
;;;563        case IP_PROTO_UDP:
;;;564    #if LWIP_UDPLITE
;;;565        case IP_PROTO_UDPLITE:
;;;566    #endif /* LWIP_UDPLITE */
;;;567          snmp_inc_ipindelivers();
;;;568          udp_input(p, inp);
;;;569          break;
;;;570    #endif /* LWIP_UDP */
;;;571    #if LWIP_TCP
;;;572        case IP_PROTO_TCP:
;;;573          snmp_inc_ipindelivers();
;;;574          tcp_input(p, inp);
;;;575          break;
;;;576    #endif /* LWIP_TCP */
;;;577    #if LWIP_ICMP
;;;578        case IP_PROTO_ICMP:
;;;579          snmp_inc_ipindelivers();
;;;580          icmp_input(p, inp);
;;;581          break;
;;;582    #endif /* LWIP_ICMP */
;;;583    #if LWIP_IGMP
;;;584        case IP_PROTO_IGMP:
;;;585          igmp_input(p, inp, &current_iphdr_dest);
;;;586          break;
;;;587    #endif /* LWIP_IGMP */
;;;588        default:
;;;589    #if LWIP_ICMP
;;;590          /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;591          if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
;;;592              !ip_addr_ismulticast(&current_iphdr_dest)) {
;;;593            p->payload = iphdr;
;;;594            icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;595          }
;;;596    #endif /* LWIP_ICMP */
;;;597          pbuf_free(p);
;;;598    
;;;599          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));
;;;600    
;;;601          IP_STATS_INC(ip.proterr);
;;;602          IP_STATS_INC(ip.drop);
;;;603          snmp_inc_ipinunknownprotos();
;;;604        }
;;;605      }
;;;606    
;;;607      current_netif = NULL;
;;;608      current_header = NULL;
;;;609      ip_addr_set_any(&current_iphdr_src);
;;;610      ip_addr_set_any(&current_iphdr_dest);
;;;611    
;;;612      return ERR_OK;
;;;613    }
00719a  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.29086|
00719e  7828              LDRB     r0,[r5,#0]            ;338
0071a0  f000080f          AND      r8,r0,#0xf            ;338
0071a4  f64f70ff          MOV      r0,#0xffff            ;340
0071a8  ea000888          AND      r8,r0,r8,LSL #2       ;340
0071ac  8868              LDRH     r0,[r5,#2]            ;342
0071ae  f7fffffe          BL       lwip_ntohs
0071b2  4681              MOV      r9,r0                 ;342
0071b4  8978              LDRH     r0,[r7,#0xa]          ;345
0071b6  4540              CMP      r0,r8                 ;345
0071b8  db02              BLT      |L1.29120|
0071ba  8938              LDRH     r0,[r7,#8]            ;345
0071bc  4548              CMP      r0,r9                 ;345
0071be  da19              BGE      |L1.29172|
                  |L1.29120|
0071c0  8978              LDRH     r0,[r7,#0xa]          ;346
0071c2  4540              CMP      r0,r8                 ;346
0071c4  da01              BGE      |L1.29130|
0071c6  bf00              NOP                            ;347
0071c8  bf00              NOP                            ;347
                  |L1.29130|
0071ca  8938              LDRH     r0,[r7,#8]            ;351
0071cc  4548              CMP      r0,r9                 ;351
0071ce  da01              BGE      |L1.29140|
0071d0  bf00              NOP                            ;352
0071d2  bf00              NOP                            ;352
                  |L1.29140|
0071d4  4638              MOV      r0,r7                 ;357
0071d6  f7fffffe          BL       pbuf_free
0071da  48df              LDR      r0,|L1.30040|
0071dc  8f40              LDRH     r0,[r0,#0x3a]         ;358
0071de  1c40              ADDS     r0,r0,#1              ;358
0071e0  b281              UXTH     r1,r0                 ;358
0071e2  48dd              LDR      r0,|L1.30040|
0071e4  8741              STRH     r1,[r0,#0x3a]         ;358
0071e6  8ec0              LDRH     r0,[r0,#0x36]         ;359
0071e8  1c40              ADDS     r0,r0,#1              ;359
0071ea  b281              UXTH     r1,r0                 ;359
0071ec  48da              LDR      r0,|L1.30040|
0071ee  86c1              STRH     r1,[r0,#0x36]         ;359
0071f0  2000              MOVS     r0,#0                 ;361
0071f2  e7d2              B        |L1.29082|
                  |L1.29172|
0071f4  4649              MOV      r1,r9                 ;381
0071f6  4638              MOV      r0,r7                 ;381
0071f8  f7fffffe          BL       pbuf_realloc
0071fc  6928              LDR      r0,[r5,#0x10]         ;384
0071fe  49d7              LDR      r1,|L1.30044|
007200  6008              STR      r0,[r1,#0]            ;384  ; current_iphdr_dest
007202  68e8              LDR      r0,[r5,#0xc]          ;385
007204  49d6              LDR      r1,|L1.30048|
007206  6008              STR      r0,[r1,#0]            ;385  ; current_iphdr_src
007208  48d4              LDR      r0,|L1.30044|
00720a  7800              LDRB     r0,[r0,#0]            ;389  ; current_iphdr_dest
00720c  f00000f0          AND      r0,r0,#0xf0           ;389
007210  28e0              CMP      r0,#0xe0              ;389
007212  d10d              BNE      |L1.29232|
007214  f8960031          LDRB     r0,[r6,#0x31]         ;390
007218  f0100f80          TST      r0,#0x80              ;390
00721c  d006              BEQ      |L1.29228|
00721e  49cf              LDR      r1,|L1.30044|
007220  4630              MOV      r0,r6                 ;390
007222  f7fffffe          BL       igmp_lookfor_group
007226  b108              CBZ      r0,|L1.29228|
007228  4634              MOV      r4,r6                 ;391
00722a  e039              B        |L1.29344|
                  |L1.29228|
00722c  2400              MOVS     r4,#0                 ;393
00722e  e037              B        |L1.29344|
                  |L1.29232|
007230  f04f0b01          MOV      r11,#1                ;401
007234  4634              MOV      r4,r6                 ;402
007236  bf00              NOP                            ;403
                  |L1.29240|
007238  bf00              NOP                            ;404
00723a  bf00              NOP                            ;404
00723c  f8940031          LDRB     r0,[r4,#0x31]         ;411
007240  f0100f01          TST      r0,#1                 ;411
007244  d01c              BEQ      |L1.29312|
007246  1d20              ADDS     r0,r4,#4              ;411
007248  d01a              BEQ      |L1.29312|
00724a  6860              LDR      r0,[r4,#4]            ;411
00724c  b1c0              CBZ      r0,|L1.29312|
00724e  48c3              LDR      r0,|L1.30044|
007250  6800              LDR      r0,[r0,#0]            ;413  ; current_iphdr_dest
007252  6861              LDR      r1,[r4,#4]            ;413
007254  4288              CMP      r0,r1                 ;413
007256  d005              BEQ      |L1.29284|
007258  49c0              LDR      r1,|L1.30044|
00725a  6808              LDR      r0,[r1,#0]            ;415  ; current_iphdr_dest
00725c  4621              MOV      r1,r4                 ;415
00725e  f7fffffe          BL       ip4_addr_isbroadcast
007262  b110              CBZ      r0,|L1.29290|
                  |L1.29284|
007264  bf00              NOP                            ;416
007266  bf00              NOP                            ;416
007268  e018              B        |L1.29340|
                  |L1.29290|
00726a  6a60              LDR      r0,[r4,#0x24]         ;424
00726c  b140              CBZ      r0,|L1.29312|
00726e  48bb              LDR      r0,|L1.30044|
007270  6800              LDR      r0,[r0,#0]            ;425  ; current_iphdr_dest
007272  6a61              LDR      r1,[r4,#0x24]         ;425
007274  6809              LDR      r1,[r1,#0]            ;425
007276  4288              CMP      r0,r1                 ;425
007278  d102              BNE      |L1.29312|
00727a  bf00              NOP                            ;426
00727c  bf00              NOP                            ;426
00727e  e00d              B        |L1.29340|
                  |L1.29312|
007280  f1bb0f00          CMP      r11,#0                ;433
007284  d004              BEQ      |L1.29328|
007286  f04f0b00          MOV      r11,#0                ;434
00728a  48b6              LDR      r0,|L1.30052|
00728c  6804              LDR      r4,[r0,#0]            ;435  ; netif_list
00728e  e000              B        |L1.29330|
                  |L1.29328|
007290  6824              LDR      r4,[r4,#0]            ;437
                  |L1.29330|
007292  42b4              CMP      r4,r6                 ;439
007294  d100              BNE      |L1.29336|
007296  6824              LDR      r4,[r4,#0]            ;440
                  |L1.29336|
007298  2c00              CMP      r4,#0                 ;442
00729a  d1cd              BNE      |L1.29240|
                  |L1.29340|
00729c  bf00              NOP                            ;419
00729e  bf00              NOP                            ;443
                  |L1.29344|
0072a0  b984              CBNZ     r4,|L1.29380|
0072a2  7a68              LDRB     r0,[r5,#9]            ;457
0072a4  2811              CMP      r0,#0x11              ;457
0072a6  d10d              BNE      |L1.29380|
0072a8  eb050008          ADD      r0,r5,r8              ;458
0072ac  bf00              NOP                            ;459
0072ae  bf00              NOP                            ;459
0072b0  8841              LDRH     r1,[r0,#2]            ;461
0072b2  f5b14f88          CMP      r1,#0x4400            ;461
0072b6  d104              BNE      |L1.29378|
0072b8  bf00              NOP                            ;462
0072ba  bf00              NOP                            ;462
0072bc  4634              MOV      r4,r6                 ;463
0072be  f04f0a00          MOV      r10,#0                ;464
                  |L1.29378|
0072c2  bf00              NOP                            ;466
                  |L1.29380|
0072c4  f1ba0f00          CMP      r10,#0                ;473
0072c8  d01c              BEQ      |L1.29444|
0072ca  48a5              LDR      r0,|L1.30048|
0072cc  b1d0              CBZ      r0,|L1.29444|
0072ce  6800              LDR      r0,[r0,#0]            ;473  ; current_iphdr_src
0072d0  b1c0              CBZ      r0,|L1.29444|
0072d2  49a3              LDR      r1,|L1.30048|
0072d4  6808              LDR      r0,[r1,#0]            ;475  ; current_iphdr_src
0072d6  4631              MOV      r1,r6                 ;475
0072d8  f7fffffe          BL       ip4_addr_isbroadcast
0072dc  b928              CBNZ     r0,|L1.29418|
0072de  48a0              LDR      r0,|L1.30048|
0072e0  7800              LDRB     r0,[r0,#0]            ;476  ; current_iphdr_src
0072e2  f00000f0          AND      r0,r0,#0xf0           ;476
0072e6  28e0              CMP      r0,#0xe0              ;476
0072e8  d10c              BNE      |L1.29444|
                  |L1.29418|
0072ea  bf00              NOP                            ;478
0072ec  bf00              NOP                            ;478
0072ee  4638              MOV      r0,r7                 ;480
0072f0  f7fffffe          BL       pbuf_free
0072f4  4898              LDR      r0,|L1.30040|
0072f6  8ec0              LDRH     r0,[r0,#0x36]         ;481
0072f8  1c40              ADDS     r0,r0,#1              ;481
0072fa  b281              UXTH     r1,r0                 ;481
0072fc  4896              LDR      r0,|L1.30040|
0072fe  86c1              STRH     r1,[r0,#0x36]         ;481
007300  2000              MOVS     r0,#0                 ;484
007302  e74a              B        |L1.29082|
                  |L1.29444|
007304  b934              CBNZ     r4,|L1.29460|
007306  bf00              NOP                            ;491
007308  bf00              NOP                            ;491
00730a  4638              MOV      r0,r7                 ;503
00730c  f7fffffe          BL       pbuf_free
007310  2000              MOVS     r0,#0                 ;504
007312  e742              B        |L1.29082|
                  |L1.29460|
007314  88e8              LDRH     r0,[r5,#6]            ;507
007316  f64f713f          MOV      r1,#0xff3f            ;507
00731a  4208              TST      r0,r1                 ;507
00731c  d013              BEQ      |L1.29510|
00731e  4638              MOV      r0,r7                 ;519
007320  f7fffffe          BL       pbuf_free
007324  bf00              NOP                            ;520
007326  bf00              NOP                            ;520
007328  488b              LDR      r0,|L1.30040|
00732a  f8b00042          LDRH     r0,[r0,#0x42]         ;522
00732e  1c40              ADDS     r0,r0,#1              ;522
007330  b281              UXTH     r1,r0                 ;522
007332  4889              LDR      r0,|L1.30040|
007334  f8a01042          STRH     r1,[r0,#0x42]         ;522
007338  8ec0              LDRH     r0,[r0,#0x36]         ;523
00733a  1c40              ADDS     r0,r0,#1              ;523
00733c  b281              UXTH     r1,r0                 ;523
00733e  4886              LDR      r0,|L1.30040|
007340  86c1              STRH     r1,[r0,#0x36]         ;523
007342  2000              MOVS     r0,#0                 ;526
007344  e729              B        |L1.29082|
                  |L1.29510|
007346  bf00              NOP                            ;549
007348  bf00              NOP                            ;549
00734a  bf00              NOP                            ;551
00734c  bf00              NOP                            ;551
00734e  4886              LDR      r0,|L1.30056|
007350  6006              STR      r6,[r0,#0]            ;553  ; current_netif
007352  4886              LDR      r0,|L1.30060|
007354  6005              STR      r5,[r0,#0]            ;554  ; current_header
007356  4631              MOV      r1,r6                 ;558
007358  4638              MOV      r0,r7                 ;558
00735a  f7fffffe          BL       raw_input
00735e  bbe8              CBNZ     r0,|L1.29660|
007360  7a68              LDRB     r0,[r5,#9]            ;561
007362  2801              CMP      r0,#1                 ;561
007364  d00f              BEQ      |L1.29574|
007366  2802              CMP      r0,#2                 ;561
007368  d012              BEQ      |L1.29584|
00736a  2806              CMP      r0,#6                 ;561
00736c  d006              BEQ      |L1.29564|
00736e  2811              CMP      r0,#0x11              ;561
007370  d114              BNE      |L1.29596|
007372  4631              MOV      r1,r6                 ;568
007374  4638              MOV      r0,r7                 ;568
007376  f7fffffe          BL       udp_input
00737a  e035              B        |L1.29672|
                  |L1.29564|
00737c  4631              MOV      r1,r6                 ;574
00737e  4638              MOV      r0,r7                 ;574
007380  f7fffffe          BL       tcp_input
007384  e030              B        |L1.29672|
                  |L1.29574|
007386  4631              MOV      r1,r6                 ;580
007388  4638              MOV      r0,r7                 ;580
00738a  f7fffffe          BL       icmp_input
00738e  e02b              B        |L1.29672|
                  |L1.29584|
007390  4a72              LDR      r2,|L1.30044|
007392  4631              MOV      r1,r6                 ;585
007394  4638              MOV      r0,r7                 ;585
007396  f7fffffe          BL       igmp_input
00739a  e025              B        |L1.29672|
                  |L1.29596|
00739c  496f              LDR      r1,|L1.30044|
00739e  6808              LDR      r0,[r1,#0]            ;591  ; current_iphdr_dest
0073a0  4631              MOV      r1,r6                 ;591
0073a2  f7fffffe          BL       ip4_addr_isbroadcast
0073a6  b950              CBNZ     r0,|L1.29630|
0073a8  486c              LDR      r0,|L1.30044|
0073aa  7800              LDRB     r0,[r0,#0]            ;592  ; current_iphdr_dest
0073ac  f00000f0          AND      r0,r0,#0xf0           ;592
0073b0  28e0              CMP      r0,#0xe0              ;592
0073b2  d004              BEQ      |L1.29630|
0073b4  607d              STR      r5,[r7,#4]            ;593
0073b6  2102              MOVS     r1,#2                 ;594
0073b8  4638              MOV      r0,r7                 ;594
0073ba  f7fffffe          BL       icmp_dest_unreach
                  |L1.29630|
0073be  4638              MOV      r0,r7                 ;597
0073c0  f7fffffe          BL       pbuf_free
0073c4  bf00              NOP                            ;599
0073c6  bf00              NOP                            ;599
0073c8  4863              LDR      r0,|L1.30040|
0073ca  f8b00040          LDRH     r0,[r0,#0x40]         ;601
0073ce  1c40              ADDS     r0,r0,#1              ;601
0073d0  b281              UXTH     r1,r0                 ;601
0073d2  4861              LDR      r0,|L1.30040|
0073d4  f8a01040          STRH     r1,[r0,#0x40]         ;601
0073d8  8ec0              LDRH     r0,[r0,#0x36]         ;602
0073da  e000              B        |L1.29662|
                  |L1.29660|
0073dc  e005              B        |L1.29674|
                  |L1.29662|
0073de  1c40              ADDS     r0,r0,#1              ;602
0073e0  b281              UXTH     r1,r0                 ;602
0073e2  485d              LDR      r0,|L1.30040|
0073e4  86c1              STRH     r1,[r0,#0x36]         ;602
0073e6  bf00              NOP                            ;561
                  |L1.29672|
0073e8  bf00              NOP                            ;569
                  |L1.29674|
0073ea  2000              MOVS     r0,#0                 ;607
0073ec  495e              LDR      r1,|L1.30056|
0073ee  6008              STR      r0,[r1,#0]            ;607  ; current_netif
0073f0  495e              LDR      r1,|L1.30060|
0073f2  6008              STR      r0,[r1,#0]            ;608  ; current_header
0073f4  495a              LDR      r1,|L1.30048|
0073f6  6008              STR      r0,[r1,#0]            ;609  ; current_iphdr_src
0073f8  4958              LDR      r1,|L1.30044|
0073fa  6008              STR      r0,[r1,#0]            ;610  ; current_iphdr_dest
0073fc  bf00              NOP                            ;612
0073fe  e6cc              B        |L1.29082|
;;;614    
                          ENDP

                  dhcp_delete_msg PROC
;;;1734   static void
;;;1735   dhcp_delete_msg(struct dhcp *dhcp)
007400  b510              PUSH     {r4,lr}
;;;1736   {
007402  4604              MOV      r4,r0
;;;1737     LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
007404  bf00              NOP      
007406  b904              CBNZ     r4,|L1.29706|
                  |L1.29704|
;;;1738     LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
;;;1739     LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
;;;1740     if (dhcp->p_out != NULL) {
;;;1741       pbuf_free(dhcp->p_out);
;;;1742     }
;;;1743     dhcp->p_out = NULL;
;;;1744     dhcp->msg_out = NULL;
;;;1745   }
007408  bd10              POP      {r4,pc}
                  |L1.29706|
00740a  bf00              NOP                            ;1737
00740c  bf00              NOP                            ;1738
00740e  bf00              NOP                            ;1738
007410  bf00              NOP                            ;1739
007412  bf00              NOP                            ;1739
007414  6920              LDR      r0,[r4,#0x10]         ;1740
007416  b110              CBZ      r0,|L1.29726|
007418  6920              LDR      r0,[r4,#0x10]         ;1741
00741a  f7fffffe          BL       pbuf_free
                  |L1.29726|
00741e  2000              MOVS     r0,#0                 ;1743
007420  6120              STR      r0,[r4,#0x10]         ;1743
007422  6160              STR      r0,[r4,#0x14]         ;1744
007424  bf00              NOP      
007426  e7ef              B        |L1.29704|
;;;1746   
                          ENDP

                  dhcp_option_trailer PROC
;;;1755   static void
;;;1756   dhcp_option_trailer(struct dhcp *dhcp)
007428  bf00              NOP      
;;;1757   {
;;;1758     LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
00742a  b900              CBNZ     r0,|L1.29742|
                  |L1.29740|
;;;1759     LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
;;;1760     LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
;;;1761     dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
;;;1762     /* packet is too small, or not 4 byte aligned? */
;;;1763     while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
;;;1764            (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
;;;1765       /* add a fill/padding byte */
;;;1766       dhcp->msg_out->options[dhcp->options_out_len++] = 0;
;;;1767     }
;;;1768   }
00742c  4770              BX       lr
                  |L1.29742|
00742e  bf00              NOP                            ;1758
007430  bf00              NOP                            ;1759
007432  bf00              NOP                            ;1759
007434  bf00              NOP                            ;1760
007436  bf00              NOP                            ;1760
007438  22ff              MOVS     r2,#0xff              ;1761
00743a  8b03              LDRH     r3,[r0,#0x18]         ;1761
00743c  1c59              ADDS     r1,r3,#1              ;1761
00743e  8301              STRH     r1,[r0,#0x18]         ;1761
007440  6941              LDR      r1,[r0,#0x14]         ;1761
007442  31f0              ADDS     r1,r1,#0xf0           ;1761
007444  54ca              STRB     r2,[r1,r3]            ;1761
007446  e006              B        |L1.29782|
                  |L1.29768|
007448  2200              MOVS     r2,#0                 ;1766
00744a  8b03              LDRH     r3,[r0,#0x18]         ;1766
00744c  1c59              ADDS     r1,r3,#1              ;1766
00744e  8301              STRH     r1,[r0,#0x18]         ;1766
007450  6941              LDR      r1,[r0,#0x14]         ;1766
007452  31f0              ADDS     r1,r1,#0xf0           ;1766
007454  54ca              STRB     r2,[r1,r3]            ;1766
                  |L1.29782|
007456  8b01              LDRH     r1,[r0,#0x18]         ;1763
007458  2944              CMP      r1,#0x44              ;1763
00745a  d303              BCC      |L1.29796|
00745c  7e01              LDRB     r1,[r0,#0x18]         ;1763
00745e  f0110f03          TST      r1,#3                 ;1763
007462  d002              BEQ      |L1.29802|
                  |L1.29796|
007464  8b01              LDRH     r1,[r0,#0x18]         ;1764
007466  2944              CMP      r1,#0x44              ;1764
007468  d3ee              BCC      |L1.29768|
                  |L1.29802|
00746a  bf00              NOP      
00746c  e7de              B        |L1.29740|
;;;1769   
                          ENDP

                  dhcp_option_long PROC
;;;1293   static void
;;;1294   dhcp_option_long(struct dhcp *dhcp, u32_t value)
00746e  b510              PUSH     {r4,lr}
;;;1295   {
;;;1296     LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
007470  bf00              NOP      
007472  bf00              NOP      
;;;1297     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
007474  0e0b              LSRS     r3,r1,#24
007476  8b04              LDRH     r4,[r0,#0x18]
007478  1c62              ADDS     r2,r4,#1
00747a  8302              STRH     r2,[r0,#0x18]
00747c  6942              LDR      r2,[r0,#0x14]
00747e  32f0              ADDS     r2,r2,#0xf0
007480  5513              STRB     r3,[r2,r4]
;;;1298     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
007482  f3c14307          UBFX     r3,r1,#16,#8
007486  8b04              LDRH     r4,[r0,#0x18]
007488  1c62              ADDS     r2,r4,#1
00748a  8302              STRH     r2,[r0,#0x18]
00748c  6942              LDR      r2,[r0,#0x14]
00748e  32f0              ADDS     r2,r2,#0xf0
007490  5513              STRB     r3,[r2,r4]
;;;1299     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
007492  f3c12307          UBFX     r3,r1,#8,#8
007496  8b04              LDRH     r4,[r0,#0x18]
007498  1c62              ADDS     r2,r4,#1
00749a  8302              STRH     r2,[r0,#0x18]
00749c  6942              LDR      r2,[r0,#0x14]
00749e  32f0              ADDS     r2,r2,#0xf0
0074a0  5513              STRB     r3,[r2,r4]
;;;1300     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
0074a2  8b04              LDRH     r4,[r0,#0x18]
0074a4  1c62              ADDS     r2,r4,#1
0074a6  8302              STRH     r2,[r0,#0x18]
0074a8  6942              LDR      r2,[r0,#0x14]
0074aa  32f0              ADDS     r2,r2,#0xf0
0074ac  5511              STRB     r1,[r2,r4]
;;;1301   }
0074ae  bd10              POP      {r4,pc}
;;;1302   
                          ENDP

                  dhcp_option PROC
;;;1267   static void
;;;1268   dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
0074b0  b510              PUSH     {r4,lr}
;;;1269   {
;;;1270     LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
0074b2  bf00              NOP      
0074b4  bf00              NOP      
;;;1271     dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
0074b6  8b04              LDRH     r4,[r0,#0x18]
0074b8  1c63              ADDS     r3,r4,#1
0074ba  8303              STRH     r3,[r0,#0x18]
0074bc  6943              LDR      r3,[r0,#0x14]
0074be  33f0              ADDS     r3,r3,#0xf0
0074c0  5519              STRB     r1,[r3,r4]
;;;1272     dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
0074c2  8b04              LDRH     r4,[r0,#0x18]
0074c4  1c63              ADDS     r3,r4,#1
0074c6  8303              STRH     r3,[r0,#0x18]
0074c8  6943              LDR      r3,[r0,#0x14]
0074ca  33f0              ADDS     r3,r3,#0xf0
0074cc  551a              STRB     r2,[r3,r4]
;;;1273   }
0074ce  bd10              POP      {r4,pc}
;;;1274   /*
                          ENDP

                  dhcp_option_byte PROC
;;;1278   static void
;;;1279   dhcp_option_byte(struct dhcp *dhcp, u8_t value)
0074d0  bf00              NOP      
;;;1280   {
;;;1281     LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
0074d2  bf00              NOP      
;;;1282     dhcp->msg_out->options[dhcp->options_out_len++] = value;
0074d4  8b03              LDRH     r3,[r0,#0x18]
0074d6  1c5a              ADDS     r2,r3,#1
0074d8  8302              STRH     r2,[r0,#0x18]
0074da  6942              LDR      r2,[r0,#0x14]
0074dc  32f0              ADDS     r2,r2,#0xf0
0074de  54d1              STRB     r1,[r2,r3]
;;;1283   }
0074e0  4770              BX       lr
;;;1284   
                          ENDP

                  dhcp_create_msg PROC
;;;1640   static err_t
;;;1641   dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
0074e2  e92d41f0          PUSH     {r4-r8,lr}
;;;1642   {
0074e6  4606              MOV      r6,r0
0074e8  460c              MOV      r4,r1
0074ea  4617              MOV      r7,r2
;;;1643     u16_t i;
;;;1644   #ifndef DHCP_GLOBAL_XID
;;;1645     /** default global transaction identifier starting value (easy to match
;;;1646      *  with a packet analyser). We simply increment for each new request.
;;;1647      *  Predefine DHCP_GLOBAL_XID to a better value or a function call to generate one
;;;1648      *  at runtime, any supporting function prototypes can be defined in DHCP_GLOBAL_XID_HEADER */
;;;1649   #if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
;;;1650     static u32_t xid;
;;;1651   #else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1652     static u32_t xid = 0xABCD0000;
;;;1653   #endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1654   #else
;;;1655     if (!xid_initialised) {
;;;1656       xid = DHCP_GLOBAL_XID;
;;;1657       xid_initialised = !xid_initialised;
;;;1658     }
;;;1659   #endif
;;;1660     LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
0074ec  bf00              NOP      
0074ee  b91e              CBNZ     r6,|L1.29944|
0074f0  f06f000d          MVN      r0,#0xd
                  |L1.29940|
;;;1661     LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
;;;1662     LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
;;;1663     LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
;;;1664     dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
;;;1665     if (dhcp->p_out == NULL) {
;;;1666       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1667         ("dhcp_create_msg(): could not allocate pbuf\n"));
;;;1668       return ERR_MEM;
;;;1669     }
;;;1670     LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
;;;1671              (dhcp->p_out->len >= sizeof(struct dhcp_msg)));
;;;1672   
;;;1673     /* reuse transaction identifier in retransmissions */
;;;1674     if (dhcp->tries == 0) {
;;;1675   #if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
;;;1676       xid = LWIP_RAND();
;;;1677   #else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1678       xid++;
;;;1679   #endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1680     }
;;;1681     dhcp->xid = xid;
;;;1682     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
;;;1683                 ("transaction id xid(%"X32_F")\n", xid));
;;;1684   
;;;1685     dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
;;;1686   
;;;1687     dhcp->msg_out->op = DHCP_BOOTREQUEST;
;;;1688     /* TODO: make link layer independent */
;;;1689     dhcp->msg_out->htype = DHCP_HTYPE_ETH;
;;;1690     dhcp->msg_out->hlen = netif->hwaddr_len;
;;;1691     dhcp->msg_out->hops = 0;
;;;1692     dhcp->msg_out->xid = htonl(dhcp->xid);
;;;1693     dhcp->msg_out->secs = 0;
;;;1694     /* we don't need the broadcast flag since we can receive unicast traffic
;;;1695        before being fully configured! */
;;;1696     dhcp->msg_out->flags = 0;
;;;1697     ip_addr_set_zero(&dhcp->msg_out->ciaddr);
;;;1698     /* set ciaddr to netif->ip_addr based on message_type and state */
;;;1699     if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
;;;1700         ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
;;;1701          ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
;;;1702       ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
;;;1703     }
;;;1704     ip_addr_set_zero(&dhcp->msg_out->yiaddr);
;;;1705     ip_addr_set_zero(&dhcp->msg_out->siaddr);
;;;1706     ip_addr_set_zero(&dhcp->msg_out->giaddr);
;;;1707     for (i = 0; i < DHCP_CHADDR_LEN; i++) {
;;;1708       /* copy netif hardware address, pad with zeroes */
;;;1709       dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
;;;1710     }
;;;1711     for (i = 0; i < DHCP_SNAME_LEN; i++) {
;;;1712       dhcp->msg_out->sname[i] = 0;
;;;1713     }
;;;1714     for (i = 0; i < DHCP_FILE_LEN; i++) {
;;;1715       dhcp->msg_out->file[i] = 0;
;;;1716     }
;;;1717     dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
;;;1718     dhcp->options_out_len = 0;
;;;1719     /* fill options field with an incrementing array (for debugging purposes) */
;;;1720     for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
;;;1721       dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
;;;1722     }
;;;1723     /* Add option MESSAGE_TYPE */
;;;1724     dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
;;;1725     dhcp_option_byte(dhcp, message_type);
;;;1726     return ERR_OK;
;;;1727   }
0074f4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.29944|
0074f8  bf00              NOP                            ;1660
0074fa  bf00              NOP                            ;1661
0074fc  b914              CBNZ     r4,|L1.29956|
0074fe  f06f0005          MVN      r0,#5                 ;1661
007502  e7f7              B        |L1.29940|
                  |L1.29956|
007504  bf00              NOP                            ;1661
007506  bf00              NOP                            ;1662
007508  bf00              NOP                            ;1662
00750a  bf00              NOP                            ;1663
00750c  bf00              NOP                            ;1663
00750e  2200              MOVS     r2,#0                 ;1664
007510  f44f719a          MOV      r1,#0x134             ;1664
007514  4610              MOV      r0,r2                 ;1664
007516  f7fffffe          BL       pbuf_alloc
00751a  6120              STR      r0,[r4,#0x10]         ;1664
00751c  6920              LDR      r0,[r4,#0x10]         ;1665
00751e  b920              CBNZ     r0,|L1.29994|
007520  bf00              NOP                            ;1666
007522  bf00              NOP                            ;1666
007524  f04f30ff          MOV      r0,#0xffffffff        ;1668
007528  e7e4              B        |L1.29940|
                  |L1.29994|
00752a  bf00              NOP                            ;1670
00752c  bf00              NOP                            ;1670
00752e  7b60              LDRB     r0,[r4,#0xd]          ;1674
007530  b918              CBNZ     r0,|L1.30010|
007532  f7fffffe          BL       rand
007536  490e              LDR      r1,|L1.30064|
007538  6008              STR      r0,[r1,#0]            ;1676  ; xid
                  |L1.30010|
00753a  480d              LDR      r0,|L1.30064|
00753c  6800              LDR      r0,[r0,#0]            ;1681  ; xid
00753e  6020              STR      r0,[r4,#0]            ;1681
007540  bf00              NOP                            ;1682
007542  bf00              NOP                            ;1682
007544  6920              LDR      r0,[r4,#0x10]         ;1685
007546  6840              LDR      r0,[r0,#4]            ;1685
007548  6160              STR      r0,[r4,#0x14]         ;1685
00754a  2001              MOVS     r0,#1                 ;1687
00754c  6961              LDR      r1,[r4,#0x14]         ;1687
00754e  7008              STRB     r0,[r1,#0]            ;1687
007550  6961              LDR      r1,[r4,#0x14]         ;1689
007552  7048              STRB     r0,[r1,#1]            ;1689
007554  e00e              B        |L1.30068|
007556  0000              DCW      0x0000
                  |L1.30040|
                          DCD      lwip_stats
                  |L1.30044|
                          DCD      current_iphdr_dest
                  |L1.30048|
                          DCD      current_iphdr_src
                  |L1.30052|
                          DCD      netif_list
                  |L1.30056|
                          DCD      current_netif
                  |L1.30060|
                          DCD      current_header
                  |L1.30064|
                          DCD      xid
                  |L1.30068|
007574  f896002a          LDRB     r0,[r6,#0x2a]         ;1690
007578  6961              LDR      r1,[r4,#0x14]         ;1690
00757a  7088              STRB     r0,[r1,#2]            ;1690
00757c  2000              MOVS     r0,#0                 ;1691
00757e  6961              LDR      r1,[r4,#0x14]         ;1691
007580  70c8              STRB     r0,[r1,#3]            ;1691
007582  6820              LDR      r0,[r4,#0]            ;1692
007584  f7fffffe          BL       lwip_htonl
007588  6961              LDR      r1,[r4,#0x14]         ;1692
00758a  6048              STR      r0,[r1,#4]            ;1692
00758c  2000              MOVS     r0,#0                 ;1693
00758e  6961              LDR      r1,[r4,#0x14]         ;1693
007590  8108              STRH     r0,[r1,#8]            ;1693
007592  6961              LDR      r1,[r4,#0x14]         ;1696
007594  8148              STRH     r0,[r1,#0xa]          ;1696
007596  6961              LDR      r1,[r4,#0x14]         ;1697
007598  60c8              STR      r0,[r1,#0xc]          ;1697
00759a  2f08              CMP      r7,#8                 ;1699
00759c  d009              BEQ      |L1.30130|
00759e  2f04              CMP      r7,#4                 ;1699
0075a0  d007              BEQ      |L1.30130|
0075a2  2f03              CMP      r7,#3                 ;1700
0075a4  d108              BNE      |L1.30136|
0075a6  7b20              LDRB     r0,[r4,#0xc]          ;1701
0075a8  2805              CMP      r0,#5                 ;1701
0075aa  d002              BEQ      |L1.30130|
0075ac  7b20              LDRB     r0,[r4,#0xc]          ;1701
0075ae  2804              CMP      r0,#4                 ;1701
0075b0  d102              BNE      |L1.30136|
                  |L1.30130|
0075b2  6870              LDR      r0,[r6,#4]            ;1702
0075b4  6961              LDR      r1,[r4,#0x14]         ;1702
0075b6  60c8              STR      r0,[r1,#0xc]          ;1702
                  |L1.30136|
0075b8  2000              MOVS     r0,#0                 ;1704
0075ba  6961              LDR      r1,[r4,#0x14]         ;1704
0075bc  6108              STR      r0,[r1,#0x10]         ;1704
0075be  6961              LDR      r1,[r4,#0x14]         ;1705
0075c0  6148              STR      r0,[r1,#0x14]         ;1705
0075c2  6961              LDR      r1,[r4,#0x14]         ;1706
0075c4  6188              STR      r0,[r1,#0x18]         ;1706
0075c6  2500              MOVS     r5,#0                 ;1707
0075c8  e00d              B        |L1.30182|
                  |L1.30154|
0075ca  f896002a          LDRB     r0,[r6,#0x2a]         ;1709
0075ce  42a8              CMP      r0,r5                 ;1709
0075d0  dd03              BLE      |L1.30170|
0075d2  f106002b          ADD      r0,r6,#0x2b           ;1709
0075d6  5d40              LDRB     r0,[r0,r5]            ;1709
0075d8  e000              B        |L1.30172|
                  |L1.30170|
0075da  2000              MOVS     r0,#0                 ;1709
                  |L1.30172|
0075dc  6961              LDR      r1,[r4,#0x14]         ;1709
0075de  311c              ADDS     r1,r1,#0x1c           ;1709
0075e0  5548              STRB     r0,[r1,r5]            ;1709
0075e2  1c68              ADDS     r0,r5,#1              ;1707
0075e4  b285              UXTH     r5,r0                 ;1707
                  |L1.30182|
0075e6  2d10              CMP      r5,#0x10              ;1707
0075e8  d3ef              BCC      |L1.30154|
0075ea  2500              MOVS     r5,#0                 ;1711
0075ec  e005              B        |L1.30202|
                  |L1.30190|
0075ee  2100              MOVS     r1,#0                 ;1712
0075f0  6960              LDR      r0,[r4,#0x14]         ;1712
0075f2  302c              ADDS     r0,r0,#0x2c           ;1712
0075f4  5541              STRB     r1,[r0,r5]            ;1712
0075f6  1c68              ADDS     r0,r5,#1              ;1711
0075f8  b285              UXTH     r5,r0                 ;1711
                  |L1.30202|
0075fa  2d40              CMP      r5,#0x40              ;1711
0075fc  d3f7              BCC      |L1.30190|
0075fe  2500              MOVS     r5,#0                 ;1714
007600  e005              B        |L1.30222|
                  |L1.30210|
007602  2100              MOVS     r1,#0                 ;1715
007604  6960              LDR      r0,[r4,#0x14]         ;1715
007606  306c              ADDS     r0,r0,#0x6c           ;1715
007608  5541              STRB     r1,[r0,r5]            ;1715
00760a  1c68              ADDS     r0,r5,#1              ;1714
00760c  b285              UXTH     r5,r0                 ;1714
                  |L1.30222|
00760e  2d80              CMP      r5,#0x80              ;1714
007610  d3f7              BCC      |L1.30210|
007612  48fb              LDR      r0,|L1.31232|
007614  6961              LDR      r1,[r4,#0x14]         ;1717
007616  f8c100ec          STR      r0,[r1,#0xec]         ;1717
00761a  2000              MOVS     r0,#0                 ;1718
00761c  8320              STRH     r0,[r4,#0x18]         ;1718
00761e  2500              MOVS     r5,#0                 ;1720
007620  e004              B        |L1.30252|
                  |L1.30242|
007622  6960              LDR      r0,[r4,#0x14]         ;1721
007624  30f0              ADDS     r0,r0,#0xf0           ;1721
007626  5545              STRB     r5,[r0,r5]            ;1721
007628  1c68              ADDS     r0,r5,#1              ;1720
00762a  b285              UXTH     r5,r0                 ;1720
                  |L1.30252|
00762c  2d44              CMP      r5,#0x44              ;1720
00762e  d3f8              BCC      |L1.30242|
007630  2201              MOVS     r2,#1                 ;1724
007632  2135              MOVS     r1,#0x35              ;1724
007634  4620              MOV      r0,r4                 ;1724
007636  f7fffffe          BL       dhcp_option
00763a  4639              MOV      r1,r7                 ;1725
00763c  4620              MOV      r0,r4                 ;1725
00763e  f7fffffe          BL       dhcp_option_byte
007642  2000              MOVS     r0,#0                 ;1726
007644  e756              B        |L1.29940|
;;;1728   
                          ENDP

                  dhcp_set_state PROC
;;;1252   static void
;;;1253   dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
007646  7b02              LDRB     r2,[r0,#0xc]
;;;1254   {
;;;1255     if (new_state != dhcp->state) {
007648  428a              CMP      r2,r1
00764a  d003              BEQ      |L1.30292|
;;;1256       dhcp->state = new_state;
00764c  7301              STRB     r1,[r0,#0xc]
;;;1257       dhcp->tries = 0;
00764e  2200              MOVS     r2,#0
007650  7342              STRB     r2,[r0,#0xd]
;;;1258       dhcp->request_timeout = 0;
007652  8342              STRH     r2,[r0,#0x1a]
                  |L1.30292|
;;;1259     }
;;;1260   }
007654  4770              BX       lr
;;;1261   
                          ENDP

                  dhcp_decline PROC
;;;831    static err_t
;;;832    dhcp_decline(struct netif *netif)
007656  e92d43f8          PUSH     {r3-r9,lr}
;;;833    {
00765a  4605              MOV      r5,r0
;;;834      struct dhcp *dhcp = netif->dhcp;
00765c  6a2c              LDR      r4,[r5,#0x20]
;;;835      err_t result = ERR_OK;
00765e  2600              MOVS     r6,#0
;;;836      u16_t msecs;
;;;837      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
007660  bf00              NOP      
007662  bf00              NOP      
;;;838      dhcp_set_state(dhcp, DHCP_BACKING_OFF);
007664  210c              MOVS     r1,#0xc
007666  4620              MOV      r0,r4
007668  f7fffffe          BL       dhcp_set_state
;;;839      /* create and initialize the DHCP message header */
;;;840      result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
00766c  2204              MOVS     r2,#4
00766e  4621              MOV      r1,r4
007670  4628              MOV      r0,r5
007672  f7fffffe          BL       dhcp_create_msg
007676  4606              MOV      r6,r0
;;;841      if (result == ERR_OK) {
007678  bb0e              CBNZ     r6,|L1.30398|
;;;842        dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
00767a  2204              MOVS     r2,#4
00767c  2132              MOVS     r1,#0x32
00767e  4620              MOV      r0,r4
007680  f7fffffe          BL       dhcp_option
;;;843        dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
007684  6a60              LDR      r0,[r4,#0x24]
007686  f7fffffe          BL       lwip_ntohl
00768a  4680              MOV      r8,r0
00768c  4641              MOV      r1,r8
00768e  4620              MOV      r0,r4
007690  f7fffffe          BL       dhcp_option_long
;;;844    
;;;845        dhcp_option_trailer(dhcp);
007694  4620              MOV      r0,r4
007696  f7fffffe          BL       dhcp_option_trailer
;;;846        /* resize pbuf to reflect true size of options */
;;;847        pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
00769a  8b22              LDRH     r2,[r4,#0x18]
00769c  32f0              ADDS     r2,r2,#0xf0
00769e  b291              UXTH     r1,r2
0076a0  6920              LDR      r0,[r4,#0x10]
0076a2  f7fffffe          BL       pbuf_realloc
;;;848    
;;;849        /* per section 4.4.4, broadcast DECLINE messages */
;;;850        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
0076a6  9500              STR      r5,[sp,#0]
0076a8  2343              MOVS     r3,#0x43
0076aa  4ad6              LDR      r2,|L1.31236|
0076ac  6921              LDR      r1,[r4,#0x10]
0076ae  6860              LDR      r0,[r4,#4]
0076b0  f7fffffe          BL       udp_sendto_if
;;;851        dhcp_delete_msg(dhcp);
0076b4  4620              MOV      r0,r4
0076b6  f7fffffe          BL       dhcp_delete_msg
;;;852        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
0076ba  bf00              NOP      
0076bc  e001              B        |L1.30402|
                  |L1.30398|
;;;853      } else {
;;;854        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
0076be  bf00              NOP      
0076c0  bf00              NOP      
                  |L1.30402|
;;;855          ("dhcp_decline: could not allocate DHCP request\n"));
;;;856      }
;;;857      dhcp->tries++;
0076c2  7b60              LDRB     r0,[r4,#0xd]
0076c4  1c40              ADDS     r0,r0,#1
0076c6  7360              STRB     r0,[r4,#0xd]
;;;858      msecs = 10*1000;
0076c8  f2427710          MOV      r7,#0x2710
;;;859      dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
0076cc  f20710f3          ADD      r0,r7,#0x1f3
0076d0  f44f71fa          MOV      r1,#0x1f4
0076d4  fb90f0f1          SDIV     r0,r0,r1
0076d8  8360              STRH     r0,[r4,#0x1a]
;;;860      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
0076da  bf00              NOP      
0076dc  bf00              NOP      
;;;861      return result;
0076de  4630              MOV      r0,r6
;;;862    }
0076e0  e8bd83f8          POP      {r3-r9,pc}
;;;863    #endif /* DHCP_DOES_ARP_CHECK */
                          ENDP

                  dhcp_arp_reply PROC
;;;802     */
;;;803    void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
0076e4  b570              PUSH     {r4-r6,lr}
;;;804    {
0076e6  4604              MOV      r4,r0
0076e8  460d              MOV      r5,r1
;;;805      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
0076ea  bf00              NOP      
0076ec  b904              CBNZ     r4,|L1.30448|
                  |L1.30446|
;;;806      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
;;;807      /* is a DHCP client doing an ARP check? */
;;;808      if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
;;;809        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
;;;810          ip4_addr_get_u32(addr)));
;;;811        /* did a host respond with the address we
;;;812           were offered by the DHCP server? */
;;;813        if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
;;;814          /* we will not accept the offered address */
;;;815          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
;;;816            ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
;;;817          dhcp_decline(netif);
;;;818        }
;;;819      }
;;;820    }
0076ee  bd70              POP      {r4-r6,pc}
                  |L1.30448|
0076f0  bf00              NOP                            ;805
0076f2  bf00              NOP                            ;806
0076f4  bf00              NOP                            ;806
0076f6  6a20              LDR      r0,[r4,#0x20]         ;808
0076f8  b178              CBZ      r0,|L1.30490|
0076fa  6a20              LDR      r0,[r4,#0x20]         ;808
0076fc  7b00              LDRB     r0,[r0,#0xc]          ;808
0076fe  2808              CMP      r0,#8                 ;808
007700  d10b              BNE      |L1.30490|
007702  bf00              NOP                            ;809
007704  bf00              NOP                            ;809
007706  6828              LDR      r0,[r5,#0]            ;813
007708  6a21              LDR      r1,[r4,#0x20]         ;813
00770a  6a49              LDR      r1,[r1,#0x24]         ;813
00770c  4288              CMP      r0,r1                 ;813
00770e  d104              BNE      |L1.30490|
007710  bf00              NOP                            ;815
007712  bf00              NOP                            ;815
007714  4620              MOV      r0,r4                 ;817
007716  f7fffffe          BL       dhcp_decline
                  |L1.30490|
00771a  bf00              NOP      
00771c  e7e7              B        |L1.30446|
;;;821    
                          ENDP

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
00771e  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
007722  4605              MOV      r5,r0
007724  460e              MOV      r6,r1
007726  4617              MOV      r7,r2
007728  4698              MOV      r8,r3
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
00772a  6874              LDR      r4,[r6,#4]
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
00772c  bf00              NOP      
00772e  bf00              NOP      
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
007730  f8d80000          LDR      r0,[r8,#0]
007734  6020              STR      r0,[r4,#0]
007736  f8b80004          LDRH     r0,[r8,#4]
00773a  80a0              STRH     r0,[r4,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
00773c  6838              LDR      r0,[r7,#0]
00773e  f8c40006          STR      r0,[r4,#6]
007742  88b8              LDRH     r0,[r7,#4]
007744  8160              STRH     r0,[r4,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
007746  2008              MOVS     r0,#8
007748  81a0              STRH     r0,[r4,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
00774a  bf00              NOP      
00774c  bf00              NOP      
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
00774e  4631              MOV      r1,r6
007750  4628              MOV      r0,r5
007752  69aa              LDR      r2,[r5,#0x18]
007754  4790              BLX      r2
;;;427    }
007756  e8bd81f0          POP      {r4-r8,pc}
;;;428    
                          ENDP

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
00775a  b510              PUSH     {r4,lr}
;;;178    {
00775c  4604              MOV      r4,r0
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
00775e  eb040084          ADD      r0,r4,r4,LSL #2
007762  49a9              LDR      r1,|L1.31240|
007764  f8510020          LDR      r0,[r1,r0,LSL #2]
007768  b170              CBZ      r0,|L1.30600|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
00776a  bf00              NOP      
00776c  bf00              NOP      
;;;185        free_etharp_q(arp_table[i].q);
00776e  eb040184          ADD      r1,r4,r4,LSL #2
007772  4aa5              LDR      r2,|L1.31240|
007774  f8520021          LDR      r0,[r2,r1,LSL #2]
007778  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
00777c  2000              MOVS     r0,#0
00777e  eb040184          ADD      r1,r4,r4,LSL #2
007782  4aa1              LDR      r2,|L1.31240|
007784  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L1.30600|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
007788  2000              MOVS     r0,#0
00778a  eb040184          ADD      r1,r4,r4,LSL #2
00778e  4a9e              LDR      r2,|L1.31240|
007790  eb020181          ADD      r1,r2,r1,LSL #2
007794  7488              STRB     r0,[r1,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
007796  eb040184          ADD      r1,r4,r4,LSL #2
00779a  eb020181          ADD      r1,r2,r1,LSL #2
00779e  74c8              STRB     r0,[r1,#0x13]
;;;193      arp_table[i].netif = NULL;
0077a0  eb040184          ADD      r1,r4,r4,LSL #2
0077a4  eb020181          ADD      r1,r2,r1,LSL #2
0077a8  6088              STR      r0,[r1,#8]
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
0077aa  eb040184          ADD      r1,r4,r4,LSL #2
0077ae  eb020181          ADD      r1,r2,r1,LSL #2
0077b2  6048              STR      r0,[r1,#4]
;;;195      arp_table[i].ethaddr = ethzero;
0077b4  eb040084          ADD      r0,r4,r4,LSL #2
0077b8  4611              MOV      r1,r2
0077ba  eb010080          ADD      r0,r1,r0,LSL #2
0077be  4993              LDR      r1,|L1.31244|
0077c0  680a              LDR      r2,[r1,#0]  ; ethzero
0077c2  60c2              STR      r2,[r0,#0xc]
0077c4  8889              LDRH     r1,[r1,#4]  ; ethzero
0077c6  8201              STRH     r1,[r0,#0x10]
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
0077c8  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
0077ca  e92d5ffc          PUSH     {r2-r12,lr}
;;;267    {
0077ce  4605              MOV      r5,r0
0077d0  460f              MOV      r7,r1
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
0077d2  f04f080a          MOV      r8,#0xa
0077d6  46c1              MOV      r9,r8
;;;269      s8_t empty = ARP_TABLE_SIZE;
0077d8  260a              MOVS     r6,#0xa
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
0077da  2400              MOVS     r4,#0
0077dc  46a3              MOV      r11,r4
0077de  2000              MOVS     r0,#0
0077e0  9001              STR      r0,[sp,#4]
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
0077e2  46b2              MOV      r10,r6
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
0077e4  9000              STR      r0,[sp,#0]
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
0077e6  bf00              NOP      
0077e8  e060              B        |L1.30892|
                  |L1.30698|
;;;292        u8_t state = arp_table[i].state;
0077ea  eb040084          ADD      r0,r4,r4,LSL #2
0077ee  4a86              LDR      r2,|L1.31240|
0077f0  eb020080          ADD      r0,r2,r0,LSL #2
0077f4  7c81              LDRB     r1,[r0,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
0077f6  2e0a              CMP      r6,#0xa
0077f8  d104              BNE      |L1.30724|
0077fa  b919              CBNZ     r1,|L1.30724|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
0077fc  bf00              NOP      
0077fe  bf00              NOP      
;;;296          /* remember first empty entry */
;;;297          empty = i;
007800  b266              SXTB     r6,r4
007802  e051              B        |L1.30888|
                  |L1.30724|
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
007804  2900              CMP      r1,#0
007806  d04f              BEQ      |L1.30888|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
007808  bf00              NOP      
00780a  bf00              NOP      
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
00780c  b16d              CBZ      r5,|L1.30762|
00780e  eb040284          ADD      r2,r4,r4,LSL #2
007812  4b7d              LDR      r3,|L1.31240|
007814  eb030282          ADD      r2,r3,r2,LSL #2
007818  6828              LDR      r0,[r5,#0]
00781a  6852              LDR      r2,[r2,#4]
00781c  4290              CMP      r0,r2
00781e  d104              BNE      |L1.30762|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
007820  bf00              NOP      
007822  bf00              NOP      
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
007824  b260              SXTB     r0,r4
                  |L1.30758|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
007826  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.30762|
00782a  2901              CMP      r1,#1                 ;308
00782c  d128              BNE      |L1.30848|
00782e  eb040084          ADD      r0,r4,r4,LSL #2       ;310
007832  4a75              LDR      r2,|L1.31240|
007834  f8520020          LDR      r0,[r2,r0,LSL #2]     ;310
007838  b188              CBZ      r0,|L1.30814|
00783a  eb040084          ADD      r0,r4,r4,LSL #2       ;311
00783e  eb020080          ADD      r0,r2,r0,LSL #2       ;311
007842  7cc2              LDRB     r2,[r0,#0x13]         ;311
007844  9800              LDR      r0,[sp,#0]            ;311
007846  4282              CMP      r2,r0                 ;311
007848  db2e              BLT      |L1.30888|
00784a  fa4ffa84          SXTB     r10,r4                ;312
00784e  eb040084          ADD      r0,r4,r4,LSL #2       ;313
007852  4a6d              LDR      r2,|L1.31240|
007854  eb020080          ADD      r0,r2,r0,LSL #2       ;313
007858  7cc0              LDRB     r0,[r0,#0x13]         ;313
00785a  9000              STR      r0,[sp,#0]            ;313
00785c  e024              B        |L1.30888|
                  |L1.30814|
00785e  eb040084          ADD      r0,r4,r4,LSL #2       ;318
007862  4a69              LDR      r2,|L1.31240|
007864  eb020080          ADD      r0,r2,r0,LSL #2       ;318
007868  7cc0              LDRB     r0,[r0,#0x13]         ;318
00786a  4558              CMP      r0,r11                ;318
00786c  db1c              BLT      |L1.30888|
00786e  fa4ff884          SXTB     r8,r4                 ;319
007872  eb040084          ADD      r0,r4,r4,LSL #2       ;320
007876  eb020080          ADD      r0,r2,r0,LSL #2       ;320
00787a  f890b013          LDRB     r11,[r0,#0x13]        ;320
00787e  e013              B        |L1.30888|
                  |L1.30848|
007880  2902              CMP      r1,#2                 ;324
007882  db11              BLT      |L1.30888|
007884  eb040084          ADD      r0,r4,r4,LSL #2       ;331
007888  4a5f              LDR      r2,|L1.31240|
00788a  eb020080          ADD      r0,r2,r0,LSL #2       ;331
00788e  7cc2              LDRB     r2,[r0,#0x13]         ;331
007890  9801              LDR      r0,[sp,#4]            ;331
007892  4282              CMP      r2,r0                 ;331
007894  db08              BLT      |L1.30888|
007896  fa4ff984          SXTB     r9,r4                 ;332
00789a  eb040084          ADD      r0,r4,r4,LSL #2       ;333
00789e  4a5a              LDR      r2,|L1.31240|
0078a0  eb020080          ADD      r0,r2,r0,LSL #2       ;333
0078a4  7cc0              LDRB     r0,[r0,#0x13]         ;333
0078a6  9001              STR      r0,[sp,#4]            ;333
                  |L1.30888|
0078a8  1c60              ADDS     r0,r4,#1              ;291
0078aa  b2c4              UXTB     r4,r0                 ;291
                  |L1.30892|
0078ac  2c0a              CMP      r4,#0xa               ;291
0078ae  db9c              BLT      |L1.30698|
0078b0  f0170f02          TST      r7,#2                 ;342
0078b4  d104              BNE      |L1.30912|
0078b6  2e0a              CMP      r6,#0xa               ;344
0078b8  d107              BNE      |L1.30922|
0078ba  f0170f01          TST      r7,#1                 ;344
0078be  d104              BNE      |L1.30922|
                  |L1.30912|
0078c0  bf00              NOP                            ;345
0078c2  bf00              NOP                            ;345
0078c4  f04f30ff          MOV      r0,#0xffffffff        ;346
0078c8  e7ad              B        |L1.30758|
                  |L1.30922|
0078ca  2e0a              CMP      r6,#0xa               ;359
0078cc  da02              BGE      |L1.30932|
0078ce  b2f4              UXTB     r4,r6                 ;360
0078d0  bf00              NOP                            ;361
0078d2  e020              B        |L1.30998|
                  |L1.30932|
0078d4  f1b90f0a          CMP      r9,#0xa               ;364
0078d8  da05              BGE      |L1.30950|
0078da  f00904ff          AND      r4,r9,#0xff           ;366
0078de  bf00              NOP                            ;367
0078e0  bf00              NOP                            ;367
0078e2  bf00              NOP                            ;369
0078e4  e012              B        |L1.30988|
                  |L1.30950|
0078e6  f1b80f0a          CMP      r8,#0xa               ;371
0078ea  da03              BGE      |L1.30964|
0078ec  f00804ff          AND      r4,r8,#0xff           ;373
0078f0  bf00              NOP                            ;374
0078f2  e00b              B        |L1.30988|
                  |L1.30964|
0078f4  f1ba0f0a          CMP      r10,#0xa              ;376
0078f8  da03              BGE      |L1.30978|
0078fa  f00a04ff          AND      r4,r10,#0xff          ;378
0078fe  bf00              NOP                            ;379
007900  e004              B        |L1.30988|
                  |L1.30978|
007902  bf00              NOP                            ;382
007904  bf00              NOP                            ;382
007906  f04f30ff          MOV      r0,#0xffffffff        ;383
00790a  e78c              B        |L1.30758|
                  |L1.30988|
00790c  bf00              NOP                            ;387
00790e  bf00              NOP                            ;387
007910  4620              MOV      r0,r4                 ;388
007912  f7fffffe          BL       etharp_free_entry
                  |L1.30998|
007916  bf00              NOP                            ;391
007918  bf00              NOP                            ;391
00791a  bf00              NOP                            ;392
00791c  bf00              NOP                            ;392
00791e  b135              CBZ      r5,|L1.31022|
007920  eb040184          ADD      r1,r4,r4,LSL #2       ;398
007924  4a38              LDR      r2,|L1.31240|
007926  eb020181          ADD      r1,r2,r1,LSL #2       ;398
00792a  6828              LDR      r0,[r5,#0]            ;398
00792c  6048              STR      r0,[r1,#4]            ;398
                  |L1.31022|
00792e  2000              MOVS     r0,#0                 ;400
007930  eb040184          ADD      r1,r4,r4,LSL #2       ;400
007934  4a34              LDR      r2,|L1.31240|
007936  eb020181          ADD      r1,r2,r1,LSL #2       ;400
00793a  74c8              STRB     r0,[r1,#0x13]         ;400
00793c  b260              SXTB     r0,r4                 ;401
00793e  e772              B        |L1.30758|
;;;403    
                          ENDP

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
007940  e92d47f0          PUSH     {r4-r10,lr}
;;;449    {
007944  4606              MOV      r6,r0
007946  460d              MOV      r5,r1
007948  4617              MOV      r7,r2
00794a  4698              MOV      r8,r3
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
00794c  bf00              NOP      
00794e  bf00              NOP      
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
007950  bf00              NOP      
007952  bf00              NOP      
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
007954  b15d              CBZ      r5,|L1.31086|
007956  6828              LDR      r0,[r5,#0]
007958  b148              CBZ      r0,|L1.31086|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
00795a  4631              MOV      r1,r6
00795c  6828              LDR      r0,[r5,#0]
00795e  f7fffffe          BL       ip4_addr_isbroadcast
007962  b920              CBNZ     r0,|L1.31086|
;;;459          ip_addr_ismulticast(ipaddr)) {
007964  7828              LDRB     r0,[r5,#0]
007966  f00000f0          AND      r0,r0,#0xf0
00796a  28e0              CMP      r0,#0xe0
00796c  d105              BNE      |L1.31098|
                  |L1.31086|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
00796e  bf00              NOP      
007970  bf00              NOP      
;;;461        return ERR_ARG;
007972  f06f000d          MVN      r0,#0xd
                  |L1.31094|
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
007976  e8bd87f0          POP      {r4-r10,pc}
                  |L1.31098|
00797a  4641              MOV      r1,r8                 ;464
00797c  4628              MOV      r0,r5                 ;464
00797e  f7fffffe          BL       etharp_find_entry
007982  4604              MOV      r4,r0                 ;464
007984  2c00              CMP      r4,#0                 ;466
007986  da01              BGE      |L1.31116|
007988  4620              MOV      r0,r4                 ;467
00798a  e7f4              B        |L1.31094|
                  |L1.31116|
00798c  2002              MOVS     r0,#2                 ;478
00798e  eb040184          ADD      r1,r4,r4,LSL #2       ;478
007992  4a1d              LDR      r2,|L1.31240|
007994  eb020181          ADD      r1,r2,r1,LSL #2       ;478
007998  7488              STRB     r0,[r1,#0x12]         ;478
00799a  eb040084          ADD      r0,r4,r4,LSL #2       ;482
00799e  4611              MOV      r1,r2                 ;482
0079a0  eb010080          ADD      r0,r1,r0,LSL #2       ;482
0079a4  6086              STR      r6,[r0,#8]            ;482
0079a6  bf00              NOP                            ;486
0079a8  bf00              NOP                            ;486
0079aa  eb040084          ADD      r0,r4,r4,LSL #2       ;488
0079ae  eb010080          ADD      r0,r1,r0,LSL #2       ;488
0079b2  6839              LDR      r1,[r7,#0]            ;488
0079b4  60c1              STR      r1,[r0,#0xc]          ;488
0079b6  88b9              LDRH     r1,[r7,#4]            ;488
0079b8  8201              STRH     r1,[r0,#0x10]         ;488
0079ba  2000              MOVS     r0,#0                 ;490
0079bc  eb040184          ADD      r1,r4,r4,LSL #2       ;490
0079c0  eb020181          ADD      r1,r2,r1,LSL #2       ;490
0079c4  74c8              STRB     r0,[r1,#0x13]         ;490
0079c6  eb040084          ADD      r0,r4,r4,LSL #2       ;504
0079ca  4611              MOV      r1,r2                 ;504
0079cc  f8510020          LDR      r0,[r1,r0,LSL #2]     ;504
0079d0  b198              CBZ      r0,|L1.31226|
0079d2  eb040084          ADD      r0,r4,r4,LSL #2       ;505
0079d6  f8519020          LDR      r9,[r1,r0,LSL #2]     ;505
0079da  2000              MOVS     r0,#0                 ;506
0079dc  eb040184          ADD      r1,r4,r4,LSL #2       ;506
0079e0  f8420021          STR      r0,[r2,r1,LSL #2]     ;506
0079e4  463b              MOV      r3,r7                 ;509
0079e6  f106022b          ADD      r2,r6,#0x2b           ;509
0079ea  4649              MOV      r1,r9                 ;509
0079ec  4630              MOV      r0,r6                 ;509
0079ee  f7fffffe          BL       etharp_send_ip
0079f2  4648              MOV      r0,r9                 ;511
0079f4  f7fffffe          BL       pbuf_free
0079f8  bf00              NOP                            ;512
                  |L1.31226|
0079fa  2000              MOVS     r0,#0                 ;513
0079fc  e7bb              B        |L1.31094|
0079fe  0000              DCW      0x0000
                  |L1.31232|
                          DCD      0x63538263
                  |L1.31236|
                          DCD      ip_addr_broadcast
                  |L1.31240|
                          DCD      arp_table
                  |L1.31244|
                          DCD      ethzero
                          ENDP

                  autoip_start_probing PROC
;;;332    static void
;;;333    autoip_start_probing(struct netif *netif)
007a10  b510              PUSH     {r4,lr}
;;;334    {
;;;335      struct autoip *autoip = netif->autoip;
007a12  6a41              LDR      r1,[r0,#0x24]
;;;336    
;;;337      autoip->state = AUTOIP_STATE_PROBING;
007a14  2201              MOVS     r2,#1
007a16  710a              STRB     r2,[r1,#4]
;;;338      autoip->sent_num = 0;
007a18  2200              MOVS     r2,#0
007a1a  714a              STRB     r2,[r1,#5]
;;;339      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007a1c  bf00              NOP      
007a1e  bf00              NOP      
;;;340         ("autoip_start_probing(): changing state to PROBING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;341          ip4_addr1_16(&netif->autoip->llipaddr), ip4_addr2_16(&netif->autoip->llipaddr),
;;;342          ip4_addr3_16(&netif->autoip->llipaddr), ip4_addr4_16(&netif->autoip->llipaddr)));
;;;343    
;;;344      /* time to wait to first probe, this is randomly
;;;345       * choosen out of 0 to PROBE_WAIT seconds.
;;;346       * compliant to RFC 3927 Section 2.2.1
;;;347       */
;;;348      autoip->ttw = (u16_t)(LWIP_AUTOIP_RAND(netif) % (PROBE_WAIT * AUTOIP_TICKS_PER_SECOND));
007a20  2230              MOVS     r2,#0x30
007a22  5c12              LDRB     r2,[r2,r0]
007a24  0613              LSLS     r3,r2,#24
007a26  222e              MOVS     r2,#0x2e
007a28  5c12              LDRB     r2,[r2,r0]
007a2a  ea434302          ORR      r3,r3,r2,LSL #16
007a2e  222d              MOVS     r2,#0x2d
007a30  5c12              LDRB     r2,[r2,r0]
007a32  ea432202          ORR      r2,r3,r2,LSL #8
007a36  232f              MOVS     r3,#0x2f
007a38  5c1b              LDRB     r3,[r3,r0]
007a3a  431a              ORRS     r2,r2,r3
007a3c  6a43              LDR      r3,[r0,#0x24]
007a3e  b113              CBZ      r3,|L1.31302|
007a40  6a43              LDR      r3,[r0,#0x24]
007a42  7a5b              LDRB     r3,[r3,#9]
007a44  e000              B        |L1.31304|
                  |L1.31302|
007a46  2300              MOVS     r3,#0
                  |L1.31304|
007a48  441a              ADD      r2,r2,r3
007a4a  230a              MOVS     r3,#0xa
007a4c  fbb2f4f3          UDIV     r4,r2,r3
007a50  fb032214          MLS      r2,r3,r4,r2
007a54  80ca              STRH     r2,[r1,#6]
;;;349    
;;;350      /*
;;;351       * if we tried more then MAX_CONFLICTS we must limit our rate for
;;;352       * accquiring and probing address
;;;353       * compliant to RFC 3927 Section 2.2.1
;;;354       */
;;;355      if (autoip->tried_llipaddr > MAX_CONFLICTS) {
007a56  7a4a              LDRB     r2,[r1,#9]
007a58  2a0a              CMP      r2,#0xa
007a5a  dd02              BLE      |L1.31330|
;;;356        autoip->ttw = RATE_LIMIT_INTERVAL * AUTOIP_TICKS_PER_SECOND;
007a5c  f44f7216          MOV      r2,#0x258
007a60  80ca              STRH     r2,[r1,#6]
                  |L1.31330|
;;;357      }
;;;358    }
007a62  bd10              POP      {r4,pc}
;;;359    
                          ENDP

                  autoip_create_addr PROC
;;;195    static void
;;;196    autoip_create_addr(struct netif *netif, ip_addr_t *ipaddr)
007a64  b5f0              PUSH     {r4-r7,lr}
;;;197    {
007a66  4605              MOV      r5,r0
007a68  460e              MOV      r6,r1
;;;198      /* Here we create an IP-Address out of range 169.254.1.0 to 169.254.254.255
;;;199       * compliant to RFC 3927 Section 2.1
;;;200       * We have 254 * 256 possibilities */
;;;201    
;;;202      u32_t addr = ntohl(LWIP_AUTOIP_CREATE_SEED_ADDR(netif));
007a6a  212f              MOVS     r1,#0x2f
007a6c  5d4a              LDRB     r2,[r1,r5]
007a6e  2130              MOVS     r1,#0x30
007a70  5d49              LDRB     r1,[r1,r5]
007a72  ea422101          ORR      r1,r2,r1,LSL #8
007a76  4af8              LDR      r2,|L1.32344|
007a78  1888              ADDS     r0,r1,r2
007a7a  f7fffffe          BL       lwip_htonl
007a7e  4607              MOV      r7,r0
007a80  f7fffffe          BL       lwip_ntohl
007a84  4604              MOV      r4,r0
;;;203      addr += netif->autoip->tried_llipaddr;
007a86  6a68              LDR      r0,[r5,#0x24]
007a88  7a40              LDRB     r0,[r0,#9]
007a8a  4404              ADD      r4,r4,r0
;;;204      addr = AUTOIP_NET | (addr & 0xffff);
007a8c  b2a0              UXTH     r0,r4
007a8e  49f3              LDR      r1,|L1.32348|
007a90  ea400401          ORR      r4,r0,r1
;;;205      /* Now, 169.254.0.0 <= addr <= 169.254.255.255 */ 
;;;206    
;;;207      if (addr < AUTOIP_RANGE_START) {
007a94  48f0              LDR      r0,|L1.32344|
007a96  4284              CMP      r4,r0
007a98  d201              BCS      |L1.31390|
;;;208        addr += AUTOIP_RANGE_END - AUTOIP_RANGE_START + 1;
007a9a  f504447e          ADD      r4,r4,#0xfe00
                  |L1.31390|
;;;209      }
;;;210      if (addr > AUTOIP_RANGE_END) {
007a9e  48f0              LDR      r0,|L1.32352|
007aa0  4284              CMP      r4,r0
007aa2  d901              BLS      |L1.31400|
;;;211        addr -= AUTOIP_RANGE_END - AUTOIP_RANGE_START + 1;
007aa4  f5a4447e          SUB      r4,r4,#0xfe00
                  |L1.31400|
;;;212      }
;;;213      LWIP_ASSERT("AUTOIP address not in range", (addr >= AUTOIP_RANGE_START) &&
007aa8  bf00              NOP      
007aaa  bf00              NOP      
;;;214        (addr <= AUTOIP_RANGE_END));
;;;215      ip4_addr_set_u32(ipaddr, htonl(addr));
007aac  4620              MOV      r0,r4
007aae  f7fffffe          BL       lwip_htonl
007ab2  6030              STR      r0,[r6,#0]
;;;216      
;;;217      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007ab4  bf00              NOP      
007ab6  bf00              NOP      
;;;218        ("autoip_create_addr(): tried_llipaddr=%"U16_F", %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;219        (u16_t)(netif->autoip->tried_llipaddr), ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr),
;;;220        ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
;;;221    }
007ab8  bdf0              POP      {r4-r7,pc}
;;;222    
                          ENDP

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
007aba  b570              PUSH     {r4-r6,lr}
;;;580    {
007abc  4605              MOV      r5,r0
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
007abe  2400              MOVS     r4,#0
007ac0  e012              B        |L1.31464|
                  |L1.31426|
;;;584        u8_t state = arp_table[i].state;
007ac2  eb040084          ADD      r0,r4,r4,LSL #2
007ac6  49e7              LDR      r1,|L1.32356|
007ac8  eb010080          ADD      r0,r1,r0,LSL #2
007acc  7c86              LDRB     r6,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
007ace  b14e              CBZ      r6,|L1.31460|
007ad0  eb040084          ADD      r0,r4,r4,LSL #2
007ad4  eb010080          ADD      r0,r1,r0,LSL #2
007ad8  6880              LDR      r0,[r0,#8]
007ada  42a8              CMP      r0,r5
007adc  d102              BNE      |L1.31460|
;;;586          etharp_free_entry(i);
007ade  4620              MOV      r0,r4
007ae0  f7fffffe          BL       etharp_free_entry
                  |L1.31460|
007ae4  1c60              ADDS     r0,r4,#1              ;583
007ae6  b2c4              UXTB     r4,r0                 ;583
                  |L1.31464|
007ae8  2c0a              CMP      r4,#0xa               ;583
007aea  dbea              BLT      |L1.31426|
;;;587        }
;;;588      }
;;;589    }
007aec  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

                  netif_set_down PROC
;;;489     */ 
;;;490    void netif_set_down(struct netif *netif)
007aee  b510              PUSH     {r4,lr}
;;;491    {
007af0  4604              MOV      r4,r0
;;;492      if (netif->flags & NETIF_FLAG_UP) {
007af2  f8940031          LDRB     r0,[r4,#0x31]
007af6  f0100f01          TST      r0,#1
007afa  d00c              BEQ      |L1.31510|
;;;493        netif->flags &= ~NETIF_FLAG_UP;
007afc  f8140f31          LDRB     r0,[r4,#0x31]!
007b00  f0200001          BIC      r0,r0,#1
007b04  7020              STRB     r0,[r4,#0]
;;;494    #if LWIP_SNMP
;;;495        snmp_get_sysuptime(&netif->ts);
;;;496    #endif
;;;497    
;;;498    #if LWIP_ARP
;;;499        if (netif->flags & NETIF_FLAG_ETHARP) {
007b06  f8140931          LDRB     r0,[r4],#-0x31
007b0a  f0100f20          TST      r0,#0x20
007b0e  d002              BEQ      |L1.31510|
;;;500          etharp_cleanup_netif(netif);
007b10  4620              MOV      r0,r4
007b12  f7fffffe          BL       etharp_cleanup_netif
                  |L1.31510|
;;;501        }
;;;502    #endif /* LWIP_ARP */
;;;503        NETIF_STATUS_CALLBACK(netif);
;;;504      }
;;;505    }
007b16  bd10              POP      {r4,pc}
;;;506    
                          ENDP

                  autoip_start PROC
;;;284    err_t
;;;285    autoip_start(struct netif *netif)
007b18  b570              PUSH     {r4-r6,lr}
;;;286    {
007b1a  4605              MOV      r5,r0
;;;287      struct autoip *autoip = netif->autoip;
007b1c  6a6c              LDR      r4,[r5,#0x24]
;;;288      err_t result = ERR_OK;
007b1e  2600              MOVS     r6,#0
;;;289    
;;;290      if (netif_is_up(netif)) {
007b20  f8950031          LDRB     r0,[r5,#0x31]
007b24  f0100f01          TST      r0,#1
007b28  d002              BEQ      |L1.31536|
;;;291        netif_set_down(netif);
007b2a  4628              MOV      r0,r5
007b2c  f7fffffe          BL       netif_set_down
                  |L1.31536|
;;;292      }
;;;293    
;;;294      /* Set IP-Address, Netmask and Gateway to 0 to make sure that
;;;295       * ARP Packets are formed correctly
;;;296       */
;;;297      ip_addr_set_zero(&netif->ip_addr);
007b30  2000              MOVS     r0,#0
007b32  6068              STR      r0,[r5,#4]
;;;298      ip_addr_set_zero(&netif->netmask);
007b34  60a8              STR      r0,[r5,#8]
;;;299      ip_addr_set_zero(&netif->gw);
007b36  60e8              STR      r0,[r5,#0xc]
;;;300    
;;;301      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007b38  bf00              NOP      
007b3a  bf00              NOP      
;;;302        ("autoip_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0],
;;;303        netif->name[1], (u16_t)netif->num));
;;;304      if (autoip == NULL) {
007b3c  b994              CBNZ     r4,|L1.31588|
;;;305        /* no AutoIP client attached yet? */
;;;306        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
007b3e  bf00              NOP      
007b40  bf00              NOP      
;;;307          ("autoip_start(): starting new AUTOIP client\n"));
;;;308        autoip = (struct autoip *)mem_malloc(sizeof(struct autoip));
007b42  200c              MOVS     r0,#0xc
007b44  f7fffffe          BL       mem_malloc
007b48  4604              MOV      r4,r0
;;;309        if (autoip == NULL) {
007b4a  b924              CBNZ     r4,|L1.31574|
;;;310          LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
007b4c  bf00              NOP      
007b4e  bf00              NOP      
;;;311            ("autoip_start(): could not allocate autoip\n"));
;;;312          return ERR_MEM;
007b50  f04f30ff          MOV      r0,#0xffffffff
                  |L1.31572|
;;;313        }
;;;314        memset(autoip, 0, sizeof(struct autoip));
;;;315        /* store this AutoIP client in the netif */
;;;316        netif->autoip = autoip;
;;;317        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_start(): allocated autoip"));
;;;318      } else {
;;;319        autoip->state = AUTOIP_STATE_OFF;
;;;320        autoip->ttw = 0;
;;;321        autoip->sent_num = 0;
;;;322        ip_addr_set_zero(&autoip->llipaddr);
;;;323        autoip->lastconflict = 0;
;;;324      }
;;;325    
;;;326      autoip_create_addr(netif, &(autoip->llipaddr));
;;;327      autoip_start_probing(netif);
;;;328    
;;;329      return result;
;;;330    }
007b54  bd70              POP      {r4-r6,pc}
                  |L1.31574|
007b56  2000              MOVS     r0,#0                 ;314
007b58  6020              STR      r0,[r4,#0]            ;314
007b5a  6060              STR      r0,[r4,#4]            ;314
007b5c  60a0              STR      r0,[r4,#8]            ;314
007b5e  626c              STR      r4,[r5,#0x24]         ;316
007b60  bf00              NOP                            ;317
007b62  e005              B        |L1.31600|
                  |L1.31588|
007b64  2000              MOVS     r0,#0                 ;319
007b66  7120              STRB     r0,[r4,#4]            ;319
007b68  80e0              STRH     r0,[r4,#6]            ;320
007b6a  7160              STRB     r0,[r4,#5]            ;321
007b6c  6020              STR      r0,[r4,#0]            ;322
007b6e  7220              STRB     r0,[r4,#8]            ;323
                  |L1.31600|
007b70  4621              MOV      r1,r4                 ;326
007b72  4628              MOV      r0,r5                 ;326
007b74  f7fffffe          BL       autoip_create_addr
007b78  4628              MOV      r0,r5                 ;327
007b7a  f7fffffe          BL       autoip_start_probing
007b7e  4630              MOV      r0,r6                 ;329
007b80  e7e8              B        |L1.31572|
;;;331    
                          ENDP

                  autoip_restart PROC
;;;149    static void
;;;150    autoip_restart(struct netif *netif)
007b82  b510              PUSH     {r4,lr}
;;;151    {
007b84  4604              MOV      r4,r0
;;;152      netif->autoip->tried_llipaddr++;
007b86  6a60              LDR      r0,[r4,#0x24]
007b88  7a40              LDRB     r0,[r0,#9]
007b8a  1c40              ADDS     r0,r0,#1
007b8c  6a61              LDR      r1,[r4,#0x24]
007b8e  7248              STRB     r0,[r1,#9]
;;;153      autoip_start(netif);
007b90  4620              MOV      r0,r4
007b92  f7fffffe          BL       autoip_start
;;;154    }
007b96  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  etharp_raw PROC
;;;1175   err_t
;;;1176   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
007b98  e92d5ffc          PUSH     {r2-r12,lr}
;;;1177              const struct eth_addr *ethdst_addr,
;;;1178              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1179              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1180              const u16_t opcode)
;;;1181   {
007b9c  4607              MOV      r7,r0
007b9e  4688              MOV      r8,r1
007ba0  4693              MOV      r11,r2
007ba2  4699              MOV      r9,r3
007ba4  f8dda030          LDR      r10,[sp,#0x30]
;;;1182     struct pbuf *p;
;;;1183     err_t result = ERR_OK;
007ba8  2000              MOVS     r0,#0
007baa  9001              STR      r0,[sp,#4]
;;;1184     struct eth_hdr *ethhdr;
;;;1185     struct etharp_hdr *hdr;
;;;1186   #if LWIP_AUTOIP
;;;1187     const u8_t * ethdst_hwaddr;
;;;1188   #endif /* LWIP_AUTOIP */
;;;1189   
;;;1190     LWIP_ASSERT("netif != NULL", netif != NULL);
007bac  bf00              NOP      
007bae  bf00              NOP      
;;;1191   
;;;1192     /* allocate a pbuf for the outgoing ARP request packet */
;;;1193     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
007bb0  2200              MOVS     r2,#0
007bb2  212a              MOVS     r1,#0x2a
007bb4  2003              MOVS     r0,#3
007bb6  f7fffffe          BL       pbuf_alloc
007bba  4605              MOV      r5,r0
;;;1194     /* could allocate a pbuf for an ARP request? */
;;;1195     if (p == NULL) {
007bbc  b95d              CBNZ     r5,|L1.31702|
;;;1196       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
007bbe  bf00              NOP      
007bc0  bf00              NOP      
;;;1197         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1198       ETHARP_STATS_INC(etharp.memerr);
007bc2  48a9              LDR      r0,|L1.32360|
007bc4  8c80              LDRH     r0,[r0,#0x24]
007bc6  1c40              ADDS     r0,r0,#1
007bc8  b281              UXTH     r1,r0
007bca  48a7              LDR      r0,|L1.32360|
007bcc  8481              STRH     r1,[r0,#0x24]
;;;1199       return ERR_MEM;
007bce  f04f30ff          MOV      r0,#0xffffffff
                  |L1.31698|
;;;1200     }
;;;1201     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1202                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1203   
;;;1204     ethhdr = (struct eth_hdr *)p->payload;
;;;1205     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1206     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1207     hdr->opcode = htons(opcode);
;;;1208   
;;;1209     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1210                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1211   #if LWIP_AUTOIP
;;;1212     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1213      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1214      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1215     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1216   #endif /* LWIP_AUTOIP */
;;;1217     /* Write the ARP MAC-Addresses */
;;;1218     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1219     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1220     /* Write the Ethernet MAC-Addresses */
;;;1221   #if LWIP_AUTOIP
;;;1222     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1223   #else  /* LWIP_AUTOIP */
;;;1224     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1225   #endif /* LWIP_AUTOIP */
;;;1226     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1227     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1228      * structure packing. */ 
;;;1229     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1230     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1231   
;;;1232     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1233     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1234     /* set hwlen and protolen */
;;;1235     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1236     hdr->protolen = sizeof(ip_addr_t);
;;;1237   
;;;1238     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1239     /* send ARP query */
;;;1240     result = netif->linkoutput(netif, p);
;;;1241     ETHARP_STATS_INC(etharp.xmit);
;;;1242     /* free ARP query packet */
;;;1243     pbuf_free(p);
;;;1244     p = NULL;
;;;1245     /* could not allocate pbuf for ARP request */
;;;1246   
;;;1247     return result;
;;;1248   }
007bd2  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.31702|
007bd6  bf00              NOP                            ;1201
007bd8  bf00              NOP                            ;1201
007bda  686e              LDR      r6,[r5,#4]            ;1204
007bdc  f106040e          ADD      r4,r6,#0xe            ;1205
007be0  bf00              NOP                            ;1206
007be2  bf00              NOP                            ;1206
007be4  980f              LDR      r0,[sp,#0x3c]         ;1207
007be6  f7fffffe          BL       lwip_htons
007bea  80e0              STRH     r0,[r4,#6]            ;1207
007bec  bf00              NOP                            ;1209
007bee  bf00              NOP                            ;1209
007bf0  f8ba0000          LDRH     r0,[r10,#0]           ;1215
007bf4  b280              UXTH     r0,r0                 ;1215
007bf6  f5a0417e          SUB      r1,r0,#0xfe00         ;1215
007bfa  39a9              SUBS     r1,r1,#0xa9           ;1215
007bfc  d101              BNE      |L1.31746|
007bfe  489b              LDR      r0,|L1.32364|
007c00  e000              B        |L1.31748|
                  |L1.31746|
007c02  4658              MOV      r0,r11                ;1215
                  |L1.31748|
007c04  9000              STR      r0,[sp,#0]            ;1215
007c06  f8d90000          LDR      r0,[r9,#0]            ;1218
007c0a  60a0              STR      r0,[r4,#8]            ;1218
007c0c  f8b90004          LDRH     r0,[r9,#4]            ;1218
007c10  81a0              STRH     r0,[r4,#0xc]          ;1218
007c12  980d              LDR      r0,[sp,#0x34]         ;1219
007c14  6801              LDR      r1,[r0,#0]            ;1219
007c16  f8c41012          STR      r1,[r4,#0x12]         ;1219
007c1a  8880              LDRH     r0,[r0,#4]            ;1219
007c1c  82e0              STRH     r0,[r4,#0x16]         ;1219
007c1e  9800              LDR      r0,[sp,#0]            ;1222
007c20  6801              LDR      r1,[r0,#0]            ;1222
007c22  6031              STR      r1,[r6,#0]            ;1222
007c24  8880              LDRH     r0,[r0,#4]            ;1222
007c26  80b0              STRH     r0,[r6,#4]            ;1222
007c28  f8d80000          LDR      r0,[r8,#0]            ;1226
007c2c  f8c60006          STR      r0,[r6,#6]            ;1226
007c30  f8b80004          LDRH     r0,[r8,#4]            ;1226
007c34  8170              STRH     r0,[r6,#0xa]          ;1226
007c36  f8da0000          LDR      r0,[r10,#0]           ;1229
007c3a  f8c4000e          STR      r0,[r4,#0xe]          ;1229
007c3e  980e              LDR      r0,[sp,#0x38]         ;1230
007c40  6800              LDR      r0,[r0,#0]            ;1230
007c42  61a0              STR      r0,[r4,#0x18]         ;1230
007c44  f44f7080          MOV      r0,#0x100             ;1232
007c48  8020              STRH     r0,[r4,#0]            ;1232
007c4a  2008              MOVS     r0,#8                 ;1233
007c4c  8060              STRH     r0,[r4,#2]            ;1233
007c4e  2006              MOVS     r0,#6                 ;1235
007c50  7120              STRB     r0,[r4,#4]            ;1235
007c52  2004              MOVS     r0,#4                 ;1236
007c54  7160              STRB     r0,[r4,#5]            ;1236
007c56  f44f60c1          MOV      r0,#0x608             ;1238
007c5a  81b0              STRH     r0,[r6,#0xc]          ;1238
007c5c  4629              MOV      r1,r5                 ;1240
007c5e  4638              MOV      r0,r7                 ;1240
007c60  69ba              LDR      r2,[r7,#0x18]         ;1240
007c62  4790              BLX      r2                    ;1240
007c64  9001              STR      r0,[sp,#4]            ;1240
007c66  4880              LDR      r0,|L1.32360|
007c68  8b00              LDRH     r0,[r0,#0x18]         ;1241  ; lwip_stats
007c6a  1c40              ADDS     r0,r0,#1              ;1241
007c6c  497e              LDR      r1,|L1.32360|
007c6e  8308              STRH     r0,[r1,#0x18]         ;1241
007c70  4628              MOV      r0,r5                 ;1243
007c72  f7fffffe          BL       pbuf_free
007c76  2500              MOVS     r5,#0                 ;1244
007c78  9801              LDR      r0,[sp,#4]            ;1247
007c7a  e7aa              B        |L1.31698|
;;;1249   
                          ENDP

                  autoip_arp_announce PROC
;;;241    static err_t
;;;242    autoip_arp_announce(struct netif *netif)
007c7c  b51f              PUSH     {r0-r4,lr}
;;;243    {
007c7e  4604              MOV      r4,r0
;;;244      return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
007c80  2201              MOVS     r2,#1
007c82  4b7b              LDR      r3,|L1.32368|
007c84  6a60              LDR      r0,[r4,#0x24]
007c86  e9cd0300          STRD     r0,r3,[sp,#0]
007c8a  f104032b          ADD      r3,r4,#0x2b
007c8e  e9cd0202          STRD     r0,r2,[sp,#8]
007c92  4a76              LDR      r2,|L1.32364|
007c94  4619              MOV      r1,r3
007c96  4620              MOV      r0,r4
007c98  f7fffffe          BL       etharp_raw
;;;245        (struct eth_addr *)netif->hwaddr, &netif->autoip->llipaddr, &ethzero,
;;;246        &netif->autoip->llipaddr, ARP_REQUEST);
;;;247    }
007c9c  b004              ADD      sp,sp,#0x10
007c9e  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  autoip_handle_arp_conflict PROC
;;;159    static void
;;;160    autoip_handle_arp_conflict(struct netif *netif)
007ca0  b570              PUSH     {r4-r6,lr}
;;;161    {
007ca2  4604              MOV      r4,r0
;;;162      /* Somehow detect if we are defending or retreating */
;;;163      unsigned char defend = 1; /* tbd */
007ca4  2501              MOVS     r5,#1
;;;164    
;;;165      if (defend) {
007ca6  b195              CBZ      r5,|L1.31950|
;;;166        if (netif->autoip->lastconflict > 0) {
007ca8  6a60              LDR      r0,[r4,#0x24]
007caa  7a00              LDRB     r0,[r0,#8]
007cac  2800              CMP      r0,#0
007cae  dd05              BLE      |L1.31932|
;;;167          /* retreat, there was a conflicting ARP in the last
;;;168           * DEFEND_INTERVAL seconds
;;;169           */
;;;170          LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007cb0  bf00              NOP      
007cb2  bf00              NOP      
;;;171            ("autoip_handle_arp_conflict(): we are defending, but in DEFEND_INTERVAL, retreating\n"));
;;;172    
;;;173          /* TODO: close all TCP sessions */
;;;174          autoip_restart(netif);
007cb4  4620              MOV      r0,r4
007cb6  f7fffffe          BL       autoip_restart
007cba  e00d              B        |L1.31960|
                  |L1.31932|
;;;175        } else {
;;;176          LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007cbc  bf00              NOP      
007cbe  bf00              NOP      
;;;177            ("autoip_handle_arp_conflict(): we are defend, send ARP Announce\n"));
;;;178          autoip_arp_announce(netif);
007cc0  4620              MOV      r0,r4
007cc2  f7fffffe          BL       autoip_arp_announce
;;;179          netif->autoip->lastconflict = DEFEND_INTERVAL * AUTOIP_TICKS_PER_SECOND;
007cc6  2064              MOVS     r0,#0x64
007cc8  6a61              LDR      r1,[r4,#0x24]
007cca  7208              STRB     r0,[r1,#8]
007ccc  e004              B        |L1.31960|
                  |L1.31950|
;;;180        }
;;;181      } else {
;;;182        LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
007cce  bf00              NOP      
007cd0  bf00              NOP      
;;;183          ("autoip_handle_arp_conflict(): we do not defend, retreating\n"));
;;;184        /* TODO: close all TCP sessions */
;;;185        autoip_restart(netif);
007cd2  4620              MOV      r0,r4
007cd4  f7fffffe          BL       autoip_restart
                  |L1.31960|
;;;186      }
;;;187    }
007cd8  bd70              POP      {r4-r6,pc}
;;;188    
                          ENDP

                  autoip_arp_reply PROC
;;;477    void
;;;478    autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
007cda  b57f              PUSH     {r0-r6,lr}
;;;479    {
007cdc  4604              MOV      r4,r0
007cde  460d              MOV      r5,r1
;;;480      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE, ("autoip_arp_reply()\n"));
007ce0  bf00              NOP      
007ce2  bf00              NOP      
;;;481      if ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) {
007ce4  6a60              LDR      r0,[r4,#0x24]
007ce6  2800              CMP      r0,#0
007ce8  d043              BEQ      |L1.32114|
007cea  6a60              LDR      r0,[r4,#0x24]
007cec  7900              LDRB     r0,[r0,#4]
007cee  2800              CMP      r0,#0
007cf0  d03f              BEQ      |L1.32114|
;;;482       /* when ip.src == llipaddr && hw.src != netif->hwaddr
;;;483        *
;;;484        * when probing  ip.dst == llipaddr && hw.src != netif->hwaddr
;;;485        * we have a conflict and must solve it
;;;486        */
;;;487        ip_addr_t sipaddr, dipaddr;
;;;488        struct eth_addr netifaddr;
;;;489        ETHADDR16_COPY(netifaddr.addr, netif->hwaddr);
007cf2  f8d4002b          LDR      r0,[r4,#0x2b]
007cf6  9000              STR      r0,[sp,#0]
007cf8  f8b4002f          LDRH     r0,[r4,#0x2f]
007cfc  f8ad0004          STRH     r0,[sp,#4]
;;;490    
;;;491        /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;492         * structure packing (not using structure copy which breaks strict-aliasing rules).
;;;493         */
;;;494        IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
007d00  f8d5000e          LDR      r0,[r5,#0xe]
007d04  9003              STR      r0,[sp,#0xc]
;;;495        IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
007d06  69a8              LDR      r0,[r5,#0x18]
007d08  9002              STR      r0,[sp,#8]
;;;496          
;;;497        if ((netif->autoip->state == AUTOIP_STATE_PROBING) ||
007d0a  6a60              LDR      r0,[r4,#0x24]
007d0c  7900              LDRB     r0,[r0,#4]
007d0e  2801              CMP      r0,#1
007d10  d006              BEQ      |L1.32032|
;;;498            ((netif->autoip->state == AUTOIP_STATE_ANNOUNCING) &&
007d12  6a60              LDR      r0,[r4,#0x24]
007d14  7900              LDRB     r0,[r0,#4]
007d16  2802              CMP      r0,#2
007d18  d119              BNE      |L1.32078|
;;;499             (netif->autoip->sent_num == 0))) {
007d1a  6a60              LDR      r0,[r4,#0x24]
007d1c  7940              LDRB     r0,[r0,#5]
007d1e  b9b0              CBNZ     r0,|L1.32078|
                  |L1.32032|
;;;500         /* RFC 3927 Section 2.2.1:
;;;501          * from beginning to after ANNOUNCE_WAIT
;;;502          * seconds we have a conflict if
;;;503          * ip.src == llipaddr OR
;;;504          * ip.dst == llipaddr && hw.src != own hwaddr
;;;505          */
;;;506          if ((ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr)) ||
007d20  9803              LDR      r0,[sp,#0xc]
007d22  6a61              LDR      r1,[r4,#0x24]
007d24  6809              LDR      r1,[r1,#0]
007d26  4288              CMP      r0,r1
007d28  d00b              BEQ      |L1.32066|
;;;507              (ip_addr_cmp(&dipaddr, &netif->autoip->llipaddr) &&
007d2a  9802              LDR      r0,[sp,#8]
007d2c  6a61              LDR      r1,[r4,#0x24]
007d2e  6809              LDR      r1,[r1,#0]
007d30  4288              CMP      r0,r1
007d32  d11d              BNE      |L1.32112|
;;;508               !eth_addr_cmp(&netifaddr, &hdr->shwaddr))) {
007d34  2206              MOVS     r2,#6
007d36  f1050108          ADD      r1,r5,#8
007d3a  4668              MOV      r0,sp
007d3c  f7fffffe          BL       memcmp
007d40  b1b0              CBZ      r0,|L1.32112|
                  |L1.32066|
;;;509            LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
007d42  bf00              NOP      
007d44  bf00              NOP      
;;;510              ("autoip_arp_reply(): Probe Conflict detected\n"));
;;;511            autoip_restart(netif);
007d46  4620              MOV      r0,r4
007d48  f7fffffe          BL       autoip_restart
007d4c  e010              B        |L1.32112|
                  |L1.32078|
;;;512          }
;;;513        } else {
;;;514         /* RFC 3927 Section 2.5:
;;;515          * in any state we have a conflict if
;;;516          * ip.src == llipaddr && hw.src != own hwaddr
;;;517          */
;;;518          if (ip_addr_cmp(&sipaddr, &netif->autoip->llipaddr) &&
007d4e  9803              LDR      r0,[sp,#0xc]
007d50  6a61              LDR      r1,[r4,#0x24]
007d52  6809              LDR      r1,[r1,#0]
007d54  4288              CMP      r0,r1
007d56  d10b              BNE      |L1.32112|
;;;519              !eth_addr_cmp(&netifaddr, &hdr->shwaddr)) {
007d58  2206              MOVS     r2,#6
007d5a  f1050108          ADD      r1,r5,#8
007d5e  4668              MOV      r0,sp
007d60  f7fffffe          BL       memcmp
007d64  b120              CBZ      r0,|L1.32112|
;;;520            LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
007d66  bf00              NOP      
007d68  bf00              NOP      
;;;521              ("autoip_arp_reply(): Conflicting ARP-Packet detected\n"));
;;;522            autoip_handle_arp_conflict(netif);
007d6a  4620              MOV      r0,r4
007d6c  f7fffffe          BL       autoip_handle_arp_conflict
                  |L1.32112|
;;;523          }
;;;524        }
;;;525      }
007d70  bf00              NOP      
                  |L1.32114|
;;;526    }
007d72  bd7f              POP      {r0-r6,pc}
;;;527    
                          ENDP

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
007d74  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
007d78  4605              MOV      r5,r0
007d7a  4688              MOV      r8,r1
007d7c  4616              MOV      r6,r2
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
007d7e  bf00              NOP      
007d80  b90d              CBNZ     r5,|L1.32134|
                  |L1.32130|
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812    			ip_addr_debug_print(NETIF_DEBUG, &netif->ip_addr);
;;;813        /* request was not directed to us */
;;;814        } else {
;;;815          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;816          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;817        }
;;;818        break;
;;;819      case PP_HTONS(ARP_REPLY):
;;;820        /* ARP reply. We already updated the ARP cache earlier. */
;;;821        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;822    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;823        /* DHCP wants to know about ARP replies from any host with an
;;;824         * IP address also offered to us by the DHCP server. We do not
;;;825         * want to take a duplicate IP address on a single network.
;;;826         * @todo How should we handle redundant (fail-over) interfaces? */
;;;827        dhcp_arp_reply(netif, &sipaddr);
;;;828    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;829        break;
;;;830      default:
;;;831        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;832        ETHARP_STATS_INC(etharp.err);
;;;833        break;
;;;834      }
;;;835      /* free ARP packet */
;;;836      pbuf_free(p);
;;;837    }
007d82  e8bd87fc          POP      {r2-r10,pc}
                  |L1.32134|
007d86  bf00              NOP                            ;699
007d88  8970              LDRH     r0,[r6,#0xa]          ;703
007d8a  282a              CMP      r0,#0x2a              ;703
007d8c  da10              BGE      |L1.32176|
007d8e  bf00              NOP                            ;704
007d90  bf00              NOP                            ;704
007d92  4835              LDR      r0,|L1.32360|
007d94  8c40              LDRH     r0,[r0,#0x22]         ;707
007d96  1c40              ADDS     r0,r0,#1              ;707
007d98  b281              UXTH     r1,r0                 ;707
007d9a  4833              LDR      r0,|L1.32360|
007d9c  8441              STRH     r1,[r0,#0x22]         ;707
007d9e  8bc0              LDRH     r0,[r0,#0x1e]         ;708
007da0  1c40              ADDS     r0,r0,#1              ;708
007da2  b281              UXTH     r1,r0                 ;708
007da4  4830              LDR      r0,|L1.32360|
007da6  83c1              STRH     r1,[r0,#0x1e]         ;708
007da8  4630              MOV      r0,r6                 ;709
007daa  f7fffffe          BL       pbuf_free
007dae  e7e8              B        |L1.32130|
                  |L1.32176|
007db0  6877              LDR      r7,[r6,#4]            ;713
007db2  f107040e          ADD      r4,r7,#0xe            ;714
007db6  8820              LDRH     r0,[r4,#0]            ;722
007db8  f5b07f80          CMP      r0,#0x100             ;722
007dbc  d108              BNE      |L1.32208|
007dbe  7920              LDRB     r0,[r4,#4]            ;723
007dc0  2806              CMP      r0,#6                 ;723
007dc2  d105              BNE      |L1.32208|
007dc4  7960              LDRB     r0,[r4,#5]            ;724
007dc6  2804              CMP      r0,#4                 ;724
007dc8  d102              BNE      |L1.32208|
007dca  8860              LDRH     r0,[r4,#2]            ;725
007dcc  2808              CMP      r0,#8                 ;725
007dce  d010              BEQ      |L1.32242|
                  |L1.32208|
007dd0  bf00              NOP                            ;726
007dd2  bf00              NOP                            ;726
007dd4  4824              LDR      r0,|L1.32360|
007dd6  8d00              LDRH     r0,[r0,#0x28]         ;729
007dd8  1c40              ADDS     r0,r0,#1              ;729
007dda  b281              UXTH     r1,r0                 ;729
007ddc  4822              LDR      r0,|L1.32360|
007dde  8501              STRH     r1,[r0,#0x28]         ;729
007de0  8bc0              LDRH     r0,[r0,#0x1e]         ;730
007de2  1c40              ADDS     r0,r0,#1              ;730
007de4  b281              UXTH     r1,r0                 ;730
007de6  4820              LDR      r0,|L1.32360|
007de8  83c1              STRH     r1,[r0,#0x1e]         ;730
007dea  4630              MOV      r0,r6                 ;731
007dec  f7fffffe          BL       pbuf_free
007df0  e7c7              B        |L1.32130|
                  |L1.32242|
007df2  481d              LDR      r0,|L1.32360|
007df4  8b40              LDRH     r0,[r0,#0x1a]         ;734
007df6  1c40              ADDS     r0,r0,#1              ;734
007df8  b281              UXTH     r1,r0                 ;734
007dfa  481b              LDR      r0,|L1.32360|
007dfc  8341              STRH     r1,[r0,#0x1a]         ;734
007dfe  4621              MOV      r1,r4                 ;740
007e00  4628              MOV      r0,r5                 ;740
007e02  f7fffffe          BL       autoip_arp_reply
007e06  f8d4000e          LDR      r0,[r4,#0xe]          ;745
007e0a  9001              STR      r0,[sp,#4]            ;745
007e0c  69a0              LDR      r0,[r4,#0x18]         ;746
007e0e  9000              STR      r0,[sp,#0]            ;746
007e10  1d28              ADDS     r0,r5,#4              ;749
007e12  d001              BEQ      |L1.32280|
007e14  6868              LDR      r0,[r5,#4]            ;749
007e16  b910              CBNZ     r0,|L1.32286|
                  |L1.32280|
007e18  f04f0900          MOV      r9,#0                 ;750
007e1c  e007              B        |L1.32302|
                  |L1.32286|
007e1e  9800              LDR      r0,[sp,#0]            ;753
007e20  6869              LDR      r1,[r5,#4]            ;753
007e22  4288              CMP      r0,r1                 ;753
007e24  d101              BNE      |L1.32298|
007e26  2001              MOVS     r0,#1                 ;753
007e28  e000              B        |L1.32300|
                  |L1.32298|
007e2a  2000              MOVS     r0,#0                 ;753
                  |L1.32300|
007e2c  4681              MOV      r9,r0                 ;753
                  |L1.32302|
007e2e  f1b90f00          CMP      r9,#0                 ;761
007e32  d001              BEQ      |L1.32312|
007e34  2001              MOVS     r0,#1                 ;762
007e36  e000              B        |L1.32314|
                  |L1.32312|
007e38  2002              MOVS     r0,#2                 ;762
                  |L1.32314|
007e3a  4603              MOV      r3,r0                 ;762
007e3c  f1040208          ADD      r2,r4,#8              ;762
007e40  a901              ADD      r1,sp,#4              ;762
007e42  4628              MOV      r0,r5                 ;762
007e44  f7fffffe          BL       etharp_update_arp_entry
007e48  88e0              LDRH     r0,[r4,#6]            ;765
007e4a  f5b07f80          CMP      r0,#0x100             ;765
007e4e  d011              BEQ      |L1.32372|
007e50  f5b07f00          CMP      r0,#0x200             ;765
007e54  d15b              BNE      |L1.32526|
007e56  e053              B        |L1.32512|
                  |L1.32344|
                          DCD      0xa9fe0100
                  |L1.32348|
                          DCD      0xa9fe0000
                  |L1.32352|
                          DCD      0xa9fefeff
                  |L1.32356|
                          DCD      arp_table
                  |L1.32360|
                          DCD      lwip_stats
                  |L1.32364|
                          DCD      ethbroadcast
                  |L1.32368|
                          DCD      ethzero
                  |L1.32372|
007e74  bf00              NOP                            ;772
007e76  bf00              NOP                            ;772
007e78  f1b90f00          CMP      r9,#0                 ;774
007e7c  d035              BEQ      |L1.32490|
007e7e  bf00              NOP                            ;776
007e80  bf00              NOP                            ;776
007e82  2002              MOVS     r0,#2                 ;780
007e84  f7fffffe          BL       lwip_htons
007e88  80e0              STRH     r0,[r4,#6]            ;780
007e8a  f8d4000e          LDR      r0,[r4,#0xe]          ;782
007e8e  61a0              STR      r0,[r4,#0x18]         ;782
007e90  6868              LDR      r0,[r5,#4]            ;783
007e92  f8c4000e          STR      r0,[r4,#0xe]          ;783
007e96  bf00              NOP                            ;785
007e98  bf00              NOP                            ;785
007e9a  88a8              LDRH     r0,[r5,#4]            ;791
007e9c  b280              UXTH     r0,r0                 ;791
007e9e  f5a0417e          SUB      r1,r0,#0xfe00         ;791
007ea2  39a9              SUBS     r1,r1,#0xa9           ;791
007ea4  d101              BNE      |L1.32426|
007ea6  48fe              LDR      r0,|L1.33440|
007ea8  e001              B        |L1.32430|
                  |L1.32426|
007eaa  f1040008          ADD      r0,r4,#8              ;791
                  |L1.32430|
007eae  4682              MOV      r10,r0                ;791
007eb0  68a0              LDR      r0,[r4,#8]            ;794
007eb2  f8c40012          STR      r0,[r4,#0x12]         ;794
007eb6  89a0              LDRH     r0,[r4,#0xc]          ;794
007eb8  82e0              STRH     r0,[r4,#0x16]         ;794
007eba  f8da0000          LDR      r0,[r10,#0]           ;796
007ebe  6038              STR      r0,[r7,#0]            ;796
007ec0  f8ba0004          LDRH     r0,[r10,#4]           ;796
007ec4  80b8              STRH     r0,[r7,#4]            ;796
007ec6  f8d80000          LDR      r0,[r8,#0]            ;800
007eca  60a0              STR      r0,[r4,#8]            ;800
007ecc  f8b80004          LDRH     r0,[r8,#4]            ;800
007ed0  81a0              STRH     r0,[r4,#0xc]          ;800
007ed2  f8d80000          LDR      r0,[r8,#0]            ;801
007ed6  f8c70006          STR      r0,[r7,#6]            ;801
007eda  f8b80004          LDRH     r0,[r8,#4]            ;801
007ede  8178              STRH     r0,[r7,#0xa]          ;801
007ee0  4631              MOV      r1,r6                 ;807
007ee2  4628              MOV      r0,r5                 ;807
007ee4  69aa              LDR      r2,[r5,#0x18]         ;807
007ee6  4790              BLX      r2                    ;807
007ee8  e009              B        |L1.32510|
                  |L1.32490|
007eea  1d28              ADDS     r0,r5,#4              ;809
007eec  d001              BEQ      |L1.32498|
007eee  6868              LDR      r0,[r5,#4]            ;809
007ef0  b918              CBNZ     r0,|L1.32506|
                  |L1.32498|
007ef2  bf00              NOP                            ;811
007ef4  bf00              NOP                            ;811
007ef6  bf00              NOP                            ;812
007ef8  e001              B        |L1.32510|
                  |L1.32506|
007efa  bf00              NOP                            ;816
007efc  bf00              NOP                            ;816
                  |L1.32510|
007efe  e00f              B        |L1.32544|
                  |L1.32512|
007f00  bf00              NOP                            ;821
007f02  bf00              NOP                            ;821
007f04  a901              ADD      r1,sp,#4              ;827
007f06  4628              MOV      r0,r5                 ;827
007f08  f7fffffe          BL       dhcp_arp_reply
007f0c  e008              B        |L1.32544|
                  |L1.32526|
007f0e  bf00              NOP                            ;831
007f10  bf00              NOP                            ;831
007f12  48e4              LDR      r0,|L1.33444|
007f14  8d80              LDRH     r0,[r0,#0x2c]         ;832
007f16  1c40              ADDS     r0,r0,#1              ;832
007f18  b281              UXTH     r1,r0                 ;832
007f1a  48e2              LDR      r0,|L1.33444|
007f1c  8581              STRH     r1,[r0,#0x2c]         ;832
007f1e  bf00              NOP                            ;833
                  |L1.32544|
007f20  bf00              NOP                            ;818
007f22  4630              MOV      r0,r6                 ;836
007f24  f7fffffe          BL       pbuf_free
007f28  bf00              NOP      
007f2a  e72a              B        |L1.32130|
;;;838    
                          ENDP

                  ethernet_input PROC
;;;1277   err_t
;;;1278   ethernet_input(struct pbuf *p, struct netif *netif)
007f2c  e92d41f0          PUSH     {r4-r8,lr}
;;;1279   {
007f30  4604              MOV      r4,r0
007f32  460e              MOV      r6,r1
;;;1280     struct eth_hdr* ethhdr;
;;;1281     u16_t type;
;;;1282   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1283     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
007f34  f04f080e          MOV      r8,#0xe
;;;1284   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1285   
;;;1286     if (p->len <= SIZEOF_ETH_HDR) {
007f38  8960              LDRH     r0,[r4,#0xa]
007f3a  280e              CMP      r0,#0xe
007f3c  dc0b              BGT      |L1.32598|
;;;1287       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1288       ETHARP_STATS_INC(etharp.proterr);
007f3e  48d9              LDR      r0,|L1.33444|
007f40  8d00              LDRH     r0,[r0,#0x28]
007f42  1c40              ADDS     r0,r0,#1
007f44  b281              UXTH     r1,r0
007f46  48d7              LDR      r0,|L1.33444|
007f48  8501              STRH     r1,[r0,#0x28]
;;;1289       ETHARP_STATS_INC(etharp.drop);
007f4a  8bc0              LDRH     r0,[r0,#0x1e]
007f4c  1c40              ADDS     r0,r0,#1
007f4e  b281              UXTH     r1,r0
007f50  48d4              LDR      r0,|L1.33444|
007f52  83c1              STRH     r1,[r0,#0x1e]
;;;1290       goto free_and_return;
007f54  e056              B        |L1.32772|
                  |L1.32598|
;;;1291     }
;;;1292   
;;;1293     /* points to packet payload, which starts with an Ethernet header */
;;;1294     ethhdr = (struct eth_hdr *)p->payload;
007f56  6865              LDR      r5,[r4,#4]
;;;1295     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
007f58  bf00              NOP      
007f5a  bf00              NOP      
;;;1296       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1297        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1298        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1299        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1300        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1301        (unsigned)htons(ethhdr->type)));
;;;1302   
;;;1303     type = ethhdr->type;
007f5c  89af              LDRH     r7,[r5,#0xc]
;;;1304   #if ETHARP_SUPPORT_VLAN
;;;1305     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1306       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1307       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1308         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1309         ETHARP_STATS_INC(etharp.proterr);
;;;1310         ETHARP_STATS_INC(etharp.drop);
;;;1311         goto free_and_return;
;;;1312       }
;;;1313   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1314   #ifdef ETHARP_VLAN_CHECK_FN
;;;1315       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1316   #elif defined(ETHARP_VLAN_CHECK)
;;;1317       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1318   #endif
;;;1319         /* silently ignore this packet: not for our VLAN */
;;;1320         pbuf_free(p);
;;;1321         return ERR_OK;
;;;1322       }
;;;1323   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1324       type = vlan->tpid;
;;;1325       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1326     }
;;;1327   #endif /* ETHARP_SUPPORT_VLAN */
;;;1328   
;;;1329   #if LWIP_ARP_FILTER_NETIF
;;;1330     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1331   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1332   
;;;1333     if (ethhdr->dest.addr[0] & 1) {
007f5e  7828              LDRB     r0,[r5,#0]
007f60  f0100f01          TST      r0,#1
007f64  d016              BEQ      |L1.32660|
;;;1334       /* this might be a multicast or broadcast packet */
;;;1335       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
007f66  7828              LDRB     r0,[r5,#0]
007f68  2801              CMP      r0,#1
007f6a  d109              BNE      |L1.32640|
;;;1336         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
007f6c  7868              LDRB     r0,[r5,#1]
007f6e  b988              CBNZ     r0,|L1.32660|
;;;1337             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
007f70  78a8              LDRB     r0,[r5,#2]
007f72  285e              CMP      r0,#0x5e
007f74  d10e              BNE      |L1.32660|
;;;1338           /* mark the pbuf as link-layer multicast */
;;;1339           p->flags |= PBUF_FLAG_LLMCAST;
007f76  7b60              LDRB     r0,[r4,#0xd]
007f78  f0400010          ORR      r0,r0,#0x10
007f7c  7360              STRB     r0,[r4,#0xd]
007f7e  e009              B        |L1.32660|
                  |L1.32640|
;;;1340         }
;;;1341       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
007f80  2206              MOVS     r2,#6
007f82  49c7              LDR      r1,|L1.33440|
007f84  4628              MOV      r0,r5
007f86  f7fffffe          BL       memcmp
007f8a  b918              CBNZ     r0,|L1.32660|
;;;1342         /* mark the pbuf as link-layer broadcast */
;;;1343         p->flags |= PBUF_FLAG_LLBCAST;
007f8c  7b60              LDRB     r0,[r4,#0xd]
007f8e  f0400008          ORR      r0,r0,#8
007f92  7360              STRB     r0,[r4,#0xd]
                  |L1.32660|
;;;1344       }
;;;1345     }
;;;1346   
;;;1347     switch (type) {
007f94  2f08              CMP      r7,#8
007f96  d003              BEQ      |L1.32672|
007f98  f5b76fc1          CMP      r7,#0x608
007f9c  d122              BNE      |L1.32740|
007f9e  e014              B        |L1.32714|
                  |L1.32672|
;;;1348   #if LWIP_ARP
;;;1349       /* IP packet? */
;;;1350       case PP_HTONS(ETHTYPE_IP):
;;;1351         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
007fa0  f8960031          LDRB     r0,[r6,#0x31]
007fa4  f0100f20          TST      r0,#0x20
007fa8  d100              BNE      |L1.32684|
;;;1352           goto free_and_return;
007faa  e02b              B        |L1.32772|
                  |L1.32684|
;;;1353         }
;;;1354   #if ETHARP_TRUST_IP_MAC
;;;1355         /* update ARP table */
;;;1356         etharp_ip_input(netif, p);
;;;1357   #endif /* ETHARP_TRUST_IP_MAC */
;;;1358         /* skip Ethernet header */
;;;1359         if(pbuf_header(p, -ip_hdr_offset)) {
007fac  f1c80000          RSB      r0,r8,#0
007fb0  b201              SXTH     r1,r0
007fb2  4620              MOV      r0,r4
007fb4  f7fffffe          BL       pbuf_header
007fb8  b110              CBZ      r0,|L1.32704|
;;;1360           LWIP_ASSERT("Can't move over header in packet", 0);
007fba  bf00              NOP      
007fbc  bf00              NOP      
;;;1361           goto free_and_return;
007fbe  e021              B        |L1.32772|
                  |L1.32704|
;;;1362         } else {
;;;1363           /* pass to IP layer */
;;;1364           ip_input(p, netif);
007fc0  4631              MOV      r1,r6
007fc2  4620              MOV      r0,r4
007fc4  f7fffffe          BL       ip_input
;;;1365         }
;;;1366         break;
007fc8  e018              B        |L1.32764|
                  |L1.32714|
;;;1367         
;;;1368       case PP_HTONS(ETHTYPE_ARP):
;;;1369         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
007fca  f8960031          LDRB     r0,[r6,#0x31]
007fce  f0100f20          TST      r0,#0x20
007fd2  d100              BNE      |L1.32726|
;;;1370           goto free_and_return;
007fd4  e016              B        |L1.32772|
                  |L1.32726|
;;;1371         }
;;;1372         /* pass p to ARP module */
;;;1373         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
007fd6  4622              MOV      r2,r4
007fd8  f106012b          ADD      r1,r6,#0x2b
007fdc  4630              MOV      r0,r6
007fde  f7fffffe          BL       etharp_arp_input
;;;1374         break;
007fe2  e00b              B        |L1.32764|
                  |L1.32740|
;;;1375   #endif /* LWIP_ARP */
;;;1376   #if PPPOE_SUPPORT
;;;1377       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1378         pppoe_disc_input(netif, p);
;;;1379         break;
;;;1380   
;;;1381       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1382         pppoe_data_input(netif, p);
;;;1383         break;
;;;1384   #endif /* PPPOE_SUPPORT */
;;;1385   
;;;1386       default:
;;;1387         ETHARP_STATS_INC(etharp.proterr);
007fe4  48af              LDR      r0,|L1.33444|
007fe6  8d00              LDRH     r0,[r0,#0x28]
007fe8  1c40              ADDS     r0,r0,#1
007fea  b281              UXTH     r1,r0
007fec  48ad              LDR      r0,|L1.33444|
007fee  8501              STRH     r1,[r0,#0x28]
;;;1388         ETHARP_STATS_INC(etharp.drop);
007ff0  8bc0              LDRH     r0,[r0,#0x1e]
007ff2  1c40              ADDS     r0,r0,#1
007ff4  b281              UXTH     r1,r0
007ff6  48ab              LDR      r0,|L1.33444|
007ff8  83c1              STRH     r1,[r0,#0x1e]
;;;1389         goto free_and_return;
007ffa  e003              B        |L1.32772|
                  |L1.32764|
007ffc  bf00              NOP                            ;1366
;;;1390     }
;;;1391   
;;;1392     /* This means the pbuf is freed or consumed,
;;;1393        so the caller doesn't have to free it again */
;;;1394     return ERR_OK;
007ffe  2000              MOVS     r0,#0
                  |L1.32768|
;;;1395   
;;;1396   free_and_return:
;;;1397     pbuf_free(p);
;;;1398     return ERR_OK;
;;;1399   }
008000  e8bd81f0          POP      {r4-r8,pc}
                  |L1.32772|
008004  4620              MOV      r0,r4                 ;1397
008006  f7fffffe          BL       pbuf_free
00800a  2000              MOVS     r0,#0                 ;1398
00800c  e7f8              B        |L1.32768|
;;;1400   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

                  sys_timeouts_mbox_fetch PROC
;;;422    void
;;;423    sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
00800e  e92d47f0          PUSH     {r4-r10,lr}
;;;424    {
008012  4680              MOV      r8,r0
008014  4689              MOV      r9,r1
;;;425      u32_t time_needed;
;;;426      struct sys_timeo *tmptimeout;
;;;427      sys_timeout_handler handler;
;;;428      void *arg;
;;;429    
;;;430     again:
008016  bf00              NOP      
                  |L1.32792|
;;;431      if (!next_timeout) {
008018  48a3              LDR      r0,|L1.33448|
00801a  6800              LDR      r0,[r0,#0]  ; next_timeout
00801c  b930              CBNZ     r0,|L1.32812|
;;;432        time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
00801e  2200              MOVS     r2,#0
008020  4649              MOV      r1,r9
008022  4640              MOV      r0,r8
008024  f7fffffe          BL       sys_arch_mbox_fetch
008028  4605              MOV      r5,r0
00802a  e030              B        |L1.32910|
                  |L1.32812|
;;;433      } else {
;;;434        if (next_timeout->time > 0) {
00802c  489e              LDR      r0,|L1.33448|
00802e  6800              LDR      r0,[r0,#0]  ; next_timeout
008030  6840              LDR      r0,[r0,#4]
008032  b140              CBZ      r0,|L1.32838|
;;;435          time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
008034  489c              LDR      r0,|L1.33448|
008036  6800              LDR      r0,[r0,#0]  ; next_timeout
008038  4649              MOV      r1,r9
00803a  6842              LDR      r2,[r0,#4]
00803c  4640              MOV      r0,r8
00803e  f7fffffe          BL       sys_arch_mbox_fetch
008042  4605              MOV      r5,r0
008044  e001              B        |L1.32842|
                  |L1.32838|
;;;436        } else {
;;;437          time_needed = SYS_ARCH_TIMEOUT;
008046  f04f35ff          MOV      r5,#0xffffffff
                  |L1.32842|
;;;438        }
;;;439    
;;;440        if (time_needed == SYS_ARCH_TIMEOUT) {
00804a  1c68              ADDS     r0,r5,#1
00804c  d10e              BNE      |L1.32876|
;;;441          /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;442             could be fetched. We should now call the timeout handler and
;;;443             deallocate the memory allocated for the timeout. */
;;;444          tmptimeout = next_timeout;
00804e  4896              LDR      r0,|L1.33448|
008050  6804              LDR      r4,[r0,#0]  ; next_timeout
;;;445          next_timeout = tmptimeout->next;
008052  4995              LDR      r1,|L1.33448|
008054  6820              LDR      r0,[r4,#0]
008056  6008              STR      r0,[r1,#0]  ; next_timeout
;;;446          handler = tmptimeout->h;
008058  68a6              LDR      r6,[r4,#8]
;;;447          arg = tmptimeout->arg;
00805a  68e7              LDR      r7,[r4,#0xc]
;;;448    #if LWIP_DEBUG_TIMERNAMES
;;;449          if (handler != NULL) {
;;;450            LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
;;;451              tmptimeout->handler_name, arg));
;;;452          }
;;;453    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;454          memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
00805c  4621              MOV      r1,r4
00805e  200a              MOVS     r0,#0xa
008060  f7fffffe          BL       memp_free
;;;455          if (handler != NULL) {
008064  b10e              CBZ      r6,|L1.32874|
;;;456            /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;457               timeout handler function. */
;;;458            LOCK_TCPIP_CORE();
;;;459            handler(arg);
008066  4638              MOV      r0,r7
008068  47b0              BLX      r6
                  |L1.32874|
;;;460            UNLOCK_TCPIP_CORE();
;;;461          }
;;;462          LWIP_TCPIP_THREAD_ALIVE();
;;;463    
;;;464          /* We try again to fetch a message from the mbox. */
;;;465          goto again;
00806a  e7d5              B        |L1.32792|
                  |L1.32876|
;;;466        } else {
;;;467          /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;468             occured. The time variable is set to the number of
;;;469             milliseconds we waited for the message. */
;;;470          if (time_needed < next_timeout->time) {
00806c  488e              LDR      r0,|L1.33448|
00806e  6800              LDR      r0,[r0,#0]  ; next_timeout
008070  6840              LDR      r0,[r0,#4]
008072  42a8              CMP      r0,r5
008074  d907              BLS      |L1.32902|
;;;471            next_timeout->time -= time_needed;
008076  488c              LDR      r0,|L1.33448|
008078  6800              LDR      r0,[r0,#0]  ; next_timeout
00807a  6840              LDR      r0,[r0,#4]
00807c  1b40              SUBS     r0,r0,r5
00807e  498a              LDR      r1,|L1.33448|
008080  6809              LDR      r1,[r1,#0]  ; next_timeout
008082  6048              STR      r0,[r1,#4]
008084  e003              B        |L1.32910|
                  |L1.32902|
;;;472          } else {
;;;473            next_timeout->time = 0;
008086  2000              MOVS     r0,#0
008088  4987              LDR      r1,|L1.33448|
00808a  6809              LDR      r1,[r1,#0]  ; next_timeout
00808c  6048              STR      r0,[r1,#4]
                  |L1.32910|
;;;474          }
;;;475        }
;;;476      }
;;;477    }
00808e  e8bd87f0          POP      {r4-r10,pc}
;;;478    
                          ENDP

                  tcpip_thread PROC
;;;74     static void
;;;75     tcpip_thread(void *arg)
008092  b508              PUSH     {r3,lr}
;;;76     {
;;;77       struct tcpip_msg *msg;
;;;78       LWIP_UNUSED_ARG(arg);
;;;79     
;;;80       if (tcpip_init_done != NULL) {
008094  4885              LDR      r0,|L1.33452|
008096  6800              LDR      r0,[r0,#0]  ; tcpip_init_done
008098  b120              CBZ      r0,|L1.32932|
;;;81         tcpip_init_done(tcpip_init_done_arg);
00809a  4885              LDR      r0,|L1.33456|
00809c  6800              LDR      r0,[r0,#0]  ; tcpip_init_done_arg
00809e  4983              LDR      r1,|L1.33452|
0080a0  6809              LDR      r1,[r1,#0]  ; tcpip_init_done
0080a2  4788              BLX      r1
                  |L1.32932|
;;;82       }
;;;83     
;;;84       LOCK_TCPIP_CORE();
;;;85       while (1) {                          /* MAIN Loop */
0080a4  e05f              B        |L1.33126|
                  |L1.32934|
;;;86         UNLOCK_TCPIP_CORE();
;;;87         LWIP_TCPIP_THREAD_ALIVE();
;;;88         /* wait for a message, timeouts are processed while waiting */
;;;89         sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
0080a6  4669              MOV      r1,sp
0080a8  4882              LDR      r0,|L1.33460|
0080aa  f7fffffe          BL       sys_timeouts_mbox_fetch
;;;90         LOCK_TCPIP_CORE();
;;;91         switch (msg->type) {
0080ae  9800              LDR      r0,[sp,#0]
0080b0  7800              LDRB     r0,[r0,#0]
0080b2  2806              CMP      r0,#6
0080b4  d251              BCS      |L1.33114|
0080b6  e8dff000          TBB      [pc,r0]
0080ba  030d              DCB      0x03,0x0d
0080bc  26323e49          DCB      0x26,0x32,0x3e,0x49
;;;92     #if LWIP_NETCONN
;;;93         case TCPIP_MSG_API:
;;;94           LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
0080c0  bf00              NOP      
0080c2  bf00              NOP      
;;;95           msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
0080c4  9a00              LDR      r2,[sp,#0]
0080c6  6892              LDR      r2,[r2,#8]
0080c8  1d10              ADDS     r0,r2,#4
0080ca  9a00              LDR      r2,[sp,#0]
0080cc  6892              LDR      r2,[r2,#8]
0080ce  6811              LDR      r1,[r2,#0]
0080d0  4788              BLX      r1
;;;96           break;
0080d2  e047              B        |L1.33124|
;;;97     #endif /* LWIP_NETCONN */
;;;98     
;;;99     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;100        case TCPIP_MSG_INPKT:
;;;101          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
0080d4  bf00              NOP      
0080d6  bf00              NOP      
;;;102    #if LWIP_ETHERNET
;;;103          if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
0080d8  9800              LDR      r0,[sp,#0]
0080da  68c0              LDR      r0,[r0,#0xc]
0080dc  f8900031          LDRB     r0,[r0,#0x31]
0080e0  f0100f60          TST      r0,#0x60
0080e4  d005              BEQ      |L1.33010|
;;;104            ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
0080e6  9a00              LDR      r2,[sp,#0]
0080e8  e9d20102          LDRD     r0,r1,[r2,#8]
0080ec  f7fffffe          BL       ethernet_input
0080f0  e004              B        |L1.33020|
                  |L1.33010|
;;;105          } else
;;;106    #endif /* LWIP_ETHERNET */
;;;107          {
;;;108            ip_input(msg->msg.inp.p, msg->msg.inp.netif);
0080f2  9a00              LDR      r2,[sp,#0]
0080f4  e9d20102          LDRD     r0,r1,[r2,#8]
0080f8  f7fffffe          BL       ip_input
                  |L1.33020|
;;;109          }
;;;110          memp_free(MEMP_TCPIP_MSG_INPKT, msg);
0080fc  2008              MOVS     r0,#8
0080fe  9900              LDR      r1,[sp,#0]
008100  f7fffffe          BL       memp_free
;;;111          break;
008104  e02e              B        |L1.33124|
;;;112    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;113    
;;;114    #if LWIP_NETIF_API
;;;115        case TCPIP_MSG_NETIFAPI:
;;;116          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: Netif API message %p\n", (void *)msg));
;;;117          msg->msg.netifapimsg->function(&(msg->msg.netifapimsg->msg));
;;;118          break;
;;;119    #endif /* LWIP_NETIF_API */
;;;120    
;;;121    #if LWIP_TCPIP_TIMEOUT
;;;122        case TCPIP_MSG_TIMEOUT:
;;;123          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
008106  bf00              NOP      
008108  bf00              NOP      
;;;124          sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
00810a  9b00              LDR      r3,[sp,#0]
00810c  3308              ADDS     r3,r3,#8
00810e  cb07              LDM      r3!,{r0-r2}
008110  f7fffffe          BL       sys_timeout
;;;125          memp_free(MEMP_TCPIP_MSG_API, msg);
008114  2007              MOVS     r0,#7
008116  9900              LDR      r1,[sp,#0]
008118  f7fffffe          BL       memp_free
;;;126          break;
00811c  e022              B        |L1.33124|
;;;127        case TCPIP_MSG_UNTIMEOUT:
;;;128          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
00811e  bf00              NOP      
008120  bf00              NOP      
;;;129          sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
008122  9a00              LDR      r2,[sp,#0]
008124  e9d20103          LDRD     r0,r1,[r2,#0xc]
008128  f7fffffe          BL       sys_untimeout
;;;130          memp_free(MEMP_TCPIP_MSG_API, msg);
00812c  2007              MOVS     r0,#7
00812e  9900              LDR      r1,[sp,#0]
008130  f7fffffe          BL       memp_free
;;;131          break;
008134  e016              B        |L1.33124|
;;;132    #endif /* LWIP_TCPIP_TIMEOUT */
;;;133    
;;;134        case TCPIP_MSG_CALLBACK:
;;;135          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
008136  bf00              NOP      
008138  bf00              NOP      
;;;136          msg->msg.cb.function(msg->msg.cb.ctx);
00813a  9a00              LDR      r2,[sp,#0]
00813c  e9d21002          LDRD     r1,r0,[r2,#8]
008140  4788              BLX      r1
;;;137          memp_free(MEMP_TCPIP_MSG_API, msg);
008142  2007              MOVS     r0,#7
008144  9900              LDR      r1,[sp,#0]
008146  f7fffffe          BL       memp_free
;;;138          break;
00814a  e00b              B        |L1.33124|
;;;139    
;;;140        case TCPIP_MSG_CALLBACK_STATIC:
;;;141          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
00814c  bf00              NOP      
00814e  bf00              NOP      
;;;142          msg->msg.cb.function(msg->msg.cb.ctx);
008150  9a00              LDR      r2,[sp,#0]
008152  e9d21002          LDRD     r1,r0,[r2,#8]
008156  4788              BLX      r1
;;;143          break;
008158  e004              B        |L1.33124|
                  |L1.33114|
;;;144    
;;;145        default:
;;;146          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
00815a  bf00              NOP      
00815c  bf00              NOP      
;;;147          LWIP_ASSERT("tcpip_thread: invalid message", 0);
00815e  bf00              NOP      
008160  bf00              NOP      
;;;148          break;
008162  bf00              NOP      
                  |L1.33124|
008164  bf00              NOP                            ;96
                  |L1.33126|
008166  e79e              B        |L1.32934|
;;;149        }
;;;150      }
;;;151    }
;;;152    
                          ENDP

                  tcpip_input PROC
;;;161    err_t
;;;162    tcpip_input(struct pbuf *p, struct netif *inp)
008168  b570              PUSH     {r4-r6,lr}
;;;163    {
00816a  4605              MOV      r5,r0
00816c  460e              MOV      r6,r1
;;;164    #if LWIP_TCPIP_CORE_LOCKING_INPUT
;;;165      err_t ret;
;;;166      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_input: PACKET %p/%p\n", (void *)p, (void *)inp));
;;;167      LOCK_TCPIP_CORE();
;;;168    #if LWIP_ETHERNET
;;;169      if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
;;;170        ret = ethernet_input(p, inp);
;;;171      } else
;;;172    #endif /* LWIP_ETHERNET */
;;;173      {
;;;174        ret = ip_input(p, inp);
;;;175      }
;;;176      UNLOCK_TCPIP_CORE();
;;;177      return ret;
;;;178    #else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;179      struct tcpip_msg *msg;
;;;180    
;;;181      if (!sys_mbox_valid(&mbox)) {
00816e  4851              LDR      r0,|L1.33460|
008170  f7fffffe          BL       sys_mbox_valid
008174  b910              CBNZ     r0,|L1.33148|
;;;182        return ERR_VAL;
008176  f06f0005          MVN      r0,#5
                  |L1.33146|
;;;183      }
;;;184      msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
;;;185      if (msg == NULL) {
;;;186        return ERR_MEM;
;;;187      }
;;;188    
;;;189      msg->type = TCPIP_MSG_INPKT;
;;;190      msg->msg.inp.p = p;
;;;191      msg->msg.inp.netif = inp;
;;;192      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;193        memp_free(MEMP_TCPIP_MSG_INPKT, msg);
;;;194        return ERR_MEM;
;;;195      }
;;;196      return ERR_OK;
;;;197    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;198    }
00817a  bd70              POP      {r4-r6,pc}
                  |L1.33148|
00817c  2008              MOVS     r0,#8                 ;184
00817e  f7fffffe          BL       memp_malloc
008182  4604              MOV      r4,r0                 ;184
008184  b914              CBNZ     r4,|L1.33164|
008186  f04f30ff          MOV      r0,#0xffffffff        ;186
00818a  e7f6              B        |L1.33146|
                  |L1.33164|
00818c  2001              MOVS     r0,#1                 ;189
00818e  7020              STRB     r0,[r4,#0]            ;189
008190  60a5              STR      r5,[r4,#8]            ;190
008192  60e6              STR      r6,[r4,#0xc]          ;191
008194  4621              MOV      r1,r4                 ;192
008196  4847              LDR      r0,|L1.33460|
008198  f7fffffe          BL       sys_mbox_trypost
00819c  b130              CBZ      r0,|L1.33196|
00819e  4621              MOV      r1,r4                 ;193
0081a0  2008              MOVS     r0,#8                 ;193
0081a2  f7fffffe          BL       memp_free
0081a6  f04f30ff          MOV      r0,#0xffffffff        ;194
0081aa  e7e6              B        |L1.33146|
                  |L1.33196|
0081ac  2000              MOVS     r0,#0                 ;196
0081ae  e7e4              B        |L1.33146|
;;;199    
                          ENDP

                  tcpip_timeout PROC
;;;247    err_t
;;;248    tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
0081b0  e92d41f0          PUSH     {r4-r8,lr}
;;;249    {
0081b4  4605              MOV      r5,r0
0081b6  460e              MOV      r6,r1
0081b8  4617              MOV      r7,r2
;;;250      struct tcpip_msg *msg;
;;;251    
;;;252      if (sys_mbox_valid(&mbox)) {
0081ba  483e              LDR      r0,|L1.33460|
0081bc  f7fffffe          BL       sys_mbox_valid
0081c0  b198              CBZ      r0,|L1.33258|
;;;253        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
0081c2  2007              MOVS     r0,#7
0081c4  f7fffffe          BL       memp_malloc
0081c8  4604              MOV      r4,r0
;;;254        if (msg == NULL) {
0081ca  b91c              CBNZ     r4,|L1.33236|
;;;255          return ERR_MEM;
0081cc  f04f30ff          MOV      r0,#0xffffffff
                  |L1.33232|
;;;256        }
;;;257    
;;;258        msg->type = TCPIP_MSG_TIMEOUT;
;;;259        msg->msg.tmo.msecs = msecs;
;;;260        msg->msg.tmo.h = h;
;;;261        msg->msg.tmo.arg = arg;
;;;262        sys_mbox_post(&mbox, msg);
;;;263        return ERR_OK;
;;;264      }
;;;265      return ERR_VAL;
;;;266    }
0081d0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.33236|
0081d4  2002              MOVS     r0,#2                 ;258
0081d6  7020              STRB     r0,[r4,#0]            ;258
0081d8  60a5              STR      r5,[r4,#8]            ;259
0081da  60e6              STR      r6,[r4,#0xc]          ;260
0081dc  6127              STR      r7,[r4,#0x10]         ;261
0081de  4621              MOV      r1,r4                 ;262
0081e0  4834              LDR      r0,|L1.33460|
0081e2  f7fffffe          BL       sys_mbox_post
0081e6  2000              MOVS     r0,#0                 ;263
0081e8  e7f2              B        |L1.33232|
                  |L1.33258|
0081ea  f06f0005          MVN      r0,#5                 ;265
0081ee  e7ef              B        |L1.33232|
;;;267    
                          ENDP

                  tcpip_untimeout PROC
;;;276    err_t
;;;277    tcpip_untimeout(sys_timeout_handler h, void *arg)
0081f0  b570              PUSH     {r4-r6,lr}
;;;278    {
0081f2  4605              MOV      r5,r0
0081f4  460e              MOV      r6,r1
;;;279      struct tcpip_msg *msg;
;;;280    
;;;281      if (sys_mbox_valid(&mbox)) {
0081f6  482f              LDR      r0,|L1.33460|
0081f8  f7fffffe          BL       sys_mbox_valid
0081fc  b188              CBZ      r0,|L1.33314|
;;;282        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
0081fe  2007              MOVS     r0,#7
008200  f7fffffe          BL       memp_malloc
008204  4604              MOV      r4,r0
;;;283        if (msg == NULL) {
008206  b914              CBNZ     r4,|L1.33294|
;;;284          return ERR_MEM;
008208  f04f30ff          MOV      r0,#0xffffffff
                  |L1.33292|
;;;285        }
;;;286    
;;;287        msg->type = TCPIP_MSG_UNTIMEOUT;
;;;288        msg->msg.tmo.h = h;
;;;289        msg->msg.tmo.arg = arg;
;;;290        sys_mbox_post(&mbox, msg);
;;;291        return ERR_OK;
;;;292      }
;;;293      return ERR_VAL;
;;;294    }
00820c  bd70              POP      {r4-r6,pc}
                  |L1.33294|
00820e  2003              MOVS     r0,#3                 ;287
008210  7020              STRB     r0,[r4,#0]            ;287
008212  60e5              STR      r5,[r4,#0xc]          ;288
008214  6126              STR      r6,[r4,#0x10]         ;289
008216  4621              MOV      r1,r4                 ;290
008218  4826              LDR      r0,|L1.33460|
00821a  f7fffffe          BL       sys_mbox_post
00821e  2000              MOVS     r0,#0                 ;291
008220  e7f4              B        |L1.33292|
                  |L1.33314|
008222  f06f0005          MVN      r0,#5                 ;293
008226  e7f1              B        |L1.33292|
;;;295    #endif /* LWIP_TCPIP_TIMEOUT */
                          ENDP

                  tcpip_callbackmsg_new PROC
;;;408     */
;;;409    struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
008228  b570              PUSH     {r4-r6,lr}
;;;410    {
00822a  4605              MOV      r5,r0
00822c  460e              MOV      r6,r1
;;;411      struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
00822e  2007              MOVS     r0,#7
008230  f7fffffe          BL       memp_malloc
008234  4604              MOV      r4,r0
;;;412      if (msg == NULL) {
008236  b90c              CBNZ     r4,|L1.33340|
;;;413        return NULL;
008238  2000              MOVS     r0,#0
                  |L1.33338|
;;;414      }
;;;415      msg->type = TCPIP_MSG_CALLBACK_STATIC;
;;;416      msg->msg.cb.function = function;
;;;417      msg->msg.cb.ctx = ctx;
;;;418      return (struct tcpip_callback_msg*)msg;
;;;419    }
00823a  bd70              POP      {r4-r6,pc}
                  |L1.33340|
00823c  2005              MOVS     r0,#5                 ;415
00823e  7020              STRB     r0,[r4,#0]            ;415
008240  60a5              STR      r5,[r4,#8]            ;416
008242  60e6              STR      r6,[r4,#0xc]          ;417
008244  4620              MOV      r0,r4                 ;418
008246  e7f8              B        |L1.33338|
;;;420    
                          ENDP

                  tcpip_callbackmsg_delete PROC
;;;425     */
;;;426    void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
008248  b510              PUSH     {r4,lr}
;;;427    {
00824a  4604              MOV      r4,r0
;;;428      memp_free(MEMP_TCPIP_MSG_API, msg);
00824c  4621              MOV      r1,r4
00824e  2007              MOVS     r0,#7
008250  f7fffffe          BL       memp_free
;;;429    }
008254  bd10              POP      {r4,pc}
;;;430    
                          ENDP

                  tcpip_trycallback PROC
;;;438    err_t
;;;439    tcpip_trycallback(struct tcpip_callback_msg* msg)
008256  b510              PUSH     {r4,lr}
;;;440    {
008258  4604              MOV      r4,r0
;;;441      if (!sys_mbox_valid(&mbox)) {
00825a  4816              LDR      r0,|L1.33460|
00825c  f7fffffe          BL       sys_mbox_valid
008260  b910              CBNZ     r0,|L1.33384|
;;;442        return ERR_VAL;
008262  f06f0005          MVN      r0,#5
                  |L1.33382|
;;;443      }
;;;444      return sys_mbox_trypost(&mbox, msg);
;;;445    }
008266  bd10              POP      {r4,pc}
                  |L1.33384|
008268  4621              MOV      r1,r4                 ;444
00826a  4812              LDR      r0,|L1.33460|
00826c  f7fffffe          BL       sys_mbox_trypost
008270  e7f9              B        |L1.33382|
;;;446    
                          ENDP

                  sys_arch_thread PROC
;;;574    static void
;;;575    sys_arch_thread(void *arg)
008272  b570              PUSH     {r4-r6,lr}
;;;576    {
008274  4604              MOV      r4,r0
;;;577      u32_t i;
;;;578    
;;;579      /* Get this threads index. */
;;;580      i = (u32_t)arg;
008276  4625              MOV      r5,r4
;;;581    
;;;582      /* Call the application's thread routine. */
;;;583      threads[i].thread(threads[i].arg);
008278  eb050285          ADD      r2,r5,r5,LSL #2
00827c  4b0e              LDR      r3,|L1.33464|
00827e  eb030282          ADD      r2,r3,r2,LSL #2
008282  68d0              LDR      r0,[r2,#0xc]
008284  eb050285          ADD      r2,r5,r5,LSL #2
008288  eb030282          ADD      r2,r3,r2,LSL #2
00828c  6891              LDR      r1,[r2,#8]
00828e  4788              BLX      r1
;;;584    
;;;585      /* Free the memory used by this thread's stack. */
;;;586      mem_free(threads[i].stackstart);
008290  eb050185          ADD      r1,r5,r5,LSL #2
008294  4a08              LDR      r2,|L1.33464|
008296  f8520021          LDR      r0,[r2,r1,LSL #2]
00829a  f7fffffe          BL       mem_free
;;;587    
;;;588      /* Clear the stack from the thread structure. */
;;;589      threads[i].stackstart = NULL;
00829e  e00d              B        |L1.33468|
                  |L1.33440|
                          DCD      ethbroadcast
                  |L1.33444|
                          DCD      lwip_stats
                  |L1.33448|
                          DCD      next_timeout
                  |L1.33452|
                          DCD      tcpip_init_done
                  |L1.33456|
                          DCD      tcpip_init_done_arg
                  |L1.33460|
                          DCD      mbox
                  |L1.33464|
                          DCD      threads
                  |L1.33468|
0082bc  2000              MOVS     r0,#0
0082be  eb050185          ADD      r1,r5,r5,LSL #2
0082c2  4afe              LDR      r2,|L1.34492|
0082c4  f8420021          STR      r0,[r2,r1,LSL #2]
;;;590      threads[i].stackend = NULL;
0082c8  eb050185          ADD      r1,r5,r5,LSL #2
0082cc  eb020181          ADD      r1,r2,r1,LSL #2
0082d0  6048              STR      r0,[r1,#4]
;;;591    
;;;592      /* Delete this task. */
;;;593    #if RTOS_FREERTOS
;;;594      vTaskDelete(NULL);
0082d2  f7fffffe          BL       vTaskDelete
;;;595    #endif
;;;596    }
0082d6  bd70              POP      {r4-r6,pc}
;;;597    
                          ENDP

                  sys_thread_new PROC
;;;608    sys_thread_t
;;;609    sys_thread_new(const char *name, lwip_thread_fn thread, void *arg,
0082d8  e92d5fff          PUSH     {r0-r12,lr}
;;;610                   int stacksize, int prio)
;;;611    {
0082dc  4680              MOV      r8,r0
0082de  4689              MOV      r9,r1
0082e0  4692              MOV      r10,r2
0082e2  461e              MOV      r6,r3
0082e4  9f0e              LDR      r7,[sp,#0x38]
;;;612      sys_thread_t created_thread;
;;;613      void *data;
;;;614      u32_t i;
;;;615    
;;;616      /* Find a thread that is not in use. */
;;;617      for(i = 0; i < SYS_THREAD_MAX; i++) {
0082e6  2400              MOVS     r4,#0
0082e8  e007              B        |L1.33530|
                  |L1.33514|
;;;618        if(threads[i].stackstart == NULL) {
0082ea  eb040084          ADD      r0,r4,r4,LSL #2
0082ee  49f3              LDR      r1,|L1.34492|
0082f0  f8510020          LDR      r0,[r1,r0,LSL #2]
0082f4  b900              CBNZ     r0,|L1.33528|
;;;619          break;
0082f6  e002              B        |L1.33534|
                  |L1.33528|
0082f8  1c64              ADDS     r4,r4,#1              ;617
                  |L1.33530|
0082fa  2c07              CMP      r4,#7                 ;617
0082fc  d3f5              BCC      |L1.33514|
                  |L1.33534|
0082fe  bf00              NOP      
;;;620        }
;;;621      }
;;;622      if(i == SYS_THREAD_MAX) {
008300  2c07              CMP      r4,#7
008302  d103              BNE      |L1.33548|
;;;623          return NULL;
008304  2000              MOVS     r0,#0
                  |L1.33542|
;;;624      }
;;;625    
;;;626      /* Allocate memory for the thread's stack. */
;;;627      data = mem_malloc(stacksize);
;;;628      if(!data) {
;;;629        return NULL;
;;;630      }
;;;631    
;;;632      /* Save the details of this thread. */
;;;633      threads[i].stackstart = data;
;;;634      threads[i].stackend = (void *)((char *)data + stacksize);
;;;635      threads[i].thread = thread;
;;;636      threads[i].arg = arg;
;;;637    
;;;638      /* Create a new thread. */
;;;639    #if RTOS_FREERTOS
;;;640      if(xTaskCreate(sys_arch_thread, (signed portCHAR *)name,
;;;641                     stacksize/sizeof(int), (void *)i, tskIDLE_PRIORITY+prio,
;;;642                     &threads[i].taskhandle) != pdTRUE){
;;;643        threads[i].stackstart = NULL;
;;;644        threads[i].stackend = NULL;
;;;645        return NULL;
;;;646      }
;;;647      created_thread = threads[i].taskhandle;
;;;648    #endif /* RTOS_FREERTOS */
;;;649    
;;;650      /* Return this thread. */
;;;651      return created_thread;
;;;652    }
008306  b004              ADD      sp,sp,#0x10
008308  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.33548|
00830c  4630              MOV      r0,r6                 ;627
00830e  f7fffffe          BL       mem_malloc
008312  4605              MOV      r5,r0                 ;627
008314  b90d              CBNZ     r5,|L1.33562|
008316  2000              MOVS     r0,#0                 ;629
008318  e7f5              B        |L1.33542|
                  |L1.33562|
00831a  eb040084          ADD      r0,r4,r4,LSL #2       ;633
00831e  49e7              LDR      r1,|L1.34492|
008320  f8415020          STR      r5,[r1,r0,LSL #2]     ;633
008324  19a8              ADDS     r0,r5,r6              ;634
008326  eb040184          ADD      r1,r4,r4,LSL #2       ;634
00832a  4ae4              LDR      r2,|L1.34492|
00832c  eb020181          ADD      r1,r2,r1,LSL #2       ;634
008330  6048              STR      r0,[r1,#4]            ;634
008332  eb040084          ADD      r0,r4,r4,LSL #2       ;635
008336  4611              MOV      r1,r2                 ;635
008338  eb010080          ADD      r0,r1,r0,LSL #2       ;635
00833c  f8c09008          STR      r9,[r0,#8]            ;635
008340  eb040084          ADD      r0,r4,r4,LSL #2       ;636
008344  eb010080          ADD      r0,r1,r0,LSL #2       ;636
008348  f8c0a00c          STR      r10,[r0,#0xc]         ;636
00834c  2100              MOVS     r1,#0                 ;640
00834e  eb040084          ADD      r0,r4,r4,LSL #2       ;640
008352  4613              MOV      r3,r2                 ;640
008354  eb030080          ADD      r0,r3,r0,LSL #2       ;640
008358  3010              ADDS     r0,r0,#0x10           ;640
00835a  e9cd0101          STRD     r0,r1,[sp,#4]         ;640
00835e  4623              MOV      r3,r4                 ;640
008360  f3c6028f          UBFX     r2,r6,#2,#16          ;640
008364  9700              STR      r7,[sp,#0]            ;640
008366  9103              STR      r1,[sp,#0xc]          ;640
008368  4641              MOV      r1,r8                 ;640
00836a  48d5              LDR      r0,|L1.34496|
00836c  f7fffffe          BL       xTaskGenericCreate
008370  2801              CMP      r0,#1                 ;640
008372  d00b              BEQ      |L1.33676|
008374  2000              MOVS     r0,#0                 ;643
008376  eb040184          ADD      r1,r4,r4,LSL #2       ;643
00837a  4ad0              LDR      r2,|L1.34492|
00837c  f8420021          STR      r0,[r2,r1,LSL #2]     ;643
008380  eb040184          ADD      r1,r4,r4,LSL #2       ;644
008384  eb020181          ADD      r1,r2,r1,LSL #2       ;644
008388  6048              STR      r0,[r1,#4]            ;644
00838a  e7bc              B        |L1.33542|
                  |L1.33676|
00838c  eb040084          ADD      r0,r4,r4,LSL #2       ;647
008390  49ca              LDR      r1,|L1.34492|
008392  eb010080          ADD      r0,r1,r0,LSL #2       ;647
008396  f8d0b010          LDR      r11,[r0,#0x10]        ;647
00839a  4658              MOV      r0,r11                ;651
00839c  e7b3              B        |L1.33542|
;;;653    
                          ENDP

                  igmp_timeout PROC
;;;676    static void
;;;677    igmp_timeout(struct igmp_group *group)
00839e  b510              PUSH     {r4,lr}
;;;678    {
0083a0  4604              MOV      r4,r0
;;;679      /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */
;;;680      if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
0083a2  7b60              LDRB     r0,[r4,#0xd]
0083a4  2801              CMP      r0,#1
0083a6  d111              BNE      |L1.33740|
;;;681        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_timeout: report membership for group with address "));
0083a8  bf00              NOP      
0083aa  bf00              NOP      
;;;682        ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));
0083ac  bf00              NOP      
0083ae  bf00              NOP      
;;;683        LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", group->netif));
0083b0  bf00              NOP      
0083b2  bf00              NOP      
;;;684    
;;;685        IGMP_STATS_INC(igmp.tx_report);
0083b4  48c3              LDR      r0,|L1.34500|
0083b6  f8b0007a          LDRH     r0,[r0,#0x7a]
0083ba  1c40              ADDS     r0,r0,#1
0083bc  b281              UXTH     r1,r0
0083be  48c1              LDR      r0,|L1.34500|
0083c0  f8a0107a          STRH     r1,[r0,#0x7a]
;;;686        igmp_send(group, IGMP_V2_MEMB_REPORT);
0083c4  2116              MOVS     r1,#0x16
0083c6  4620              MOV      r0,r4
0083c8  f7fffffe          BL       igmp_send
                  |L1.33740|
;;;687      }
;;;688    }
0083cc  bd10              POP      {r4,pc}
;;;689    
                          ENDP

                  igmp_tmr PROC
;;;654    void
;;;655    igmp_tmr(void)
0083ce  b510              PUSH     {r4,lr}
;;;656    {
;;;657      struct igmp_group *group = igmp_group_list;
0083d0  48bd              LDR      r0,|L1.34504|
0083d2  6804              LDR      r4,[r0,#0]  ; igmp_group_list
;;;658    
;;;659      while (group != NULL) {
0083d4  e00b              B        |L1.33774|
                  |L1.33750|
;;;660        if (group->timer > 0) {
0083d6  89e0              LDRH     r0,[r4,#0xe]
0083d8  2800              CMP      r0,#0
0083da  dd07              BLE      |L1.33772|
;;;661          group->timer--;
0083dc  89e0              LDRH     r0,[r4,#0xe]
0083de  1e40              SUBS     r0,r0,#1
0083e0  81e0              STRH     r0,[r4,#0xe]
;;;662          if (group->timer == 0) {
0083e2  89e0              LDRH     r0,[r4,#0xe]
0083e4  b910              CBNZ     r0,|L1.33772|
;;;663            igmp_timeout(group);
0083e6  4620              MOV      r0,r4
0083e8  f7fffffe          BL       igmp_timeout
                  |L1.33772|
;;;664          }
;;;665        }
;;;666        group = group->next;
0083ec  6824              LDR      r4,[r4,#0]
                  |L1.33774|
0083ee  2c00              CMP      r4,#0                 ;659
0083f0  d1f1              BNE      |L1.33750|
;;;667      }
;;;668    }
0083f2  bd10              POP      {r4,pc}
;;;669    
                          ENDP

                  igmp_timer PROC
;;;196    static void
;;;197    igmp_timer(void *arg)
0083f4  b510              PUSH     {r4,lr}
;;;198    {
0083f6  4604              MOV      r4,r0
;;;199      LWIP_UNUSED_ARG(arg);
;;;200      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: igmp_tmr()\n"));
0083f8  bf00              NOP      
0083fa  bf00              NOP      
;;;201      igmp_tmr();
0083fc  f7fffffe          BL       igmp_tmr
;;;202      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
008400  2200              MOVS     r2,#0
008402  49b2              LDR      r1,|L1.34508|
008404  2064              MOVS     r0,#0x64
008406  f7fffffe          BL       sys_timeout
;;;203    }
00840a  bd10              POP      {r4,pc}
;;;204    #endif /* LWIP_IGMP */
                          ENDP

                  igmp_report_groups PROC
;;;266    void
;;;267    igmp_report_groups(struct netif *netif)
00840c  b570              PUSH     {r4-r6,lr}
;;;268    {
00840e  4605              MOV      r5,r0
;;;269      struct igmp_group *group = igmp_group_list;
008410  48ad              LDR      r0,|L1.34504|
008412  6804              LDR      r4,[r0,#0]  ; igmp_group_list
;;;270    
;;;271      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", netif));
008414  bf00              NOP      
008416  bf00              NOP      
;;;272    
;;;273      while (group != NULL) {
008418  e007              B        |L1.33834|
                  |L1.33818|
;;;274        if (group->netif == netif) {
00841a  6860              LDR      r0,[r4,#4]
00841c  42a8              CMP      r0,r5
00841e  d103              BNE      |L1.33832|
;;;275          igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
008420  2105              MOVS     r1,#5
008422  4620              MOV      r0,r4
008424  f7fffffe          BL       igmp_delaying_member
                  |L1.33832|
;;;276        }
;;;277        group = group->next;
008428  6824              LDR      r4,[r4,#0]
                  |L1.33834|
00842a  2c00              CMP      r4,#0                 ;273
00842c  d1f5              BNE      |L1.33818|
;;;278      }
;;;279    }
00842e  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

                  etharp_request PROC
;;;1259   err_t
;;;1260   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
008430  b57f              PUSH     {r0-r6,lr}
;;;1261   {
008432  4604              MOV      r4,r0
008434  460d              MOV      r5,r1
;;;1262     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
008436  bf00              NOP      
008438  bf00              NOP      
;;;1263     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
00843a  2101              MOVS     r1,#1
00843c  4aa4              LDR      r2,|L1.34512|
00843e  1d20              ADDS     r0,r4,#4
008440  f104032b          ADD      r3,r4,#0x2b
008444  e88d0025          STM      sp,{r0,r2,r5}
008448  9103              STR      r1,[sp,#0xc]
00844a  4aa2              LDR      r2,|L1.34516|
00844c  4619              MOV      r1,r3
00844e  4620              MOV      r0,r4
008450  f7fffffe          BL       etharp_raw
;;;1264                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1265                       ipaddr, ARP_REQUEST);
;;;1266   }
008454  b004              ADD      sp,sp,#0x10
008456  bd70              POP      {r4-r6,pc}
;;;1267   #endif /* LWIP_ARP */
                          ENDP

                  netif_set_up PROC
;;;452     */ 
;;;453    void netif_set_up(struct netif *netif)
008458  b510              PUSH     {r4,lr}
;;;454    {
00845a  4604              MOV      r4,r0
;;;455      if (!(netif->flags & NETIF_FLAG_UP)) {
00845c  f8940031          LDRB     r0,[r4,#0x31]
008460  f0100f01          TST      r0,#1
008464  d11a              BNE      |L1.33948|
;;;456        netif->flags |= NETIF_FLAG_UP;
008466  f8140f31          LDRB     r0,[r4,#0x31]!
00846a  f0400001          ORR      r0,r0,#1
00846e  7020              STRB     r0,[r4,#0]
;;;457        
;;;458    #if LWIP_SNMP
;;;459        snmp_get_sysuptime(&netif->ts);
;;;460    #endif /* LWIP_SNMP */
;;;461    
;;;462        NETIF_STATUS_CALLBACK(netif);
;;;463    
;;;464        if (netif->flags & NETIF_FLAG_LINK_UP) {
008470  f8140931          LDRB     r0,[r4],#-0x31
008474  f0100f10          TST      r0,#0x10
008478  d010              BEQ      |L1.33948|
;;;465    #if LWIP_ARP
;;;466          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;467          if (netif->flags & (NETIF_FLAG_ETHARP)) {
00847a  f8940031          LDRB     r0,[r4,#0x31]
00847e  f0100f20          TST      r0,#0x20
008482  d003              BEQ      |L1.33932|
;;;468            etharp_gratuitous(netif);
008484  1d21              ADDS     r1,r4,#4
008486  4620              MOV      r0,r4
008488  f7fffffe          BL       etharp_request
                  |L1.33932|
;;;469          }
;;;470    #endif /* LWIP_ARP */
;;;471    
;;;472    #if LWIP_IGMP
;;;473          /* resend IGMP memberships */
;;;474          if (netif->flags & NETIF_FLAG_IGMP) {
00848c  f8940031          LDRB     r0,[r4,#0x31]
008490  f0100f80          TST      r0,#0x80
008494  d002              BEQ      |L1.33948|
;;;475            igmp_report_groups( netif);
008496  4620              MOV      r0,r4
008498  f7fffffe          BL       igmp_report_groups
                  |L1.33948|
;;;476          }
;;;477    #endif /* LWIP_IGMP */
;;;478        }
;;;479      }
;;;480    }
00849c  bd10              POP      {r4,pc}
;;;481    
                          ENDP

                  netif_set_gw PROC
;;;387    void
;;;388    netif_set_gw(struct netif *netif, ip_addr_t *gw)
00849e  b909              CBNZ     r1,|L1.33956|
;;;389    {
;;;390      ip_addr_set(&(netif->gw), gw);
0084a0  2200              MOVS     r2,#0
0084a2  e000              B        |L1.33958|
                  |L1.33956|
0084a4  680a              LDR      r2,[r1,#0]
                  |L1.33958|
0084a6  60c2              STR      r2,[r0,#0xc]
;;;391      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
0084a8  bf00              NOP      
0084aa  bf00              NOP      
;;;392        netif->name[0], netif->name[1],
;;;393        ip4_addr1_16(&netif->gw),
;;;394        ip4_addr2_16(&netif->gw),
;;;395        ip4_addr3_16(&netif->gw),
;;;396        ip4_addr4_16(&netif->gw)));
;;;397    }
0084ac  4770              BX       lr
;;;398    
                          ENDP

                  netif_set_netmask PROC
;;;408    void
;;;409    netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
0084ae  b909              CBNZ     r1,|L1.33972|
;;;410    {
;;;411      snmp_delete_iprteidx_tree(0, netif);
;;;412      /* set new netmask to netif */
;;;413      ip_addr_set(&(netif->netmask), netmask);
0084b0  2200              MOVS     r2,#0
0084b2  e000              B        |L1.33974|
                  |L1.33972|
0084b4  680a              LDR      r2,[r1,#0]
                  |L1.33974|
0084b6  6082              STR      r2,[r0,#8]
;;;414      snmp_insert_iprteidx_tree(0, netif);
;;;415      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
0084b8  bf00              NOP      
0084ba  bf00              NOP      
;;;416        netif->name[0], netif->name[1],
;;;417        ip4_addr1_16(&netif->netmask),
;;;418        ip4_addr2_16(&netif->netmask),
;;;419        ip4_addr3_16(&netif->netmask),
;;;420        ip4_addr4_16(&netif->netmask)));
;;;421    }
0084bc  4770              BX       lr
;;;422    
                          ENDP

                  netif_set_ipaddr PROC
;;;322    void
;;;323    netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
0084be  e92d41f0          PUSH     {r4-r8,lr}
;;;324    {
0084c2  4607              MOV      r7,r0
0084c4  460c              MOV      r4,r1
;;;325      /* TODO: Handling of obsolete pcbs */
;;;326      /* See:  http://mail.gnu.org/archive/html/lwip-users/2003-03/msg00118.html */
;;;327    #if LWIP_TCP
;;;328      struct tcp_pcb *pcb;
;;;329      struct tcp_pcb_listen *lpcb;
;;;330    
;;;331      /* address is actually being changed? */
;;;332      if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
0084c6  2c00              CMP      r4,#0
0084c8  d034              BEQ      |L1.34100|
0084ca  6820              LDR      r0,[r4,#0]
0084cc  6879              LDR      r1,[r7,#4]
0084ce  4288              CMP      r0,r1
0084d0  d101              BNE      |L1.34006|
0084d2  2001              MOVS     r0,#1
0084d4  e000              B        |L1.34008|
                  |L1.34006|
0084d6  2000              MOVS     r0,#0
                  |L1.34008|
0084d8  bb60              CBNZ     r0,|L1.34100|
;;;333        /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
;;;334        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
0084da  bf00              NOP      
0084dc  bf00              NOP      
;;;335        pcb = tcp_active_pcbs;
0084de  487e              LDR      r0,|L1.34520|
0084e0  6805              LDR      r5,[r0,#0]  ; tcp_active_pcbs
;;;336        while (pcb != NULL) {
0084e2  e013              B        |L1.34060|
                  |L1.34020|
;;;337          /* PCB bound to current local interface address? */
;;;338          if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
0084e4  6828              LDR      r0,[r5,#0]
0084e6  6879              LDR      r1,[r7,#4]
0084e8  4288              CMP      r0,r1
0084ea  d10e              BNE      |L1.34058|
;;;339    #if LWIP_AUTOIP
;;;340            /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
;;;341            && !ip_addr_islinklocal(&(pcb->local_ip))
0084ec  8828              LDRH     r0,[r5,#0]
0084ee  b280              UXTH     r0,r0
0084f0  f5a0417e          SUB      r1,r0,#0xfe00
0084f4  39a9              SUBS     r1,r1,#0xa9
0084f6  d008              BEQ      |L1.34058|
;;;342    #endif /* LWIP_AUTOIP */
;;;343            ) {
;;;344            /* this connection must be aborted */
;;;345            struct tcp_pcb *next = pcb->next;
0084f8  f8d5800c          LDR      r8,[r5,#0xc]
;;;346            LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
0084fc  bf00              NOP      
0084fe  bf00              NOP      
;;;347            tcp_abort(pcb);
008500  4628              MOV      r0,r5
008502  f7fffffe          BL       tcp_abort
;;;348            pcb = next;
008506  4645              MOV      r5,r8
;;;349          } else {
008508  e000              B        |L1.34060|
                  |L1.34058|
;;;350            pcb = pcb->next;
00850a  68ed              LDR      r5,[r5,#0xc]
                  |L1.34060|
00850c  2d00              CMP      r5,#0                 ;336
00850e  d1e9              BNE      |L1.34020|
;;;351          }
;;;352        }
;;;353        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
008510  4872              LDR      r0,|L1.34524|
008512  6806              LDR      r6,[r0,#0]  ; tcp_listen_pcbs
008514  e00c              B        |L1.34096|
                  |L1.34070|
;;;354          /* PCB bound to current local interface address? */
;;;355          if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
008516  b156              CBZ      r6,|L1.34094|
008518  6830              LDR      r0,[r6,#0]
00851a  b140              CBZ      r0,|L1.34094|
;;;356              (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
00851c  6830              LDR      r0,[r6,#0]
00851e  6879              LDR      r1,[r7,#4]
008520  4288              CMP      r0,r1
008522  d104              BNE      |L1.34094|
;;;357            /* The PCB is listening to the old ipaddr and
;;;358             * is set to listen to the new one instead */
;;;359            ip_addr_set(&(lpcb->local_ip), ipaddr);
008524  b90c              CBNZ     r4,|L1.34090|
008526  2000              MOVS     r0,#0
008528  e000              B        |L1.34092|
                  |L1.34090|
00852a  6820              LDR      r0,[r4,#0]
                  |L1.34092|
00852c  6030              STR      r0,[r6,#0]
                  |L1.34094|
00852e  68f6              LDR      r6,[r6,#0xc]          ;353
                  |L1.34096|
008530  2e00              CMP      r6,#0                 ;353
008532  d1f0              BNE      |L1.34070|
                  |L1.34100|
;;;360          }
;;;361        }
;;;362      }
;;;363    #endif
;;;364      snmp_delete_ipaddridx_tree(netif);
;;;365      snmp_delete_iprteidx_tree(0,netif);
;;;366      /* set new IP address to netif */
;;;367      ip_addr_set(&(netif->ip_addr), ipaddr);
008534  b90c              CBNZ     r4,|L1.34106|
008536  2000              MOVS     r0,#0
008538  e000              B        |L1.34108|
                  |L1.34106|
00853a  6820              LDR      r0,[r4,#0]
                  |L1.34108|
00853c  6078              STR      r0,[r7,#4]
;;;368      snmp_insert_ipaddridx_tree(netif);
;;;369      snmp_insert_iprteidx_tree(0,netif);
;;;370    
;;;371      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IP address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
00853e  bf00              NOP      
008540  bf00              NOP      
;;;372        netif->name[0], netif->name[1],
;;;373        ip4_addr1_16(&netif->ip_addr),
;;;374        ip4_addr2_16(&netif->ip_addr),
;;;375        ip4_addr3_16(&netif->ip_addr),
;;;376        ip4_addr4_16(&netif->ip_addr)));
;;;377    }
008542  e8bd81f0          POP      {r4-r8,pc}
;;;378    
                          ENDP

                  autoip_bind PROC
;;;254    static err_t
;;;255    autoip_bind(struct netif *netif)
008546  b57c              PUSH     {r2-r6,lr}
;;;256    {
008548  4604              MOV      r4,r0
;;;257      struct autoip *autoip = netif->autoip;
00854a  6a65              LDR      r5,[r4,#0x24]
;;;258      ip_addr_t sn_mask, gw_addr;
;;;259    
;;;260      LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
00854c  bf00              NOP      
00854e  bf00              NOP      
;;;261        ("autoip_bind(netif=%p) %c%c%"U16_F" %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;262        (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num,
;;;263        ip4_addr1_16(&autoip->llipaddr), ip4_addr2_16(&autoip->llipaddr),
;;;264        ip4_addr3_16(&autoip->llipaddr), ip4_addr4_16(&autoip->llipaddr)));
;;;265    
;;;266      IP4_ADDR(&sn_mask, 255, 255, 0, 0);
008550  f64f70ff          MOV      r0,#0xffff
008554  9001              STR      r0,[sp,#4]
;;;267      IP4_ADDR(&gw_addr, 0, 0, 0, 0);
008556  2000              MOVS     r0,#0
008558  9000              STR      r0,[sp,#0]
;;;268    
;;;269      netif_set_ipaddr(netif, &autoip->llipaddr);
00855a  4629              MOV      r1,r5
00855c  4620              MOV      r0,r4
00855e  f7fffffe          BL       netif_set_ipaddr
;;;270      netif_set_netmask(netif, &sn_mask);
008562  a901              ADD      r1,sp,#4
008564  4620              MOV      r0,r4
008566  f7fffffe          BL       netif_set_netmask
;;;271      netif_set_gw(netif, &gw_addr);  
00856a  4669              MOV      r1,sp
00856c  4620              MOV      r0,r4
00856e  f7fffffe          BL       netif_set_gw
;;;272    
;;;273      /* bring the interface up */
;;;274      netif_set_up(netif);
008572  4620              MOV      r0,r4
008574  f7fffffe          BL       netif_set_up
;;;275    
;;;276      return ERR_OK;
008578  2000              MOVS     r0,#0
;;;277    }
00857a  bd7c              POP      {r2-r6,pc}
;;;278    
                          ENDP

                  autoip_arp_probe PROC
;;;228    static err_t
;;;229    autoip_arp_probe(struct netif *netif)
00857c  b51f              PUSH     {r0-r4,lr}
;;;230    {
00857e  4604              MOV      r4,r0
;;;231      return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
008580  2101              MOVS     r1,#1
008582  4a53              LDR      r2,|L1.34512|
008584  4b56              LDR      r3,|L1.34528|
008586  6a60              LDR      r0,[r4,#0x24]
008588  e9cd3200          STRD     r3,r2,[sp,#0]
00858c  e9cd0102          STRD     r0,r1,[sp,#8]
008590  f104032b          ADD      r3,r4,#0x2b
008594  4a4f              LDR      r2,|L1.34516|
008596  4619              MOV      r1,r3
008598  4620              MOV      r0,r4
00859a  f7fffffe          BL       etharp_raw
;;;232        (struct eth_addr *)netif->hwaddr, IP_ADDR_ANY, &ethzero,
;;;233        &netif->autoip->llipaddr, ARP_REQUEST);
;;;234    }
00859e  b004              ADD      sp,sp,#0x10
0085a0  bd10              POP      {r4,pc}
;;;235    
                          ENDP

                  autoip_tmr PROC
;;;391    void
;;;392    autoip_tmr()
0085a2  b510              PUSH     {r4,lr}
;;;393    {
;;;394      struct netif *netif = netif_list;
0085a4  484f              LDR      r0,|L1.34532|
0085a6  6804              LDR      r4,[r0,#0]  ; netif_list
;;;395      /* loop through netif's */
;;;396      while (netif != NULL) {
0085a8  e086              B        |L1.34488|
                  |L1.34218|
;;;397        /* only act on AutoIP configured interfaces */
;;;398        if (netif->autoip != NULL) {
0085aa  6a60              LDR      r0,[r4,#0x24]
0085ac  2800              CMP      r0,#0
0085ae  d07d              BEQ      |L1.34476|
;;;399          if (netif->autoip->lastconflict > 0) {
0085b0  6a60              LDR      r0,[r4,#0x24]
0085b2  7a00              LDRB     r0,[r0,#8]
0085b4  2800              CMP      r0,#0
0085b6  dd04              BLE      |L1.34242|
;;;400            netif->autoip->lastconflict--;
0085b8  6a60              LDR      r0,[r4,#0x24]
0085ba  7a00              LDRB     r0,[r0,#8]
0085bc  1e40              SUBS     r0,r0,#1
0085be  6a61              LDR      r1,[r4,#0x24]
0085c0  7208              STRB     r0,[r1,#8]
                  |L1.34242|
;;;401          }
;;;402    
;;;403          LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
0085c2  bf00              NOP      
0085c4  bf00              NOP      
;;;404            ("autoip_tmr() AutoIP-State: %"U16_F", ttw=%"U16_F"\n",
;;;405            (u16_t)(netif->autoip->state), netif->autoip->ttw));
;;;406    
;;;407          switch(netif->autoip->state) {
0085c6  6a60              LDR      r0,[r4,#0x24]
0085c8  7900              LDRB     r0,[r0,#4]
0085ca  2801              CMP      r0,#1
0085cc  d002              BEQ      |L1.34260|
0085ce  2802              CMP      r0,#2
0085d0  d170              BNE      |L1.34484|
0085d2  e040              B        |L1.34390|
                  |L1.34260|
;;;408            case AUTOIP_STATE_PROBING:
;;;409              if (netif->autoip->ttw > 0) {
0085d4  6a60              LDR      r0,[r4,#0x24]
0085d6  88c0              LDRH     r0,[r0,#6]
0085d8  2800              CMP      r0,#0
0085da  dd05              BLE      |L1.34280|
;;;410                netif->autoip->ttw--;
0085dc  6a60              LDR      r0,[r4,#0x24]
0085de  88c0              LDRH     r0,[r0,#6]
0085e0  1e40              SUBS     r0,r0,#1
0085e2  6a61              LDR      r1,[r4,#0x24]
0085e4  80c8              STRH     r0,[r1,#6]
0085e6  e035              B        |L1.34388|
                  |L1.34280|
;;;411              } else {
;;;412                if (netif->autoip->sent_num >= PROBE_NUM) {
0085e8  6a60              LDR      r0,[r4,#0x24]
0085ea  7940              LDRB     r0,[r0,#5]
0085ec  2803              CMP      r0,#3
0085ee  db0a              BLT      |L1.34310|
;;;413                  netif->autoip->state = AUTOIP_STATE_ANNOUNCING;
0085f0  2002              MOVS     r0,#2
0085f2  6a61              LDR      r1,[r4,#0x24]
0085f4  7108              STRB     r0,[r1,#4]
;;;414                  netif->autoip->sent_num = 0;
0085f6  2000              MOVS     r0,#0
0085f8  6a61              LDR      r1,[r4,#0x24]
0085fa  7148              STRB     r0,[r1,#5]
;;;415                  netif->autoip->ttw = ANNOUNCE_WAIT * AUTOIP_TICKS_PER_SECOND;
0085fc  2014              MOVS     r0,#0x14
0085fe  6a61              LDR      r1,[r4,#0x24]
008600  80c8              STRH     r0,[r1,#6]
;;;416                  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
008602  bf00              NOP      
008604  e026              B        |L1.34388|
                  |L1.34310|
;;;417                     ("autoip_tmr(): changing state to ANNOUNCING: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;418                      ip4_addr1_16(&netif->autoip->llipaddr), ip4_addr2_16(&netif->autoip->llipaddr),
;;;419                      ip4_addr3_16(&netif->autoip->llipaddr), ip4_addr4_16(&netif->autoip->llipaddr)));
;;;420                } else {
;;;421                  autoip_arp_probe(netif);
008606  4620              MOV      r0,r4
008608  f7fffffe          BL       autoip_arp_probe
;;;422                  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
00860c  bf00              NOP      
00860e  bf00              NOP      
;;;423                    ("autoip_tmr() PROBING Sent Probe\n"));
;;;424                  netif->autoip->sent_num++;
008610  6a60              LDR      r0,[r4,#0x24]
008612  7940              LDRB     r0,[r0,#5]
008614  1c40              ADDS     r0,r0,#1
008616  6a61              LDR      r1,[r4,#0x24]
008618  7148              STRB     r0,[r1,#5]
;;;425                  /* calculate time to wait to next probe */
;;;426                  netif->autoip->ttw = (u16_t)((LWIP_AUTOIP_RAND(netif) %
00861a  2030              MOVS     r0,#0x30
00861c  5d00              LDRB     r0,[r0,r4]
00861e  0601              LSLS     r1,r0,#24
008620  202e              MOVS     r0,#0x2e
008622  5d00              LDRB     r0,[r0,r4]
008624  ea414100          ORR      r1,r1,r0,LSL #16
008628  202d              MOVS     r0,#0x2d
00862a  5d00              LDRB     r0,[r0,r4]
00862c  ea412000          ORR      r0,r1,r0,LSL #8
008630  212f              MOVS     r1,#0x2f
008632  5d09              LDRB     r1,[r1,r4]
008634  4308              ORRS     r0,r0,r1
008636  6a61              LDR      r1,[r4,#0x24]
008638  b111              CBZ      r1,|L1.34368|
00863a  6a61              LDR      r1,[r4,#0x24]
00863c  7a49              LDRB     r1,[r1,#9]
00863e  e000              B        |L1.34370|
                  |L1.34368|
008640  2100              MOVS     r1,#0
                  |L1.34370|
008642  4408              ADD      r0,r0,r1
008644  210a              MOVS     r1,#0xa
008646  fbb0f2f1          UDIV     r2,r0,r1
00864a  fb010012          MLS      r0,r1,r2,r0
00864e  300a              ADDS     r0,r0,#0xa
008650  6a61              LDR      r1,[r4,#0x24]
008652  80c8              STRH     r0,[r1,#6]
                  |L1.34388|
;;;427                    ((PROBE_MAX - PROBE_MIN) * AUTOIP_TICKS_PER_SECOND) ) +
;;;428                    PROBE_MIN * AUTOIP_TICKS_PER_SECOND);
;;;429                }
;;;430              }
;;;431              break;
008654  e02e              B        |L1.34484|
                  |L1.34390|
;;;432    
;;;433            case AUTOIP_STATE_ANNOUNCING:
;;;434              if (netif->autoip->ttw > 0) {
008656  6a60              LDR      r0,[r4,#0x24]
008658  88c0              LDRH     r0,[r0,#6]
00865a  2800              CMP      r0,#0
00865c  dd05              BLE      |L1.34410|
;;;435                netif->autoip->ttw--;
00865e  6a60              LDR      r0,[r4,#0x24]
008660  88c0              LDRH     r0,[r0,#6]
008662  1e40              SUBS     r0,r0,#1
008664  6a61              LDR      r1,[r4,#0x24]
008666  80c8              STRH     r0,[r1,#6]
008668  e023              B        |L1.34482|
                  |L1.34410|
;;;436              } else {
;;;437                if (netif->autoip->sent_num == 0) {
00866a  6a60              LDR      r0,[r4,#0x24]
00866c  7940              LDRB     r0,[r0,#5]
00866e  b918              CBNZ     r0,|L1.34424|
;;;438                 /* We are here the first time, so we waited ANNOUNCE_WAIT seconds
;;;439                  * Now we can bind to an IP address and use it.
;;;440                  *
;;;441                  * autoip_bind calls netif_set_up. This triggers a gratuitous ARP
;;;442                  * which counts as an announcement.
;;;443                  */
;;;444                  autoip_bind(netif);
008670  4620              MOV      r0,r4
008672  f7fffffe          BL       autoip_bind
008676  e004              B        |L1.34434|
                  |L1.34424|
;;;445                } else {
;;;446                  autoip_arp_announce(netif);
008678  4620              MOV      r0,r4
00867a  f7fffffe          BL       autoip_arp_announce
;;;447                  LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE,
00867e  bf00              NOP      
008680  bf00              NOP      
                  |L1.34434|
;;;448                    ("autoip_tmr() ANNOUNCING Sent Announce\n"));
;;;449                }
;;;450                netif->autoip->ttw = ANNOUNCE_INTERVAL * AUTOIP_TICKS_PER_SECOND;
008682  2014              MOVS     r0,#0x14
008684  6a61              LDR      r1,[r4,#0x24]
008686  80c8              STRH     r0,[r1,#6]
;;;451                netif->autoip->sent_num++;
008688  6a60              LDR      r0,[r4,#0x24]
00868a  7940              LDRB     r0,[r0,#5]
00868c  1c40              ADDS     r0,r0,#1
00868e  6a61              LDR      r1,[r4,#0x24]
008690  7148              STRB     r0,[r1,#5]
;;;452    
;;;453                if (netif->autoip->sent_num >= ANNOUNCE_NUM) {
008692  6a60              LDR      r0,[r4,#0x24]
008694  7940              LDRB     r0,[r0,#5]
008696  2802              CMP      r0,#2
008698  db0b              BLT      |L1.34482|
;;;454                    netif->autoip->state = AUTOIP_STATE_BOUND;
00869a  2003              MOVS     r0,#3
00869c  6a61              LDR      r1,[r4,#0x24]
00869e  7108              STRB     r0,[r1,#4]
;;;455                    netif->autoip->sent_num = 0;
0086a0  2000              MOVS     r0,#0
0086a2  6a61              LDR      r1,[r4,#0x24]
0086a4  7148              STRB     r0,[r1,#5]
;;;456                    netif->autoip->ttw = 0;
0086a6  6a61              LDR      r1,[r4,#0x24]
0086a8  80c8              STRH     r0,[r1,#6]
;;;457                     LWIP_DEBUGF(AUTOIP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
0086aa  e000              B        |L1.34478|
                  |L1.34476|
0086ac  e003              B        |L1.34486|
                  |L1.34478|
0086ae  bf00              NOP      
0086b0  bf00              NOP      
                  |L1.34482|
;;;458                        ("autoip_tmr(): changing state to BOUND: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;459                         ip4_addr1_16(&netif->autoip->llipaddr), ip4_addr2_16(&netif->autoip->llipaddr),
;;;460                         ip4_addr3_16(&netif->autoip->llipaddr), ip4_addr4_16(&netif->autoip->llipaddr)));
;;;461                }
;;;462              }
;;;463              break;
0086b2  bf00              NOP      
                  |L1.34484|
0086b4  bf00              NOP                            ;431
                  |L1.34486|
;;;464          }
;;;465        }
;;;466        /* proceed to next network interface */
;;;467        netif = netif->next;
0086b6  6824              LDR      r4,[r4,#0]
                  |L1.34488|
0086b8  2c00              CMP      r4,#0                 ;396
0086ba  e015              B        |L1.34536|
                  |L1.34492|
                          DCD      threads
                  |L1.34496|
                          DCD      sys_arch_thread
                  |L1.34500|
                          DCD      lwip_stats
                  |L1.34504|
                          DCD      igmp_group_list
                  |L1.34508|
                          DCD      igmp_timer
                  |L1.34512|
                          DCD      ethzero
                  |L1.34516|
                          DCD      ethbroadcast
                  |L1.34520|
                          DCD      tcp_active_pcbs
                  |L1.34524|
                          DCD      tcp_listen_pcbs
                  |L1.34528|
                          DCD      ip_addr_any
                  |L1.34532|
                          DCD      netif_list
                  |L1.34536|
0086e8  f47faf5f          BNE      |L1.34218|
;;;468      }
;;;469    }
0086ec  bd10              POP      {r4,pc}
;;;470    
                          ENDP

                  autoip_timer PROC
;;;180    static void
;;;181    autoip_timer(void *arg)
0086ee  b510              PUSH     {r4,lr}
;;;182    {
0086f0  4604              MOV      r4,r0
;;;183      LWIP_UNUSED_ARG(arg);
;;;184      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: autoip_tmr()\n"));
0086f2  bf00              NOP      
0086f4  bf00              NOP      
;;;185      autoip_tmr();
0086f6  f7fffffe          BL       autoip_tmr
;;;186      sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
0086fa  2200              MOVS     r2,#0
0086fc  49fe              LDR      r1,|L1.35576|
0086fe  2064              MOVS     r0,#0x64
008700  f7fffffe          BL       sys_timeout
;;;187    }
008704  bd10              POP      {r4,pc}
;;;188    #endif /* LWIP_AUTOIP */
                          ENDP

                  dhcp_option_short PROC
;;;1285   static void
;;;1286   dhcp_option_short(struct dhcp *dhcp, u16_t value)
008706  b510              PUSH     {r4,lr}
;;;1287   {
;;;1288     LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
008708  bf00              NOP      
00870a  bf00              NOP      
;;;1289     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
00870c  0a0b              LSRS     r3,r1,#8
00870e  8b04              LDRH     r4,[r0,#0x18]
008710  1c62              ADDS     r2,r4,#1
008712  8302              STRH     r2,[r0,#0x18]
008714  6942              LDR      r2,[r0,#0x14]
008716  32f0              ADDS     r2,r2,#0xf0
008718  5513              STRB     r3,[r2,r4]
;;;1290     dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
00871a  8b04              LDRH     r4,[r0,#0x18]
00871c  1c62              ADDS     r2,r4,#1
00871e  8302              STRH     r2,[r0,#0x18]
008720  6942              LDR      r2,[r0,#0x14]
008722  32f0              ADDS     r2,r2,#0xf0
008724  5511              STRB     r1,[r2,r4]
;;;1291   }
008726  bd10              POP      {r4,pc}
;;;1292   
                          ENDP

                  dhcp_discover PROC
;;;871    static err_t
;;;872    dhcp_discover(struct netif *netif)
008728  b5f8              PUSH     {r3-r7,lr}
;;;873    {
00872a  4605              MOV      r5,r0
;;;874      struct dhcp *dhcp = netif->dhcp;
00872c  6a2c              LDR      r4,[r5,#0x20]
;;;875      err_t result = ERR_OK;
00872e  2600              MOVS     r6,#0
;;;876      u16_t msecs;
;;;877      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
008730  bf00              NOP      
008732  bf00              NOP      
;;;878      ip_addr_set_any(&dhcp->offered_ip_addr);
008734  2000              MOVS     r0,#0
008736  6260              STR      r0,[r4,#0x24]
;;;879      dhcp_set_state(dhcp, DHCP_SELECTING);
008738  2106              MOVS     r1,#6
00873a  4620              MOV      r0,r4
00873c  f7fffffe          BL       dhcp_set_state
;;;880      /* create and initialize the DHCP message header */
;;;881      result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
008740  2201              MOVS     r2,#1
008742  4621              MOV      r1,r4
008744  4628              MOV      r0,r5
008746  f7fffffe          BL       dhcp_create_msg
00874a  4606              MOV      r6,r0
;;;882      if (result == ERR_OK) {
00874c  2e00              CMP      r6,#0
00874e  d13a              BNE      |L1.34758|
;;;883        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
008750  bf00              NOP      
008752  bf00              NOP      
;;;884    
;;;885        dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
008754  2202              MOVS     r2,#2
008756  2139              MOVS     r1,#0x39
008758  4620              MOV      r0,r4
00875a  f7fffffe          BL       dhcp_option
;;;886        dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
00875e  8d29              LDRH     r1,[r5,#0x28]
008760  4620              MOV      r0,r4
008762  f7fffffe          BL       dhcp_option_short
;;;887    
;;;888        dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
008766  2204              MOVS     r2,#4
008768  2137              MOVS     r1,#0x37
00876a  4620              MOV      r0,r4
00876c  f7fffffe          BL       dhcp_option
;;;889        dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
008770  2101              MOVS     r1,#1
008772  4620              MOV      r0,r4
008774  f7fffffe          BL       dhcp_option_byte
;;;890        dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
008778  2103              MOVS     r1,#3
00877a  4620              MOV      r0,r4
00877c  f7fffffe          BL       dhcp_option_byte
;;;891        dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
008780  211c              MOVS     r1,#0x1c
008782  4620              MOV      r0,r4
008784  f7fffffe          BL       dhcp_option_byte
;;;892        dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
008788  2106              MOVS     r1,#6
00878a  4620              MOV      r0,r4
00878c  f7fffffe          BL       dhcp_option_byte
;;;893    
;;;894        dhcp_option_trailer(dhcp);
008790  4620              MOV      r0,r4
008792  f7fffffe          BL       dhcp_option_trailer
;;;895    
;;;896        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
008796  bf00              NOP      
008798  bf00              NOP      
;;;897        pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
00879a  8b22              LDRH     r2,[r4,#0x18]
00879c  32f0              ADDS     r2,r2,#0xf0
00879e  b291              UXTH     r1,r2
0087a0  6920              LDR      r0,[r4,#0x10]
0087a2  f7fffffe          BL       pbuf_realloc
;;;898    
;;;899        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
0087a6  bf00              NOP      
0087a8  bf00              NOP      
;;;900        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
0087aa  9500              STR      r5,[sp,#0]
0087ac  2343              MOVS     r3,#0x43
0087ae  4ad3              LDR      r2,|L1.35580|
0087b0  6921              LDR      r1,[r4,#0x10]
0087b2  6860              LDR      r0,[r4,#4]
0087b4  f7fffffe          BL       udp_sendto_if
;;;901        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
0087b8  bf00              NOP      
0087ba  bf00              NOP      
;;;902        dhcp_delete_msg(dhcp);
0087bc  4620              MOV      r0,r4
0087be  f7fffffe          BL       dhcp_delete_msg
;;;903        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
0087c2  bf00              NOP      
0087c4  e001              B        |L1.34762|
                  |L1.34758|
;;;904      } else {
;;;905        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
0087c6  bf00              NOP      
0087c8  bf00              NOP      
                  |L1.34762|
;;;906      }
;;;907      dhcp->tries++;
0087ca  7b60              LDRB     r0,[r4,#0xd]
0087cc  1c40              ADDS     r0,r0,#1
0087ce  7360              STRB     r0,[r4,#0xd]
;;;908    #if LWIP_DHCP_AUTOIP_COOP
;;;909      if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
0087d0  7b60              LDRB     r0,[r4,#0xd]
0087d2  2805              CMP      r0,#5
0087d4  db06              BLT      |L1.34788|
0087d6  7ba0              LDRB     r0,[r4,#0xe]
0087d8  b920              CBNZ     r0,|L1.34788|
;;;910        dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
0087da  2001              MOVS     r0,#1
0087dc  73a0              STRB     r0,[r4,#0xe]
;;;911        autoip_start(netif);
0087de  4628              MOV      r0,r5
0087e0  f7fffffe          BL       autoip_start
                  |L1.34788|
;;;912      }
;;;913    #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;914      msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
0087e4  7b60              LDRB     r0,[r4,#0xd]
0087e6  2806              CMP      r0,#6
0087e8  da03              BGE      |L1.34802|
0087ea  7b61              LDRB     r1,[r4,#0xd]
0087ec  2001              MOVS     r0,#1
0087ee  4088              LSLS     r0,r0,r1
0087f0  e000              B        |L1.34804|
                  |L1.34802|
0087f2  203c              MOVS     r0,#0x3c
                  |L1.34804|
0087f4  eb000140          ADD      r1,r0,r0,LSL #1
0087f8  ebc110c0          RSB      r0,r1,r0,LSL #7
0087fc  f64f71ff          MOV      r1,#0xffff
008800  ea0107c0          AND      r7,r1,r0,LSL #3
;;;915      dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
008804  f20710f3          ADD      r0,r7,#0x1f3
008808  f44f71fa          MOV      r1,#0x1f4
00880c  fb90f0f1          SDIV     r0,r0,r1
008810  8360              STRH     r0,[r4,#0x1a]
;;;916      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
008812  bf00              NOP      
008814  bf00              NOP      
;;;917      return result;
008816  4630              MOV      r0,r6
;;;918    }
008818  bdf8              POP      {r3-r7,pc}
;;;919    
                          ENDP

                  dhcp_reboot PROC
;;;1125   static err_t
;;;1126   dhcp_reboot(struct netif *netif)
00881a  e92d43f8          PUSH     {r3-r9,lr}
;;;1127   {
00881e  4605              MOV      r5,r0
;;;1128     struct dhcp *dhcp = netif->dhcp;
008820  6a2c              LDR      r4,[r5,#0x20]
;;;1129     err_t result;
;;;1130     u16_t msecs;
;;;1131     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
008822  bf00              NOP      
008824  bf00              NOP      
;;;1132     dhcp_set_state(dhcp, DHCP_REBOOTING);
008826  2103              MOVS     r1,#3
008828  4620              MOV      r0,r4
00882a  f7fffffe          BL       dhcp_set_state
;;;1133   
;;;1134     /* create and initialize the DHCP message header */
;;;1135     result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
00882e  2203              MOVS     r2,#3
008830  4621              MOV      r1,r4
008832  4628              MOV      r0,r5
008834  f7fffffe          BL       dhcp_create_msg
008838  4606              MOV      r6,r0
;;;1136     if (result == ERR_OK) {
00883a  bb5e              CBNZ     r6,|L1.34964|
;;;1137       dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
00883c  2202              MOVS     r2,#2
00883e  2139              MOVS     r1,#0x39
008840  4620              MOV      r0,r4
008842  f7fffffe          BL       dhcp_option
;;;1138       dhcp_option_short(dhcp, 576);
008846  f44f7110          MOV      r1,#0x240
00884a  4620              MOV      r0,r4
00884c  f7fffffe          BL       dhcp_option_short
;;;1139   
;;;1140       dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
008850  2204              MOVS     r2,#4
008852  2132              MOVS     r1,#0x32
008854  4620              MOV      r0,r4
008856  f7fffffe          BL       dhcp_option
;;;1141       dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
00885a  6a60              LDR      r0,[r4,#0x24]
00885c  f7fffffe          BL       lwip_ntohl
008860  4680              MOV      r8,r0
008862  4641              MOV      r1,r8
008864  4620              MOV      r0,r4
008866  f7fffffe          BL       dhcp_option_long
;;;1142   
;;;1143       dhcp_option_trailer(dhcp);
00886a  4620              MOV      r0,r4
00886c  f7fffffe          BL       dhcp_option_trailer
;;;1144   
;;;1145       pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
008870  8b22              LDRH     r2,[r4,#0x18]
008872  32f0              ADDS     r2,r2,#0xf0
008874  b291              UXTH     r1,r2
008876  6920              LDR      r0,[r4,#0x10]
008878  f7fffffe          BL       pbuf_realloc
;;;1146   
;;;1147       /* broadcast to server */
;;;1148       udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
00887c  9500              STR      r5,[sp,#0]
00887e  2343              MOVS     r3,#0x43
008880  4a9e              LDR      r2,|L1.35580|
008882  6921              LDR      r1,[r4,#0x10]
008884  6860              LDR      r0,[r4,#4]
008886  f7fffffe          BL       udp_sendto_if
;;;1149       dhcp_delete_msg(dhcp);
00888a  4620              MOV      r0,r4
00888c  f7fffffe          BL       dhcp_delete_msg
;;;1150       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
008890  bf00              NOP      
008892  e001              B        |L1.34968|
                  |L1.34964|
;;;1151     } else {
;;;1152       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
008894  bf00              NOP      
008896  bf00              NOP      
                  |L1.34968|
;;;1153     }
;;;1154     dhcp->tries++;
008898  7b60              LDRB     r0,[r4,#0xd]
00889a  1c40              ADDS     r0,r0,#1
00889c  7360              STRB     r0,[r4,#0xd]
;;;1155     msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
00889e  7b60              LDRB     r0,[r4,#0xd]
0088a0  280a              CMP      r0,#0xa
0088a2  da05              BGE      |L1.34992|
0088a4  7b60              LDRB     r0,[r4,#0xd]
0088a6  f44f717a          MOV      r1,#0x3e8
0088aa  fb10f001          SMULBB   r0,r0,r1
0088ae  e001              B        |L1.34996|
                  |L1.34992|
0088b0  f2427010          MOV      r0,#0x2710
                  |L1.34996|
0088b4  b287              UXTH     r7,r0
;;;1156     dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
0088b6  f20710f3          ADD      r0,r7,#0x1f3
0088ba  f44f71fa          MOV      r1,#0x1f4
0088be  fb90f0f1          SDIV     r0,r0,r1
0088c2  8360              STRH     r0,[r4,#0x1a]
;;;1157     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
0088c4  bf00              NOP      
0088c6  bf00              NOP      
;;;1158     return result;
0088c8  4630              MOV      r0,r6
;;;1159   }
0088ca  e8bd83f8          POP      {r3-r9,pc}
;;;1160   
                          ENDP

                  dhcp_release PROC
;;;1167   err_t
;;;1168   dhcp_release(struct netif *netif)
0088ce  b5f8              PUSH     {r3-r7,lr}
;;;1169   {
0088d0  4605              MOV      r5,r0
;;;1170     struct dhcp *dhcp = netif->dhcp;
0088d2  6a2c              LDR      r4,[r5,#0x20]
;;;1171     err_t result;
;;;1172     u16_t msecs;
;;;1173     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));
0088d4  bf00              NOP      
0088d6  bf00              NOP      
;;;1174   
;;;1175     /* idle DHCP client */
;;;1176     dhcp_set_state(dhcp, DHCP_OFF);
0088d8  2100              MOVS     r1,#0
0088da  4620              MOV      r0,r4
0088dc  f7fffffe          BL       dhcp_set_state
;;;1177     /* clean old DHCP offer */
;;;1178     ip_addr_set_zero(&dhcp->server_ip_addr);
0088e0  2000              MOVS     r0,#0
0088e2  6220              STR      r0,[r4,#0x20]
;;;1179     ip_addr_set_zero(&dhcp->offered_ip_addr);
0088e4  6260              STR      r0,[r4,#0x24]
;;;1180     ip_addr_set_zero(&dhcp->offered_sn_mask);
0088e6  62a0              STR      r0,[r4,#0x28]
;;;1181     ip_addr_set_zero(&dhcp->offered_gw_addr);
0088e8  62e0              STR      r0,[r4,#0x2c]
;;;1182   #if LWIP_DHCP_BOOTP_FILE
;;;1183     ip_addr_set_zero(&dhcp->offered_si_addr);
;;;1184   #endif /* LWIP_DHCP_BOOTP_FILE */
;;;1185     dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
0088ea  63a0              STR      r0,[r4,#0x38]
0088ec  6360              STR      r0,[r4,#0x34]
0088ee  6320              STR      r0,[r4,#0x30]
;;;1186     
;;;1187     /* create and initialize the DHCP message header */
;;;1188     result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
0088f0  2207              MOVS     r2,#7
0088f2  4621              MOV      r1,r4
0088f4  4628              MOV      r0,r5
0088f6  f7fffffe          BL       dhcp_create_msg
0088fa  4606              MOV      r6,r0
;;;1189     if (result == ERR_OK) {
0088fc  b9ae              CBNZ     r6,|L1.35114|
;;;1190       dhcp_option_trailer(dhcp);
0088fe  4620              MOV      r0,r4
008900  f7fffffe          BL       dhcp_option_trailer
;;;1191   
;;;1192       pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
008904  8b22              LDRH     r2,[r4,#0x18]
008906  32f0              ADDS     r2,r2,#0xf0
008908  b291              UXTH     r1,r2
00890a  6920              LDR      r0,[r4,#0x10]
00890c  f7fffffe          BL       pbuf_realloc
;;;1193   
;;;1194       udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
008910  9500              STR      r5,[sp,#0]
008912  2343              MOVS     r3,#0x43
008914  f1040220          ADD      r2,r4,#0x20
008918  6921              LDR      r1,[r4,#0x10]
00891a  6860              LDR      r0,[r4,#4]
00891c  f7fffffe          BL       udp_sendto_if
;;;1195       dhcp_delete_msg(dhcp);
008920  4620              MOV      r0,r4
008922  f7fffffe          BL       dhcp_delete_msg
;;;1196       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
008926  bf00              NOP      
008928  e001              B        |L1.35118|
                  |L1.35114|
;;;1197     } else {
;;;1198       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
00892a  bf00              NOP      
00892c  bf00              NOP      
                  |L1.35118|
;;;1199     }
;;;1200     dhcp->tries++;
00892e  7b60              LDRB     r0,[r4,#0xd]
008930  1c40              ADDS     r0,r0,#1
008932  7360              STRB     r0,[r4,#0xd]
;;;1201     msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
008934  7b60              LDRB     r0,[r4,#0xd]
008936  280a              CMP      r0,#0xa
008938  da05              BGE      |L1.35142|
00893a  7b60              LDRB     r0,[r4,#0xd]
00893c  f44f717a          MOV      r1,#0x3e8
008940  fb10f001          SMULBB   r0,r0,r1
008944  e001              B        |L1.35146|
                  |L1.35142|
008946  f2427010          MOV      r0,#0x2710
                  |L1.35146|
00894a  b287              UXTH     r7,r0
;;;1202     dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
00894c  f20710f3          ADD      r0,r7,#0x1f3
008950  f44f71fa          MOV      r1,#0x1f4
008954  fb90f0f1          SDIV     r0,r0,r1
008958  8360              STRH     r0,[r4,#0x1a]
;;;1203     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
00895a  bf00              NOP      
00895c  bf00              NOP      
;;;1204     /* bring the interface down */
;;;1205     netif_set_down(netif);
00895e  4628              MOV      r0,r5
008960  f7fffffe          BL       netif_set_down
;;;1206     /* remove IP address from interface */
;;;1207     netif_set_ipaddr(netif, IP_ADDR_ANY);
008964  4966              LDR      r1,|L1.35584|
008966  4628              MOV      r0,r5
008968  f7fffffe          BL       netif_set_ipaddr
;;;1208     netif_set_gw(netif, IP_ADDR_ANY);
00896c  4964              LDR      r1,|L1.35584|
00896e  4628              MOV      r0,r5
008970  f7fffffe          BL       netif_set_gw
;;;1209     netif_set_netmask(netif, IP_ADDR_ANY);
008974  4962              LDR      r1,|L1.35584|
008976  4628              MOV      r0,r5
008978  f7fffffe          BL       netif_set_netmask
;;;1210     
;;;1211     return result;
00897c  4630              MOV      r0,r6
;;;1212   }
00897e  bdf8              POP      {r3-r7,pc}
;;;1213   
                          ENDP

                  dhcp_rebind PROC
;;;1075   static err_t
;;;1076   dhcp_rebind(struct netif *netif)
008980  b5f8              PUSH     {r3-r7,lr}
;;;1077   {
008982  4605              MOV      r5,r0
;;;1078     struct dhcp *dhcp = netif->dhcp;
008984  6a2c              LDR      r4,[r5,#0x20]
;;;1079     err_t result;
;;;1080     u16_t msecs;
;;;1081     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
008986  bf00              NOP      
008988  bf00              NOP      
;;;1082     dhcp_set_state(dhcp, DHCP_REBINDING);
00898a  2104              MOVS     r1,#4
00898c  4620              MOV      r0,r4
00898e  f7fffffe          BL       dhcp_set_state
;;;1083   
;;;1084     /* create and initialize the DHCP message header */
;;;1085     result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
008992  2203              MOVS     r2,#3
008994  4621              MOV      r1,r4
008996  4628              MOV      r0,r5
008998  f7fffffe          BL       dhcp_create_msg
00899c  4606              MOV      r6,r0
;;;1086     if (result == ERR_OK) {
00899e  b9ee              CBNZ     r6,|L1.35292|
;;;1087       dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
0089a0  2202              MOVS     r2,#2
0089a2  2139              MOVS     r1,#0x39
0089a4  4620              MOV      r0,r4
0089a6  f7fffffe          BL       dhcp_option
;;;1088       dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
0089aa  8d29              LDRH     r1,[r5,#0x28]
0089ac  4620              MOV      r0,r4
0089ae  f7fffffe          BL       dhcp_option_short
;;;1089   
;;;1090   #if LWIP_NETIF_HOSTNAME
;;;1091       dhcp_option_hostname(dhcp, netif);
;;;1092   #endif /* LWIP_NETIF_HOSTNAME */
;;;1093   
;;;1094   #if 0
;;;1095       dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
;;;1096       dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
;;;1097   
;;;1098       dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
;;;1099       dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
;;;1100   #endif
;;;1101   
;;;1102       dhcp_option_trailer(dhcp);
0089b2  4620              MOV      r0,r4
0089b4  f7fffffe          BL       dhcp_option_trailer
;;;1103   
;;;1104       pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
0089b8  8b22              LDRH     r2,[r4,#0x18]
0089ba  32f0              ADDS     r2,r2,#0xf0
0089bc  b291              UXTH     r1,r2
0089be  6920              LDR      r0,[r4,#0x10]
0089c0  f7fffffe          BL       pbuf_realloc
;;;1105   
;;;1106       /* broadcast to server */
;;;1107       udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
0089c4  9500              STR      r5,[sp,#0]
0089c6  2343              MOVS     r3,#0x43
0089c8  4a4c              LDR      r2,|L1.35580|
0089ca  6921              LDR      r1,[r4,#0x10]
0089cc  6860              LDR      r0,[r4,#4]
0089ce  f7fffffe          BL       udp_sendto_if
;;;1108       dhcp_delete_msg(dhcp);
0089d2  4620              MOV      r0,r4
0089d4  f7fffffe          BL       dhcp_delete_msg
;;;1109       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
0089d8  bf00              NOP      
0089da  e001              B        |L1.35296|
                  |L1.35292|
;;;1110     } else {
;;;1111       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
0089dc  bf00              NOP      
0089de  bf00              NOP      
                  |L1.35296|
;;;1112     }
;;;1113     dhcp->tries++;
0089e0  7b60              LDRB     r0,[r4,#0xd]
0089e2  1c40              ADDS     r0,r0,#1
0089e4  7360              STRB     r0,[r4,#0xd]
;;;1114     msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
0089e6  7b60              LDRB     r0,[r4,#0xd]
0089e8  280a              CMP      r0,#0xa
0089ea  da05              BGE      |L1.35320|
0089ec  7b60              LDRB     r0,[r4,#0xd]
0089ee  f44f717a          MOV      r1,#0x3e8
0089f2  fb10f001          SMULBB   r0,r0,r1
0089f6  e001              B        |L1.35324|
                  |L1.35320|
0089f8  f2427010          MOV      r0,#0x2710
                  |L1.35324|
0089fc  b287              UXTH     r7,r0
;;;1115     dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
0089fe  f20710f3          ADD      r0,r7,#0x1f3
008a02  f44f71fa          MOV      r1,#0x1f4
008a06  fb90f0f1          SDIV     r0,r0,r1
008a0a  8360              STRH     r0,[r4,#0x1a]
;;;1116     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
008a0c  bf00              NOP      
008a0e  bf00              NOP      
;;;1117     return result;
008a10  4630              MOV      r0,r6
;;;1118   }
008a12  bdf8              POP      {r3-r7,pc}
;;;1119   
                          ENDP

                  dhcp_renew PROC
;;;1021   err_t
;;;1022   dhcp_renew(struct netif *netif)
008a14  b5f8              PUSH     {r3-r7,lr}
;;;1023   {
008a16  4605              MOV      r5,r0
;;;1024     struct dhcp *dhcp = netif->dhcp;
008a18  6a2c              LDR      r4,[r5,#0x20]
;;;1025     err_t result;
;;;1026     u16_t msecs;
;;;1027     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
008a1a  bf00              NOP      
008a1c  bf00              NOP      
;;;1028     dhcp_set_state(dhcp, DHCP_RENEWING);
008a1e  2105              MOVS     r1,#5
008a20  4620              MOV      r0,r4
008a22  f7fffffe          BL       dhcp_set_state
;;;1029   
;;;1030     /* create and initialize the DHCP message header */
;;;1031     result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
008a26  2203              MOVS     r2,#3
008a28  4621              MOV      r1,r4
008a2a  4628              MOV      r0,r5
008a2c  f7fffffe          BL       dhcp_create_msg
008a30  4606              MOV      r6,r0
;;;1032     if (result == ERR_OK) {
008a32  b9f6              CBNZ     r6,|L1.35442|
;;;1033       dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
008a34  2202              MOVS     r2,#2
008a36  2139              MOVS     r1,#0x39
008a38  4620              MOV      r0,r4
008a3a  f7fffffe          BL       dhcp_option
;;;1034       dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
008a3e  8d29              LDRH     r1,[r5,#0x28]
008a40  4620              MOV      r0,r4
008a42  f7fffffe          BL       dhcp_option_short
;;;1035   
;;;1036   #if 0
;;;1037       dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
;;;1038       dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
;;;1039   #endif
;;;1040   
;;;1041   #if 0
;;;1042       dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
;;;1043       dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
;;;1044   #endif
;;;1045   
;;;1046   #if LWIP_NETIF_HOSTNAME
;;;1047       dhcp_option_hostname(dhcp, netif);
;;;1048   #endif /* LWIP_NETIF_HOSTNAME */
;;;1049   
;;;1050       /* append DHCP message trailer */
;;;1051       dhcp_option_trailer(dhcp);
008a46  4620              MOV      r0,r4
008a48  f7fffffe          BL       dhcp_option_trailer
;;;1052   
;;;1053       pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
008a4c  8b22              LDRH     r2,[r4,#0x18]
008a4e  32f0              ADDS     r2,r2,#0xf0
008a50  b291              UXTH     r1,r2
008a52  6920              LDR      r0,[r4,#0x10]
008a54  f7fffffe          BL       pbuf_realloc
;;;1054   
;;;1055       udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
008a58  9500              STR      r5,[sp,#0]
008a5a  2343              MOVS     r3,#0x43
008a5c  f1040220          ADD      r2,r4,#0x20
008a60  6921              LDR      r1,[r4,#0x10]
008a62  6860              LDR      r0,[r4,#4]
008a64  f7fffffe          BL       udp_sendto_if
;;;1056       dhcp_delete_msg(dhcp);
008a68  4620              MOV      r0,r4
008a6a  f7fffffe          BL       dhcp_delete_msg
;;;1057   
;;;1058       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
008a6e  bf00              NOP      
008a70  e001              B        |L1.35446|
                  |L1.35442|
;;;1059     } else {
;;;1060       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
008a72  bf00              NOP      
008a74  bf00              NOP      
                  |L1.35446|
;;;1061     }
;;;1062     dhcp->tries++;
008a76  7b60              LDRB     r0,[r4,#0xd]
008a78  1c40              ADDS     r0,r0,#1
008a7a  7360              STRB     r0,[r4,#0xd]
;;;1063     /* back-off on retries, but to a maximum of 20 seconds */
;;;1064     msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
008a7c  7b60              LDRB     r0,[r4,#0xd]
008a7e  280a              CMP      r0,#0xa
008a80  da05              BGE      |L1.35470|
008a82  7b60              LDRB     r0,[r4,#0xd]
008a84  f44f61fa          MOV      r1,#0x7d0
008a88  fb10f001          SMULBB   r0,r0,r1
008a8c  e001              B        |L1.35474|
                  |L1.35470|
008a8e  f6446020          MOV      r0,#0x4e20
                  |L1.35474|
008a92  b287              UXTH     r7,r0
;;;1065     dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
008a94  f20710f3          ADD      r0,r7,#0x1f3
008a98  f44f71fa          MOV      r1,#0x1f4
008a9c  fb90f0f1          SDIV     r0,r0,r1
008aa0  8360              STRH     r0,[r4,#0x1a]
;;;1066     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
008aa2  bf00              NOP      
008aa4  bf00              NOP      
;;;1067     return result;
008aa6  4630              MOV      r0,r6
;;;1068   }
008aa8  bdf8              POP      {r3-r7,pc}
;;;1069   
                          ENDP

                  autoip_stop PROC
;;;380    err_t
;;;381    autoip_stop(struct netif *netif)
008aaa  b510              PUSH     {r4,lr}
;;;382    {
008aac  4604              MOV      r4,r0
;;;383      netif->autoip->state = AUTOIP_STATE_OFF;
008aae  2000              MOVS     r0,#0
008ab0  6a61              LDR      r1,[r4,#0x24]
008ab2  7108              STRB     r0,[r1,#4]
;;;384      netif_set_down(netif);
008ab4  4620              MOV      r0,r4
008ab6  f7fffffe          BL       netif_set_down
;;;385      return ERR_OK;
008aba  2000              MOVS     r0,#0
;;;386    }
008abc  bd10              POP      {r4,pc}
;;;387    
                          ENDP

                  dhcp_bind PROC
;;;926    static void
;;;927    dhcp_bind(struct netif *netif)
008abe  b57c              PUSH     {r2-r6,lr}
;;;928    {
008ac0  4606              MOV      r6,r0
;;;929      u32_t timeout;
;;;930      struct dhcp *dhcp;
;;;931      ip_addr_t sn_mask, gw_addr;
;;;932      LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
008ac2  bf00              NOP      
008ac4  b906              CBNZ     r6,|L1.35528|
                  |L1.35526|
;;;933      dhcp = netif->dhcp;
;;;934      LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
;;;935      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;936    
;;;937      /* temporary DHCP lease? */
;;;938      if (dhcp->offered_t1_renew != 0xffffffffUL) {
;;;939        /* set renewal period timer */
;;;940        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
;;;941        timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
;;;942        if(timeout > 0xffff) {
;;;943          timeout = 0xffff;
;;;944        }
;;;945        dhcp->t1_timeout = (u16_t)timeout;
;;;946        if (dhcp->t1_timeout == 0) {
;;;947          dhcp->t1_timeout = 1;
;;;948        }
;;;949        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
;;;950      }
;;;951      /* set renewal period timer */
;;;952      if (dhcp->offered_t2_rebind != 0xffffffffUL) {
;;;953        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
;;;954        timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
;;;955        if(timeout > 0xffff) {
;;;956          timeout = 0xffff;
;;;957        }
;;;958        dhcp->t2_timeout = (u16_t)timeout;
;;;959        if (dhcp->t2_timeout == 0) {
;;;960          dhcp->t2_timeout = 1;
;;;961        }
;;;962        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
;;;963      }
;;;964    
;;;965      /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
;;;966      if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
;;;967        dhcp->t1_timeout = 0;
;;;968      }
;;;969    
;;;970      if (dhcp->subnet_mask_given) {
;;;971        /* copy offered network mask */
;;;972        ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
;;;973      } else {
;;;974        /* subnet mask not given, choose a safe subnet mask given the network class */
;;;975        u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
;;;976        if (first_octet <= 127) {
;;;977          ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
;;;978        } else if (first_octet >= 192) {
;;;979          ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
;;;980        } else {
;;;981          ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
;;;982        }
;;;983      }
;;;984    
;;;985      ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
;;;986      /* gateway address not given? */
;;;987      if (ip_addr_isany(&gw_addr)) {
;;;988        /* copy network address */
;;;989        ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
;;;990        /* use first host address on network as gateway */
;;;991        ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
;;;992      }
;;;993    
;;;994    #if LWIP_DHCP_AUTOIP_COOP
;;;995      if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;996        autoip_stop(netif);
;;;997        dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;998      }
;;;999    #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;1000   
;;;1001     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
;;;1002       ip4_addr_get_u32(&dhcp->offered_ip_addr)));
;;;1003     netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
;;;1004     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
;;;1005       ip4_addr_get_u32(&sn_mask)));
;;;1006     netif_set_netmask(netif, &sn_mask);
;;;1007     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
;;;1008       ip4_addr_get_u32(&gw_addr)));
;;;1009     netif_set_gw(netif, &gw_addr);
;;;1010     /* bring the interface up */
;;;1011     netif_set_up(netif);
;;;1012     /* netif is now bound to DHCP leased address */
;;;1013     dhcp_set_state(dhcp, DHCP_BOUND);
;;;1014   }
008ac6  bd7c              POP      {r2-r6,pc}
                  |L1.35528|
008ac8  bf00              NOP                            ;932
008aca  6a34              LDR      r4,[r6,#0x20]         ;933
008acc  bf00              NOP                            ;934
008ace  b904              CBNZ     r4,|L1.35538|
008ad0  e7f9              B        |L1.35526|
                  |L1.35538|
008ad2  bf00              NOP                            ;934
008ad4  bf00              NOP                            ;935
008ad6  bf00              NOP                            ;935
008ad8  6b60              LDR      r0,[r4,#0x34]         ;938
008ada  1c40              ADDS     r0,r0,#1              ;938
008adc  d019              BEQ      |L1.35602|
008ade  bf00              NOP                            ;940
008ae0  bf00              NOP                            ;940
008ae2  6b60              LDR      r0,[r4,#0x34]         ;941
008ae4  301e              ADDS     r0,r0,#0x1e           ;941
008ae6  213c              MOVS     r1,#0x3c              ;941
008ae8  fbb0f5f1          UDIV     r5,r0,r1              ;941
008aec  f5b53f80          CMP      r5,#0x10000           ;942
008af0  d301              BCC      |L1.35574|
008af2  f64f75ff          MOV      r5,#0xffff            ;943
                  |L1.35574|
008af6  e005              B        |L1.35588|
                  |L1.35576|
                          DCD      autoip_timer
                  |L1.35580|
                          DCD      ip_addr_broadcast
                  |L1.35584|
                          DCD      ip_addr_any
                  |L1.35588|
008b04  83a5              STRH     r5,[r4,#0x1c]         ;945
008b06  8ba0              LDRH     r0,[r4,#0x1c]         ;946
008b08  b908              CBNZ     r0,|L1.35598|
008b0a  2001              MOVS     r0,#1                 ;947
008b0c  83a0              STRH     r0,[r4,#0x1c]         ;947
                  |L1.35598|
008b0e  bf00              NOP                            ;949
008b10  bf00              NOP                            ;949
                  |L1.35602|
008b12  6ba0              LDR      r0,[r4,#0x38]         ;952
008b14  1c40              ADDS     r0,r0,#1              ;952
008b16  d012              BEQ      |L1.35646|
008b18  bf00              NOP                            ;953
008b1a  bf00              NOP                            ;953
008b1c  6ba0              LDR      r0,[r4,#0x38]         ;954
008b1e  301e              ADDS     r0,r0,#0x1e           ;954
008b20  213c              MOVS     r1,#0x3c              ;954
008b22  fbb0f5f1          UDIV     r5,r0,r1              ;954
008b26  f5b53f80          CMP      r5,#0x10000           ;955
008b2a  d301              BCC      |L1.35632|
008b2c  f64f75ff          MOV      r5,#0xffff            ;956
                  |L1.35632|
008b30  83e5              STRH     r5,[r4,#0x1e]         ;958
008b32  8be0              LDRH     r0,[r4,#0x1e]         ;959
008b34  b908              CBNZ     r0,|L1.35642|
008b36  2001              MOVS     r0,#1                 ;960
008b38  83e0              STRH     r0,[r4,#0x1e]         ;960
                  |L1.35642|
008b3a  bf00              NOP                            ;962
008b3c  bf00              NOP                            ;962
                  |L1.35646|
008b3e  8ba0              LDRH     r0,[r4,#0x1c]         ;966
008b40  8be1              LDRH     r1,[r4,#0x1e]         ;966
008b42  4288              CMP      r0,r1                 ;966
008b44  db04              BLT      |L1.35664|
008b46  8be0              LDRH     r0,[r4,#0x1e]         ;966
008b48  2800              CMP      r0,#0                 ;966
008b4a  dd01              BLE      |L1.35664|
008b4c  2000              MOVS     r0,#0                 ;967
008b4e  83a0              STRH     r0,[r4,#0x1c]         ;967
                  |L1.35664|
008b50  7be0              LDRB     r0,[r4,#0xf]          ;970
008b52  b110              CBZ      r0,|L1.35674|
008b54  6aa0              LDR      r0,[r4,#0x28]         ;972
008b56  9001              STR      r0,[sp,#4]            ;972
008b58  e010              B        |L1.35708|
                  |L1.35674|
008b5a  f8940024          LDRB     r0,[r4,#0x24]         ;975
008b5e  287f              CMP      r0,#0x7f              ;976
008b60  dc02              BGT      |L1.35688|
008b62  21ff              MOVS     r1,#0xff              ;977
008b64  9101              STR      r1,[sp,#4]            ;977
008b66  e008              B        |L1.35706|
                  |L1.35688|
008b68  28c0              CMP      r0,#0xc0              ;978
008b6a  db03              BLT      |L1.35700|
008b6c  f06f417f          MVN      r1,#0xff000000        ;979
008b70  9101              STR      r1,[sp,#4]            ;979
008b72  e002              B        |L1.35706|
                  |L1.35700|
008b74  f64f71ff          MOV      r1,#0xffff            ;981
008b78  9101              STR      r1,[sp,#4]            ;981
                  |L1.35706|
008b7a  bf00              NOP                            ;983
                  |L1.35708|
008b7c  6ae0              LDR      r0,[r4,#0x2c]         ;985
008b7e  9000              STR      r0,[sp,#0]            ;985
008b80  4668              MOV      r0,sp                 ;987
008b82  b108              CBZ      r0,|L1.35720|
008b84  9800              LDR      r0,[sp,#0]            ;987
008b86  b938              CBNZ     r0,|L1.35736|
                  |L1.35720|
008b88  6a60              LDR      r0,[r4,#0x24]         ;989
008b8a  9901              LDR      r1,[sp,#4]            ;989
008b8c  4008              ANDS     r0,r0,r1              ;989
008b8e  9000              STR      r0,[sp,#0]            ;989
008b90  9800              LDR      r0,[sp,#0]            ;991
008b92  f0407080          ORR      r0,r0,#0x1000000      ;991
008b96  9000              STR      r0,[sp,#0]            ;991
                  |L1.35736|
008b98  7ba0              LDRB     r0,[r4,#0xe]          ;995
008b9a  2801              CMP      r0,#1                 ;995
008b9c  d104              BNE      |L1.35752|
008b9e  4630              MOV      r0,r6                 ;996
008ba0  f7fffffe          BL       autoip_stop
008ba4  2000              MOVS     r0,#0                 ;997
008ba6  73a0              STRB     r0,[r4,#0xe]          ;997
                  |L1.35752|
008ba8  bf00              NOP                            ;1001
008baa  bf00              NOP                            ;1001
008bac  f1040124          ADD      r1,r4,#0x24           ;1003
008bb0  4630              MOV      r0,r6                 ;1003
008bb2  f7fffffe          BL       netif_set_ipaddr
008bb6  bf00              NOP                            ;1004
008bb8  bf00              NOP                            ;1004
008bba  a901              ADD      r1,sp,#4              ;1006
008bbc  4630              MOV      r0,r6                 ;1006
008bbe  f7fffffe          BL       netif_set_netmask
008bc2  bf00              NOP                            ;1007
008bc4  bf00              NOP                            ;1007
008bc6  4669              MOV      r1,sp                 ;1009
008bc8  4630              MOV      r0,r6                 ;1009
008bca  f7fffffe          BL       netif_set_gw
008bce  4630              MOV      r0,r6                 ;1011
008bd0  f7fffffe          BL       netif_set_up
008bd4  210a              MOVS     r1,#0xa               ;1013
008bd6  4620              MOV      r0,r4                 ;1013
008bd8  f7fffffe          BL       dhcp_set_state
008bdc  bf00              NOP      
008bde  e772              B        |L1.35526|
;;;1015   
                          ENDP

                  etharp_query PROC
;;;1016   err_t
;;;1017   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
008be0  e92d5ff0          PUSH     {r4-r12,lr}
;;;1018   {
008be4  4680              MOV      r8,r0
008be6  460f              MOV      r7,r1
008be8  4616              MOV      r6,r2
;;;1019     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
008bea  f108092b          ADD      r9,r8,#0x2b
;;;1020     err_t result = ERR_MEM;
008bee  f04f3aff          MOV      r10,#0xffffffff
;;;1021     s8_t i; /* ARP entry index */
;;;1022   
;;;1023     /* non-unicast address? */
;;;1024     if (ip_addr_isbroadcast(ipaddr, netif) ||
008bf2  4641              MOV      r1,r8
008bf4  6838              LDR      r0,[r7,#0]
008bf6  f7fffffe          BL       ip4_addr_isbroadcast
008bfa  b938              CBNZ     r0,|L1.35852|
;;;1025         ip_addr_ismulticast(ipaddr) ||
008bfc  7838              LDRB     r0,[r7,#0]
008bfe  f00000f0          AND      r0,r0,#0xf0
008c02  28e0              CMP      r0,#0xe0
008c04  d002              BEQ      |L1.35852|
;;;1026         ip_addr_isany(ipaddr)) {
008c06  b10f              CBZ      r7,|L1.35852|
008c08  6838              LDR      r0,[r7,#0]
008c0a  b928              CBNZ     r0,|L1.35864|
                  |L1.35852|
;;;1027       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
008c0c  bf00              NOP      
008c0e  bf00              NOP      
;;;1028       return ERR_ARG;
008c10  f06f000d          MVN      r0,#0xd
                  |L1.35860|
;;;1029     }
;;;1030   
;;;1031     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1032     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
;;;1033   
;;;1034     /* could not find or create entry? */
;;;1035     if (i < 0) {
;;;1036       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1037       if (q) {
;;;1038         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1039         ETHARP_STATS_INC(etharp.memerr);
;;;1040       }
;;;1041       return (err_t)i;
;;;1042     }
;;;1043   
;;;1044     /* mark a fresh entry as pending (we just sent a request) */
;;;1045     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1046       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1047     }
;;;1048   
;;;1049     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1050     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1051     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1052      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1053   
;;;1054     /* do we have a pending entry? or an implicit query request? */
;;;1055     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1056       /* try to resolve it; send out ARP request */
;;;1057       result = etharp_request(netif, ipaddr);
;;;1058       if (result != ERR_OK) {
;;;1059         /* ARP request couldn't be sent */
;;;1060         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1061            since this failure could be temporary, and the next packet calling
;;;1062            etharp_query again could lead to sending the queued packets. */
;;;1063       }
;;;1064       if (q == NULL) {
;;;1065         return result;
;;;1066       }
;;;1067     }
;;;1068   
;;;1069     /* packet given? */
;;;1070     LWIP_ASSERT("q != NULL", q != NULL);
;;;1071     /* stable entry? */
;;;1072     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1073       /* we have a valid IP->Ethernet address mapping */
;;;1074       ETHARP_SET_HINT(netif, i);
;;;1075       /* send the packet */
;;;1076       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1077     /* pending entry? (either just created or already pending */
;;;1078     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1079       /* entry is still pending, queue the given packet 'q' */
;;;1080       struct pbuf *p;
;;;1081       int copy_needed = 0;
;;;1082       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1083        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1084        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1085       p = q;
;;;1086       while (p) {
;;;1087         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1088         if(p->type != PBUF_ROM) {
;;;1089           copy_needed = 1;
;;;1090           break;
;;;1091         }
;;;1092         p = p->next;
;;;1093       }
;;;1094       if(copy_needed) {
;;;1095         /* copy the whole packet into new pbufs */
;;;1096         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1097         if(p != NULL) {
;;;1098           if (pbuf_copy(p, q) != ERR_OK) {
;;;1099             pbuf_free(p);
;;;1100             p = NULL;
;;;1101           }
;;;1102         }
;;;1103       } else {
;;;1104         /* referencing the old pbuf is enough */
;;;1105         p = q;
;;;1106         pbuf_ref(p);
;;;1107       }
;;;1108       /* packet could be taken over? */
;;;1109       if (p != NULL) {
;;;1110         /* queue packet ... */
;;;1111   #if ARP_QUEUEING
;;;1112         struct etharp_q_entry *new_entry;
;;;1113         /* allocate a new arp queue entry */
;;;1114         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1115         if (new_entry != NULL) {
;;;1116           new_entry->next = 0;
;;;1117           new_entry->p = p;
;;;1118           if(arp_table[i].q != NULL) {
;;;1119             /* queue was already existent, append the new entry to the end */
;;;1120             struct etharp_q_entry *r;
;;;1121             r = arp_table[i].q;
;;;1122             while (r->next != NULL) {
;;;1123               r = r->next;
;;;1124             }
;;;1125             r->next = new_entry;
;;;1126           } else {
;;;1127             /* queue did not exist, first item in queue */
;;;1128             arp_table[i].q = new_entry;
;;;1129           }
;;;1130           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1131           result = ERR_OK;
;;;1132         } else {
;;;1133           /* the pool MEMP_ARP_QUEUE is empty */
;;;1134           pbuf_free(p);
;;;1135           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1136           result = ERR_MEM;
;;;1137         }
;;;1138   #else /* ARP_QUEUEING */
;;;1139         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1140         if (arp_table[i].q != NULL) {
;;;1141           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1142           pbuf_free(arp_table[i].q);
;;;1143         }
;;;1144         arp_table[i].q = p;
;;;1145         result = ERR_OK;
;;;1146         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1147   #endif /* ARP_QUEUEING */
;;;1148       } else {
;;;1149         ETHARP_STATS_INC(etharp.memerr);
;;;1150         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1151         result = ERR_MEM;
;;;1152       }
;;;1153     }
;;;1154     return result;
;;;1155   }
008c14  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.35864|
008c18  2101              MOVS     r1,#1                 ;1032
008c1a  4638              MOV      r0,r7                 ;1032
008c1c  f7fffffe          BL       etharp_find_entry
008c20  4604              MOV      r4,r0                 ;1032
008c22  2c00              CMP      r4,#0                 ;1035
008c24  da0c              BGE      |L1.35904|
008c26  bf00              NOP                            ;1036
008c28  bf00              NOP                            ;1036
008c2a  b13e              CBZ      r6,|L1.35900|
008c2c  bf00              NOP                            ;1038
008c2e  bf00              NOP                            ;1038
008c30  48fa              LDR      r0,|L1.36892|
008c32  8c80              LDRH     r0,[r0,#0x24]         ;1039
008c34  1c40              ADDS     r0,r0,#1              ;1039
008c36  b281              UXTH     r1,r0                 ;1039
008c38  48f8              LDR      r0,|L1.36892|
008c3a  8481              STRH     r1,[r0,#0x24]         ;1039
                  |L1.35900|
008c3c  4620              MOV      r0,r4                 ;1041
008c3e  e7e9              B        |L1.35860|
                  |L1.35904|
008c40  eb040084          ADD      r0,r4,r4,LSL #2       ;1045
008c44  49f6              LDR      r1,|L1.36896|
008c46  eb010080          ADD      r0,r1,r0,LSL #2       ;1045
008c4a  7c80              LDRB     r0,[r0,#0x12]         ;1045
008c4c  b930              CBNZ     r0,|L1.35932|
008c4e  2001              MOVS     r0,#1                 ;1046
008c50  eb040184          ADD      r1,r4,r4,LSL #2       ;1046
008c54  4af2              LDR      r2,|L1.36896|
008c56  eb020181          ADD      r1,r2,r1,LSL #2       ;1046
008c5a  7488              STRB     r0,[r1,#0x12]         ;1046
                  |L1.35932|
008c5c  bf00              NOP                            ;1050
008c5e  bf00              NOP                            ;1050
008c60  eb040084          ADD      r0,r4,r4,LSL #2       ;1055
008c64  49ee              LDR      r1,|L1.36896|
008c66  eb010080          ADD      r0,r1,r0,LSL #2       ;1055
008c6a  7c80              LDRB     r0,[r0,#0x12]         ;1055
008c6c  2801              CMP      r0,#1                 ;1055
008c6e  d000              BEQ      |L1.35954|
008c70  b93e              CBNZ     r6,|L1.35970|
                  |L1.35954|
008c72  4639              MOV      r1,r7                 ;1057
008c74  4640              MOV      r0,r8                 ;1057
008c76  f7fffffe          BL       etharp_request
008c7a  4682              MOV      r10,r0                ;1057
008c7c  b90e              CBNZ     r6,|L1.35970|
008c7e  4650              MOV      r0,r10                ;1065
008c80  e7c8              B        |L1.35860|
                  |L1.35970|
008c82  bf00              NOP                            ;1070
008c84  bf00              NOP                            ;1070
008c86  eb040084          ADD      r0,r4,r4,LSL #2       ;1072
008c8a  49e5              LDR      r1,|L1.36896|
008c8c  eb010080          ADD      r0,r1,r0,LSL #2       ;1072
008c90  7c80              LDRB     r0,[r0,#0x12]         ;1072
008c92  2802              CMP      r0,#2                 ;1072
008c94  db0f              BLT      |L1.36022|
008c96  49e3              LDR      r1,|L1.36900|
008c98  700c              STRB     r4,[r1,#0]            ;1074
008c9a  eb040084          ADD      r0,r4,r4,LSL #2       ;1076
008c9e  49e0              LDR      r1,|L1.36896|
008ca0  eb010080          ADD      r0,r1,r0,LSL #2       ;1076
008ca4  f100030c          ADD      r3,r0,#0xc            ;1076
008ca8  464a              MOV      r2,r9                 ;1076
008caa  4631              MOV      r1,r6                 ;1076
008cac  4640              MOV      r0,r8                 ;1076
008cae  f7fffffe          BL       etharp_send_ip
008cb2  4682              MOV      r10,r0                ;1076
008cb4  e053              B        |L1.36190|
                  |L1.36022|
008cb6  eb040084          ADD      r0,r4,r4,LSL #2       ;1078
008cba  49d9              LDR      r1,|L1.36896|
008cbc  eb010080          ADD      r0,r1,r0,LSL #2       ;1078
008cc0  7c80              LDRB     r0,[r0,#0x12]         ;1078
008cc2  2801              CMP      r0,#1                 ;1078
008cc4  d14b              BNE      |L1.36190|
008cc6  f04f0b00          MOV      r11,#0                ;1081
008cca  4635              MOV      r5,r6                 ;1085
008ccc  e008              B        |L1.36064|
                  |L1.36046|
008cce  bf00              NOP                            ;1087
008cd0  bf00              NOP                            ;1087
008cd2  7b28              LDRB     r0,[r5,#0xc]          ;1088
008cd4  2801              CMP      r0,#1                 ;1088
008cd6  d002              BEQ      |L1.36062|
008cd8  f04f0b01          MOV      r11,#1                ;1089
008cdc  e002              B        |L1.36068|
                  |L1.36062|
008cde  682d              LDR      r5,[r5,#0]            ;1092
                  |L1.36064|
008ce0  2d00              CMP      r5,#0                 ;1086
008ce2  d1f4              BNE      |L1.36046|
                  |L1.36068|
008ce4  bf00              NOP                            ;1090
008ce6  f1bb0f00          CMP      r11,#0                ;1094
008cea  d010              BEQ      |L1.36110|
008cec  8929              LDRH     r1,[r5,#8]            ;1096
008cee  2200              MOVS     r2,#0                 ;1096
008cf0  2003              MOVS     r0,#3                 ;1096
008cf2  f7fffffe          BL       pbuf_alloc
008cf6  4605              MOV      r5,r0                 ;1096
008cf8  b16d              CBZ      r5,|L1.36118|
008cfa  4631              MOV      r1,r6                 ;1098
008cfc  4628              MOV      r0,r5                 ;1098
008cfe  f7fffffe          BL       pbuf_copy
008d02  b140              CBZ      r0,|L1.36118|
008d04  4628              MOV      r0,r5                 ;1099
008d06  f7fffffe          BL       pbuf_free
008d0a  2500              MOVS     r5,#0                 ;1100
008d0c  e003              B        |L1.36118|
                  |L1.36110|
008d0e  4635              MOV      r5,r6                 ;1105
008d10  4628              MOV      r0,r5                 ;1106
008d12  f7fffffe          BL       pbuf_ref
                  |L1.36118|
008d16  b1bd              CBZ      r5,|L1.36168|
008d18  eb040084          ADD      r0,r4,r4,LSL #2       ;1140
008d1c  49c0              LDR      r1,|L1.36896|
008d1e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1140
008d22  b140              CBZ      r0,|L1.36150|
008d24  bf00              NOP                            ;1141
008d26  bf00              NOP                            ;1141
008d28  eb040184          ADD      r1,r4,r4,LSL #2       ;1142
008d2c  4abc              LDR      r2,|L1.36896|
008d2e  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1142
008d32  f7fffffe          BL       pbuf_free
                  |L1.36150|
008d36  eb040084          ADD      r0,r4,r4,LSL #2       ;1144
008d3a  49b9              LDR      r1,|L1.36896|
008d3c  f8415020          STR      r5,[r1,r0,LSL #2]     ;1144
008d40  f04f0a00          MOV      r10,#0                ;1145
008d44  bf00              NOP                            ;1146
008d46  e009              B        |L1.36188|
                  |L1.36168|
008d48  48b4              LDR      r0,|L1.36892|
008d4a  8c80              LDRH     r0,[r0,#0x24]         ;1149
008d4c  1c40              ADDS     r0,r0,#1              ;1149
008d4e  b281              UXTH     r1,r0                 ;1149
008d50  48b2              LDR      r0,|L1.36892|
008d52  8481              STRH     r1,[r0,#0x24]         ;1149
008d54  bf00              NOP                            ;1150
008d56  bf00              NOP                            ;1150
008d58  f04f3aff          MOV      r10,#0xffffffff       ;1151
                  |L1.36188|
008d5c  bf00              NOP                            ;1153
                  |L1.36190|
008d5e  4650              MOV      r0,r10                ;1154
008d60  e758              B        |L1.35860|
;;;1156   
                          ENDP

                  dhcp_check PROC
;;;224    static void
;;;225    dhcp_check(struct netif *netif)
008d62  e92d41f0          PUSH     {r4-r8,lr}
;;;226    {
008d66  4606              MOV      r6,r0
;;;227      struct dhcp *dhcp = netif->dhcp;
008d68  6a34              LDR      r4,[r6,#0x20]
;;;228      err_t result;
;;;229      u16_t msecs;
;;;230      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
008d6a  bf00              NOP      
008d6c  bf00              NOP      
;;;231        (s16_t)netif->name[1]));
;;;232      dhcp_set_state(dhcp, DHCP_CHECKING);
008d6e  2108              MOVS     r1,#8
008d70  4620              MOV      r0,r4
008d72  f7fffffe          BL       dhcp_set_state
;;;233      /* create an ARP query for the offered IP address, expecting that no host
;;;234         responds, as the IP address should not be in use. */
;;;235      result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
008d76  2200              MOVS     r2,#0
008d78  f1040124          ADD      r1,r4,#0x24
008d7c  4630              MOV      r0,r6
008d7e  f7fffffe          BL       etharp_query
008d82  4605              MOV      r5,r0
;;;236      if (result != ERR_OK) {
008d84  b10d              CBZ      r5,|L1.36234|
;;;237        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
008d86  bf00              NOP      
008d88  bf00              NOP      
                  |L1.36234|
;;;238      }
;;;239      dhcp->tries++;
008d8a  7b60              LDRB     r0,[r4,#0xd]
008d8c  1c40              ADDS     r0,r0,#1
008d8e  7360              STRB     r0,[r4,#0xd]
;;;240      msecs = 500;
008d90  f44f77fa          MOV      r7,#0x1f4
;;;241      dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
008d94  f20710f3          ADD      r0,r7,#0x1f3
008d98  4639              MOV      r1,r7
008d9a  fb90f0f1          SDIV     r0,r0,r1
008d9e  8360              STRH     r0,[r4,#0x1a]
;;;242      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
008da0  bf00              NOP      
008da2  bf00              NOP      
;;;243    }
008da4  e8bd81f0          POP      {r4-r8,pc}
;;;244    #endif /* DHCP_DOES_ARP_CHECK */
                          ENDP

                  dhcp_select PROC
;;;282    static err_t
;;;283    dhcp_select(struct netif *netif)
008da8  e92d43f8          PUSH     {r3-r9,lr}
;;;284    {
008dac  4605              MOV      r5,r0
;;;285      struct dhcp *dhcp = netif->dhcp;
008dae  6a2c              LDR      r4,[r5,#0x20]
;;;286      err_t result;
;;;287      u16_t msecs;
;;;288    
;;;289      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
008db0  bf00              NOP      
008db2  bf00              NOP      
;;;290      dhcp_set_state(dhcp, DHCP_REQUESTING);
008db4  2101              MOVS     r1,#1
008db6  4620              MOV      r0,r4
008db8  f7fffffe          BL       dhcp_set_state
;;;291    
;;;292      /* create and initialize the DHCP message header */
;;;293      result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
008dbc  2203              MOVS     r2,#3
008dbe  4621              MOV      r1,r4
008dc0  4628              MOV      r0,r5
008dc2  f7fffffe          BL       dhcp_create_msg
008dc6  4606              MOV      r6,r0
;;;294      if (result == ERR_OK) {
008dc8  2e00              CMP      r6,#0
008dca  d14c              BNE      |L1.36454|
;;;295        dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
008dcc  2202              MOVS     r2,#2
008dce  2139              MOVS     r1,#0x39
008dd0  4620              MOV      r0,r4
008dd2  f7fffffe          BL       dhcp_option
;;;296        dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
008dd6  8d29              LDRH     r1,[r5,#0x28]
008dd8  4620              MOV      r0,r4
008dda  f7fffffe          BL       dhcp_option_short
;;;297    
;;;298        /* MUST request the offered IP address */
;;;299        dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
008dde  2204              MOVS     r2,#4
008de0  2132              MOVS     r1,#0x32
008de2  4620              MOV      r0,r4
008de4  f7fffffe          BL       dhcp_option
;;;300        dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
008de8  6a60              LDR      r0,[r4,#0x24]
008dea  f7fffffe          BL       lwip_ntohl
008dee  4680              MOV      r8,r0
008df0  4641              MOV      r1,r8
008df2  4620              MOV      r0,r4
008df4  f7fffffe          BL       dhcp_option_long
;;;301    
;;;302        dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
008df8  2204              MOVS     r2,#4
008dfa  2136              MOVS     r1,#0x36
008dfc  4620              MOV      r0,r4
008dfe  f7fffffe          BL       dhcp_option
;;;303        dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
008e02  6a20              LDR      r0,[r4,#0x20]
008e04  f7fffffe          BL       lwip_ntohl
008e08  4680              MOV      r8,r0
008e0a  4641              MOV      r1,r8
008e0c  4620              MOV      r0,r4
008e0e  f7fffffe          BL       dhcp_option_long
;;;304    
;;;305        dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
008e12  2204              MOVS     r2,#4
008e14  2137              MOVS     r1,#0x37
008e16  4620              MOV      r0,r4
008e18  f7fffffe          BL       dhcp_option
;;;306        dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
008e1c  2101              MOVS     r1,#1
008e1e  4620              MOV      r0,r4
008e20  f7fffffe          BL       dhcp_option_byte
;;;307        dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
008e24  2103              MOVS     r1,#3
008e26  4620              MOV      r0,r4
008e28  f7fffffe          BL       dhcp_option_byte
;;;308        dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
008e2c  211c              MOVS     r1,#0x1c
008e2e  4620              MOV      r0,r4
008e30  f7fffffe          BL       dhcp_option_byte
;;;309        dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
008e34  2106              MOVS     r1,#6
008e36  4620              MOV      r0,r4
008e38  f7fffffe          BL       dhcp_option_byte
;;;310    
;;;311    #if LWIP_NETIF_HOSTNAME
;;;312        dhcp_option_hostname(dhcp, netif);
;;;313    #endif /* LWIP_NETIF_HOSTNAME */
;;;314    
;;;315        dhcp_option_trailer(dhcp);
008e3c  4620              MOV      r0,r4
008e3e  f7fffffe          BL       dhcp_option_trailer
;;;316        /* shrink the pbuf to the actual content length */
;;;317        pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
008e42  8b22              LDRH     r2,[r4,#0x18]
008e44  32f0              ADDS     r2,r2,#0xf0
008e46  b291              UXTH     r1,r2
008e48  6920              LDR      r0,[r4,#0x10]
008e4a  f7fffffe          BL       pbuf_realloc
;;;318    
;;;319        /* send broadcast to any DHCP server */
;;;320        udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
008e4e  9500              STR      r5,[sp,#0]
008e50  2343              MOVS     r3,#0x43
008e52  4a75              LDR      r2,|L1.36904|
008e54  6921              LDR      r1,[r4,#0x10]
008e56  6860              LDR      r0,[r4,#4]
008e58  f7fffffe          BL       udp_sendto_if
;;;321        dhcp_delete_msg(dhcp);
008e5c  4620              MOV      r0,r4
008e5e  f7fffffe          BL       dhcp_delete_msg
;;;322        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
008e62  bf00              NOP      
008e64  e001              B        |L1.36458|
                  |L1.36454|
;;;323      } else {
;;;324        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
008e66  bf00              NOP      
008e68  bf00              NOP      
                  |L1.36458|
;;;325      }
;;;326      dhcp->tries++;
008e6a  7b60              LDRB     r0,[r4,#0xd]
008e6c  1c40              ADDS     r0,r0,#1
008e6e  7360              STRB     r0,[r4,#0xd]
;;;327      msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
008e70  7b60              LDRB     r0,[r4,#0xd]
008e72  2806              CMP      r0,#6
008e74  da03              BGE      |L1.36478|
008e76  7b61              LDRB     r1,[r4,#0xd]
008e78  2001              MOVS     r0,#1
008e7a  4088              LSLS     r0,r0,r1
008e7c  e000              B        |L1.36480|
                  |L1.36478|
008e7e  203c              MOVS     r0,#0x3c
                  |L1.36480|
008e80  eb000140          ADD      r1,r0,r0,LSL #1
008e84  ebc110c0          RSB      r0,r1,r0,LSL #7
008e88  f64f71ff          MOV      r1,#0xffff
008e8c  ea0107c0          AND      r7,r1,r0,LSL #3
;;;328      dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
008e90  f20710f3          ADD      r0,r7,#0x1f3
008e94  f44f71fa          MOV      r1,#0x1f4
008e98  fb90f0f1          SDIV     r0,r0,r1
008e9c  8360              STRH     r0,[r4,#0x1a]
;;;329      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
008e9e  bf00              NOP      
008ea0  bf00              NOP      
;;;330      return result;
008ea2  4630              MOV      r0,r6
;;;331    }
008ea4  e8bd83f8          POP      {r3-r9,pc}
;;;332    
                          ENDP

                  dhcp_timeout PROC
;;;401    static void
;;;402    dhcp_timeout(struct netif *netif)
008ea8  b570              PUSH     {r4-r6,lr}
;;;403    {
008eaa  4605              MOV      r5,r0
;;;404      struct dhcp *dhcp = netif->dhcp;
008eac  6a2c              LDR      r4,[r5,#0x20]
;;;405      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
008eae  bf00              NOP      
008eb0  bf00              NOP      
;;;406      /* back-off period has passed, or server selection timed out */
;;;407      if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
008eb2  7b20              LDRB     r0,[r4,#0xc]
008eb4  280c              CMP      r0,#0xc
008eb6  d002              BEQ      |L1.36542|
008eb8  7b20              LDRB     r0,[r4,#0xc]
008eba  2806              CMP      r0,#6
008ebc  d105              BNE      |L1.36554|
                  |L1.36542|
;;;408        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
008ebe  bf00              NOP      
008ec0  bf00              NOP      
;;;409        dhcp_discover(netif);
008ec2  4628              MOV      r0,r5
008ec4  f7fffffe          BL       dhcp_discover
008ec8  e04f              B        |L1.36714|
                  |L1.36554|
;;;410      /* receiving the requested lease timed out */
;;;411      } else if (dhcp->state == DHCP_REQUESTING) {
008eca  7b20              LDRB     r0,[r4,#0xc]
008ecc  2801              CMP      r0,#1
008ece  d111              BNE      |L1.36596|
;;;412        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
008ed0  bf00              NOP      
008ed2  bf00              NOP      
;;;413        if (dhcp->tries <= 5) {
008ed4  7b60              LDRB     r0,[r4,#0xd]
008ed6  2805              CMP      r0,#5
008ed8  dc03              BGT      |L1.36578|
;;;414          dhcp_select(netif);
008eda  4628              MOV      r0,r5
008edc  f7fffffe          BL       dhcp_select
008ee0  e043              B        |L1.36714|
                  |L1.36578|
;;;415        } else {
;;;416          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
008ee2  bf00              NOP      
008ee4  bf00              NOP      
;;;417          dhcp_release(netif);
008ee6  4628              MOV      r0,r5
008ee8  f7fffffe          BL       dhcp_release
;;;418          dhcp_discover(netif);
008eec  4628              MOV      r0,r5
008eee  f7fffffe          BL       dhcp_discover
008ef2  e03a              B        |L1.36714|
                  |L1.36596|
;;;419        }
;;;420    #if DHCP_DOES_ARP_CHECK
;;;421      /* received no ARP reply for the offered address (which is good) */
;;;422      } else if (dhcp->state == DHCP_CHECKING) {
008ef4  7b20              LDRB     r0,[r4,#0xc]
008ef6  2808              CMP      r0,#8
008ef8  d10c              BNE      |L1.36628|
;;;423        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
008efa  bf00              NOP      
008efc  bf00              NOP      
;;;424        if (dhcp->tries <= 1) {
008efe  7b60              LDRB     r0,[r4,#0xd]
008f00  2801              CMP      r0,#1
008f02  dc03              BGT      |L1.36620|
;;;425          dhcp_check(netif);
008f04  4628              MOV      r0,r5
008f06  f7fffffe          BL       dhcp_check
008f0a  e02e              B        |L1.36714|
                  |L1.36620|
;;;426        /* no ARP replies on the offered address,
;;;427           looks like the IP address is indeed free */
;;;428        } else {
;;;429          /* bind the interface to the offered address */
;;;430          dhcp_bind(netif);
008f0c  4628              MOV      r0,r5
008f0e  f7fffffe          BL       dhcp_bind
008f12  e02a              B        |L1.36714|
                  |L1.36628|
;;;431        }
;;;432    #endif /* DHCP_DOES_ARP_CHECK */
;;;433      }
;;;434      /* did not get response to renew request? */
;;;435      else if (dhcp->state == DHCP_RENEWING) {
008f14  7b20              LDRB     r0,[r4,#0xc]
008f16  2805              CMP      r0,#5
008f18  d105              BNE      |L1.36646|
;;;436        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
008f1a  bf00              NOP      
008f1c  bf00              NOP      
;;;437        /* just retry renewal */
;;;438        /* note that the rebind timer will eventually time-out if renew does not work */
;;;439        dhcp_renew(netif);
008f1e  4628              MOV      r0,r5
008f20  f7fffffe          BL       dhcp_renew
008f24  e021              B        |L1.36714|
                  |L1.36646|
;;;440      /* did not get response to rebind request? */
;;;441      } else if (dhcp->state == DHCP_REBINDING) {
008f26  7b20              LDRB     r0,[r4,#0xc]
008f28  2804              CMP      r0,#4
008f2a  d111              BNE      |L1.36688|
;;;442        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
008f2c  bf00              NOP      
008f2e  bf00              NOP      
;;;443        if (dhcp->tries <= 8) {
008f30  7b60              LDRB     r0,[r4,#0xd]
008f32  2808              CMP      r0,#8
008f34  dc03              BGT      |L1.36670|
;;;444          dhcp_rebind(netif);
008f36  4628              MOV      r0,r5
008f38  f7fffffe          BL       dhcp_rebind
008f3c  e015              B        |L1.36714|
                  |L1.36670|
;;;445        } else {
;;;446          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
008f3e  bf00              NOP      
008f40  bf00              NOP      
;;;447          dhcp_release(netif);
008f42  4628              MOV      r0,r5
008f44  f7fffffe          BL       dhcp_release
;;;448          dhcp_discover(netif);
008f48  4628              MOV      r0,r5
008f4a  f7fffffe          BL       dhcp_discover
008f4e  e00c              B        |L1.36714|
                  |L1.36688|
;;;449        }
;;;450      } else if (dhcp->state == DHCP_REBOOTING) {
008f50  7b20              LDRB     r0,[r4,#0xc]
008f52  2803              CMP      r0,#3
008f54  d109              BNE      |L1.36714|
;;;451        if (dhcp->tries < REBOOT_TRIES) {
008f56  7b60              LDRB     r0,[r4,#0xd]
008f58  2802              CMP      r0,#2
008f5a  da03              BGE      |L1.36708|
;;;452          dhcp_reboot(netif);
008f5c  4628              MOV      r0,r5
008f5e  f7fffffe          BL       dhcp_reboot
008f62  e002              B        |L1.36714|
                  |L1.36708|
;;;453        } else {
;;;454          dhcp_discover(netif);
008f64  4628              MOV      r0,r5
008f66  f7fffffe          BL       dhcp_discover
                  |L1.36714|
;;;455        }
;;;456      }
;;;457    }
008f6a  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

                  dhcp_fine_tmr PROC
;;;368    void
;;;369    dhcp_fine_tmr()
008f6c  b510              PUSH     {r4,lr}
;;;370    {
;;;371      struct netif *netif = netif_list;
008f6e  482f              LDR      r0,|L1.36908|
008f70  6804              LDR      r4,[r0,#0]  ; netif_list
;;;372      /* loop through netif's */
;;;373      while (netif != NULL) {
008f72  e01a              B        |L1.36778|
                  |L1.36724|
;;;374        /* only act on DHCP configured interfaces */
;;;375        if (netif->dhcp != NULL) {
008f74  6a20              LDR      r0,[r4,#0x20]
008f76  b1b8              CBZ      r0,|L1.36776|
;;;376          /* timer is active (non zero), and is about to trigger now */      
;;;377          if (netif->dhcp->request_timeout > 1) {
008f78  6a20              LDR      r0,[r4,#0x20]
008f7a  8b40              LDRH     r0,[r0,#0x1a]
008f7c  2801              CMP      r0,#1
008f7e  dd05              BLE      |L1.36748|
;;;378            netif->dhcp->request_timeout--;
008f80  6a20              LDR      r0,[r4,#0x20]
008f82  8b40              LDRH     r0,[r0,#0x1a]
008f84  1e40              SUBS     r0,r0,#1
008f86  6a21              LDR      r1,[r4,#0x20]
008f88  8348              STRH     r0,[r1,#0x1a]
008f8a  e00d              B        |L1.36776|
                  |L1.36748|
;;;379          }
;;;380          else if (netif->dhcp->request_timeout == 1) {
008f8c  6a20              LDR      r0,[r4,#0x20]
008f8e  8b40              LDRH     r0,[r0,#0x1a]
008f90  2801              CMP      r0,#1
008f92  d109              BNE      |L1.36776|
;;;381            netif->dhcp->request_timeout--;
008f94  6a20              LDR      r0,[r4,#0x20]
008f96  8b40              LDRH     r0,[r0,#0x1a]
008f98  1e40              SUBS     r0,r0,#1
008f9a  6a21              LDR      r1,[r4,#0x20]
008f9c  8348              STRH     r0,[r1,#0x1a]
;;;382            /* { netif->dhcp->request_timeout == 0 } */
;;;383            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
008f9e  bf00              NOP      
008fa0  bf00              NOP      
;;;384            /* this client's request timeout triggered */
;;;385            dhcp_timeout(netif);
008fa2  4620              MOV      r0,r4
008fa4  f7fffffe          BL       dhcp_timeout
                  |L1.36776|
;;;386          }
;;;387        }
;;;388        /* proceed to next network interface */
;;;389        netif = netif->next;
008fa8  6824              LDR      r4,[r4,#0]
                  |L1.36778|
008faa  2c00              CMP      r4,#0                 ;373
008fac  d1e2              BNE      |L1.36724|
;;;390      }
;;;391    }
008fae  bd10              POP      {r4,pc}
;;;392    
                          ENDP

                  dhcp_timer_fine PROC
;;;164    static void
;;;165    dhcp_timer_fine(void *arg)
008fb0  b510              PUSH     {r4,lr}
;;;166    {
008fb2  4604              MOV      r4,r0
;;;167      LWIP_UNUSED_ARG(arg);
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
008fb4  bf00              NOP      
008fb6  bf00              NOP      
;;;169      dhcp_fine_tmr();
008fb8  f7fffffe          BL       dhcp_fine_tmr
;;;170      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
008fbc  2200              MOVS     r2,#0
008fbe  491c              LDR      r1,|L1.36912|
008fc0  f44f70fa          MOV      r0,#0x1f4
008fc4  f7fffffe          BL       sys_timeout
;;;171    }
008fc8  bd10              POP      {r4,pc}
;;;172    #endif /* LWIP_DHCP */
                          ENDP

                  dhcp_t1_timeout PROC
;;;464    static void
;;;465    dhcp_t1_timeout(struct netif *netif)
008fca  b570              PUSH     {r4-r6,lr}
;;;466    {
008fcc  4605              MOV      r5,r0
;;;467      struct dhcp *dhcp = netif->dhcp;
008fce  6a2c              LDR      r4,[r5,#0x20]
;;;468      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
008fd0  bf00              NOP      
008fd2  bf00              NOP      
;;;469      if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
008fd4  7b20              LDRB     r0,[r4,#0xc]
008fd6  2801              CMP      r0,#1
008fd8  d005              BEQ      |L1.36838|
008fda  7b20              LDRB     r0,[r4,#0xc]
008fdc  280a              CMP      r0,#0xa
008fde  d002              BEQ      |L1.36838|
;;;470          (dhcp->state == DHCP_RENEWING)) {
008fe0  7b20              LDRB     r0,[r4,#0xc]
008fe2  2805              CMP      r0,#5
008fe4  d104              BNE      |L1.36848|
                  |L1.36838|
;;;471        /* just retry to renew - note that the rebind timer (t2) will
;;;472         * eventually time-out if renew tries fail. */
;;;473        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
008fe6  bf00              NOP      
008fe8  bf00              NOP      
;;;474                    ("dhcp_t1_timeout(): must renew\n"));
;;;475        /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
;;;476           DHCP_RENEWING, not DHCP_BOUND */
;;;477        dhcp_renew(netif);
008fea  4628              MOV      r0,r5
008fec  f7fffffe          BL       dhcp_renew
                  |L1.36848|
;;;478      }
;;;479    }
008ff0  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP

                  dhcp_t2_timeout PROC
;;;486    static void
;;;487    dhcp_t2_timeout(struct netif *netif)
008ff2  b570              PUSH     {r4-r6,lr}
;;;488    {
008ff4  4605              MOV      r5,r0
;;;489      struct dhcp *dhcp = netif->dhcp;
008ff6  6a2c              LDR      r4,[r5,#0x20]
;;;490      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
008ff8  bf00              NOP      
008ffa  bf00              NOP      
;;;491      if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
008ffc  7b20              LDRB     r0,[r4,#0xc]
008ffe  2801              CMP      r0,#1
009000  d005              BEQ      |L1.36878|
009002  7b20              LDRB     r0,[r4,#0xc]
009004  280a              CMP      r0,#0xa
009006  d002              BEQ      |L1.36878|
;;;492          (dhcp->state == DHCP_RENEWING)) {
009008  7b20              LDRB     r0,[r4,#0xc]
00900a  2805              CMP      r0,#5
00900c  d104              BNE      |L1.36888|
                  |L1.36878|
;;;493        /* just retry to rebind */
;;;494        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
00900e  bf00              NOP      
009010  bf00              NOP      
;;;495                    ("dhcp_t2_timeout(): must rebind\n"));
;;;496        /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
;;;497           DHCP_REBINDING, not DHCP_BOUND */
;;;498        dhcp_rebind(netif);
009012  4628              MOV      r0,r5
009014  f7fffffe          BL       dhcp_rebind
                  |L1.36888|
;;;499      }
;;;500    }
009018  bd70              POP      {r4-r6,pc}
00901a  0000              DCW      0x0000
                  |L1.36892|
                          DCD      lwip_stats
                  |L1.36896|
                          DCD      arp_table
                  |L1.36900|
                          DCD      etharp_cached_entry
                  |L1.36904|
                          DCD      ip_addr_broadcast
                  |L1.36908|
                          DCD      netif_list
                  |L1.36912|
                          DCD      dhcp_timer_fine
                          ENDP

                  dhcp_coarse_tmr PROC
;;;336    void
;;;337    dhcp_coarse_tmr()
009034  b510              PUSH     {r4,lr}
;;;338    {
;;;339      struct netif *netif = netif_list;
009036  48fc              LDR      r0,|L1.37928|
009038  6804              LDR      r4,[r0,#0]  ; netif_list
;;;340      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
00903a  bf00              NOP      
00903c  bf00              NOP      
;;;341      /* iterate through all network interfaces */
;;;342      while (netif != NULL) {
00903e  e01b              B        |L1.36984|
                  |L1.36928|
;;;343        /* only act on DHCP configured interfaces */
;;;344        if (netif->dhcp != NULL) {
009040  6a20              LDR      r0,[r4,#0x20]
009042  b1c0              CBZ      r0,|L1.36982|
;;;345          /* timer is active (non zero), and triggers (zeroes) now? */
;;;346          if (netif->dhcp->t2_timeout-- == 1) {
009044  6a20              LDR      r0,[r4,#0x20]
009046  8bc1              LDRH     r1,[r0,#0x1e]
009048  1e48              SUBS     r0,r1,#1
00904a  6a22              LDR      r2,[r4,#0x20]
00904c  83d0              STRH     r0,[r2,#0x1e]
00904e  2901              CMP      r1,#1
009050  d105              BNE      |L1.36958|
;;;347            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
009052  bf00              NOP      
009054  bf00              NOP      
;;;348            /* this clients' rebind timeout triggered */
;;;349            dhcp_t2_timeout(netif);
009056  4620              MOV      r0,r4
009058  f7fffffe          BL       dhcp_t2_timeout
00905c  e00b              B        |L1.36982|
                  |L1.36958|
;;;350          /* timer is active (non zero), and triggers (zeroes) now */
;;;351          } else if (netif->dhcp->t1_timeout-- == 1) {
00905e  6a20              LDR      r0,[r4,#0x20]
009060  8b81              LDRH     r1,[r0,#0x1c]
009062  1e48              SUBS     r0,r1,#1
009064  6a22              LDR      r2,[r4,#0x20]
009066  8390              STRH     r0,[r2,#0x1c]
009068  2901              CMP      r1,#1
00906a  d104              BNE      |L1.36982|
;;;352            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
00906c  bf00              NOP      
00906e  bf00              NOP      
;;;353            /* this clients' renewal timeout triggered */
;;;354            dhcp_t1_timeout(netif);
009070  4620              MOV      r0,r4
009072  f7fffffe          BL       dhcp_t1_timeout
                  |L1.36982|
;;;355          }
;;;356        }
;;;357        /* proceed to next netif */
;;;358        netif = netif->next;
009076  6824              LDR      r4,[r4,#0]
                  |L1.36984|
009078  2c00              CMP      r4,#0                 ;342
00907a  d1e1              BNE      |L1.36928|
;;;359      }
;;;360    }
00907c  bd10              POP      {r4,pc}
;;;361    
                          ENDP

                  dhcp_timer_coarse PROC
;;;150    static void
;;;151    dhcp_timer_coarse(void *arg)
00907e  b510              PUSH     {r4,lr}
;;;152    {
009080  4604              MOV      r4,r0
;;;153      LWIP_UNUSED_ARG(arg);
;;;154      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
009082  bf00              NOP      
009084  bf00              NOP      
;;;155      dhcp_coarse_tmr();
009086  f7fffffe          BL       dhcp_coarse_tmr
;;;156      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00908a  2200              MOVS     r2,#0
00908c  49e7              LDR      r1,|L1.37932|
00908e  f64e2060          MOV      r0,#0xea60
009092  f7fffffe          BL       sys_timeout
;;;157    }
009096  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
009098  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
00909a  bf00              NOP      
00909c  bf00              NOP      
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
00909e  2400              MOVS     r4,#0
0090a0  e03f              B        |L1.37154|
                  |L1.37026|
;;;213        u8_t state = arp_table[i].state;
0090a2  eb040084          ADD      r0,r4,r4,LSL #2
0090a6  49e2              LDR      r1,|L1.37936|
0090a8  eb010080          ADD      r0,r1,r0,LSL #2
0090ac  7c85              LDRB     r5,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
0090ae  b335              CBZ      r5,|L1.37118|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
0090b0  eb040084          ADD      r0,r4,r4,LSL #2
0090b4  eb010080          ADD      r0,r1,r0,LSL #2
0090b8  7cc0              LDRB     r0,[r0,#0x13]
0090ba  1c40              ADDS     r0,r0,#1
0090bc  eb040184          ADD      r1,r4,r4,LSL #2
0090c0  4adb              LDR      r2,|L1.37936|
0090c2  eb020181          ADD      r1,r2,r1,LSL #2
0090c6  74c8              STRB     r0,[r1,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
0090c8  eb040084          ADD      r0,r4,r4,LSL #2
0090cc  4611              MOV      r1,r2
0090ce  eb010080          ADD      r0,r1,r0,LSL #2
0090d2  7cc0              LDRB     r0,[r0,#0x13]
0090d4  28f0              CMP      r0,#0xf0
0090d6  da0d              BGE      |L1.37108|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
0090d8  eb040084          ADD      r0,r4,r4,LSL #2
0090dc  eb010080          ADD      r0,r1,r0,LSL #2
0090e0  7c80              LDRB     r0,[r0,#0x12]
0090e2  2801              CMP      r0,#1
0090e4  d10c              BNE      |L1.37120|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
0090e6  eb040084          ADD      r0,r4,r4,LSL #2
0090ea  eb010080          ADD      r0,r1,r0,LSL #2
0090ee  7cc0              LDRB     r0,[r0,#0x13]
0090f0  2802              CMP      r0,#2
0090f2  db05              BLT      |L1.37120|
                  |L1.37108|
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
0090f4  bf00              NOP      
0090f6  bf00              NOP      
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
0090f8  4620              MOV      r0,r4
0090fa  f7fffffe          BL       etharp_free_entry
                  |L1.37118|
0090fe  e00e              B        |L1.37150|
                  |L1.37120|
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
009100  eb040084          ADD      r0,r4,r4,LSL #2
009104  49ca              LDR      r1,|L1.37936|
009106  eb010080          ADD      r0,r1,r0,LSL #2
00910a  7c80              LDRB     r0,[r0,#0x12]
00910c  2803              CMP      r0,#3
00910e  d106              BNE      |L1.37150|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
009110  2002              MOVS     r0,#2
009112  eb040184          ADD      r1,r4,r4,LSL #2
009116  4ac6              LDR      r2,|L1.37936|
009118  eb020181          ADD      r1,r2,r1,LSL #2
00911c  7488              STRB     r0,[r1,#0x12]
                  |L1.37150|
00911e  1c60              ADDS     r0,r4,#1              ;212
009120  b2c4              UXTB     r4,r0                 ;212
                  |L1.37154|
009122  2c0a              CMP      r4,#0xa               ;212
009124  dbbd              BLT      |L1.37026|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
009126  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  arp_timer PROC
;;;134    static void
;;;135    arp_timer(void *arg)
009128  b510              PUSH     {r4,lr}
;;;136    {
00912a  4604              MOV      r4,r0
;;;137      LWIP_UNUSED_ARG(arg);
;;;138      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
00912c  bf00              NOP      
00912e  bf00              NOP      
;;;139      etharp_tmr();
009130  f7fffffe          BL       etharp_tmr
;;;140      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
009134  2200              MOVS     r2,#0
009136  49bf              LDR      r1,|L1.37940|
009138  f2413088          MOV      r0,#0x1388
00913c  f7fffffe          BL       sys_timeout
;;;141    }
009140  bd10              POP      {r4,pc}
;;;142    #endif /* LWIP_ARP */
                          ENDP

                  sys_timeouts_init PROC
;;;222    /** Initialize this module */
;;;223    void sys_timeouts_init(void)
009142  b510              PUSH     {r4,lr}
;;;224    {
;;;225    #if IP_REASSEMBLY
;;;226      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
;;;227    #endif /* IP_REASSEMBLY */
;;;228    #if LWIP_ARP
;;;229      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
009144  2200              MOVS     r2,#0
009146  49bb              LDR      r1,|L1.37940|
009148  f2413088          MOV      r0,#0x1388
00914c  f7fffffe          BL       sys_timeout
;;;230    #endif /* LWIP_ARP */
;;;231    #if LWIP_DHCP
;;;232      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
009150  2200              MOVS     r2,#0
009152  49b6              LDR      r1,|L1.37932|
009154  f64e2060          MOV      r0,#0xea60
009158  f7fffffe          BL       sys_timeout
;;;233      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
00915c  2200              MOVS     r2,#0
00915e  49b6              LDR      r1,|L1.37944|
009160  f44f70fa          MOV      r0,#0x1f4
009164  f7fffffe          BL       sys_timeout
;;;234    #endif /* LWIP_DHCP */
;;;235    #if LWIP_AUTOIP
;;;236      sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
009168  2200              MOVS     r2,#0
00916a  49b4              LDR      r1,|L1.37948|
00916c  2064              MOVS     r0,#0x64
00916e  f7fffffe          BL       sys_timeout
;;;237    #endif /* LWIP_AUTOIP */
;;;238    #if LWIP_IGMP
;;;239      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
009172  2200              MOVS     r2,#0
009174  49b2              LDR      r1,|L1.37952|
009176  2064              MOVS     r0,#0x64
009178  f7fffffe          BL       sys_timeout
;;;240    #endif /* LWIP_IGMP */
;;;241    #if LWIP_DNS
;;;242      sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
;;;243    #endif /* LWIP_DNS */
;;;244    
;;;245    #if NO_SYS
;;;246      /* Initialise timestamp for sys_check_timeouts */
;;;247      timeouts_last_time = sys_now();
;;;248    #endif
;;;249    }
00917c  bd10              POP      {r4,pc}
;;;250    
                          ENDP

                  igmp_init PROC
;;;155    void
;;;156    igmp_init(void)
00917e  bf00              NOP      
;;;157    {
;;;158      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_init: initializing\n"));
009180  bf00              NOP      
;;;159    
;;;160      IP4_ADDR(&allsystems, 224, 0, 0, 1);
009182  48b0              LDR      r0,|L1.37956|
009184  49b0              LDR      r1,|L1.37960|
009186  6008              STR      r0,[r1,#0]  ; allsystems
;;;161      IP4_ADDR(&allrouters, 224, 0, 0, 2);
009188  48b0              LDR      r0,|L1.37964|
00918a  49b1              LDR      r1,|L1.37968|
00918c  6008              STR      r0,[r1,#0]  ; allrouters
;;;162    }
00918e  4770              BX       lr
;;;163    
                          ENDP

                  tcp_init PROC
;;;130    void
;;;131    tcp_init(void)
009190  4770              BX       lr
;;;132    {
;;;133    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;134      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;135    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;136    }
;;;137    
                          ENDP

                  udp_init PROC
;;;85     void
;;;86     udp_init(void)
009192  4770              BX       lr
;;;87     {
;;;88     #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;89       udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;90     #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;91     }
;;;92     
                          ENDP

                  netif_init PROC
;;;105    void
;;;106    netif_init(void)
009194  4770              BX       lr
;;;107    {
;;;108    #if LWIP_HAVE_LOOPIF
;;;109      ip_addr_t loop_ipaddr, loop_netmask, loop_gw;
;;;110      IP4_ADDR(&loop_gw, 127,0,0,1);
;;;111      IP4_ADDR(&loop_ipaddr, 127,0,0,1);
;;;112      IP4_ADDR(&loop_netmask, 255,0,0,0);
;;;113    
;;;114    #if NO_SYS
;;;115      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, ip_input);
;;;116    #else  /* NO_SYS */
;;;117      netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
;;;118    #endif /* NO_SYS */
;;;119      netif_set_up(&loop_netif);
;;;120    
;;;121    #endif /* LWIP_HAVE_LOOPIF */
;;;122    }
;;;123    
                          ENDP

                  memp_init PROC
;;;337    void
;;;338    memp_init(void)
009196  b530              PUSH     {r4,r5,lr}
;;;339    {
;;;340      struct memp *memp;
;;;341      u16_t i, j;
;;;342    
;;;343      for (i = 0; i < MEMP_MAX; ++i) {
009198  2000              MOVS     r0,#0
00919a  e01d              B        |L1.37336|
                  |L1.37276|
;;;344        MEMP_STATS_AVAIL(used, i, 0);
00919c  2400              MOVS     r4,#0
00919e  eb000580          ADD      r5,r0,r0,LSL #2
0091a2  4bac              LDR      r3,|L1.37972|
0091a4  eb030385          ADD      r3,r3,r5,LSL #2
0091a8  609c              STR      r4,[r3,#8]
;;;345        MEMP_STATS_AVAIL(max, i, 0);
0091aa  eb000580          ADD      r5,r0,r0,LSL #2
0091ae  4ba9              LDR      r3,|L1.37972|
0091b0  eb030385          ADD      r3,r3,r5,LSL #2
0091b4  60dc              STR      r4,[r3,#0xc]
;;;346        MEMP_STATS_AVAIL(err, i, 0);
0091b6  eb000580          ADD      r5,r0,r0,LSL #2
0091ba  4ba6              LDR      r3,|L1.37972|
0091bc  eb030385          ADD      r3,r3,r5,LSL #2
0091c0  821c              STRH     r4,[r3,#0x10]
;;;347        MEMP_STATS_AVAIL(avail, i, memp_num[i]);
0091c2  4ba5              LDR      r3,|L1.37976|
0091c4  f8334010          LDRH     r4,[r3,r0,LSL #1]
0091c8  eb000580          ADD      r5,r0,r0,LSL #2
0091cc  4ba1              LDR      r3,|L1.37972|
0091ce  eb030385          ADD      r3,r3,r5,LSL #2
0091d2  605c              STR      r4,[r3,#4]
0091d4  1c43              ADDS     r3,r0,#1              ;343
0091d6  b298              UXTH     r0,r3                 ;343
                  |L1.37336|
0091d8  280d              CMP      r0,#0xd               ;343
0091da  dbdf              BLT      |L1.37276|
;;;348      }
;;;349    
;;;350    #if !MEMP_SEPARATE_POOLS
;;;351      memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
0091dc  4b9f              LDR      r3,|L1.37980|
0091de  f0230103          BIC      r1,r3,#3
;;;352    #endif /* !MEMP_SEPARATE_POOLS */
;;;353      /* for every pool: */
;;;354      for (i = 0; i < MEMP_MAX; ++i) {
0091e2  2000              MOVS     r0,#0
0091e4  e019              B        |L1.37402|
                  |L1.37350|
;;;355        memp_tab[i] = NULL;
0091e6  2300              MOVS     r3,#0
0091e8  4c9d              LDR      r4,|L1.37984|
0091ea  f8443020          STR      r3,[r4,r0,LSL #2]
;;;356    #if MEMP_SEPARATE_POOLS
;;;357        memp = (struct memp*)memp_bases[i];
;;;358    #endif /* MEMP_SEPARATE_POOLS */
;;;359        /* create a linked list of memp elements */
;;;360        for (j = 0; j < memp_num[i]; ++j) {
0091ee  2200              MOVS     r2,#0
0091f0  e00c              B        |L1.37388|
                  |L1.37362|
;;;361          memp->next = memp_tab[i];
0091f2  4b9b              LDR      r3,|L1.37984|
0091f4  f8533020          LDR      r3,[r3,r0,LSL #2]
0091f8  600b              STR      r3,[r1,#0]
;;;362          memp_tab[i] = memp;
0091fa  4b99              LDR      r3,|L1.37984|
0091fc  f8431020          STR      r1,[r3,r0,LSL #2]
;;;363          memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
009200  4b98              LDR      r3,|L1.37988|
009202  f8333010          LDRH     r3,[r3,r0,LSL #1]
009206  4419              ADD      r1,r1,r3
009208  1c53              ADDS     r3,r2,#1              ;360
00920a  b29a              UXTH     r2,r3                 ;360
                  |L1.37388|
00920c  4b92              LDR      r3,|L1.37976|
00920e  f8333010          LDRH     r3,[r3,r0,LSL #1]     ;360
009212  4293              CMP      r3,r2                 ;360
009214  dced              BGT      |L1.37362|
009216  1c43              ADDS     r3,r0,#1              ;354
009218  b298              UXTH     r0,r3                 ;354
                  |L1.37402|
00921a  280d              CMP      r0,#0xd               ;354
00921c  dbe3              BLT      |L1.37350|
;;;364    #if MEMP_OVERFLOW_CHECK
;;;365            + MEMP_SANITY_REGION_AFTER_ALIGNED
;;;366    #endif
;;;367          );
;;;368        }
;;;369      }
;;;370    #if MEMP_OVERFLOW_CHECK
;;;371      memp_overflow_init();
;;;372      /* check everything a first time to see if it worked */
;;;373      memp_overflow_check_all();
;;;374    #endif /* MEMP_OVERFLOW_CHECK */
;;;375    }
00921e  bd30              POP      {r4,r5,pc}
;;;376    
                          ENDP

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
009220  b510              PUSH     {r4,lr}
;;;275    {
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
009222  bf00              NOP      
009224  bf00              NOP      
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
009226  4890              LDR      r0,|L1.37992|
009228  f0200003          BIC      r0,r0,#3
00922c  498f              LDR      r1,|L1.37996|
00922e  6008              STR      r0,[r1,#0]  ; ram
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
009230  4608              MOV      r0,r1
009232  6804              LDR      r4,[r0,#0]  ; ram
;;;285      mem->next = MEM_SIZE_ALIGNED;
009234  f44f3080          MOV      r0,#0x10000
009238  6020              STR      r0,[r4,#0]
;;;286      mem->prev = 0;
00923a  2000              MOVS     r0,#0
00923c  6060              STR      r0,[r4,#4]
;;;287      mem->used = 0;
00923e  7220              STRB     r0,[r4,#8]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
009240  4608              MOV      r0,r1
009242  6800              LDR      r0,[r0,#0]  ; ram
009244  f5003080          ADD      r0,r0,#0x10000
009248  4989              LDR      r1,|L1.38000|
00924a  6008              STR      r0,[r1,#0]  ; ram_end
;;;290      ram_end->used = 1;
00924c  2001              MOVS     r0,#1
00924e  6809              LDR      r1,[r1,#0]  ; ram_end
009250  7208              STRB     r0,[r1,#8]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
009252  0400              LSLS     r0,r0,#16
009254  4986              LDR      r1,|L1.38000|
009256  6809              LDR      r1,[r1,#0]  ; ram_end
009258  6008              STR      r0,[r1,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
00925a  4985              LDR      r1,|L1.38000|
00925c  6809              LDR      r1,[r1,#0]  ; ram_end
00925e  6048              STR      r0,[r1,#4]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
009260  4882              LDR      r0,|L1.37996|
009262  6800              LDR      r0,[r0,#0]  ; ram
009264  4983              LDR      r1,|L1.38004|
009266  6008              STR      r0,[r1,#0]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
009268  f44f3180          MOV      r1,#0x10000
00926c  4879              LDR      r0,|L1.37972|
00926e  38c0              SUBS     r0,r0,#0xc0
009270  f8c010b0          STR      r1,[r0,#0xb0]
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
009274  2101              MOVS     r1,#1
009276  4880              LDR      r0,|L1.38008|
009278  f7fffffe          BL       sys_sem_new
00927c  b108              CBZ      r0,|L1.37506|
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
00927e  bf00              NOP      
009280  bf00              NOP      
                  |L1.37506|
;;;301      }
;;;302    }
009282  bd10              POP      {r4,pc}
;;;303    
                          ENDP

                  sys_init PROC
;;;156    void
;;;157    sys_init(void)
009284  2000              MOVS     r0,#0
;;;158    {
;;;159      u32_t i;
;;;160    
;;;161      /* Clear out the mailboxes. */
;;;162      for(i = 0; i < SYS_MBOX_MAX; i++) {
009286  e006              B        |L1.37526|
                  |L1.37512|
;;;163        mboxes[i].queue = 0;
009288  2100              MOVS     r1,#0
00928a  eb001200          ADD      r2,r0,r0,LSL #4
00928e  4b7b              LDR      r3,|L1.38012|
009290  f8431032          STR      r1,[r3,r2,LSL #3]
009294  1c40              ADDS     r0,r0,#1              ;162
                  |L1.37526|
009296  2810              CMP      r0,#0x10              ;162
009298  d3f6              BCC      |L1.37512|
;;;164      }
;;;165    
;;;166      /* Clear out the semaphores. */
;;;167      for(i = 0; i < SYS_SEM_MAX; i++) {
00929a  2000              MOVS     r0,#0
00929c  e006              B        |L1.37548|
                  |L1.37534|
;;;168        sems[i].queue = 0;
00929e  2100              MOVS     r1,#0
0092a0  eb000240          ADD      r2,r0,r0,LSL #1
0092a4  4b76              LDR      r3,|L1.38016|
0092a6  f8431022          STR      r1,[r3,r2,LSL #2]
0092aa  1c40              ADDS     r0,r0,#1              ;167
                  |L1.37548|
0092ac  2810              CMP      r0,#0x10              ;167
0092ae  d3f6              BCC      |L1.37534|
;;;169      }
;;;170    
;;;171      /* Clear out the threads. */
;;;172      for(i = 0; i < SYS_THREAD_MAX; i++) {
0092b0  2000              MOVS     r0,#0
0092b2  e00b              B        |L1.37580|
                  |L1.37556|
;;;173        threads[i].stackstart = NULL;
0092b4  2100              MOVS     r1,#0
0092b6  eb000280          ADD      r2,r0,r0,LSL #2
0092ba  4b72              LDR      r3,|L1.38020|
0092bc  f8431022          STR      r1,[r3,r2,LSL #2]
;;;174        threads[i].stackend = NULL;
0092c0  eb000280          ADD      r2,r0,r0,LSL #2
0092c4  eb030282          ADD      r2,r3,r2,LSL #2
0092c8  6051              STR      r1,[r2,#4]
0092ca  1c40              ADDS     r0,r0,#1              ;172
                  |L1.37580|
0092cc  2807              CMP      r0,#7                 ;172
0092ce  d3f1              BCC      |L1.37556|
;;;175      }
;;;176    }
0092d0  4770              BX       lr
;;;177    
                          ENDP

                  stats_init PROC
;;;50     
;;;51     void stats_init(void)
0092d2  b510              PUSH     {r4,lr}
;;;52     {
0092d4  b08e              SUB      sp,sp,#0x38
;;;53     #ifdef LWIP_DEBUG
;;;54     #if MEMP_STATS
;;;55       const char * memp_names[] = {
0092d6  2234              MOVS     r2,#0x34
0092d8  496b              LDR      r1,|L1.38024|
0092da  a801              ADD      r0,sp,#4
0092dc  f7fffffe          BL       __aeabi_memcpy4
;;;56     #define LWIP_MEMPOOL(name,num,size,desc) desc,
;;;57     #include "lwip/memp_std.h"
;;;1      /*
;;;2       * SETUP: Make sure we define everything we will need.
;;;3       *
;;;4       * We have create three types of pools:
;;;5       *   1) MEMPOOL - standard pools
;;;6       *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
;;;7       *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
;;;8       *
;;;9       * If the include'r doesn't require any special treatment of each of the types
;;;10      * above, then will declare #2 & #3 to be just standard mempools.
;;;11      */
;;;12     #ifndef LWIP_MALLOC_MEMPOOL
;;;13     /* This treats "malloc pools" just like any other pool.
;;;14        The pools are a little bigger to provide 'size' as the amount of user data. */
;;;15     #define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
;;;16     #define LWIP_MALLOC_MEMPOOL_START
;;;17     #define LWIP_MALLOC_MEMPOOL_END
;;;18     #endif /* LWIP_MALLOC_MEMPOOL */ 
;;;19     
;;;20     #ifndef LWIP_PBUF_MEMPOOL
;;;21     /* This treats "pbuf pools" just like any other pool.
;;;22      * Allocates buffers for a pbuf struct AND a payload size */
;;;23     #define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
;;;24     #endif /* LWIP_PBUF_MEMPOOL */
;;;25     
;;;26     
;;;27     /*
;;;28      * A list of internal pools used by LWIP.
;;;29      *
;;;30      * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
;;;31      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;32      */
;;;33     #if LWIP_RAW
;;;34     LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
;;;35     #endif /* LWIP_RAW */
;;;36     
;;;37     #if LWIP_UDP
;;;38     LWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
;;;39     #endif /* LWIP_UDP */
;;;40     
;;;41     #if LWIP_TCP
;;;42     LWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
;;;43     LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
;;;44     LWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
;;;45     #endif /* LWIP_TCP */
;;;46     
;;;47     #if IP_REASSEMBLY
;;;48     LWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
;;;49     #endif /* IP_REASSEMBLY */
;;;50     #if IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;51     LWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
;;;52     #endif /* IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF */
;;;53     
;;;54     #if LWIP_NETCONN
;;;55     LWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
;;;56     LWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
;;;57     #endif /* LWIP_NETCONN */
;;;58     
;;;59     #if NO_SYS==0
;;;60     LWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
;;;61     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;62     LWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
;;;63     #endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;64     #endif /* NO_SYS==0 */
;;;65     
;;;66     #if LWIP_ARP && ARP_QUEUEING
;;;67     LWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
;;;68     #endif /* LWIP_ARP && ARP_QUEUEING */
;;;69     
;;;70     #if LWIP_IGMP
;;;71     LWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
;;;72     #endif /* LWIP_IGMP */
;;;73     
;;;74     #if (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS)) /* LWIP_TIMERS */
;;;75     LWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
;;;76     #endif /* LWIP_TIMERS */
;;;77     
;;;78     #if LWIP_SNMP
;;;79     LWIP_MEMPOOL(SNMP_ROOTNODE,  MEMP_NUM_SNMP_ROOTNODE,   sizeof(struct mib_list_rootnode), "SNMP_ROOTNODE")
;;;80     LWIP_MEMPOOL(SNMP_NODE,      MEMP_NUM_SNMP_NODE,       sizeof(struct mib_list_node),     "SNMP_NODE")
;;;81     LWIP_MEMPOOL(SNMP_VARBIND,   MEMP_NUM_SNMP_VARBIND,    sizeof(struct snmp_varbind),      "SNMP_VARBIND")
;;;82     LWIP_MEMPOOL(SNMP_VALUE,     MEMP_NUM_SNMP_VALUE,      SNMP_MAX_VALUE_SIZE,              "SNMP_VALUE")
;;;83     #endif /* LWIP_SNMP */
;;;84     #if LWIP_DNS && LWIP_SOCKET
;;;85     LWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
;;;86     #endif /* LWIP_DNS && LWIP_SOCKET */
;;;87     #if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
;;;88     LWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
;;;89     #endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
;;;90     #if PPP_SUPPORT && PPPOE_SUPPORT
;;;91     LWIP_MEMPOOL(PPPOE_IF,      MEMP_NUM_PPPOE_INTERFACES, sizeof(struct pppoe_softc),    "PPPOE_IF")
;;;92     #endif /* PPP_SUPPORT && PPPOE_SUPPORT */
;;;93     
;;;94     /*
;;;95      * A list of pools of pbuf's used by LWIP.
;;;96      *
;;;97      * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
;;;98      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;99      *     This allocates enough space for the pbuf struct and a payload.
;;;100     *     (Example: pbuf_payload_size=0 allocates only size for the struct)
;;;101     */
;;;102    LWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
;;;103    LWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
;;;104    
;;;105    
;;;106    /*
;;;107     * Allow for user-defined pools; this must be explicitly set in lwipopts.h
;;;108     * since the default is to NOT look for lwippools.h
;;;109     */
;;;110    #if MEMP_USE_CUSTOM_POOLS
;;;111    #include "lwippools.h"
;;;112    #endif /* MEMP_USE_CUSTOM_POOLS */
;;;113    
;;;114    /*
;;;115     * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
;;;116     * (#undef is ignored for something that is not defined)
;;;117     */
;;;118    #undef LWIP_MEMPOOL
;;;119    #undef LWIP_MALLOC_MEMPOOL
;;;120    #undef LWIP_MALLOC_MEMPOOL_START
;;;121    #undef LWIP_MALLOC_MEMPOOL_END
;;;122    #undef LWIP_PBUF_MEMPOOL
;;;58       };
;;;59       int i;
;;;60       for (i = 0; i < MEMP_MAX; i++) {
0092e0  2400              MOVS     r4,#0
0092e2  e008              B        |L1.37622|
                  |L1.37604|
;;;61         lwip_stats.memp[i].name = memp_names[i];
0092e4  a801              ADD      r0,sp,#4
0092e6  f8501024          LDR      r1,[r0,r4,LSL #2]
0092ea  eb040284          ADD      r2,r4,r4,LSL #2
0092ee  4859              LDR      r0,|L1.37972|
0092f0  f8401022          STR      r1,[r0,r2,LSL #2]
0092f4  1c64              ADDS     r4,r4,#1              ;60
                  |L1.37622|
0092f6  2c0d              CMP      r4,#0xd               ;60
0092f8  dbf4              BLT      |L1.37604|
;;;62       }
;;;63     #endif /* MEMP_STATS */
;;;64     #if MEM_STATS
;;;65       lwip_stats.mem.name = "MEM";
0092fa  a064              ADR      r0,|L1.38028|
0092fc  4955              LDR      r1,|L1.37972|
0092fe  39c0              SUBS     r1,r1,#0xc0
009300  f8c100ac          STR      r0,[r1,#0xac]  ; lwip_stats
;;;66     #endif /* MEM_STATS */
;;;67     #endif /* LWIP_DEBUG */
;;;68     }
009304  b00e              ADD      sp,sp,#0x38
009306  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  lwip_init PROC
;;;288    void
;;;289    lwip_init(void)
009308  b510              PUSH     {r4,lr}
;;;290    {
;;;291      /* Modules initialization */
;;;292      stats_init();
00930a  f7fffffe          BL       stats_init
;;;293    #if !NO_SYS
;;;294      sys_init();
00930e  f7fffffe          BL       sys_init
;;;295    #endif /* !NO_SYS */
;;;296      mem_init();
009312  f7fffffe          BL       mem_init
;;;297      memp_init();
009316  f7fffffe          BL       memp_init
;;;298      pbuf_init();
;;;299      netif_init();
00931a  f7fffffe          BL       netif_init
;;;300    #if LWIP_SOCKET
;;;301      lwip_socket_init();
;;;302    #endif /* LWIP_SOCKET */
;;;303      ip_init();
;;;304    #if LWIP_ARP
;;;305      etharp_init();
;;;306    #endif /* LWIP_ARP */
;;;307    #if LWIP_RAW
;;;308      raw_init();
;;;309    #endif /* LWIP_RAW */
;;;310    #if LWIP_UDP
;;;311      udp_init();
00931e  f7fffffe          BL       udp_init
;;;312    #endif /* LWIP_UDP */
;;;313    #if LWIP_TCP
;;;314      tcp_init();
009322  f7fffffe          BL       tcp_init
;;;315    #endif /* LWIP_TCP */
;;;316    #if LWIP_SNMP
;;;317      snmp_init();
;;;318    #endif /* LWIP_SNMP */
;;;319    #if LWIP_AUTOIP
;;;320      autoip_init();
;;;321    #endif /* LWIP_AUTOIP */
;;;322    #if LWIP_IGMP
;;;323      igmp_init();
009326  f7fffffe          BL       igmp_init
;;;324    #endif /* LWIP_IGMP */
;;;325    #if LWIP_DNS
;;;326      dns_init();
;;;327    #endif /* LWIP_DNS */
;;;328    
;;;329    #if LWIP_TIMERS
;;;330      sys_timeouts_init();
00932a  f7fffffe          BL       sys_timeouts_init
;;;331    #endif /* LWIP_TIMERS */
;;;332    }
00932e  bd10              POP      {r4,pc}
;;;68     #include "third_party/lwip-1.4.1/src/core/mem.c"
                          ENDP

                  tcpip_init PROC
;;;458    void
;;;459    tcpip_init(tcpip_init_done_fn initfunc, void *arg)
009330  b538              PUSH     {r3-r5,lr}
;;;460    {
009332  4604              MOV      r4,r0
009334  460d              MOV      r5,r1
;;;461      lwip_init();
009336  f7fffffe          BL       lwip_init
;;;462    
;;;463      tcpip_init_done = initfunc;
00933a  4855              LDR      r0,|L1.38032|
00933c  6004              STR      r4,[r0,#0]  ; tcpip_init_done
;;;464      tcpip_init_done_arg = arg;
00933e  4855              LDR      r0,|L1.38036|
009340  6005              STR      r5,[r0,#0]  ; tcpip_init_done_arg
;;;465      if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
009342  2120              MOVS     r1,#0x20
009344  4854              LDR      r0,|L1.38040|
009346  f7fffffe          BL       sys_mbox_new
00934a  b108              CBZ      r0,|L1.37712|
;;;466        LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
00934c  bf00              NOP      
00934e  bf00              NOP      
                  |L1.37712|
;;;467      }
;;;468    #if LWIP_TCPIP_CORE_LOCKING
;;;469      if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
;;;470        LWIP_ASSERT("failed to create lock_tcpip_core", 0);
;;;471      }
;;;472    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;473    
;;;474      sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
009350  2004              MOVS     r0,#4
009352  f44f53a0          MOV      r3,#0x1400
009356  2200              MOVS     r2,#0
009358  4950              LDR      r1,|L1.38044|
00935a  9000              STR      r0,[sp,#0]
00935c  a050              ADR      r0,|L1.38048|
00935e  f7fffffe          BL       sys_thread_new
;;;475    	
;;;476    //	sys_thread_new("web", web_task, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO+2);
;;;477    }
009362  bd38              POP      {r3-r5,pc}
;;;478     
                          ENDP

                  pbuf_free_int PROC
;;;485    static void
;;;486    pbuf_free_int(void *p)
009364  b570              PUSH     {r4-r6,lr}
;;;487    {
009366  4604              MOV      r4,r0
;;;488      struct pbuf *q = (struct pbuf *)p;
009368  4625              MOV      r5,r4
;;;489      pbuf_free(q);
00936a  4628              MOV      r0,r5
00936c  f7fffffe          BL       pbuf_free
;;;490    }
009370  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

                  pbuf_free_callback PROC
;;;498    err_t
;;;499    pbuf_free_callback(struct pbuf *p)
009372  b510              PUSH     {r4,lr}
;;;500    {
009374  4604              MOV      r4,r0
;;;501      return tcpip_callback_with_block(pbuf_free_int, p, 0);
009376  2200              MOVS     r2,#0
009378  4621              MOV      r1,r4
00937a  484d              LDR      r0,|L1.38064|
00937c  f7fffffe          BL       tcpip_callback_with_block
;;;502    }
009380  bd10              POP      {r4,pc}
;;;503    
                          ENDP

                  mem_free_callback PROC
;;;511    err_t
;;;512    mem_free_callback(void *m)
009382  b510              PUSH     {r4,lr}
;;;513    {
009384  4604              MOV      r4,r0
;;;514      return tcpip_callback_with_block(mem_free, m, 0);
009386  2200              MOVS     r2,#0
009388  4621              MOV      r1,r4
00938a  484a              LDR      r0,|L1.38068|
00938c  f7fffffe          BL       tcpip_callback_with_block
;;;515    }
009390  bd10              POP      {r4,pc}
;;;516    
                          ENDP

                  dhcp_handle_nak PROC
;;;196    static void
;;;197    dhcp_handle_nak(struct netif *netif)
009392  b570              PUSH     {r4-r6,lr}
;;;198    {
009394  4604              MOV      r4,r0
;;;199      struct dhcp *dhcp = netif->dhcp;
009396  6a25              LDR      r5,[r4,#0x20]
;;;200      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
009398  bf00              NOP      
00939a  bf00              NOP      
;;;201        (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;202      /* Set the interface down since the address must no longer be used, as per RFC2131 */
;;;203      netif_set_down(netif);
00939c  4620              MOV      r0,r4
00939e  f7fffffe          BL       netif_set_down
;;;204      /* remove IP address from interface */
;;;205      netif_set_ipaddr(netif, IP_ADDR_ANY);
0093a2  4945              LDR      r1,|L1.38072|
0093a4  4620              MOV      r0,r4
0093a6  f7fffffe          BL       netif_set_ipaddr
;;;206      netif_set_gw(netif, IP_ADDR_ANY);
0093aa  4943              LDR      r1,|L1.38072|
0093ac  4620              MOV      r0,r4
0093ae  f7fffffe          BL       netif_set_gw
;;;207      netif_set_netmask(netif, IP_ADDR_ANY); 
0093b2  4941              LDR      r1,|L1.38072|
0093b4  4620              MOV      r0,r4
0093b6  f7fffffe          BL       netif_set_netmask
;;;208      /* Change to a defined state */
;;;209      dhcp_set_state(dhcp, DHCP_BACKING_OFF);
0093ba  210c              MOVS     r1,#0xc
0093bc  4628              MOV      r0,r5
0093be  f7fffffe          BL       dhcp_set_state
;;;210      /* We can immediately restart discovery */
;;;211      dhcp_discover(netif);
0093c2  4620              MOV      r0,r4
0093c4  f7fffffe          BL       dhcp_discover
;;;212    }
0093c8  bd70              POP      {r4-r6,pc}
;;;213    
                          ENDP

                  dhcp_handle_offer PROC
;;;251    static void
;;;252    dhcp_handle_offer(struct netif *netif)
0093ca  b570              PUSH     {r4-r6,lr}
;;;253    {
0093cc  4605              MOV      r5,r0
;;;254      struct dhcp *dhcp = netif->dhcp;
0093ce  6a2c              LDR      r4,[r5,#0x20]
;;;255      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
0093d0  bf00              NOP      
0093d2  bf00              NOP      
;;;256        (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;257      /* obtain the server address */
;;;258      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
0093d4  4839              LDR      r0,|L1.38076|
0093d6  7880              LDRB     r0,[r0,#2]  ; dhcp_rx_options_given
0093d8  b178              CBZ      r0,|L1.37882|
;;;259        ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
0093da  4939              LDR      r1,|L1.38080|
0093dc  6888              LDR      r0,[r1,#8]  ; dhcp_rx_options_val
0093de  f7fffffe          BL       lwip_htonl
0093e2  6220              STR      r0,[r4,#0x20]
;;;260        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
0093e4  bf00              NOP      
0093e6  bf00              NOP      
;;;261          ip4_addr_get_u32(&dhcp->server_ip_addr)));
;;;262        /* remember offered address */
;;;263        ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
0093e8  68a0              LDR      r0,[r4,#8]
0093ea  6900              LDR      r0,[r0,#0x10]
0093ec  6260              STR      r0,[r4,#0x24]
;;;264        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
0093ee  bf00              NOP      
0093f0  bf00              NOP      
;;;265          ip4_addr_get_u32(&dhcp->offered_ip_addr)));
;;;266    
;;;267        dhcp_select(netif);
0093f2  4628              MOV      r0,r5
0093f4  f7fffffe          BL       dhcp_select
0093f8  e001              B        |L1.37886|
                  |L1.37882|
;;;268      } else {
;;;269        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
0093fa  bf00              NOP      
0093fc  bf00              NOP      
                  |L1.37886|
;;;270          ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
;;;271      }
;;;272    }
0093fe  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

                  dhcp_handle_ack PROC
;;;507    static void
;;;508    dhcp_handle_ack(struct netif *netif)
009400  b510              PUSH     {r4,lr}
;;;509    {
009402  4604              MOV      r4,r0
;;;510      struct dhcp *dhcp = netif->dhcp;
009404  6a23              LDR      r3,[r4,#0x20]
;;;511    #if LWIP_DNS
;;;512      u8_t n;
;;;513    #endif /* LWIP_DNS */
;;;514    
;;;515      /* clear options we might not get from the ACK */
;;;516      ip_addr_set_zero(&dhcp->offered_sn_mask);
009406  2000              MOVS     r0,#0
009408  6298              STR      r0,[r3,#0x28]
;;;517      ip_addr_set_zero(&dhcp->offered_gw_addr);
00940a  62d8              STR      r0,[r3,#0x2c]
;;;518    #if LWIP_DHCP_BOOTP_FILE
;;;519      ip_addr_set_zero(&dhcp->offered_si_addr);
;;;520    #endif /* LWIP_DHCP_BOOTP_FILE */
;;;521    
;;;522      /* lease time given? */
;;;523      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
00940c  482b              LDR      r0,|L1.38076|
00940e  78c0              LDRB     r0,[r0,#3]  ; dhcp_rx_options_given
009410  b110              CBZ      r0,|L1.37912|
;;;524        /* remember offered lease time */
;;;525        dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
009412  482b              LDR      r0,|L1.38080|
009414  68c0              LDR      r0,[r0,#0xc]  ; dhcp_rx_options_val
009416  6318              STR      r0,[r3,#0x30]
                  |L1.37912|
;;;526      }
;;;527      /* renewal period given? */
;;;528      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
009418  4828              LDR      r0,|L1.38076|
00941a  7900              LDRB     r0,[r0,#4]  ; dhcp_rx_options_given
00941c  b118              CBZ      r0,|L1.37926|
;;;529        /* remember given renewal period */
;;;530        dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
00941e  4828              LDR      r0,|L1.38080|
009420  6900              LDR      r0,[r0,#0x10]  ; dhcp_rx_options_val
009422  6358              STR      r0,[r3,#0x34]
009424  e051              B        |L1.38090|
                  |L1.37926|
009426  e04d              B        |L1.38084|
                  |L1.37928|
                          DCD      netif_list
                  |L1.37932|
                          DCD      dhcp_timer_coarse
                  |L1.37936|
                          DCD      arp_table
                  |L1.37940|
                          DCD      arp_timer
                  |L1.37944|
                          DCD      dhcp_timer_fine
                  |L1.37948|
                          DCD      autoip_timer
                  |L1.37952|
                          DCD      igmp_timer
                  |L1.37956|
                          DCD      0x010000e0
                  |L1.37960|
                          DCD      allsystems
                  |L1.37964|
                          DCD      0x020000e0
                  |L1.37968|
                          DCD      allrouters
                  |L1.37972|
                          DCD      lwip_stats+0xc0
                  |L1.37976|
                          DCD      memp_num
                  |L1.37980|
                          DCD      memp_memory+0x3
                  |L1.37984|
                          DCD      memp_tab
                  |L1.37988|
                          DCD      memp_sizes
                  |L1.37992|
                          DCD      ram_heap+0x3
                  |L1.37996|
                          DCD      ||ram||
                  |L1.38000|
                          DCD      ram_end
                  |L1.38004|
                          DCD      lfree
                  |L1.38008|
                          DCD      mem_mutex
                  |L1.38012|
                          DCD      mboxes
                  |L1.38016|
                          DCD      sems
                  |L1.38020|
                          DCD      threads
                  |L1.38024|
                          DCD      ||.constdata||+0x98
                  |L1.38028|
00948c  4d454d00          DCB      "MEM",0
                  |L1.38032|
                          DCD      tcpip_init_done
                  |L1.38036|
                          DCD      tcpip_init_done_arg
                  |L1.38040|
                          DCD      mbox
                  |L1.38044|
                          DCD      tcpip_thread
                  |L1.38048|
0094a0  74637069          DCB      "tcpip_thread",0
0094a4  705f7468
0094a8  72656164
0094ac  00      
0094ad  00                DCB      0
0094ae  00                DCB      0
0094af  00                DCB      0
                  |L1.38064|
                          DCD      pbuf_free_int
                  |L1.38068|
                          DCD      mem_free
                  |L1.38072|
                          DCD      ip_addr_any
                  |L1.38076|
                          DCD      dhcp_rx_options_given
                  |L1.38080|
                          DCD      dhcp_rx_options_val
                  |L1.38084|
;;;531      } else {
;;;532        /* calculate safe periods for renewal */
;;;533        dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
0094c4  6b18              LDR      r0,[r3,#0x30]
0094c6  0840              LSRS     r0,r0,#1
0094c8  6358              STR      r0,[r3,#0x34]
                  |L1.38090|
;;;534      }
;;;535    
;;;536      /* renewal period given? */
;;;537      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
0094ca  48f8              LDR      r0,|L1.39084|
0094cc  7940              LDRB     r0,[r0,#5]  ; dhcp_rx_options_given
0094ce  b118              CBZ      r0,|L1.38104|
;;;538        /* remember given rebind period */
;;;539        dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
0094d0  48f7              LDR      r0,|L1.39088|
0094d2  6940              LDR      r0,[r0,#0x14]  ; dhcp_rx_options_val
0094d4  6398              STR      r0,[r3,#0x38]
0094d6  e001              B        |L1.38108|
                  |L1.38104|
;;;540      } else {
;;;541        /* calculate safe periods for rebinding */
;;;542        dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
0094d8  6b18              LDR      r0,[r3,#0x30]
0094da  6398              STR      r0,[r3,#0x38]
                  |L1.38108|
;;;543      }
;;;544    
;;;545      /* (y)our internet address */
;;;546      ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
0094dc  6898              LDR      r0,[r3,#8]
0094de  6900              LDR      r0,[r0,#0x10]
0094e0  6258              STR      r0,[r3,#0x24]
;;;547    
;;;548    #if LWIP_DHCP_BOOTP_FILE
;;;549      /* copy boot server address,
;;;550         boot file name copied in dhcp_parse_reply if not overloaded */
;;;551      ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
;;;552    #endif /* LWIP_DHCP_BOOTP_FILE */
;;;553    
;;;554      /* subnet mask given? */
;;;555      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
0094e2  48f2              LDR      r0,|L1.39084|
0094e4  7980              LDRB     r0,[r0,#6]  ; dhcp_rx_options_given
0094e6  b138              CBZ      r0,|L1.38136|
;;;556        /* remember given subnet mask */
;;;557        ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
0094e8  49f1              LDR      r1,|L1.39088|
0094ea  6988              LDR      r0,[r1,#0x18]  ; dhcp_rx_options_val
0094ec  f7fffffe          BL       lwip_htonl
0094f0  6298              STR      r0,[r3,#0x28]
;;;558        dhcp->subnet_mask_given = 1;
0094f2  2001              MOVS     r0,#1
0094f4  73d8              STRB     r0,[r3,#0xf]
0094f6  e001              B        |L1.38140|
                  |L1.38136|
;;;559      } else {
;;;560        dhcp->subnet_mask_given = 0;
0094f8  2000              MOVS     r0,#0
0094fa  73d8              STRB     r0,[r3,#0xf]
                  |L1.38140|
;;;561      }
;;;562    
;;;563      /* gateway router */
;;;564      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
0094fc  48eb              LDR      r0,|L1.39084|
0094fe  79c0              LDRB     r0,[r0,#7]  ; dhcp_rx_options_given
009500  b120              CBZ      r0,|L1.38156|
;;;565        ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
009502  49eb              LDR      r1,|L1.39088|
009504  69c8              LDR      r0,[r1,#0x1c]  ; dhcp_rx_options_val
009506  f7fffffe          BL       lwip_htonl
00950a  62d8              STR      r0,[r3,#0x2c]
                  |L1.38156|
;;;566      }
;;;567      
;;;568    #if LWIP_DNS
;;;569      /* DNS servers */
;;;570      n = 0;
;;;571      while(dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n) && (n < DNS_MAX_SERVERS)) {
;;;572        ip_addr_t dns_addr;
;;;573        ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
;;;574        dns_setserver(n, &dns_addr);
;;;575        n++;
;;;576      }
;;;577    #endif /* LWIP_DNS */
;;;578    }
00950c  bd10              POP      {r4,pc}
;;;579    
                          ENDP

                  dhcp_set_struct PROC
;;;586    void
;;;587    dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
00950e  b570              PUSH     {r4-r6,lr}
;;;588    {
009510  4605              MOV      r5,r0
009512  460c              MOV      r4,r1
;;;589      LWIP_ASSERT("netif != NULL", netif != NULL);
009514  bf00              NOP      
009516  bf00              NOP      
;;;590      LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
009518  bf00              NOP      
00951a  bf00              NOP      
;;;591      LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);
00951c  bf00              NOP      
00951e  bf00              NOP      
;;;592    
;;;593      /* clear data structure */
;;;594      memset(dhcp, 0, sizeof(struct dhcp));
009520  213c              MOVS     r1,#0x3c
009522  4620              MOV      r0,r4
009524  f7fffffe          BL       __aeabi_memclr4
;;;595      /* dhcp_set_state(&dhcp, DHCP_OFF); */
;;;596      netif->dhcp = dhcp;
009528  622c              STR      r4,[r5,#0x20]
;;;597    }
00952a  bd70              POP      {r4-r6,pc}
;;;598    
                          ENDP

                  dhcp_cleanup PROC
;;;605     */
;;;606    void dhcp_cleanup(struct netif *netif)
00952c  b510              PUSH     {r4,lr}
;;;607    {
00952e  4604              MOV      r4,r0
;;;608      LWIP_ASSERT("netif != NULL", netif != NULL);
009530  bf00              NOP      
009532  bf00              NOP      
;;;609    
;;;610      if (netif->dhcp != NULL) {
009534  6a20              LDR      r0,[r4,#0x20]
009536  b120              CBZ      r0,|L1.38210|
;;;611        mem_free(netif->dhcp);
009538  6a20              LDR      r0,[r4,#0x20]
00953a  f7fffffe          BL       mem_free
;;;612        netif->dhcp = NULL;
00953e  2000              MOVS     r0,#0
009540  6220              STR      r0,[r4,#0x20]
                  |L1.38210|
;;;613      }
;;;614    }
009542  bd10              POP      {r4,pc}
;;;615    
                          ENDP

                  dhcp_stop PROC
;;;1219   void
;;;1220   dhcp_stop(struct netif *netif)
009544  b570              PUSH     {r4-r6,lr}
;;;1221   {
009546  4605              MOV      r5,r0
;;;1222     struct dhcp *dhcp;
;;;1223     LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
009548  bf00              NOP      
00954a  b905              CBNZ     r5,|L1.38222|
                  |L1.38220|
;;;1224     dhcp = netif->dhcp;
;;;1225     /* Remove the flag that says this netif is handled by DHCP. */
;;;1226     netif->flags &= ~NETIF_FLAG_DHCP;
;;;1227   
;;;1228     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
;;;1229     /* netif is DHCP configured? */
;;;1230     if (dhcp != NULL) {
;;;1231   #if LWIP_DHCP_AUTOIP_COOP
;;;1232       if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;1233         autoip_stop(netif);
;;;1234         dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;1235       }
;;;1236   #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;1237   
;;;1238       if (dhcp->pcb != NULL) {
;;;1239         udp_remove(dhcp->pcb);
;;;1240         dhcp->pcb = NULL;
;;;1241       }
;;;1242       LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
;;;1243       dhcp_set_state(dhcp, DHCP_OFF);
;;;1244     }
;;;1245   }
00954c  bd70              POP      {r4-r6,pc}
                  |L1.38222|
00954e  bf00              NOP                            ;1223
009550  6a2c              LDR      r4,[r5,#0x20]         ;1224
009552  f8950031          LDRB     r0,[r5,#0x31]         ;1226
009556  f0200008          BIC      r0,r0,#8              ;1226
00955a  f8850031          STRB     r0,[r5,#0x31]         ;1226
00955e  bf00              NOP                            ;1228
009560  bf00              NOP                            ;1228
009562  b1a4              CBZ      r4,|L1.38286|
009564  7ba0              LDRB     r0,[r4,#0xe]          ;1232
009566  2801              CMP      r0,#1                 ;1232
009568  d104              BNE      |L1.38260|
00956a  4628              MOV      r0,r5                 ;1233
00956c  f7fffffe          BL       autoip_stop
009570  2000              MOVS     r0,#0                 ;1234
009572  73a0              STRB     r0,[r4,#0xe]          ;1234
                  |L1.38260|
009574  6860              LDR      r0,[r4,#4]            ;1238
009576  b120              CBZ      r0,|L1.38274|
009578  6860              LDR      r0,[r4,#4]            ;1239
00957a  f7fffffe          BL       udp_remove
00957e  2000              MOVS     r0,#0                 ;1240
009580  6060              STR      r0,[r4,#4]            ;1240
                  |L1.38274|
009582  bf00              NOP                            ;1242
009584  bf00              NOP                            ;1242
009586  2100              MOVS     r1,#0                 ;1243
009588  4620              MOV      r0,r4                 ;1243
00958a  f7fffffe          BL       dhcp_set_state
                  |L1.38286|
00958e  bf00              NOP      
009590  e7dc              B        |L1.38220|
;;;1246   
                          ENDP

                  dhcp_parse_reply PROC
;;;1336   static err_t
;;;1337   dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
009592  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;1338   {
009596  b089              SUB      sp,sp,#0x24
009598  4689              MOV      r9,r1
;;;1339     u8_t *options;
;;;1340     u16_t offset;
;;;1341     u16_t offset_max;
;;;1342     u16_t options_idx;
;;;1343     u16_t options_idx_max;
;;;1344     struct pbuf *q;
;;;1345     int parse_file_as_options = 0;
00959a  2000              MOVS     r0,#0
00959c  9006              STR      r0,[sp,#0x18]
;;;1346     int parse_sname_as_options = 0;
00959e  9005              STR      r0,[sp,#0x14]
;;;1347   
;;;1348     /* clear received options */
;;;1349     dhcp_clear_all_options(dhcp);
0095a0  210a              MOVS     r1,#0xa
0095a2  48c2              LDR      r0,|L1.39084|
0095a4  f7fffffe          BL       __aeabi_memclr4
;;;1350     /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
;;;1351     if (p->len < DHCP_SNAME_OFS) {
0095a8  f8b9000a          LDRH     r0,[r9,#0xa]
0095ac  282c              CMP      r0,#0x2c
0095ae  da04              BGE      |L1.38330|
;;;1352       return ERR_BUF;
0095b0  f06f0001          MVN      r0,#1
                  |L1.38324|
;;;1353     }
;;;1354     dhcp->msg_in = (struct dhcp_msg *)p->payload;
;;;1355   #if LWIP_DHCP_BOOTP_FILE
;;;1356     /* clear boot file name */
;;;1357     dhcp->boot_file_name[0] = 0;
;;;1358   #endif /* LWIP_DHCP_BOOTP_FILE */
;;;1359   
;;;1360     /* parse options */
;;;1361   
;;;1362     /* start with options field */
;;;1363     options_idx = DHCP_OPTIONS_OFS;
;;;1364     /* parse options to the end of the received packet */
;;;1365     options_idx_max = p->tot_len;
;;;1366   again:
;;;1367     q = p;
;;;1368     while((q != NULL) && (options_idx >= q->len)) {
;;;1369       options_idx -= q->len;
;;;1370       options_idx_max -= q->len;
;;;1371       q = q->next;
;;;1372     }
;;;1373     if (q == NULL) {
;;;1374       return ERR_BUF;
;;;1375     }
;;;1376     offset = options_idx;
;;;1377     offset_max = options_idx_max;
;;;1378     options = (u8_t*)q->payload;
;;;1379     /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
;;;1380     while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
;;;1381       u8_t op = options[offset];
;;;1382       u8_t len;
;;;1383       u8_t decode_len = 0;
;;;1384       int decode_idx = -1;
;;;1385       u16_t val_offset = offset + 2;
;;;1386       /* len byte might be in the next pbuf */
;;;1387       if (offset + 1 < q->len) {
;;;1388         len = options[offset + 1];
;;;1389       } else {
;;;1390         len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
;;;1391       }
;;;1392       /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
;;;1393       decode_len = len;
;;;1394       switch(op) {
;;;1395         /* case(DHCP_OPTION_END): handled above */
;;;1396         case(DHCP_OPTION_PAD):
;;;1397           /* special option: no len encoded */
;;;1398           decode_len = len = 0;
;;;1399           /* will be increased below */
;;;1400           offset--;
;;;1401           break;
;;;1402         case(DHCP_OPTION_SUBNET_MASK):
;;;1403           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1404           decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
;;;1405           break;
;;;1406         case(DHCP_OPTION_ROUTER):
;;;1407           decode_len = 4; /* only copy the first given router */
;;;1408           LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
;;;1409           decode_idx = DHCP_OPTION_IDX_ROUTER;
;;;1410           break;
;;;1411         case(DHCP_OPTION_DNS_SERVER):
;;;1412           /* special case: there might be more than one server */
;;;1413           LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
;;;1414           /* limit number of DNS servers */
;;;1415           decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
;;;1416           LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
;;;1417           decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
;;;1418           break;
;;;1419         case(DHCP_OPTION_LEASE_TIME):
;;;1420           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1421           decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
;;;1422           break;
;;;1423         case(DHCP_OPTION_OVERLOAD):
;;;1424           LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
;;;1425           decode_idx = DHCP_OPTION_IDX_OVERLOAD;
;;;1426           break;
;;;1427         case(DHCP_OPTION_MESSAGE_TYPE):
;;;1428           LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
;;;1429           decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
;;;1430           break;
;;;1431         case(DHCP_OPTION_SERVER_ID):
;;;1432           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1433           decode_idx = DHCP_OPTION_IDX_SERVER_ID;
;;;1434           break;
;;;1435         case(DHCP_OPTION_T1):
;;;1436           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1437           decode_idx = DHCP_OPTION_IDX_T1;
;;;1438           break;
;;;1439         case(DHCP_OPTION_T2):
;;;1440           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1441           decode_idx = DHCP_OPTION_IDX_T2;
;;;1442           break;
;;;1443         default:
;;;1444           decode_len = 0;
;;;1445           LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
;;;1446           break;
;;;1447       }
;;;1448       offset += len + 2;
;;;1449       if (decode_len > 0) {
;;;1450         u32_t value = 0;
;;;1451         u16_t copy_len;
;;;1452   decode_next:
;;;1453         LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
;;;1454         if (!dhcp_option_given(dhcp, decode_idx)) {
;;;1455           copy_len = LWIP_MIN(decode_len, 4);
;;;1456           pbuf_copy_partial(q, &value, copy_len, val_offset);
;;;1457           if (decode_len > 4) {
;;;1458             /* decode more than one u32_t */
;;;1459             LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
;;;1460             dhcp_got_option(dhcp, decode_idx);
;;;1461             dhcp_set_option_value(dhcp, decode_idx, htonl(value));
;;;1462             decode_len -= 4;
;;;1463             val_offset += 4;
;;;1464             decode_idx++;
;;;1465             goto decode_next;
;;;1466           } else if (decode_len == 4) {
;;;1467             value = ntohl(value);
;;;1468           } else {
;;;1469             LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
;;;1470             value = ((u8_t*)&value)[0];
;;;1471           }
;;;1472           dhcp_got_option(dhcp, decode_idx);
;;;1473           dhcp_set_option_value(dhcp, decode_idx, value);
;;;1474         }
;;;1475       }
;;;1476       if (offset >= q->len) {
;;;1477         offset -= q->len;
;;;1478         offset_max -= q->len;
;;;1479         if ((offset < offset_max) && offset_max) {
;;;1480           q = q->next;
;;;1481           LWIP_ASSERT("next pbuf was null", q);
;;;1482           options = (u8_t*)q->payload;
;;;1483         } else {
;;;1484           // We've run out of bytes, probably no end marker. Don't proceed.
;;;1485           break;
;;;1486         }
;;;1487       }
;;;1488     }
;;;1489     /* is this an overloaded message? */
;;;1490     if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
;;;1491       u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
;;;1492       dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
;;;1493       if (overload == DHCP_OVERLOAD_FILE) {
;;;1494         parse_file_as_options = 1;
;;;1495         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
;;;1496       } else if (overload == DHCP_OVERLOAD_SNAME) {
;;;1497         parse_sname_as_options = 1;
;;;1498         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
;;;1499       } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
;;;1500         parse_sname_as_options = 1;
;;;1501         parse_file_as_options = 1;
;;;1502         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
;;;1503       } else {
;;;1504         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
;;;1505       }
;;;1506   #if LWIP_DHCP_BOOTP_FILE
;;;1507       if (!parse_file_as_options) {
;;;1508         /* only do this for ACK messages */
;;;1509         if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) &&
;;;1510           (dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) == DHCP_ACK))
;;;1511         /* copy bootp file name, don't care for sname (server hostname) */
;;;1512         pbuf_copy_partial(p, dhcp->boot_file_name, DHCP_FILE_LEN-1, DHCP_FILE_OFS);
;;;1513         /* make sure the string is really NULL-terminated */
;;;1514         dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
;;;1515       }
;;;1516   #endif /* LWIP_DHCP_BOOTP_FILE */
;;;1517     }
;;;1518     if (parse_file_as_options) {
;;;1519       /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
;;;1520       parse_file_as_options = 0;
;;;1521       options_idx = DHCP_FILE_OFS;
;;;1522       options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
;;;1523       goto again;
;;;1524     } else if (parse_sname_as_options) {
;;;1525       parse_sname_as_options = 0;
;;;1526       options_idx = DHCP_SNAME_OFS;
;;;1527       options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
;;;1528       goto again;
;;;1529     }
;;;1530     return ERR_OK;
;;;1531   }
0095b4  b00b              ADD      sp,sp,#0x2c
0095b6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.38330|
0095ba  f8d91004          LDR      r1,[r9,#4]            ;1354
0095be  9809              LDR      r0,[sp,#0x24]         ;1354
0095c0  6081              STR      r1,[r0,#8]            ;1354
0095c2  f04f0bf0          MOV      r11,#0xf0             ;1363
0095c6  f8b90008          LDRH     r0,[r9,#8]            ;1365
0095ca  9007              STR      r0,[sp,#0x1c]         ;1365
0095cc  bf00              NOP                            ;1366
                  |L1.38350|
0095ce  464c              MOV      r4,r9                 ;1367
0095d0  e00a              B        |L1.38376|
                  |L1.38354|
0095d2  8960              LDRH     r0,[r4,#0xa]          ;1369
0095d4  ebab0000          SUB      r0,r11,r0             ;1369
0095d8  fa1ffb80          UXTH     r11,r0                ;1369
0095dc  8961              LDRH     r1,[r4,#0xa]          ;1370
0095de  9807              LDR      r0,[sp,#0x1c]         ;1370
0095e0  1a40              SUBS     r0,r0,r1              ;1370
0095e2  b280              UXTH     r0,r0                 ;1370
0095e4  9007              STR      r0,[sp,#0x1c]         ;1370
0095e6  6824              LDR      r4,[r4,#0]            ;1371
                  |L1.38376|
0095e8  b114              CBZ      r4,|L1.38384|
0095ea  8960              LDRH     r0,[r4,#0xa]          ;1368
0095ec  4558              CMP      r0,r11                ;1368
0095ee  ddf0              BLE      |L1.38354|
                  |L1.38384|
0095f0  b914              CBNZ     r4,|L1.38392|
0095f2  f06f0001          MVN      r0,#1                 ;1374
0095f6  e7dd              B        |L1.38324|
                  |L1.38392|
0095f8  465f              MOV      r7,r11                ;1376
0095fa  f8dda01c          LDR      r10,[sp,#0x1c]        ;1377
0095fe  6860              LDR      r0,[r4,#4]            ;1378
009600  9008              STR      r0,[sp,#0x20]         ;1378
009602  e119              B        |L1.38968|
                  |L1.38404|
009604  9808              LDR      r0,[sp,#0x20]         ;1381
009606  5dc0              LDRB     r0,[r0,r7]            ;1381
009608  9004              STR      r0,[sp,#0x10]         ;1381
00960a  2600              MOVS     r6,#0                 ;1383
00960c  f04f38ff          MOV      r8,#0xffffffff        ;1384
009610  1cb8              ADDS     r0,r7,#2              ;1385
009612  b280              UXTH     r0,r0                 ;1385
009614  9003              STR      r0,[sp,#0xc]          ;1385
009616  8961              LDRH     r1,[r4,#0xa]          ;1387
009618  1c78              ADDS     r0,r7,#1              ;1387
00961a  4281              CMP      r1,r0                 ;1387
00961c  dd03              BLE      |L1.38438|
00961e  1c79              ADDS     r1,r7,#1              ;1388
009620  9808              LDR      r0,[sp,#0x20]         ;1388
009622  5c45              LDRB     r5,[r0,r1]            ;1388
009624  e007              B        |L1.38454|
                  |L1.38438|
009626  6820              LDR      r0,[r4,#0]            ;1390
009628  b118              CBZ      r0,|L1.38450|
00962a  6820              LDR      r0,[r4,#0]            ;1390
00962c  6840              LDR      r0,[r0,#4]            ;1390
00962e  7800              LDRB     r0,[r0,#0]            ;1390
009630  e000              B        |L1.38452|
                  |L1.38450|
009632  2000              MOVS     r0,#0                 ;1390
                  |L1.38452|
009634  4605              MOV      r5,r0                 ;1390
                  |L1.38454|
009636  462e              MOV      r6,r5                 ;1393
009638  9804              LDR      r0,[sp,#0x10]         ;1394
00963a  2834              CMP      r0,#0x34              ;1394
00963c  d056              BEQ      |L1.38636|
00963e  dc0b              BGT      |L1.38488|
009640  2803              CMP      r0,#3                 ;1394
009642  d022              BEQ      |L1.38538|
009644  dc03              BGT      |L1.38478|
009646  b180              CBZ      r0,|L1.38506|
009648  2801              CMP      r0,#1                 ;1394
00964a  d173              BNE      |L1.38708|
00964c  e013              B        |L1.38518|
                  |L1.38478|
00964e  2806              CMP      r0,#6                 ;1394
009650  d026              BEQ      |L1.38560|
009652  2833              CMP      r0,#0x33              ;1394
009654  d17d              BNE      |L1.38738|
009656  e03f              B        |L1.38616|
                  |L1.38488|
009658  2835              CMP      r0,#0x35              ;1394
00965a  d051              BEQ      |L1.38656|
00965c  2836              CMP      r0,#0x36              ;1394
00965e  d059              BEQ      |L1.38676|
009660  283a              CMP      r0,#0x3a              ;1394
009662  d061              BEQ      |L1.38696|
009664  283b              CMP      r0,#0x3b              ;1394
009666  d174              BNE      |L1.38738|
009668  e069              B        |L1.38718|
                  |L1.38506|
00966a  2000              MOVS     r0,#0                 ;1398
00966c  4605              MOV      r5,r0                 ;1398
00966e  4606              MOV      r6,r0                 ;1398
009670  1e78              SUBS     r0,r7,#1              ;1400
009672  b287              UXTH     r7,r0                 ;1400
009674  e071              B        |L1.38746|
                  |L1.38518|
009676  bf00              NOP                            ;1403
009678  2d04              CMP      r5,#4                 ;1403
00967a  d002              BEQ      |L1.38530|
00967c  f06f0005          MVN      r0,#5                 ;1403
009680  e798              B        |L1.38324|
                  |L1.38530|
009682  bf00              NOP                            ;1403
009684  f04f0806          MOV      r8,#6                 ;1404
009688  e067              B        |L1.38746|
                  |L1.38538|
00968a  2604              MOVS     r6,#4                 ;1407
00968c  bf00              NOP                            ;1408
00968e  42b5              CMP      r5,r6                 ;1408
009690  da02              BGE      |L1.38552|
009692  f06f0005          MVN      r0,#5                 ;1408
009696  e78d              B        |L1.38324|
                  |L1.38552|
009698  bf00              NOP                            ;1408
00969a  f04f0807          MOV      r8,#7                 ;1409
00969e  e05c              B        |L1.38746|
                  |L1.38560|
0096a0  bf00              NOP                            ;1413
0096a2  17e9              ASRS     r1,r5,#31             ;1413
0096a4  eb057191          ADD      r1,r5,r1,LSR #30      ;1413
0096a8  1089              ASRS     r1,r1,#2              ;1413
0096aa  ebb50181          SUBS     r1,r5,r1,LSL #2       ;1413
0096ae  d002              BEQ      |L1.38582|
0096b0  f06f0005          MVN      r0,#5                 ;1413
0096b4  e77e              B        |L1.38324|
                  |L1.38582|
0096b6  bf00              NOP                            ;1413
0096b8  2d08              CMP      r5,#8                 ;1415
0096ba  da01              BGE      |L1.38592|
0096bc  4628              MOV      r0,r5                 ;1415
0096be  e000              B        |L1.38594|
                  |L1.38592|
0096c0  2008              MOVS     r0,#8                 ;1415
                  |L1.38594|
0096c2  4606              MOV      r6,r0                 ;1415
0096c4  bf00              NOP                            ;1416
0096c6  42b5              CMP      r5,r6                 ;1416
0096c8  da02              BGE      |L1.38608|
0096ca  f06f0005          MVN      r0,#5                 ;1416
0096ce  e771              B        |L1.38324|
                  |L1.38608|
0096d0  bf00              NOP                            ;1416
0096d2  f04f0808          MOV      r8,#8                 ;1417
0096d6  e040              B        |L1.38746|
                  |L1.38616|
0096d8  bf00              NOP                            ;1420
0096da  2d04              CMP      r5,#4                 ;1420
0096dc  d002              BEQ      |L1.38628|
0096de  f06f0005          MVN      r0,#5                 ;1420
0096e2  e767              B        |L1.38324|
                  |L1.38628|
0096e4  bf00              NOP                            ;1420
0096e6  f04f0803          MOV      r8,#3                 ;1421
0096ea  e036              B        |L1.38746|
                  |L1.38636|
0096ec  bf00              NOP                            ;1424
0096ee  2d01              CMP      r5,#1                 ;1424
0096f0  d002              BEQ      |L1.38648|
0096f2  f06f0005          MVN      r0,#5                 ;1424
0096f6  e75d              B        |L1.38324|
                  |L1.38648|
0096f8  bf00              NOP                            ;1424
0096fa  f04f0800          MOV      r8,#0                 ;1425
0096fe  e02c              B        |L1.38746|
                  |L1.38656|
009700  bf00              NOP                            ;1428
009702  2d01              CMP      r5,#1                 ;1428
009704  d002              BEQ      |L1.38668|
009706  f06f0005          MVN      r0,#5                 ;1428
00970a  e753              B        |L1.38324|
                  |L1.38668|
00970c  bf00              NOP                            ;1428
00970e  f04f0801          MOV      r8,#1                 ;1429
009712  e022              B        |L1.38746|
                  |L1.38676|
009714  bf00              NOP                            ;1432
009716  2d04              CMP      r5,#4                 ;1432
009718  d002              BEQ      |L1.38688|
00971a  f06f0005          MVN      r0,#5                 ;1432
00971e  e749              B        |L1.38324|
                  |L1.38688|
009720  bf00              NOP                            ;1432
009722  f04f0802          MOV      r8,#2                 ;1433
009726  e018              B        |L1.38746|
                  |L1.38696|
009728  bf00              NOP                            ;1436
00972a  2d04              CMP      r5,#4                 ;1436
00972c  d003              BEQ      |L1.38710|
00972e  f06f0005          MVN      r0,#5                 ;1436
009732  e73f              B        |L1.38324|
                  |L1.38708|
009734  e00d              B        |L1.38738|
                  |L1.38710|
009736  bf00              NOP                            ;1436
009738  f04f0804          MOV      r8,#4                 ;1437
00973c  e00d              B        |L1.38746|
                  |L1.38718|
00973e  bf00              NOP                            ;1440
009740  2d04              CMP      r5,#4                 ;1440
009742  d002              BEQ      |L1.38730|
009744  f06f0005          MVN      r0,#5                 ;1440
009748  e734              B        |L1.38324|
                  |L1.38730|
00974a  bf00              NOP                            ;1440
00974c  f04f0805          MOV      r8,#5                 ;1441
009750  e003              B        |L1.38746|
                  |L1.38738|
009752  2600              MOVS     r6,#0                 ;1444
009754  bf00              NOP                            ;1445
009756  bf00              NOP                            ;1445
009758  bf00              NOP                            ;1446
                  |L1.38746|
00975a  bf00              NOP                            ;1401
00975c  1ca8              ADDS     r0,r5,#2              ;1448
00975e  4438              ADD      r0,r0,r7              ;1448
009760  b287              UXTH     r7,r0                 ;1448
009762  2e00              CMP      r6,#0                 ;1449
009764  dd50              BLE      |L1.38920|
009766  2000              MOVS     r0,#0                 ;1450
009768  9002              STR      r0,[sp,#8]            ;1450
00976a  bf00              NOP                            ;1452
                  |L1.38764|
00976c  bf00              NOP                            ;1453
00976e  bf00              NOP                            ;1453
009770  484e              LDR      r0,|L1.39084|
009772  f8100008          LDRB     r0,[r0,r8]            ;1454
009776  bb98              CBNZ     r0,|L1.38880|
009778  2e04              CMP      r6,#4                 ;1455
00977a  da01              BGE      |L1.38784|
00977c  4630              MOV      r0,r6                 ;1455
00977e  e000              B        |L1.38786|
                  |L1.38784|
009780  2004              MOVS     r0,#4                 ;1455
                  |L1.38786|
009782  9001              STR      r0,[sp,#4]            ;1455
009784  a902              ADD      r1,sp,#8              ;1456
009786  4620              MOV      r0,r4                 ;1456
009788  9b03              LDR      r3,[sp,#0xc]          ;1456
00978a  9a01              LDR      r2,[sp,#4]            ;1456
00978c  f7fffffe          BL       pbuf_copy_partial
009790  2e04              CMP      r6,#4                 ;1457
009792  dd1e              BLE      |L1.38866|
009794  bf00              NOP                            ;1459
009796  17f1              ASRS     r1,r6,#31             ;1459
009798  eb067191          ADD      r1,r6,r1,LSR #30      ;1459
00979c  1089              ASRS     r1,r1,#2              ;1459
00979e  ebb60181          SUBS     r1,r6,r1,LSL #2       ;1459
0097a2  d002              BEQ      |L1.38826|
0097a4  f06f0005          MVN      r0,#5                 ;1459
0097a8  e704              B        |L1.38324|
                  |L1.38826|
0097aa  bf00              NOP                            ;1459
0097ac  2001              MOVS     r0,#1                 ;1460
0097ae  493f              LDR      r1,|L1.39084|
0097b0  f8010008          STRB     r0,[r1,r8]            ;1460
0097b4  9802              LDR      r0,[sp,#8]            ;1461
0097b6  f7fffffe          BL       lwip_htonl
0097ba  493d              LDR      r1,|L1.39088|
0097bc  f8410028          STR      r0,[r1,r8,LSL #2]     ;1461
0097c0  1f30              SUBS     r0,r6,#4              ;1462
0097c2  b2c6              UXTB     r6,r0                 ;1462
0097c4  9803              LDR      r0,[sp,#0xc]          ;1463
0097c6  1d00              ADDS     r0,r0,#4              ;1463
0097c8  b280              UXTH     r0,r0                 ;1463
0097ca  9003              STR      r0,[sp,#0xc]          ;1463
0097cc  f1080801          ADD      r8,r8,#1              ;1464
0097d0  e7cc              B        |L1.38764|
                  |L1.38866|
0097d2  2e04              CMP      r6,#4                 ;1466
0097d4  d105              BNE      |L1.38882|
0097d6  9802              LDR      r0,[sp,#8]            ;1467
0097d8  f7fffffe          BL       lwip_ntohl
0097dc  9002              STR      r0,[sp,#8]            ;1467
0097de  e00a              B        |L1.38902|
                  |L1.38880|
0097e0  e011              B        |L1.38918|
                  |L1.38882|
0097e2  bf00              NOP                            ;1469
0097e4  2e01              CMP      r6,#1                 ;1469
0097e6  d002              BEQ      |L1.38894|
0097e8  f06f0005          MVN      r0,#5                 ;1469
0097ec  e6e2              B        |L1.38324|
                  |L1.38894|
0097ee  bf00              NOP                            ;1469
0097f0  f89d0008          LDRB     r0,[sp,#8]            ;1470
0097f4  9002              STR      r0,[sp,#8]            ;1470
                  |L1.38902|
0097f6  2001              MOVS     r0,#1                 ;1472
0097f8  492c              LDR      r1,|L1.39084|
0097fa  f8010008          STRB     r0,[r1,r8]            ;1472
0097fe  492c              LDR      r1,|L1.39088|
009800  9802              LDR      r0,[sp,#8]            ;1473
009802  f8410028          STR      r0,[r1,r8,LSL #2]     ;1473
                  |L1.38918|
009806  bf00              NOP                            ;1475
                  |L1.38920|
009808  8960              LDRH     r0,[r4,#0xa]          ;1476
00980a  42b8              CMP      r0,r7                 ;1476
00980c  dc13              BGT      |L1.38966|
00980e  8960              LDRH     r0,[r4,#0xa]          ;1477
009810  1a38              SUBS     r0,r7,r0              ;1477
009812  b287              UXTH     r7,r0                 ;1477
009814  8960              LDRH     r0,[r4,#0xa]          ;1478
009816  ebaa0000          SUB      r0,r10,r0             ;1478
00981a  fa1ffa80          UXTH     r10,r0                ;1478
00981e  4557              CMP      r7,r10                ;1479
009820  da08              BGE      |L1.38964|
009822  f1ba0f00          CMP      r10,#0                ;1479
009826  d005              BEQ      |L1.38964|
009828  6824              LDR      r4,[r4,#0]            ;1480
00982a  bf00              NOP                            ;1481
00982c  bf00              NOP                            ;1481
00982e  6860              LDR      r0,[r4,#4]            ;1482
009830  9008              STR      r0,[sp,#0x20]         ;1482
009832  e000              B        |L1.38966|
                  |L1.38964|
009834  e008              B        |L1.38984|
                  |L1.38966|
009836  bf00              NOP                            ;1488
                  |L1.38968|
009838  b134              CBZ      r4,|L1.38984|
00983a  9808              LDR      r0,[sp,#0x20]         ;1380
00983c  5dc0              LDRB     r0,[r0,r7]            ;1380
00983e  28ff              CMP      r0,#0xff              ;1380
009840  d002              BEQ      |L1.38984|
009842  4557              CMP      r7,r10                ;1380
009844  f6ffaede          BLT      |L1.38404|
                  |L1.38984|
009848  bf00              NOP                            ;1485
00984a  4818              LDR      r0,|L1.39084|
00984c  7800              LDRB     r0,[r0,#0]            ;1490  ; dhcp_rx_options_given
00984e  b1d0              CBZ      r0,|L1.39046|
009850  4917              LDR      r1,|L1.39088|
009852  6808              LDR      r0,[r1,#0]            ;1491  ; dhcp_rx_options_val
009854  2100              MOVS     r1,#0                 ;1492
009856  4a15              LDR      r2,|L1.39084|
009858  7011              STRB     r1,[r2,#0]            ;1492
00985a  2801              CMP      r0,#1                 ;1493
00985c  d103              BNE      |L1.39014|
00985e  2101              MOVS     r1,#1                 ;1494
009860  9106              STR      r1,[sp,#0x18]         ;1494
009862  bf00              NOP                            ;1495
009864  e00e              B        |L1.39044|
                  |L1.39014|
009866  2802              CMP      r0,#2                 ;1496
009868  d103              BNE      |L1.39026|
00986a  2101              MOVS     r1,#1                 ;1497
00986c  9105              STR      r1,[sp,#0x14]         ;1497
00986e  bf00              NOP                            ;1498
009870  e008              B        |L1.39044|
                  |L1.39026|
009872  2803              CMP      r0,#3                 ;1499
009874  d104              BNE      |L1.39040|
009876  2101              MOVS     r1,#1                 ;1500
009878  9105              STR      r1,[sp,#0x14]         ;1500
00987a  9106              STR      r1,[sp,#0x18]         ;1501
00987c  bf00              NOP                            ;1502
00987e  e001              B        |L1.39044|
                  |L1.39040|
009880  bf00              NOP                            ;1504
009882  bf00              NOP                            ;1504
                  |L1.39044|
009884  bf00              NOP                            ;1517
                  |L1.39046|
009886  9806              LDR      r0,[sp,#0x18]         ;1518
009888  b130              CBZ      r0,|L1.39064|
00988a  2000              MOVS     r0,#0                 ;1520
00988c  9006              STR      r0,[sp,#0x18]         ;1520
00988e  f04f0b6c          MOV      r11,#0x6c             ;1521
009892  20ec              MOVS     r0,#0xec              ;1522
009894  9007              STR      r0,[sp,#0x1c]         ;1522
009896  e69a              B        |L1.38350|
                  |L1.39064|
009898  9805              LDR      r0,[sp,#0x14]         ;1524
00989a  b158              CBZ      r0,|L1.39092|
00989c  2000              MOVS     r0,#0                 ;1525
00989e  9005              STR      r0,[sp,#0x14]         ;1525
0098a0  f04f0b2c          MOV      r11,#0x2c             ;1526
0098a4  206c              MOVS     r0,#0x6c              ;1527
0098a6  9007              STR      r0,[sp,#0x1c]         ;1527
0098a8  e691              B        |L1.38350|
0098aa  0000              DCW      0x0000
                  |L1.39084|
                          DCD      dhcp_rx_options_given
                  |L1.39088|
                          DCD      dhcp_rx_options_val
                  |L1.39092|
0098b4  2000              MOVS     r0,#0                 ;1530
0098b6  e67d              B        |L1.38324|
;;;1532   
                          ENDP

                  dhcp_recv PROC
;;;1536   static void
;;;1537   dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
0098b8  e92d5ff0          PUSH     {r4-r12,lr}
;;;1538   {
0098bc  4681              MOV      r9,r0
0098be  4615              MOV      r5,r2
0098c0  f8ddb028          LDR      r11,[sp,#0x28]
;;;1539     struct netif *netif = (struct netif *)arg;
0098c4  464f              MOV      r7,r9
;;;1540     struct dhcp *dhcp = netif->dhcp;
0098c6  6a3c              LDR      r4,[r7,#0x20]
;;;1541     struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
0098c8  f8d5a004          LDR      r10,[r5,#4]
;;;1542     u8_t msg_type;
;;;1543     u8_t i;
;;;1544     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_recv(pbuf = %p) from DHCP server %"U16_F".%"U16_F".%"U16_F".%"U16_F" port %"U16_F"\n", (void*)p,
0098cc  bf00              NOP      
0098ce  bf00              NOP      
;;;1545       ip4_addr1_16(addr), ip4_addr2_16(addr), ip4_addr3_16(addr), ip4_addr4_16(addr), port));
;;;1546     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %"U16_F"\n", p->len));
0098d0  bf00              NOP      
0098d2  bf00              NOP      
;;;1547     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
0098d4  bf00              NOP      
0098d6  bf00              NOP      
;;;1548     /* prevent warnings about unused arguments */
;;;1549     LWIP_UNUSED_ARG(pcb);
;;;1550     LWIP_UNUSED_ARG(addr);
;;;1551     LWIP_UNUSED_ARG(port);
;;;1552   
;;;1553     LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
0098d8  bf00              NOP      
0098da  bf00              NOP      
;;;1554   
;;;1555     if (p->len < DHCP_MIN_REPLY_LEN) {
0098dc  8968              LDRH     r0,[r5,#0xa]
0098de  282c              CMP      r0,#0x2c
0098e0  da02              BGE      |L1.39144|
;;;1556       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
0098e2  bf00              NOP      
0098e4  bf00              NOP      
;;;1557       goto free_pbuf_and_return;
0098e6  e075              B        |L1.39380|
                  |L1.39144|
;;;1558     }
;;;1559   
;;;1560     if (reply_msg->op != DHCP_BOOTREPLY) {
0098e8  f89a0000          LDRB     r0,[r10,#0]
0098ec  2802              CMP      r0,#2
0098ee  d002              BEQ      |L1.39158|
;;;1561       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
0098f0  bf00              NOP      
0098f2  bf00              NOP      
;;;1562       goto free_pbuf_and_return;
0098f4  e06e              B        |L1.39380|
                  |L1.39158|
;;;1563     }
;;;1564     /* iterate through hardware address and match against DHCP message */
;;;1565     for (i = 0; i < netif->hwaddr_len; i++) {
0098f6  2600              MOVS     r6,#0
0098f8  e00c              B        |L1.39188|
                  |L1.39162|
;;;1566       if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
0098fa  f107002b          ADD      r0,r7,#0x2b
0098fe  5d81              LDRB     r1,[r0,r6]
009900  f10a001c          ADD      r0,r10,#0x1c
009904  5d80              LDRB     r0,[r0,r6]
009906  4281              CMP      r1,r0
009908  d002              BEQ      |L1.39184|
;;;1567         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
00990a  bf00              NOP      
00990c  bf00              NOP      
;;;1568           ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
;;;1569           (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
;;;1570         goto free_pbuf_and_return;
00990e  e061              B        |L1.39380|
                  |L1.39184|
009910  1c70              ADDS     r0,r6,#1              ;1565
009912  b2c6              UXTB     r6,r0                 ;1565
                  |L1.39188|
009914  f897002a          LDRB     r0,[r7,#0x2a]         ;1565
009918  42b0              CMP      r0,r6                 ;1565
00991a  dcee              BGT      |L1.39162|
;;;1571       }
;;;1572     }
;;;1573     /* match transaction ID against what we expected */
;;;1574     if (ntohl(reply_msg->xid) != dhcp->xid) {
00991c  f8da0004          LDR      r0,[r10,#4]
009920  f7fffffe          BL       lwip_ntohl
009924  6821              LDR      r1,[r4,#0]
009926  4288              CMP      r0,r1
009928  d002              BEQ      |L1.39216|
;;;1575       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
00992a  bf00              NOP      
00992c  bf00              NOP      
;;;1576         ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
;;;1577       goto free_pbuf_and_return;
00992e  e051              B        |L1.39380|
                  |L1.39216|
;;;1578     }
;;;1579     /* option fields could be unfold? */
;;;1580     if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
009930  4629              MOV      r1,r5
009932  4620              MOV      r0,r4
009934  f7fffffe          BL       dhcp_parse_reply
009938  b110              CBZ      r0,|L1.39232|
;;;1581       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
00993a  bf00              NOP      
00993c  bf00              NOP      
;;;1582         ("problem unfolding DHCP message - too short on memory?\n"));
;;;1583       goto free_pbuf_and_return;
00993e  e049              B        |L1.39380|
                  |L1.39232|
;;;1584     }
;;;1585   
;;;1586     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
009940  bf00              NOP      
009942  bf00              NOP      
;;;1587     /* obtain pointer to DHCP message type */
;;;1588     if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
009944  48f7              LDR      r0,|L1.40228|
009946  7840              LDRB     r0,[r0,#1]  ; dhcp_rx_options_given
009948  b910              CBNZ     r0,|L1.39248|
;;;1589       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
00994a  bf00              NOP      
00994c  bf00              NOP      
;;;1590       goto free_pbuf_and_return;
00994e  e041              B        |L1.39380|
                  |L1.39248|
;;;1591     }
;;;1592   
;;;1593     /* read DHCP message type */
;;;1594     msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
009950  48f5              LDR      r0,|L1.40232|
009952  f8908004          LDRB     r8,[r0,#4]  ; dhcp_rx_options_val
;;;1595     /* message type is DHCP ACK? */
;;;1596     if (msg_type == DHCP_ACK) {
009956  f1b80f05          CMP      r8,#5
00995a  d118              BNE      |L1.39310|
;;;1597       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
00995c  bf00              NOP      
00995e  bf00              NOP      
;;;1598       /* in requesting state? */
;;;1599       if (dhcp->state == DHCP_REQUESTING) {
009960  7b20              LDRB     r0,[r4,#0xc]
009962  2801              CMP      r0,#1
009964  d106              BNE      |L1.39284|
;;;1600         dhcp_handle_ack(netif);
009966  4638              MOV      r0,r7
009968  f7fffffe          BL       dhcp_handle_ack
;;;1601   #if DHCP_DOES_ARP_CHECK
;;;1602         /* check if the acknowledged lease address is already in use */
;;;1603         dhcp_check(netif);
00996c  4638              MOV      r0,r7
00996e  f7fffffe          BL       dhcp_check
009972  e02e              B        |L1.39378|
                  |L1.39284|
;;;1604   #else
;;;1605         /* bind interface to the acknowledged lease address */
;;;1606         dhcp_bind(netif);
;;;1607   #endif
;;;1608       }
;;;1609       /* already bound to the given lease address? */
;;;1610       else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
009974  7b20              LDRB     r0,[r4,#0xc]
009976  2803              CMP      r0,#3
009978  d005              BEQ      |L1.39302|
00997a  7b20              LDRB     r0,[r4,#0xc]
00997c  2804              CMP      r0,#4
00997e  d002              BEQ      |L1.39302|
009980  7b20              LDRB     r0,[r4,#0xc]
009982  2805              CMP      r0,#5
009984  d125              BNE      |L1.39378|
                  |L1.39302|
;;;1611         dhcp_bind(netif);
009986  4638              MOV      r0,r7
009988  f7fffffe          BL       dhcp_bind
00998c  e021              B        |L1.39378|
                  |L1.39310|
;;;1612       }
;;;1613     }
;;;1614     /* received a DHCP_NAK in appropriate state? */
;;;1615     else if ((msg_type == DHCP_NAK) &&
00998e  f1b80f06          CMP      r8,#6
009992  d111              BNE      |L1.39352|
;;;1616       ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
009994  7b20              LDRB     r0,[r4,#0xc]
009996  2803              CMP      r0,#3
009998  d008              BEQ      |L1.39340|
00999a  7b20              LDRB     r0,[r4,#0xc]
00999c  2801              CMP      r0,#1
00999e  d005              BEQ      |L1.39340|
;;;1617        (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
0099a0  7b20              LDRB     r0,[r4,#0xc]
0099a2  2804              CMP      r0,#4
0099a4  d002              BEQ      |L1.39340|
0099a6  7b20              LDRB     r0,[r4,#0xc]
0099a8  2805              CMP      r0,#5
0099aa  d105              BNE      |L1.39352|
                  |L1.39340|
;;;1618       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
0099ac  bf00              NOP      
0099ae  bf00              NOP      
;;;1619       dhcp_handle_nak(netif);
0099b0  4638              MOV      r0,r7
0099b2  f7fffffe          BL       dhcp_handle_nak
0099b6  e00c              B        |L1.39378|
                  |L1.39352|
;;;1620     }
;;;1621     /* received a DHCP_OFFER in DHCP_SELECTING state? */
;;;1622     else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
0099b8  f1b80f02          CMP      r8,#2
0099bc  d109              BNE      |L1.39378|
0099be  7b20              LDRB     r0,[r4,#0xc]
0099c0  2806              CMP      r0,#6
0099c2  d106              BNE      |L1.39378|
;;;1623       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
0099c4  bf00              NOP      
0099c6  bf00              NOP      
;;;1624       dhcp->request_timeout = 0;
0099c8  2000              MOVS     r0,#0
0099ca  8360              STRH     r0,[r4,#0x1a]
;;;1625       /* remember offered lease */
;;;1626       dhcp_handle_offer(netif);
0099cc  4638              MOV      r0,r7
0099ce  f7fffffe          BL       dhcp_handle_offer
                  |L1.39378|
;;;1627     }
;;;1628   free_pbuf_and_return:
0099d2  bf00              NOP      
                  |L1.39380|
;;;1629     dhcp->msg_in = NULL;
0099d4  2000              MOVS     r0,#0
0099d6  60a0              STR      r0,[r4,#8]
;;;1630     pbuf_free(p);
0099d8  4628              MOV      r0,r5
0099da  f7fffffe          BL       pbuf_free
;;;1631   }
0099de  e8bd9ff0          POP      {r4-r12,pc}
;;;1632   
                          ENDP

                  dhcp_start PROC
;;;628    err_t
;;;629    dhcp_start(struct netif *netif)
0099e2  b570              PUSH     {r4-r6,lr}
;;;630    {
0099e4  4605              MOV      r5,r0
;;;631      struct dhcp *dhcp;
;;;632      err_t result = ERR_OK;
0099e6  2600              MOVS     r6,#0
;;;633    
;;;634      LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
0099e8  bf00              NOP      
0099ea  b915              CBNZ     r5,|L1.39410|
0099ec  f06f000d          MVN      r0,#0xd
                  |L1.39408|
;;;635      dhcp = netif->dhcp;
;;;636      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;637      /* Remove the flag that says this netif is handled by DHCP,
;;;638         it is set when we succeeded starting. */
;;;639      netif->flags &= ~NETIF_FLAG_DHCP;
;;;640    
;;;641      /* check hwtype of the netif */
;;;642      if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
;;;643        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
;;;644        return ERR_ARG;
;;;645      }
;;;646    
;;;647      /* check MTU of the netif */
;;;648      if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
;;;649        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
;;;650        return ERR_MEM;
;;;651      }
;;;652    
;;;653      /* no DHCP client attached yet? */
;;;654      if (dhcp == NULL) {
;;;655        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
;;;656        dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
;;;657        if (dhcp == NULL) {
;;;658          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
;;;659          return ERR_MEM;
;;;660        }
;;;661        /* store this dhcp client in the netif */
;;;662        netif->dhcp = dhcp;
;;;663        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
;;;664      /* already has DHCP client attached */
;;;665      } else {
;;;666        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
;;;667        if (dhcp->pcb != NULL) {
;;;668          udp_remove(dhcp->pcb);
;;;669        }
;;;670        LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
;;;671        LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
;;;672      }
;;;673        
;;;674      /* clear data structure */
;;;675      memset(dhcp, 0, sizeof(struct dhcp));
;;;676      /* dhcp_set_state(&dhcp, DHCP_OFF); */
;;;677      /* allocate UDP PCB */
;;;678      dhcp->pcb = udp_new();
;;;679      if (dhcp->pcb == NULL) {
;;;680        LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
;;;681        return ERR_MEM;
;;;682      }
;;;683      ip_set_option(dhcp->pcb, SOF_BROADCAST);
;;;684      /* set up local and remote port for the pcb */
;;;685      udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
;;;686      udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
;;;687      /* set up the recv callback and argument */
;;;688      udp_recv(dhcp->pcb, dhcp_recv, netif);
;;;689      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
;;;690      /* (re)start the DHCP negotiation */
;;;691      result = dhcp_discover(netif);
;;;692      if (result != ERR_OK) {
;;;693        /* free resources allocated above */
;;;694        dhcp_stop(netif);
;;;695        return ERR_MEM;
;;;696      }
;;;697      /* Set the flag that says this netif is handled by DHCP. */
;;;698      netif->flags |= NETIF_FLAG_DHCP;
;;;699      return result;
;;;700    }
0099f0  bd70              POP      {r4-r6,pc}
                  |L1.39410|
0099f2  bf00              NOP                            ;634
0099f4  6a2c              LDR      r4,[r5,#0x20]         ;635
0099f6  bf00              NOP                            ;636
0099f8  bf00              NOP                            ;636
0099fa  f8150f31          LDRB     r0,[r5,#0x31]!        ;639
0099fe  f0200008          BIC      r0,r0,#8              ;639
009a02  7028              STRB     r0,[r5,#0]            ;639
009a04  f8150931          LDRB     r0,[r5],#-0x31        ;642
009a08  f0100f20          TST      r0,#0x20              ;642
009a0c  d104              BNE      |L1.39448|
009a0e  bf00              NOP                            ;643
009a10  bf00              NOP                            ;643
009a12  f06f000d          MVN      r0,#0xd               ;644
009a16  e7eb              B        |L1.39408|
                  |L1.39448|
009a18  8d28              LDRH     r0,[r5,#0x28]         ;648
009a1a  f5b07f10          CMP      r0,#0x240             ;648
009a1e  da04              BGE      |L1.39466|
009a20  bf00              NOP                            ;649
009a22  bf00              NOP                            ;649
009a24  f04f30ff          MOV      r0,#0xffffffff        ;650
009a28  e7e2              B        |L1.39408|
                  |L1.39466|
009a2a  b974              CBNZ     r4,|L1.39498|
009a2c  bf00              NOP                            ;655
009a2e  bf00              NOP                            ;655
009a30  203c              MOVS     r0,#0x3c              ;656
009a32  f7fffffe          BL       mem_malloc
009a36  4604              MOV      r4,r0                 ;656
009a38  b924              CBNZ     r4,|L1.39492|
009a3a  bf00              NOP                            ;658
009a3c  bf00              NOP                            ;658
009a3e  f04f30ff          MOV      r0,#0xffffffff        ;659
009a42  e7d5              B        |L1.39408|
                  |L1.39492|
009a44  622c              STR      r4,[r5,#0x20]         ;662
009a46  bf00              NOP                            ;663
009a48  e00a              B        |L1.39520|
                  |L1.39498|
009a4a  bf00              NOP                            ;666
009a4c  bf00              NOP                            ;666
009a4e  6860              LDR      r0,[r4,#4]            ;667
009a50  b110              CBZ      r0,|L1.39512|
009a52  6860              LDR      r0,[r4,#4]            ;668
009a54  f7fffffe          BL       udp_remove
                  |L1.39512|
009a58  bf00              NOP                            ;670
009a5a  bf00              NOP                            ;670
009a5c  bf00              NOP                            ;671
009a5e  bf00              NOP                            ;671
                  |L1.39520|
009a60  213c              MOVS     r1,#0x3c              ;675
009a62  4620              MOV      r0,r4                 ;675
009a64  f7fffffe          BL       __aeabi_memclr4
009a68  f7fffffe          BL       udp_new
009a6c  6060              STR      r0,[r4,#4]            ;678
009a6e  6860              LDR      r0,[r4,#4]            ;679
009a70  b920              CBNZ     r0,|L1.39548|
009a72  bf00              NOP                            ;680
009a74  bf00              NOP                            ;680
009a76  f04f30ff          MOV      r0,#0xffffffff        ;681
009a7a  e7b9              B        |L1.39408|
                  |L1.39548|
009a7c  6860              LDR      r0,[r4,#4]            ;683
009a7e  7a00              LDRB     r0,[r0,#8]            ;683
009a80  f0400020          ORR      r0,r0,#0x20           ;683
009a84  6861              LDR      r1,[r4,#4]            ;683
009a86  7208              STRB     r0,[r1,#8]            ;683
009a88  2244              MOVS     r2,#0x44              ;685
009a8a  49a8              LDR      r1,|L1.40236|
009a8c  6860              LDR      r0,[r4,#4]            ;685
009a8e  f7fffffe          BL       udp_bind
009a92  2243              MOVS     r2,#0x43              ;686
009a94  49a5              LDR      r1,|L1.40236|
009a96  6860              LDR      r0,[r4,#4]            ;686
009a98  f7fffffe          BL       udp_connect
009a9c  462a              MOV      r2,r5                 ;688
009a9e  49a4              LDR      r1,|L1.40240|
009aa0  6860              LDR      r0,[r4,#4]            ;688
009aa2  f7fffffe          BL       udp_recv
009aa6  bf00              NOP                            ;689
009aa8  bf00              NOP                            ;689
009aaa  4628              MOV      r0,r5                 ;691
009aac  f7fffffe          BL       dhcp_discover
009ab0  4606              MOV      r6,r0                 ;691
009ab2  b12e              CBZ      r6,|L1.39616|
009ab4  4628              MOV      r0,r5                 ;694
009ab6  f7fffffe          BL       dhcp_stop
009aba  f04f30ff          MOV      r0,#0xffffffff        ;695
009abe  e797              B        |L1.39408|
                  |L1.39616|
009ac0  f8950031          LDRB     r0,[r5,#0x31]         ;698
009ac4  f0400008          ORR      r0,r0,#8              ;698
009ac8  f8850031          STRB     r0,[r5,#0x31]         ;698
009acc  4630              MOV      r0,r6                 ;699
009ace  e78f              B        |L1.39408|
;;;701    
                          ENDP

                  dhcp_inform PROC
;;;711    void
;;;712    dhcp_inform(struct netif *netif)
009ad0  b570              PUSH     {r4-r6,lr}
;;;713    {
009ad2  b090              SUB      sp,sp,#0x40
009ad4  4604              MOV      r4,r0
;;;714      struct dhcp dhcp;
;;;715      err_t result = ERR_OK;
009ad6  2600              MOVS     r6,#0
;;;716      struct udp_pcb *pcb;
;;;717    
;;;718      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
009ad8  bf00              NOP      
009ada  b90c              CBNZ     r4,|L1.39648|
                  |L1.39644|
;;;719    
;;;720      memset(&dhcp, 0, sizeof(struct dhcp));
;;;721      dhcp_set_state(&dhcp, DHCP_INFORM);
;;;722    
;;;723      if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
;;;724        /* re-use existing pcb */
;;;725        pcb = netif->dhcp->pcb;
;;;726      } else {
;;;727        pcb = udp_new();
;;;728        if (pcb == NULL) {
;;;729          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
;;;730          return;
;;;731        }
;;;732        dhcp.pcb = pcb;
;;;733        ip_set_option(dhcp.pcb, SOF_BROADCAST);
;;;734        udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
;;;735        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
;;;736      }
;;;737      /* create and initialize the DHCP message header */
;;;738      result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
;;;739      if (result == ERR_OK) {
;;;740        dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
;;;741        dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
;;;742    
;;;743        dhcp_option_trailer(&dhcp);
;;;744    
;;;745        pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
;;;746    
;;;747        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
;;;748        udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
;;;749        dhcp_delete_msg(&dhcp);
;;;750      } else {
;;;751        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
;;;752      }
;;;753    
;;;754      if (dhcp.pcb != NULL) {
;;;755        /* otherwise, the existing pcb was used */
;;;756        udp_remove(dhcp.pcb);
;;;757      }
;;;758    }
009adc  b010              ADD      sp,sp,#0x40
009ade  bd70              POP      {r4-r6,pc}
                  |L1.39648|
009ae0  bf00              NOP                            ;718
009ae2  213c              MOVS     r1,#0x3c              ;720
009ae4  a801              ADD      r0,sp,#4              ;720
009ae6  f7fffffe          BL       __aeabi_memclr4
009aea  2108              MOVS     r1,#8                 ;721
009aec  a801              ADD      r0,sp,#4              ;721
009aee  f7fffffe          BL       dhcp_set_state
009af2  6a20              LDR      r0,[r4,#0x20]         ;723
009af4  b128              CBZ      r0,|L1.39682|
009af6  6a20              LDR      r0,[r4,#0x20]         ;723
009af8  6840              LDR      r0,[r0,#4]            ;723
009afa  b110              CBZ      r0,|L1.39682|
009afc  6a20              LDR      r0,[r4,#0x20]         ;725
009afe  6845              LDR      r5,[r0,#4]            ;725
009b00  e014              B        |L1.39724|
                  |L1.39682|
009b02  f7fffffe          BL       udp_new
009b06  4605              MOV      r5,r0                 ;727
009b08  b915              CBNZ     r5,|L1.39696|
009b0a  bf00              NOP                            ;729
009b0c  bf00              NOP                            ;729
009b0e  e7e5              B        |L1.39644|
                  |L1.39696|
009b10  9502              STR      r5,[sp,#8]            ;732
009b12  9802              LDR      r0,[sp,#8]            ;733
009b14  7a00              LDRB     r0,[r0,#8]            ;733
009b16  f0400020          ORR      r0,r0,#0x20           ;733
009b1a  9902              LDR      r1,[sp,#8]            ;733
009b1c  7208              STRB     r0,[r1,#8]            ;733
009b1e  2244              MOVS     r2,#0x44              ;734
009b20  4982              LDR      r1,|L1.40236|
009b22  9802              LDR      r0,[sp,#8]            ;734
009b24  f7fffffe          BL       udp_bind
009b28  bf00              NOP                            ;735
009b2a  bf00              NOP                            ;735
                  |L1.39724|
009b2c  2208              MOVS     r2,#8                 ;738
009b2e  a901              ADD      r1,sp,#4              ;738
009b30  4620              MOV      r0,r4                 ;738
009b32  f7fffffe          BL       dhcp_create_msg
009b36  4606              MOV      r6,r0                 ;738
009b38  b9fe              CBNZ     r6,|L1.39802|
009b3a  2202              MOVS     r2,#2                 ;740
009b3c  2139              MOVS     r1,#0x39              ;740
009b3e  a801              ADD      r0,sp,#4              ;740
009b40  f7fffffe          BL       dhcp_option
009b44  8d21              LDRH     r1,[r4,#0x28]         ;741
009b46  a801              ADD      r0,sp,#4              ;741
009b48  f7fffffe          BL       dhcp_option_short
009b4c  a801              ADD      r0,sp,#4              ;743
009b4e  f7fffffe          BL       dhcp_option_trailer
009b52  f8bd201c          LDRH     r2,[sp,#0x1c]         ;745
009b56  32f0              ADDS     r2,r2,#0xf0           ;745
009b58  b291              UXTH     r1,r2                 ;745
009b5a  9805              LDR      r0,[sp,#0x14]         ;745
009b5c  f7fffffe          BL       pbuf_realloc
009b60  bf00              NOP                            ;747
009b62  bf00              NOP                            ;747
009b64  9400              STR      r4,[sp,#0]            ;748
009b66  2343              MOVS     r3,#0x43              ;748
009b68  4a72              LDR      r2,|L1.40244|
009b6a  4628              MOV      r0,r5                 ;748
009b6c  9905              LDR      r1,[sp,#0x14]         ;748
009b6e  f7fffffe          BL       udp_sendto_if
009b72  a801              ADD      r0,sp,#4              ;749
009b74  f7fffffe          BL       dhcp_delete_msg
009b78  e001              B        |L1.39806|
                  |L1.39802|
009b7a  bf00              NOP                            ;751
009b7c  bf00              NOP                            ;751
                  |L1.39806|
009b7e  9802              LDR      r0,[sp,#8]            ;754
009b80  b110              CBZ      r0,|L1.39816|
009b82  9802              LDR      r0,[sp,#8]            ;756
009b84  f7fffffe          BL       udp_remove
                  |L1.39816|
009b88  bf00              NOP      
009b8a  e7a7              B        |L1.39644|
;;;759    
                          ENDP

                  dhcp_network_changed PROC
;;;765    void
;;;766    dhcp_network_changed(struct netif *netif)
009b8c  b570              PUSH     {r4-r6,lr}
;;;767    {
009b8e  4605              MOV      r5,r0
;;;768      struct dhcp *dhcp = netif->dhcp;
009b90  6a2c              LDR      r4,[r5,#0x20]
;;;769      if (!dhcp)
009b92  b904              CBNZ     r4,|L1.39830|
                  |L1.39828|
;;;770        return;
;;;771      switch (dhcp->state) {
;;;772      case DHCP_REBINDING:
;;;773      case DHCP_RENEWING:
;;;774      case DHCP_BOUND:
;;;775      case DHCP_REBOOTING:
;;;776        netif_set_down(netif);
;;;777        dhcp->tries = 0;
;;;778        dhcp_reboot(netif);
;;;779        break;
;;;780      case DHCP_OFF:
;;;781        /* stay off */
;;;782        break;
;;;783      default:
;;;784        dhcp->tries = 0;
;;;785    #if LWIP_DHCP_AUTOIP_COOP
;;;786        if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;787          autoip_stop(netif);
;;;788          dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;789        }
;;;790    #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;791        dhcp_discover(netif);
;;;792        break;
;;;793      }
;;;794    }
009b94  bd70              POP      {r4-r6,pc}
                  |L1.39830|
009b96  7b20              LDRB     r0,[r4,#0xc]          ;771
009b98  2804              CMP      r0,#4                 ;771
009b9a  d009              BEQ      |L1.39856|
009b9c  dc03              BGT      |L1.39846|
009b9e  b198              CBZ      r0,|L1.39880|
009ba0  2803              CMP      r0,#3                 ;771
009ba2  d112              BNE      |L1.39882|
009ba4  e007              B        |L1.39862|
                  |L1.39846|
009ba6  2805              CMP      r0,#5                 ;771
009ba8  d003              BEQ      |L1.39858|
009baa  280a              CMP      r0,#0xa               ;771
009bac  d10d              BNE      |L1.39882|
009bae  e001              B        |L1.39860|
                  |L1.39856|
009bb0  bf00              NOP                            ;773
                  |L1.39858|
009bb2  bf00              NOP                            ;774
                  |L1.39860|
009bb4  bf00              NOP                            ;775
                  |L1.39862|
009bb6  4628              MOV      r0,r5                 ;776
009bb8  f7fffffe          BL       netif_set_down
009bbc  2000              MOVS     r0,#0                 ;777
009bbe  7360              STRB     r0,[r4,#0xd]          ;777
009bc0  4628              MOV      r0,r5                 ;778
009bc2  f7fffffe          BL       dhcp_reboot
009bc6  e00e              B        |L1.39910|
                  |L1.39880|
009bc8  e00d              B        |L1.39910|
                  |L1.39882|
009bca  2000              MOVS     r0,#0                 ;784
009bcc  7360              STRB     r0,[r4,#0xd]          ;784
009bce  7ba0              LDRB     r0,[r4,#0xe]          ;786
009bd0  2801              CMP      r0,#1                 ;786
009bd2  d104              BNE      |L1.39902|
009bd4  4628              MOV      r0,r5                 ;787
009bd6  f7fffffe          BL       autoip_stop
009bda  2000              MOVS     r0,#0                 ;788
009bdc  73a0              STRB     r0,[r4,#0xe]          ;788
                  |L1.39902|
009bde  4628              MOV      r0,r5                 ;791
009be0  f7fffffe          BL       dhcp_discover
009be4  bf00              NOP                            ;792
                  |L1.39910|
009be6  bf00              NOP                            ;779
009be8  bf00              NOP      
009bea  e7d3              B        |L1.39828|
;;;795    
                          ENDP

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
009bec  b570              PUSH     {r4-r6,lr}
;;;647    {
009bee  4604              MOV      r4,r0
009bf0  460d              MOV      r5,r1
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
009bf2  fb04f005          MUL      r0,r4,r5
009bf6  f7fffffe          BL       mem_malloc
009bfa  4606              MOV      r6,r0
;;;652      if (p) {
009bfc  b126              CBZ      r6,|L1.39944|
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
009bfe  fb04f105          MUL      r1,r4,r5
009c02  4630              MOV      r0,r6
009c04  f7fffffe          BL       __aeabi_memclr
                  |L1.39944|
;;;655      }
;;;656      return p;
009c08  4630              MOV      r0,r6
;;;657    }
009c0a  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP

                  igmp_start PROC
;;;190    err_t
;;;191    igmp_start(struct netif *netif)
009c0c  b570              PUSH     {r4-r6,lr}
;;;192    {
009c0e  4605              MOV      r5,r0
;;;193      struct igmp_group* group;
;;;194    
;;;195      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: starting IGMP processing on if %p\n", netif));
009c10  bf00              NOP      
009c12  bf00              NOP      
;;;196    
;;;197      group = igmp_lookup_group(netif, &allsystems);
009c14  4948              LDR      r1,|L1.40248|
009c16  4628              MOV      r0,r5
009c18  f7fffffe          BL       igmp_lookup_group
009c1c  4604              MOV      r4,r0
;;;198    
;;;199      if (group != NULL) {
009c1e  b19c              CBZ      r4,|L1.40008|
;;;200        group->group_state = IGMP_GROUP_IDLE_MEMBER;
009c20  2002              MOVS     r0,#2
009c22  7360              STRB     r0,[r4,#0xd]
;;;201        group->use++;
009c24  7c20              LDRB     r0,[r4,#0x10]
009c26  1c40              ADDS     r0,r0,#1
009c28  7420              STRB     r0,[r4,#0x10]
;;;202    
;;;203        /* Allow the igmp messages at the MAC level */
;;;204        if (netif->igmp_mac_filter != NULL) {
009c2a  6ba8              LDR      r0,[r5,#0x38]
009c2c  b150              CBZ      r0,|L1.40004|
;;;205          LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: igmp_mac_filter(ADD "));
009c2e  bf00              NOP      
009c30  bf00              NOP      
;;;206          ip_addr_debug_print(IGMP_DEBUG, &allsystems);
009c32  bf00              NOP      
009c34  bf00              NOP      
;;;207          LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
009c36  bf00              NOP      
009c38  bf00              NOP      
;;;208          netif->igmp_mac_filter(netif, &allsystems, IGMP_ADD_MAC_FILTER);
009c3a  2201              MOVS     r2,#1
009c3c  493e              LDR      r1,|L1.40248|
009c3e  4628              MOV      r0,r5
009c40  6bab              LDR      r3,[r5,#0x38]
009c42  4798              BLX      r3
                  |L1.40004|
;;;209        }
;;;210    
;;;211        return ERR_OK;
009c44  2000              MOVS     r0,#0
                  |L1.40006|
;;;212      }
;;;213    
;;;214      return ERR_MEM;
;;;215    }
009c46  bd70              POP      {r4-r6,pc}
                  |L1.40008|
009c48  f04f30ff          MOV      r0,#0xffffffff        ;214
009c4c  e7fb              B        |L1.40006|
;;;216    
                          ENDP

                  netif_set_addr PROC
;;;220    void
;;;221    netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
009c4e  e92d41f0          PUSH     {r4-r8,lr}
;;;222        ip_addr_t *gw)
;;;223    {
009c52  4606              MOV      r6,r0
009c54  460f              MOV      r7,r1
009c56  4614              MOV      r4,r2
009c58  461d              MOV      r5,r3
;;;224      netif_set_ipaddr(netif, ipaddr);
009c5a  4639              MOV      r1,r7
009c5c  4630              MOV      r0,r6
009c5e  f7fffffe          BL       netif_set_ipaddr
;;;225      netif_set_netmask(netif, netmask);
009c62  4621              MOV      r1,r4
009c64  4630              MOV      r0,r6
009c66  f7fffffe          BL       netif_set_netmask
;;;226      netif_set_gw(netif, gw);
009c6a  4629              MOV      r1,r5
009c6c  4630              MOV      r0,r6
009c6e  f7fffffe          BL       netif_set_gw
;;;227    }
009c72  e8bd81f0          POP      {r4-r8,pc}
;;;228    
                          ENDP

                  netif_add PROC
;;;138    struct netif *
;;;139    netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
009c76  e92d47f0          PUSH     {r4-r10,lr}
;;;140      ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
;;;141    {
009c7a  4604              MOV      r4,r0
009c7c  460d              MOV      r5,r1
009c7e  4616              MOV      r6,r2
009c80  461f              MOV      r7,r3
009c82  e9dda909          LDRD     r10,r9,[sp,#0x24]
009c86  f8dd8020          LDR      r8,[sp,#0x20]
;;;142    
;;;143      LWIP_ASSERT("No init function given", init != NULL);
009c8a  bf00              NOP      
009c8c  bf00              NOP      
;;;144    
;;;145      /* reset new interface configuration state */
;;;146      ip_addr_set_zero(&netif->ip_addr);
009c8e  2000              MOVS     r0,#0
009c90  6060              STR      r0,[r4,#4]
;;;147      ip_addr_set_zero(&netif->netmask);
009c92  60a0              STR      r0,[r4,#8]
;;;148      ip_addr_set_zero(&netif->gw);
009c94  60e0              STR      r0,[r4,#0xc]
;;;149      netif->flags = 0;
009c96  f8840031          STRB     r0,[r4,#0x31]
;;;150    #if LWIP_DHCP
;;;151      /* netif not under DHCP control by default */
;;;152      netif->dhcp = NULL;
009c9a  6220              STR      r0,[r4,#0x20]
;;;153    #endif /* LWIP_DHCP */
;;;154    #if LWIP_AUTOIP
;;;155      /* netif not under AutoIP control by default */
;;;156      netif->autoip = NULL;
009c9c  6260              STR      r0,[r4,#0x24]
;;;157    #endif /* LWIP_AUTOIP */
;;;158    #if LWIP_NETIF_STATUS_CALLBACK
;;;159      netif->status_callback = NULL;
;;;160    #endif /* LWIP_NETIF_STATUS_CALLBACK */
;;;161    #if LWIP_NETIF_LINK_CALLBACK
;;;162      netif->link_callback = NULL;
;;;163    #endif /* LWIP_NETIF_LINK_CALLBACK */
;;;164    #if LWIP_IGMP
;;;165      netif->igmp_mac_filter = NULL;
009c9e  63a0              STR      r0,[r4,#0x38]
;;;166    #endif /* LWIP_IGMP */
;;;167    #if ENABLE_LOOPBACK
;;;168      netif->loop_first = NULL;
;;;169      netif->loop_last = NULL;
;;;170    #endif /* ENABLE_LOOPBACK */
;;;171    
;;;172      /* remember netif specific state information data */
;;;173      netif->state = state;
009ca0  f8c4801c          STR      r8,[r4,#0x1c]
;;;174      netif->num = netif_num++;
009ca4  4825              LDR      r0,|L1.40252|
009ca6  7800              LDRB     r0,[r0,#0]  ; netif_num
009ca8  f8840034          STRB     r0,[r4,#0x34]
009cac  4823              LDR      r0,|L1.40252|
009cae  7800              LDRB     r0,[r0,#0]  ; netif_num
009cb0  1c40              ADDS     r0,r0,#1
009cb2  4922              LDR      r1,|L1.40252|
009cb4  7008              STRB     r0,[r1,#0]
;;;175      netif->input = input;
009cb6  f8c49010          STR      r9,[r4,#0x10]
;;;176      NETIF_SET_HWADDRHINT(netif, NULL);
;;;177    #if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
;;;178      netif->loop_cnt_current = 0;
;;;179    #endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */
;;;180    
;;;181      netif_set_addr(netif, ipaddr, netmask, gw);
009cba  463b              MOV      r3,r7
009cbc  4632              MOV      r2,r6
009cbe  4629              MOV      r1,r5
009cc0  4620              MOV      r0,r4
009cc2  f7fffffe          BL       netif_set_addr
;;;182    
;;;183      /* call user specified initialization function for netif */
;;;184      if (init(netif) != ERR_OK) {
009cc6  4620              MOV      r0,r4
009cc8  47d0              BLX      r10
009cca  b110              CBZ      r0,|L1.40146|
;;;185        return NULL;
009ccc  2000              MOVS     r0,#0
                  |L1.40142|
;;;186      }
;;;187    
;;;188      /* add this netif to the list */
;;;189      netif->next = netif_list;
;;;190      netif_list = netif;
;;;191      snmp_inc_iflist();
;;;192    
;;;193    #if LWIP_IGMP
;;;194      /* start IGMP processing */
;;;195      if (netif->flags & NETIF_FLAG_IGMP) {
;;;196        igmp_start(netif);
;;;197      }
;;;198    #endif /* LWIP_IGMP */
;;;199    
;;;200      LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP addr ",
;;;201        netif->name[0], netif->name[1]));
;;;202      ip_addr_debug_print(NETIF_DEBUG, ipaddr);
;;;203      LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
;;;204      ip_addr_debug_print(NETIF_DEBUG, netmask);
;;;205      LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
;;;206      ip_addr_debug_print(NETIF_DEBUG, gw);
;;;207      LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
;;;208      return netif;
;;;209    }
009cce  e8bd87f0          POP      {r4-r10,pc}
                  |L1.40146|
009cd2  481b              LDR      r0,|L1.40256|
009cd4  6800              LDR      r0,[r0,#0]            ;189  ; netif_list
009cd6  6020              STR      r0,[r4,#0]            ;189
009cd8  4819              LDR      r0,|L1.40256|
009cda  6004              STR      r4,[r0,#0]            ;190  ; netif_list
009cdc  f8940031          LDRB     r0,[r4,#0x31]         ;195
009ce0  f0100f80          TST      r0,#0x80              ;195
009ce4  d002              BEQ      |L1.40172|
009ce6  4620              MOV      r0,r4                 ;196
009ce8  f7fffffe          BL       igmp_start
                  |L1.40172|
009cec  bf00              NOP                            ;200
009cee  bf00              NOP                            ;200
009cf0  bf00              NOP                            ;202
009cf2  bf00              NOP                            ;202
009cf4  bf00              NOP                            ;203
009cf6  bf00              NOP                            ;203
009cf8  bf00              NOP                            ;204
009cfa  bf00              NOP                            ;204
009cfc  bf00              NOP                            ;205
009cfe  bf00              NOP                            ;205
009d00  bf00              NOP                            ;206
009d02  bf00              NOP                            ;206
009d04  bf00              NOP                            ;207
009d06  bf00              NOP                            ;207
009d08  4620              MOV      r0,r4                 ;208
009d0a  e7e0              B        |L1.40142|
;;;210    
                          ENDP

                  netif_set_default PROC
;;;429    void
;;;430    netif_set_default(struct netif *netif)
009d0c  490d              LDR      r1,|L1.40260|
;;;431    {
;;;432      if (netif == NULL) {
;;;433        /* remove default route */
;;;434        snmp_delete_iprteidx_tree(1, netif);
;;;435      } else {
;;;436        /* install default route */
;;;437        snmp_insert_iprteidx_tree(1, netif);
;;;438      }
;;;439      netif_default = netif;
009d0e  6008              STR      r0,[r1,#0]  ; netif_default
;;;440      LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
009d10  bf00              NOP      
009d12  bf00              NOP      
;;;441               netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
;;;442    }
009d14  4770              BX       lr
;;;443    
                          ENDP

                  igmp_stop PROC
;;;222    err_t
;;;223    igmp_stop(struct netif *netif)
009d16  e92d41f0          PUSH     {r4-r8,lr}
;;;224    {
009d1a  4605              MOV      r5,r0
;;;225      struct igmp_group *group = igmp_group_list;
009d1c  480a              LDR      r0,|L1.40264|
009d1e  6804              LDR      r4,[r0,#0]  ; igmp_group_list
;;;226      struct igmp_group *prev  = NULL;
009d20  2700              MOVS     r7,#0
;;;227      struct igmp_group *next;
;;;228    
;;;229      /* look for groups joined on this interface further down the list */
;;;230      while (group != NULL) {
009d22  e034              B        |L1.40334|
                  |L1.40228|
                          DCD      dhcp_rx_options_given
                  |L1.40232|
                          DCD      dhcp_rx_options_val
                  |L1.40236|
                          DCD      ip_addr_any
                  |L1.40240|
                          DCD      dhcp_recv
                  |L1.40244|
                          DCD      ip_addr_broadcast
                  |L1.40248|
                          DCD      allsystems
                  |L1.40252|
                          DCD      netif_num
                  |L1.40256|
                          DCD      netif_list
                  |L1.40260|
                          DCD      netif_default
                  |L1.40264|
                          DCD      igmp_group_list
                  |L1.40268|
;;;231        next = group->next;
009d4c  6826              LDR      r6,[r4,#0]
;;;232        /* is it a group joined on this interface? */
;;;233        if (group->netif == netif) {
009d4e  6860              LDR      r0,[r4,#4]
009d50  42a8              CMP      r0,r5
009d52  d11a              BNE      |L1.40330|
;;;234          /* is it the first group of the list? */
;;;235          if (group == igmp_group_list) {
009d54  48f6              LDR      r0,|L1.41264|
009d56  6800              LDR      r0,[r0,#0]  ; igmp_group_list
009d58  4284              CMP      r4,r0
009d5a  d101              BNE      |L1.40288|
;;;236            igmp_group_list = next;
009d5c  48f4              LDR      r0,|L1.41264|
009d5e  6006              STR      r6,[r0,#0]  ; igmp_group_list
                  |L1.40288|
;;;237          }
;;;238          /* is there a "previous" group defined? */
;;;239          if (prev != NULL) {
009d60  b107              CBZ      r7,|L1.40292|
;;;240            prev->next = next;
009d62  603e              STR      r6,[r7,#0]
                  |L1.40292|
;;;241          }
;;;242          /* disable the group at the MAC level */
;;;243          if (netif->igmp_mac_filter != NULL) {
009d64  6ba8              LDR      r0,[r5,#0x38]
009d66  b158              CBZ      r0,|L1.40320|
;;;244            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_stop: igmp_mac_filter(DEL "));
009d68  bf00              NOP      
009d6a  bf00              NOP      
;;;245            ip_addr_debug_print(IGMP_DEBUG, &group->group_address);
009d6c  bf00              NOP      
009d6e  bf00              NOP      
;;;246            LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
009d70  bf00              NOP      
009d72  bf00              NOP      
;;;247            netif->igmp_mac_filter(netif, &(group->group_address), IGMP_DEL_MAC_FILTER);
009d74  2200              MOVS     r2,#0
009d76  f1040108          ADD      r1,r4,#8
009d7a  4628              MOV      r0,r5
009d7c  6bab              LDR      r3,[r5,#0x38]
009d7e  4798              BLX      r3
                  |L1.40320|
;;;248          }
;;;249          /* free group */
;;;250          memp_free(MEMP_IGMP_GROUP, group);
009d80  4621              MOV      r1,r4
009d82  2009              MOVS     r0,#9
009d84  f7fffffe          BL       memp_free
009d88  e000              B        |L1.40332|
                  |L1.40330|
;;;251        } else {
;;;252          /* change the "previous" */
;;;253          prev = group;
009d8a  4627              MOV      r7,r4
                  |L1.40332|
;;;254        }
;;;255        /* move to "next" */
;;;256        group = next;
009d8c  4634              MOV      r4,r6
                  |L1.40334|
009d8e  2c00              CMP      r4,#0                 ;230
009d90  d1dc              BNE      |L1.40268|
;;;257      }
;;;258      return ERR_OK;
009d92  2000              MOVS     r0,#0
;;;259    }
009d94  e8bd81f0          POP      {r4-r8,pc}
;;;260    
                          ENDP

                  netif_remove PROC
;;;234    void
;;;235    netif_remove(struct netif *netif)
009d98  b510              PUSH     {r4,lr}
;;;236    {
009d9a  4604              MOV      r4,r0
;;;237      if (netif == NULL) {
009d9c  b904              CBNZ     r4,|L1.40352|
                  |L1.40350|
;;;238        return;
;;;239      }
;;;240    
;;;241    #if LWIP_IGMP
;;;242      /* stop IGMP processing */
;;;243      if (netif->flags & NETIF_FLAG_IGMP) {
;;;244        igmp_stop(netif);
;;;245      }
;;;246    #endif /* LWIP_IGMP */
;;;247      if (netif_is_up(netif)) {
;;;248        /* set netif down before removing (call callback function) */
;;;249        netif_set_down(netif);
;;;250      }
;;;251    
;;;252      snmp_delete_ipaddridx_tree(netif);
;;;253    
;;;254      /*  is it the first netif? */
;;;255      if (netif_list == netif) {
;;;256        netif_list = netif->next;
;;;257      } else {
;;;258        /*  look for netif further down the list */
;;;259        struct netif * tmpNetif;
;;;260        for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
;;;261          if (tmpNetif->next == netif) {
;;;262            tmpNetif->next = netif->next;
;;;263            break;
;;;264          }
;;;265        }
;;;266        if (tmpNetif == NULL)
;;;267          return; /*  we didn't find any netif today */
;;;268      }
;;;269      snmp_dec_iflist();
;;;270      /* this netif is default? */
;;;271      if (netif_default == netif) {
;;;272        /* reset default netif */
;;;273        netif_set_default(NULL);
;;;274      }
;;;275    #if LWIP_NETIF_REMOVE_CALLBACK
;;;276      if (netif->remove_callback) {
;;;277        netif->remove_callback(netif);
;;;278      }
;;;279    #endif /* LWIP_NETIF_REMOVE_CALLBACK */
;;;280      LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
;;;281    }
009d9e  bd10              POP      {r4,pc}
                  |L1.40352|
009da0  f8940031          LDRB     r0,[r4,#0x31]         ;243
009da4  f0100f80          TST      r0,#0x80              ;243
009da8  d002              BEQ      |L1.40368|
009daa  4620              MOV      r0,r4                 ;244
009dac  f7fffffe          BL       igmp_stop
                  |L1.40368|
009db0  f8940031          LDRB     r0,[r4,#0x31]         ;247
009db4  f0100f01          TST      r0,#1                 ;247
009db8  d002              BEQ      |L1.40384|
009dba  4620              MOV      r0,r4                 ;249
009dbc  f7fffffe          BL       netif_set_down
                  |L1.40384|
009dc0  48dc              LDR      r0,|L1.41268|
009dc2  6800              LDR      r0,[r0,#0]            ;255  ; netif_list
009dc4  42a0              CMP      r0,r4                 ;255
009dc6  d103              BNE      |L1.40400|
009dc8  49da              LDR      r1,|L1.41268|
009dca  6820              LDR      r0,[r4,#0]            ;256
009dcc  6008              STR      r0,[r1,#0]            ;256  ; netif_list
009dce  e00f              B        |L1.40432|
                  |L1.40400|
009dd0  49d8              LDR      r1,|L1.41268|
009dd2  6808              LDR      r0,[r1,#0]            ;260  ; netif_list
009dd4  e006              B        |L1.40420|
                  |L1.40406|
009dd6  6801              LDR      r1,[r0,#0]            ;261
009dd8  42a1              CMP      r1,r4                 ;261
009dda  d102              BNE      |L1.40418|
009ddc  6821              LDR      r1,[r4,#0]            ;262
009dde  6001              STR      r1,[r0,#0]            ;262
009de0  e002              B        |L1.40424|
                  |L1.40418|
009de2  6800              LDR      r0,[r0,#0]            ;260
                  |L1.40420|
009de4  2800              CMP      r0,#0                 ;260
009de6  d1f6              BNE      |L1.40406|
                  |L1.40424|
009de8  bf00              NOP                            ;263
009dea  b900              CBNZ     r0,|L1.40430|
009dec  e7d7              B        |L1.40350|
                  |L1.40430|
009dee  bf00              NOP                            ;268
                  |L1.40432|
009df0  48d1              LDR      r0,|L1.41272|
009df2  6800              LDR      r0,[r0,#0]            ;271  ; netif_default
009df4  42a0              CMP      r0,r4                 ;271
009df6  d102              BNE      |L1.40446|
009df8  2000              MOVS     r0,#0                 ;273
009dfa  f7fffffe          BL       netif_set_default
                  |L1.40446|
009dfe  bf00              NOP                            ;280
009e00  bf00              NOP                            ;280
009e02  bf00              NOP      
009e04  e7cb              B        |L1.40350|
;;;282    
                          ENDP

                  netif_find PROC
;;;289    struct netif *
;;;290    netif_find(char *name)
009e06  b510              PUSH     {r4,lr}
;;;291    {
009e08  4602              MOV      r2,r0
;;;292      struct netif *netif;
;;;293      u8_t num;
;;;294    
;;;295      if (name == NULL) {
009e0a  b90a              CBNZ     r2,|L1.40464|
;;;296        return NULL;
009e0c  2000              MOVS     r0,#0
                  |L1.40462|
;;;297      }
;;;298    
;;;299      num = name[2] - '0';
;;;300    
;;;301      for(netif = netif_list; netif != NULL; netif = netif->next) {
;;;302        if (num == netif->num &&
;;;303           name[0] == netif->name[0] &&
;;;304           name[1] == netif->name[1]) {
;;;305          LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
;;;306          return netif;
;;;307        }
;;;308      }
;;;309      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
;;;310      return NULL;
;;;311    }
009e0e  bd10              POP      {r4,pc}
                  |L1.40464|
009e10  7890              LDRB     r0,[r2,#2]            ;299
009e12  3830              SUBS     r0,r0,#0x30           ;299
009e14  b2c3              UXTB     r3,r0                 ;299
009e16  48c7              LDR      r0,|L1.41268|
009e18  6801              LDR      r1,[r0,#0]            ;301  ; netif_list
009e1a  e012              B        |L1.40514|
                  |L1.40476|
009e1c  f8910034          LDRB     r0,[r1,#0x34]         ;302
009e20  4298              CMP      r0,r3                 ;302
009e22  d10d              BNE      |L1.40512|
009e24  7810              LDRB     r0,[r2,#0]            ;303
009e26  f8914032          LDRB     r4,[r1,#0x32]         ;303
009e2a  42a0              CMP      r0,r4                 ;303
009e2c  d108              BNE      |L1.40512|
009e2e  7854              LDRB     r4,[r2,#1]            ;304
009e30  2033              MOVS     r0,#0x33              ;304
009e32  5c40              LDRB     r0,[r0,r1]            ;304
009e34  4284              CMP      r4,r0                 ;304
009e36  d103              BNE      |L1.40512|
009e38  bf00              NOP                            ;305
009e3a  bf00              NOP                            ;305
009e3c  4608              MOV      r0,r1                 ;306
009e3e  e7e6              B        |L1.40462|
                  |L1.40512|
009e40  6809              LDR      r1,[r1,#0]            ;301
                  |L1.40514|
009e42  2900              CMP      r1,#0                 ;301
009e44  d1ea              BNE      |L1.40476|
009e46  bf00              NOP                            ;309
009e48  bf00              NOP                            ;309
009e4a  2000              MOVS     r0,#0                 ;310
009e4c  e7df              B        |L1.40462|
;;;312    
                          ENDP

                  autoip_network_changed PROC
;;;366    void
;;;367    autoip_network_changed(struct netif *netif)
009e4e  b510              PUSH     {r4,lr}
;;;368    {
009e50  4604              MOV      r4,r0
;;;369      if (netif->autoip && netif->autoip->state != AUTOIP_STATE_OFF) {
009e52  6a60              LDR      r0,[r4,#0x24]
009e54  b140              CBZ      r0,|L1.40552|
009e56  6a60              LDR      r0,[r4,#0x24]
009e58  7900              LDRB     r0,[r0,#4]
009e5a  b128              CBZ      r0,|L1.40552|
;;;370        netif_set_down(netif);
009e5c  4620              MOV      r0,r4
009e5e  f7fffffe          BL       netif_set_down
;;;371        autoip_start_probing(netif);
009e62  4620              MOV      r0,r4
009e64  f7fffffe          BL       autoip_start_probing
                  |L1.40552|
;;;372      }
;;;373    }
009e68  bd10              POP      {r4,pc}
;;;374    
                          ENDP

                  netif_set_link_up PROC
;;;534     */
;;;535    void netif_set_link_up(struct netif *netif )
009e6a  b510              PUSH     {r4,lr}
;;;536    {
009e6c  4604              MOV      r4,r0
;;;537      if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
009e6e  f8940031          LDRB     r0,[r4,#0x31]
009e72  f0100f10          TST      r0,#0x10
009e76  d125              BNE      |L1.40644|
;;;538        netif->flags |= NETIF_FLAG_LINK_UP;
009e78  f8940031          LDRB     r0,[r4,#0x31]
009e7c  f0400010          ORR      r0,r0,#0x10
009e80  f8840031          STRB     r0,[r4,#0x31]
;;;539    
;;;540    #if LWIP_DHCP
;;;541        if (netif->dhcp) {
009e84  6a20              LDR      r0,[r4,#0x20]
009e86  b110              CBZ      r0,|L1.40590|
;;;542          dhcp_network_changed(netif);
009e88  4620              MOV      r0,r4
009e8a  f7fffffe          BL       dhcp_network_changed
                  |L1.40590|
;;;543        }
;;;544    #endif /* LWIP_DHCP */
;;;545    
;;;546    #if LWIP_AUTOIP
;;;547        if (netif->autoip) {
009e8e  6a60              LDR      r0,[r4,#0x24]
009e90  b110              CBZ      r0,|L1.40600|
;;;548          autoip_network_changed(netif);
009e92  4620              MOV      r0,r4
009e94  f7fffffe          BL       autoip_network_changed
                  |L1.40600|
;;;549        }
;;;550    #endif /* LWIP_AUTOIP */
;;;551    
;;;552        if (netif->flags & NETIF_FLAG_UP) {
009e98  f8940031          LDRB     r0,[r4,#0x31]
009e9c  f0100f01          TST      r0,#1
009ea0  d010              BEQ      |L1.40644|
;;;553    #if LWIP_ARP
;;;554          /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
;;;555          if (netif->flags & NETIF_FLAG_ETHARP) {
009ea2  f8940031          LDRB     r0,[r4,#0x31]
009ea6  f0100f20          TST      r0,#0x20
009eaa  d003              BEQ      |L1.40628|
;;;556            etharp_gratuitous(netif);
009eac  1d21              ADDS     r1,r4,#4
009eae  4620              MOV      r0,r4
009eb0  f7fffffe          BL       etharp_request
                  |L1.40628|
;;;557          }
;;;558    #endif /* LWIP_ARP */
;;;559    
;;;560    #if LWIP_IGMP
;;;561          /* resend IGMP memberships */
;;;562          if (netif->flags & NETIF_FLAG_IGMP) {
009eb4  f8940031          LDRB     r0,[r4,#0x31]
009eb8  f0100f80          TST      r0,#0x80
009ebc  d002              BEQ      |L1.40644|
;;;563            igmp_report_groups( netif);
009ebe  4620              MOV      r0,r4
009ec0  f7fffffe          BL       igmp_report_groups
                  |L1.40644|
;;;564          }
;;;565    #endif /* LWIP_IGMP */
;;;566        }
;;;567        NETIF_LINK_CALLBACK(netif);
;;;568      }
;;;569    }
009ec4  bd10              POP      {r4,pc}
;;;570    
                          ENDP

                  netif_set_link_down PROC
;;;573     */
;;;574    void netif_set_link_down(struct netif *netif )
009ec6  f8901031          LDRB     r1,[r0,#0x31]
;;;575    {
;;;576      if (netif->flags & NETIF_FLAG_LINK_UP) {
009eca  f0110f10          TST      r1,#0x10
009ece  d005              BEQ      |L1.40668|
;;;577        netif->flags &= ~NETIF_FLAG_LINK_UP;
009ed0  f8901031          LDRB     r1,[r0,#0x31]
009ed4  f0210110          BIC      r1,r1,#0x10
009ed8  f8801031          STRB     r1,[r0,#0x31]
                  |L1.40668|
;;;578        NETIF_LINK_CALLBACK(netif);
;;;579      }
;;;580    }
009edc  4770              BX       lr
;;;581    
                          ENDP

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
009ede  b570              PUSH     {r4-r6,lr}
;;;804    {
009ee0  4604              MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
009ee2  2601              MOVS     r6,#1
;;;807      /* tail */
;;;808      q = p->next;
009ee4  6825              LDR      r5,[r4,#0]
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
009ee6  b19d              CBZ      r5,|L1.40720|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
009ee8  bf00              NOP      
009eea  bf00              NOP      
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
009eec  8920              LDRH     r0,[r4,#8]
009eee  8961              LDRH     r1,[r4,#0xa]
009ef0  1a40              SUBS     r0,r0,r1
009ef2  8128              STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
009ef4  2000              MOVS     r0,#0
009ef6  6020              STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
009ef8  8960              LDRH     r0,[r4,#0xa]
009efa  8120              STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
009efc  bf00              NOP      
009efe  bf00              NOP      
;;;821        tail_gone = pbuf_free(q);
009f00  4628              MOV      r0,r5
009f02  f7fffffe          BL       pbuf_free
009f06  4606              MOV      r6,r0
;;;822        if (tail_gone > 0) {
009f08  2e00              CMP      r6,#0
009f0a  dd01              BLE      |L1.40720|
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
009f0c  bf00              NOP      
009f0e  bf00              NOP      
                  |L1.40720|
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
009f10  bf00              NOP      
009f12  bf00              NOP      
;;;830      return ((tail_gone > 0) ? NULL : q);
009f14  2e00              CMP      r6,#0
009f16  dd01              BLE      |L1.40732|
009f18  2000              MOVS     r0,#0
                  |L1.40730|
;;;831    }
009f1a  bd70              POP      {r4-r6,pc}
                  |L1.40732|
009f1c  4628              MOV      r0,r5                 ;830
009f1e  e7fc              B        |L1.40730|
;;;832    
                          ENDP

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
009f20  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
009f24  4604              MOV      r4,r0
009f26  460e              MOV      r6,r1
009f28  4691              MOV      r9,r2
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
009f2a  46c8              MOV      r8,r9
;;;971      u16_t copied_total = 0;
009f2c  f04f0a00          MOV      r10,#0
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
009f30  bf00              NOP      
009f32  b914              CBNZ     r4,|L1.40762|
009f34  2000              MOVS     r0,#0
                  |L1.40758|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
009f36  e8bd87f0          POP      {r4-r10,pc}
                  |L1.40762|
009f3a  bf00              NOP                            ;973
009f3c  bf00              NOP                            ;974
009f3e  b90e              CBNZ     r6,|L1.40772|
009f40  2000              MOVS     r0,#0                 ;974
009f42  e7f8              B        |L1.40758|
                  |L1.40772|
009f44  bf00              NOP                            ;974
009f46  b11c              CBZ      r4,|L1.40784|
009f48  b116              CBZ      r6,|L1.40784|
009f4a  8920              LDRH     r0,[r4,#8]            ;976
009f4c  4548              CMP      r0,r9                 ;976
009f4e  da02              BGE      |L1.40790|
                  |L1.40784|
009f50  f06f000d          MVN      r0,#0xd               ;977
009f54  e7ef              B        |L1.40758|
                  |L1.40790|
009f56  4625              MOV      r5,r4                 ;981
009f58  e015              B        |L1.40838|
                  |L1.40794|
009f5a  bf00              NOP                            ;982
009f5c  bf00              NOP                            ;982
009f5e  4647              MOV      r7,r8                 ;983
009f60  8968              LDRH     r0,[r5,#0xa]          ;984
009f62  42b8              CMP      r0,r7                 ;984
009f64  da00              BGE      |L1.40808|
009f66  896f              LDRH     r7,[r5,#0xa]          ;986
                  |L1.40808|
009f68  eb06010a          ADD      r1,r6,r10             ;989
009f6c  463a              MOV      r2,r7                 ;989
009f6e  6868              LDR      r0,[r5,#4]            ;989
009f70  f7fffffe          BL       __aeabi_memcpy
009f74  eba80007          SUB      r0,r8,r7              ;990
009f78  fa1ff880          UXTH     r8,r0                 ;990
009f7c  eb0a0007          ADD      r0,r10,r7             ;991
009f80  fa1ffa80          UXTH     r10,r0                ;991
009f84  682d              LDR      r5,[r5,#0]            ;981
                  |L1.40838|
009f86  f1b80f00          CMP      r8,#0                 ;981
009f8a  d1e6              BNE      |L1.40794|
009f8c  bf00              NOP                            ;993
009f8e  bf00              NOP                            ;993
009f90  2000              MOVS     r0,#0                 ;994
009f92  e7d0              B        |L1.40758|
;;;996    
                          ENDP

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
009f94  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   {
009f98  4604              MOV      r4,r0
009f9a  460e              MOV      r6,r1
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
009f9c  6820              LDR      r0,[r4,#0]
009f9e  b910              CBNZ     r0,|L1.40870|
;;;1015       return p;
009fa0  4620              MOV      r0,r4
                  |L1.40866|
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;1018     if (q == NULL) {
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
009fa2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.40870|
009fa6  8921              LDRH     r1,[r4,#8]            ;1017
009fa8  2200              MOVS     r2,#0                 ;1017
009faa  4630              MOV      r0,r6                 ;1017
009fac  f7fffffe          BL       pbuf_alloc
009fb0  4605              MOV      r5,r0                 ;1017
009fb2  b90d              CBNZ     r5,|L1.40888|
009fb4  4620              MOV      r0,r4                 ;1020
009fb6  e7f4              B        |L1.40866|
                  |L1.40888|
009fb8  4621              MOV      r1,r4                 ;1022
009fba  4628              MOV      r0,r5                 ;1022
009fbc  f7fffffe          BL       pbuf_copy
009fc0  4607              MOV      r7,r0                 ;1022
009fc2  bf00              NOP                            ;1023
009fc4  bf00              NOP                            ;1023
009fc6  4620              MOV      r0,r4                 ;1024
009fc8  f7fffffe          BL       pbuf_free
009fcc  4628              MOV      r0,r5                 ;1025
009fce  e7e8              B        |L1.40866|
;;;1027   
                          ENDP

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
009fd0  b510              PUSH     {r4,lr}
;;;1078   {
009fd2  4603              MOV      r3,r0
009fd4  460c              MOV      r4,r1
;;;1079     u16_t copy_from = offset;
009fd6  4622              MOV      r2,r4
;;;1080     struct pbuf* q = p;
009fd8  4619              MOV      r1,r3
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
009fda  e003              B        |L1.40932|
                  |L1.40924|
;;;1084       copy_from -= q->len;
009fdc  8948              LDRH     r0,[r1,#0xa]
009fde  1a10              SUBS     r0,r2,r0
009fe0  b282              UXTH     r2,r0
;;;1085       q = q->next;
009fe2  6809              LDR      r1,[r1,#0]
                  |L1.40932|
009fe4  b111              CBZ      r1,|L1.40940|
009fe6  8948              LDRH     r0,[r1,#0xa]          ;1083
009fe8  4290              CMP      r0,r2                 ;1083
009fea  ddf7              BLE      |L1.40924|
                  |L1.40940|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
009fec  b129              CBZ      r1,|L1.40954|
009fee  8948              LDRH     r0,[r1,#0xa]
009ff0  4290              CMP      r0,r2
009ff2  dd02              BLE      |L1.40954|
;;;1089       return ((u8_t*)q->payload)[copy_from];
009ff4  6848              LDR      r0,[r1,#4]
009ff6  5c80              LDRB     r0,[r0,r2]
                  |L1.40952|
;;;1090     }
;;;1091     return 0;
;;;1092   }
009ff8  bd10              POP      {r4,pc}
                  |L1.40954|
009ffa  2000              MOVS     r0,#0                 ;1091
009ffc  e7fc              B        |L1.40952|
;;;1093   
                          ENDP

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
009ffe  e92d4ff8          PUSH     {r3-r11,lr}
;;;1105   {
00a002  4607              MOV      r7,r0
00a004  4688              MOV      r8,r1
00a006  4691              MOV      r9,r2
00a008  469a              MOV      r10,r3
;;;1106     u16_t start = offset;
00a00a  4646              MOV      r6,r8
;;;1107     struct pbuf* q = p;
00a00c  463c              MOV      r4,r7
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
00a00e  e003              B        |L1.40984|
                  |L1.40976|
;;;1111       start -= q->len;
00a010  8960              LDRH     r0,[r4,#0xa]
00a012  1a30              SUBS     r0,r6,r0
00a014  b286              UXTH     r6,r0
;;;1112       q = q->next;
00a016  6824              LDR      r4,[r4,#0]
                  |L1.40984|
00a018  b114              CBZ      r4,|L1.40992|
00a01a  8960              LDRH     r0,[r4,#0xa]          ;1110
00a01c  42b0              CMP      r0,r6                 ;1110
00a01e  ddf7              BLE      |L1.40976|
                  |L1.40992|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
00a020  b1d4              CBZ      r4,|L1.41048|
00a022  8960              LDRH     r0,[r4,#0xa]
00a024  42b0              CMP      r0,r6
00a026  dd17              BLE      |L1.41048|
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
00a028  2500              MOVS     r5,#0
00a02a  e011              B        |L1.41040|
                  |L1.41004|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
00a02c  1970              ADDS     r0,r6,r5
00a02e  b281              UXTH     r1,r0
00a030  4620              MOV      r0,r4
00a032  f7fffffe          BL       pbuf_get_at
00a036  4683              MOV      r11,r0
;;;1119         u8_t b = ((u8_t*)s2)[i];
00a038  f8190005          LDRB     r0,[r9,r5]
00a03c  9000              STR      r0,[sp,#0]
;;;1120         if (a != b) {
00a03e  9800              LDR      r0,[sp,#0]
00a040  4583              CMP      r11,r0
00a042  d003              BEQ      |L1.41036|
;;;1121           return i+1;
00a044  1c68              ADDS     r0,r5,#1
00a046  b280              UXTH     r0,r0
                  |L1.41032|
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
00a048  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.41036|
00a04c  1c68              ADDS     r0,r5,#1              ;1117
00a04e  b285              UXTH     r5,r0                 ;1117
                  |L1.41040|
00a050  4555              CMP      r5,r10                ;1117
00a052  dbeb              BLT      |L1.41004|
00a054  2000              MOVS     r0,#0                 ;1124
00a056  e7f7              B        |L1.41032|
                  |L1.41048|
00a058  f64f70ff          MOV      r0,#0xffff            ;1126
00a05c  e7f4              B        |L1.41032|
;;;1128   
                          ENDP

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
00a05e  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   {
00a062  4606              MOV      r6,r0
00a064  4688              MOV      r8,r1
00a066  4615              MOV      r5,r2
00a068  461f              MOV      r7,r3
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
00a06a  8930              LDRH     r0,[r6,#8]
00a06c  1b40              SUBS     r0,r0,r5
00a06e  fa1ffa80          UXTH     r10,r0
;;;1144     if (p->tot_len >= mem_len + start_offset) {
00a072  8930              LDRH     r0,[r6,#8]
00a074  19e9              ADDS     r1,r5,r7
00a076  4288              CMP      r0,r1
00a078  db14              BLT      |L1.41124|
;;;1145       for(i = start_offset; i <= max; ) {
00a07a  463c              MOV      r4,r7
00a07c  e010              B        |L1.41120|
                  |L1.41086|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00a07e  462b              MOV      r3,r5
00a080  4642              MOV      r2,r8
00a082  4621              MOV      r1,r4
00a084  4630              MOV      r0,r6
00a086  f7fffffe          BL       pbuf_memcmp
00a08a  4681              MOV      r9,r0
;;;1147         if (plus == 0) {
00a08c  f1b90f00          CMP      r9,#0
00a090  d102              BNE      |L1.41112|
;;;1148           return i;
00a092  4620              MOV      r0,r4
                  |L1.41108|
;;;1149         } else {
;;;1150           i += plus;
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
00a094  e8bd87f0          POP      {r4-r10,pc}
                  |L1.41112|
00a098  eb040009          ADD      r0,r4,r9              ;1150
00a09c  b284              UXTH     r4,r0                 ;1150
00a09e  bf00              NOP                            ;1152
                  |L1.41120|
00a0a0  4554              CMP      r4,r10                ;1145
00a0a2  ddec              BLE      |L1.41086|
                  |L1.41124|
00a0a4  f64f70ff          MOV      r0,#0xffff            ;1154
00a0a8  e7f4              B        |L1.41108|
;;;1156   
                          ENDP

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
00a0aa  b570              PUSH     {r4-r6,lr}
;;;1169   {
00a0ac  4606              MOV      r6,r0
00a0ae  460c              MOV      r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
00a0b0  b134              CBZ      r4,|L1.41152|
00a0b2  7820              LDRB     r0,[r4,#0]
00a0b4  b120              CBZ      r0,|L1.41152|
00a0b6  8930              LDRH     r0,[r6,#8]
00a0b8  f5a0417f          SUB      r1,r0,#0xff00
00a0bc  39ff              SUBS     r1,r1,#0xff
00a0be  d102              BNE      |L1.41158|
                  |L1.41152|
;;;1172       return 0xFFFF;
00a0c0  f64f70ff          MOV      r0,#0xffff
                  |L1.41156|
;;;1173     }
;;;1174     substr_len = strlen(substr);
;;;1175     if (substr_len >= 0xFFFF) {
;;;1176       return 0xFFFF;
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
00a0c4  bd70              POP      {r4-r6,pc}
                  |L1.41158|
00a0c6  4620              MOV      r0,r4                 ;1174
00a0c8  f7fffffe          BL       strlen
00a0cc  4605              MOV      r5,r0                 ;1174
00a0ce  f64f70ff          MOV      r0,#0xffff            ;1175
00a0d2  4285              CMP      r5,r0                 ;1175
00a0d4  d300              BCC      |L1.41176|
00a0d6  e7f5              B        |L1.41156|
                  |L1.41176|
00a0d8  b2aa              UXTH     r2,r5                 ;1178
00a0da  2300              MOVS     r3,#0                 ;1178
00a0dc  4621              MOV      r1,r4                 ;1178
00a0de  4630              MOV      r0,r6                 ;1178
00a0e0  f7fffffe          BL       pbuf_memfind
00a0e4  e7ee              B        |L1.41156|
;;;72     #include "third_party/lwip-1.4.1/src/core/raw.c"
                          ENDP

                  sys_msleep PROC
;;;54     void
;;;55     sys_msleep(u32_t ms)
00a0e6  b53e              PUSH     {r1-r5,lr}
;;;56     {
00a0e8  4604              MOV      r4,r0
;;;57       if (ms > 0) {
00a0ea  b16c              CBZ      r4,|L1.41224|
;;;58         sys_sem_t delaysem;
;;;59         err_t err = sys_sem_new(&delaysem, 0);
00a0ec  2100              MOVS     r1,#0
00a0ee  4668              MOV      r0,sp
00a0f0  f7fffffe          BL       sys_sem_new
00a0f4  4605              MOV      r5,r0
;;;60         if (err == ERR_OK) {
00a0f6  b935              CBNZ     r5,|L1.41222|
;;;61           sys_arch_sem_wait(&delaysem, ms);
00a0f8  4621              MOV      r1,r4
00a0fa  4668              MOV      r0,sp
00a0fc  f7fffffe          BL       sys_arch_sem_wait
;;;62           sys_sem_free(&delaysem);
00a100  4668              MOV      r0,sp
00a102  f7fffffe          BL       sys_sem_free
                  |L1.41222|
;;;63         }
;;;64       }
00a106  bf00              NOP      
                  |L1.41224|
;;;65     }
00a108  bd3e              POP      {r1-r5,pc}
;;;66     #endif /* sys_msleep */
                          ENDP

                  tcp_setprio PROC
;;;1164   void
;;;1165   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
00a10a  7641              STRB     r1,[r0,#0x19]
;;;1166   {
;;;1167     pcb->prio = prio;
;;;1168   }
00a10c  4770              BX       lr
;;;1169   
                          ENDP

                  tcp_debug_state_str PROC
;;;1606   const char*
;;;1607   tcp_debug_state_str(enum tcp_state s)
00a10e  4601              MOV      r1,r0
;;;1608   {
;;;1609     return tcp_state_str[s];
00a110  480a              LDR      r0,|L1.41276|
00a112  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;1610   }
00a116  4770              BX       lr
;;;1611   
                          ENDP

                  autoip_set_struct PROC
;;;132    void
;;;133    autoip_set_struct(struct netif *netif, struct autoip *autoip)
00a118  bf00              NOP      
;;;134    {
;;;135      LWIP_ASSERT("netif != NULL", netif != NULL);
00a11a  bf00              NOP      
;;;136      LWIP_ASSERT("autoip != NULL", autoip != NULL);
00a11c  bf00              NOP      
00a11e  bf00              NOP      
;;;137      LWIP_ASSERT("netif already has a struct autoip set", netif->autoip == NULL);
00a120  bf00              NOP      
00a122  bf00              NOP      
;;;138    
;;;139      /* clear data structure */
;;;140      memset(autoip, 0, sizeof(struct autoip));
00a124  2200              MOVS     r2,#0
00a126  600a              STR      r2,[r1,#0]
00a128  604a              STR      r2,[r1,#4]
00a12a  608a              STR      r2,[r1,#8]
;;;141      /* autoip->state = AUTOIP_STATE_OFF; */
;;;142      netif->autoip = autoip;
00a12c  6241              STR      r1,[r0,#0x24]
;;;143    }
00a12e  4770              BX       lr
                  |L1.41264|
                          DCD      igmp_group_list
                  |L1.41268|
                          DCD      netif_list
                  |L1.41272|
                          DCD      netif_default
                  |L1.41276|
                          DCD      tcp_state_str
                          ENDP

                  igmp_dump_group_list PROC
;;;168    void
;;;169    igmp_dump_group_list()
00a140  49f9              LDR      r1,|L1.42280|
;;;170    { 
;;;171      struct igmp_group *group = igmp_group_list;
00a142  6808              LDR      r0,[r1,#0]  ; igmp_group_list
;;;172    
;;;173      while (group != NULL) {
00a144  e006              B        |L1.41300|
                  |L1.41286|
;;;174        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_dump_group_list: [%"U32_F"] ", (u32_t)(group->group_state)));
00a146  bf00              NOP      
00a148  bf00              NOP      
;;;175        ip_addr_debug_print(IGMP_DEBUG, &group->group_address);
00a14a  bf00              NOP      
00a14c  bf00              NOP      
;;;176        LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", group->netif));
00a14e  bf00              NOP      
00a150  bf00              NOP      
;;;177        group = group->next;
00a152  6800              LDR      r0,[r0,#0]
                  |L1.41300|
00a154  2800              CMP      r0,#0                 ;173
00a156  d1f6              BNE      |L1.41286|
;;;178      }
;;;179      LWIP_DEBUGF(IGMP_DEBUG, ("\n"));
00a158  bf00              NOP      
00a15a  bf00              NOP      
;;;180    }
00a15c  4770              BX       lr
;;;181    #else
                          ENDP

                  inet_chksum_pseudo PROC
;;;271    u16_t
;;;272    inet_chksum_pseudo(struct pbuf *p,
00a15e  e92d5ff0          PUSH     {r4-r12,lr}
;;;273           ip_addr_t *src, ip_addr_t *dest,
;;;274           u8_t proto, u16_t proto_len)
;;;275    {
00a162  4607              MOV      r7,r0
00a164  4688              MOV      r8,r1
00a166  4691              MOV      r9,r2
00a168  469a              MOV      r10,r3
;;;276      u32_t acc;
;;;277      u32_t addr;
;;;278      struct pbuf *q;
;;;279      u8_t swapped;
;;;280    
;;;281      acc = 0;
00a16a  2400              MOVS     r4,#0
;;;282      swapped = 0;
00a16c  46a3              MOV      r11,r4
;;;283      /* iterate through all pbuf in chain */
;;;284      for(q = p; q != NULL; q = q->next) {
00a16e  463d              MOV      r5,r7
00a170  e01a              B        |L1.41384|
                  |L1.41330|
;;;285        LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
00a172  bf00              NOP      
00a174  bf00              NOP      
;;;286          (void *)q, (void *)q->next));
;;;287        acc += LWIP_CHKSUM(q->payload, q->len);
00a176  8969              LDRH     r1,[r5,#0xa]
00a178  6868              LDR      r0,[r5,#4]
00a17a  f7fffffe          BL       lwip_standard_chksum
00a17e  4404              ADD      r4,r4,r0
;;;288        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;289        /* just executing this next line is probably faster that the if statement needed
;;;290           to check whether we really need to execute it, and does no harm */
;;;291        acc = FOLD_U32T(acc);
00a180  b2a0              UXTH     r0,r4
00a182  eb004414          ADD      r4,r0,r4,LSR #16
;;;292        if (q->len % 2 != 0) {
00a186  8968              LDRH     r0,[r5,#0xa]
00a188  eb0071d0          ADD      r1,r0,r0,LSR #31
00a18c  1049              ASRS     r1,r1,#1
00a18e  ebb00141          SUBS     r1,r0,r1,LSL #1
00a192  d008              BEQ      |L1.41382|
;;;293          swapped = 1 - swapped;
00a194  f1cb0001          RSB      r0,r11,#1
00a198  f0000bff          AND      r11,r0,#0xff
;;;294          acc = SWAP_BYTES_IN_WORD(acc);
00a19c  b2e0              UXTB     r0,r4
00a19e  f3c42107          UBFX     r1,r4,#8,#8
00a1a2  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.41382|
00a1a6  682d              LDR      r5,[r5,#0]            ;284
                  |L1.41384|
00a1a8  2d00              CMP      r5,#0                 ;284
00a1aa  d1e2              BNE      |L1.41330|
;;;295        }
;;;296        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;297      }
;;;298    
;;;299      if (swapped) {
00a1ac  f1bb0f00          CMP      r11,#0
00a1b0  d004              BEQ      |L1.41404|
;;;300        acc = SWAP_BYTES_IN_WORD(acc);
00a1b2  b2e0              UXTB     r0,r4
00a1b4  f3c42107          UBFX     r1,r4,#8,#8
00a1b8  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.41404|
;;;301      }
;;;302      addr = ip4_addr_get_u32(src);
00a1bc  f8d86000          LDR      r6,[r8,#0]
;;;303      acc += (addr & 0xffffUL);
00a1c0  b2b0              UXTH     r0,r6
00a1c2  4404              ADD      r4,r4,r0
;;;304      acc += ((addr >> 16) & 0xffffUL);
00a1c4  f64f70ff          MOV      r0,#0xffff
00a1c8  ea004016          AND      r0,r0,r6,LSR #16
00a1cc  4404              ADD      r4,r4,r0
;;;305      addr = ip4_addr_get_u32(dest);
00a1ce  f8d96000          LDR      r6,[r9,#0]
;;;306      acc += (addr & 0xffffUL);
00a1d2  b2b0              UXTH     r0,r6
00a1d4  4404              ADD      r4,r4,r0
;;;307      acc += ((addr >> 16) & 0xffffUL);
00a1d6  f64f70ff          MOV      r0,#0xffff
00a1da  ea004016          AND      r0,r0,r6,LSR #16
00a1de  4404              ADD      r4,r4,r0
;;;308      acc += (u32_t)htons((u16_t)proto);
00a1e0  4650              MOV      r0,r10
00a1e2  f7fffffe          BL       lwip_htons
00a1e6  4404              ADD      r4,r4,r0
;;;309      acc += (u32_t)htons(proto_len);
00a1e8  980a              LDR      r0,[sp,#0x28]
00a1ea  f7fffffe          BL       lwip_htons
00a1ee  4404              ADD      r4,r4,r0
;;;310    
;;;311      /* Fold 32-bit sum to 16 bits
;;;312         calling this twice is propably faster than if statements... */
;;;313      acc = FOLD_U32T(acc);
00a1f0  b2a0              UXTH     r0,r4
00a1f2  eb004414          ADD      r4,r0,r4,LSR #16
;;;314      acc = FOLD_U32T(acc);
00a1f6  b2a0              UXTH     r0,r4
00a1f8  eb004414          ADD      r4,r0,r4,LSR #16
;;;315      LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
00a1fc  bf00              NOP      
00a1fe  bf00              NOP      
;;;316      return (u16_t)~(acc & 0xffffUL);
00a200  43e0              MVNS     r0,r4
00a202  b280              UXTH     r0,r0
;;;317    }
00a204  e8bd9ff0          POP      {r4-r12,pc}
;;;318    
                          ENDP

                  inet_chksum_pseudo_partial PROC
;;;331    u16_t
;;;332    inet_chksum_pseudo_partial(struct pbuf *p,
00a208  e92d5fff          PUSH     {r0-r12,lr}
;;;333           ip_addr_t *src, ip_addr_t *dest,
;;;334           u8_t proto, u16_t proto_len, u16_t chksum_len)
;;;335    {
00a20c  4681              MOV      r9,r0
00a20e  468a              MOV      r10,r1
00a210  9e0f              LDR      r6,[sp,#0x3c]
;;;336      u32_t acc;
;;;337      u32_t addr;
;;;338      struct pbuf *q;
;;;339      u8_t swapped;
;;;340      u16_t chklen;
;;;341    
;;;342      acc = 0;
00a212  2400              MOVS     r4,#0
;;;343      swapped = 0;
00a214  46a3              MOV      r11,r4
;;;344      /* iterate through all pbuf in chain */
;;;345      for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
00a216  464d              MOV      r5,r9
00a218  e024              B        |L1.41572|
                  |L1.41498|
;;;346        LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
00a21a  bf00              NOP      
00a21c  bf00              NOP      
;;;347          (void *)q, (void *)q->next));
;;;348        chklen = q->len;
00a21e  f8b5800a          LDRH     r8,[r5,#0xa]
;;;349        if (chklen > chksum_len) {
00a222  45b0              CMP      r8,r6
00a224  dd00              BLE      |L1.41512|
;;;350          chklen = chksum_len;
00a226  46b0              MOV      r8,r6
                  |L1.41512|
;;;351        }
;;;352        acc += LWIP_CHKSUM(q->payload, chklen);
00a228  4641              MOV      r1,r8
00a22a  6868              LDR      r0,[r5,#4]
00a22c  f7fffffe          BL       lwip_standard_chksum
00a230  4404              ADD      r4,r4,r0
;;;353        chksum_len -= chklen;
00a232  eba60008          SUB      r0,r6,r8
00a236  b286              UXTH     r6,r0
;;;354        LWIP_ASSERT("delete me", chksum_len < 0x7fff);
00a238  bf00              NOP      
00a23a  bf00              NOP      
;;;355        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;356        /* fold the upper bit down */
;;;357        acc = FOLD_U32T(acc);
00a23c  b2a0              UXTH     r0,r4
00a23e  eb004414          ADD      r4,r0,r4,LSR #16
;;;358        if (q->len % 2 != 0) {
00a242  8968              LDRH     r0,[r5,#0xa]
00a244  eb0071d0          ADD      r1,r0,r0,LSR #31
00a248  1049              ASRS     r1,r1,#1
00a24a  ebb00141          SUBS     r1,r0,r1,LSL #1
00a24e  d008              BEQ      |L1.41570|
;;;359          swapped = 1 - swapped;
00a250  f1cb0001          RSB      r0,r11,#1
00a254  f0000bff          AND      r11,r0,#0xff
;;;360          acc = SWAP_BYTES_IN_WORD(acc);
00a258  b2e0              UXTB     r0,r4
00a25a  f3c42107          UBFX     r1,r4,#8,#8
00a25e  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.41570|
00a262  682d              LDR      r5,[r5,#0]            ;345
                  |L1.41572|
00a264  b10d              CBZ      r5,|L1.41578|
00a266  2e00              CMP      r6,#0                 ;345
00a268  dcd7              BGT      |L1.41498|
                  |L1.41578|
;;;361        }
;;;362        /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
;;;363      }
;;;364    
;;;365      if (swapped) {
00a26a  f1bb0f00          CMP      r11,#0
00a26e  d004              BEQ      |L1.41594|
;;;366        acc = SWAP_BYTES_IN_WORD(acc);
00a270  b2e0              UXTB     r0,r4
00a272  f3c42107          UBFX     r1,r4,#8,#8
00a276  ea412400          ORR      r4,r1,r0,LSL #8
                  |L1.41594|
;;;367      }
;;;368      addr = ip4_addr_get_u32(src);
00a27a  f8da7000          LDR      r7,[r10,#0]
;;;369      acc += (addr & 0xffffUL);
00a27e  b2b8              UXTH     r0,r7
00a280  4404              ADD      r4,r4,r0
;;;370      acc += ((addr >> 16) & 0xffffUL);
00a282  f64f70ff          MOV      r0,#0xffff
00a286  ea004017          AND      r0,r0,r7,LSR #16
00a28a  4404              ADD      r4,r4,r0
;;;371      addr = ip4_addr_get_u32(dest);
00a28c  9802              LDR      r0,[sp,#8]
00a28e  6807              LDR      r7,[r0,#0]
;;;372      acc += (addr & 0xffffUL);
00a290  b2b8              UXTH     r0,r7
00a292  4404              ADD      r4,r4,r0
;;;373      acc += ((addr >> 16) & 0xffffUL);
00a294  f64f70ff          MOV      r0,#0xffff
00a298  ea004017          AND      r0,r0,r7,LSR #16
00a29c  4404              ADD      r4,r4,r0
;;;374      acc += (u32_t)htons((u16_t)proto);
00a29e  9803              LDR      r0,[sp,#0xc]
00a2a0  f7fffffe          BL       lwip_htons
00a2a4  4404              ADD      r4,r4,r0
;;;375      acc += (u32_t)htons(proto_len);
00a2a6  980e              LDR      r0,[sp,#0x38]
00a2a8  f7fffffe          BL       lwip_htons
00a2ac  4404              ADD      r4,r4,r0
;;;376    
;;;377      /* Fold 32-bit sum to 16 bits
;;;378         calling this twice is propably faster than if statements... */
;;;379      acc = FOLD_U32T(acc);
00a2ae  b2a0              UXTH     r0,r4
00a2b0  eb004414          ADD      r4,r0,r4,LSR #16
;;;380      acc = FOLD_U32T(acc);
00a2b4  b2a0              UXTH     r0,r4
00a2b6  eb004414          ADD      r4,r0,r4,LSR #16
;;;381      LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
00a2ba  bf00              NOP      
00a2bc  bf00              NOP      
;;;382      return (u16_t)~(acc & 0xffffUL);
00a2be  43e0              MVNS     r0,r4
00a2c0  b280              UXTH     r0,r0
;;;383    }
00a2c2  b004              ADD      sp,sp,#0x10
00a2c4  e8bd9ff0          POP      {r4-r12,pc}
;;;384    
                          ENDP

                  ip4_addr_netmask_valid PROC
;;;89     u8_t
;;;90     ip4_addr_netmask_valid(u32_t netmask)
00a2c8  b530              PUSH     {r4,r5,lr}
;;;91     {
00a2ca  4605              MOV      r5,r0
;;;92       u32_t mask;
;;;93       u32_t nm_hostorder = lwip_htonl(netmask);
00a2cc  4628              MOV      r0,r5
00a2ce  f7fffffe          BL       lwip_htonl
00a2d2  4604              MOV      r4,r0
;;;94     
;;;95       /* first, check for the first zero */
;;;96       for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
00a2d4  f04f4300          MOV      r3,#0x80000000
00a2d8  e003              B        |L1.41698|
                  |L1.41690|
;;;97         if ((nm_hostorder & mask) == 0) {
00a2da  421c              TST      r4,r3
00a2dc  d100              BNE      |L1.41696|
;;;98           break;
00a2de  e002              B        |L1.41702|
                  |L1.41696|
00a2e0  085b              LSRS     r3,r3,#1              ;96
                  |L1.41698|
00a2e2  2b00              CMP      r3,#0                 ;96
00a2e4  d1f9              BNE      |L1.41690|
                  |L1.41702|
00a2e6  bf00              NOP      
;;;99         }
;;;100      }
;;;101      /* then check that there is no one */
;;;102      for (; mask != 0; mask >>= 1) {
00a2e8  e004              B        |L1.41716|
                  |L1.41706|
;;;103        if ((nm_hostorder & mask) != 0) {
00a2ea  421c              TST      r4,r3
00a2ec  d001              BEQ      |L1.41714|
;;;104          /* there is a one after the first zero -> invalid */
;;;105          return 0;
00a2ee  2000              MOVS     r0,#0
                  |L1.41712|
;;;106        }
;;;107      }
;;;108      /* no one after the first zero -> valid */
;;;109      return 1;
;;;110    }
00a2f0  bd30              POP      {r4,r5,pc}
                  |L1.41714|
00a2f2  085b              LSRS     r3,r3,#1              ;102
                  |L1.41716|
00a2f4  2b00              CMP      r3,#0                 ;102
00a2f6  d1f8              BNE      |L1.41706|
00a2f8  2001              MOVS     r0,#1                 ;109
00a2fa  e7f9              B        |L1.41712|
;;;111    
                          ENDP

                  ipaddr_aton PROC
;;;151    int
;;;152    ipaddr_aton(const char *cp, ip_addr_t *addr)
00a2fc  e92d43ff          PUSH     {r0-r9,lr}
;;;153    {
00a300  4606              MOV      r6,r0
00a302  4688              MOV      r8,r1
;;;154      u32_t val;
;;;155      u8_t base;
;;;156      char c;
;;;157      u32_t parts[4];
;;;158      u32_t *pp = parts;
00a304  466f              MOV      r7,sp
;;;159    
;;;160      c = *cp;
00a306  7834              LDRB     r4,[r6,#0]
;;;161      for (;;) {
00a308  bf00              NOP      
                  |L1.41738|
;;;162        /*
;;;163         * Collect number up to ``.''.
;;;164         * Values are specified as for C:
;;;165         * 0x=hex, 0=octal, 1-9=decimal.
;;;166         */
;;;167        if (!isdigit(c))
00a30a  2c30              CMP      r4,#0x30
00a30c  db01              BLT      |L1.41746|
00a30e  2c39              CMP      r4,#0x39
00a310  dd03              BLE      |L1.41754|
                  |L1.41746|
;;;168          return (0);
00a312  2000              MOVS     r0,#0
                  |L1.41748|
;;;169        val = 0;
;;;170        base = 10;
;;;171        if (c == '0') {
;;;172          c = *++cp;
;;;173          if (c == 'x' || c == 'X') {
;;;174            base = 16;
;;;175            c = *++cp;
;;;176          } else
;;;177            base = 8;
;;;178        }
;;;179        for (;;) {
;;;180          if (isdigit(c)) {
;;;181            val = (val * base) + (int)(c - '0');
;;;182            c = *++cp;
;;;183          } else if (base == 16 && isxdigit(c)) {
;;;184            val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
;;;185            c = *++cp;
;;;186          } else
;;;187            break;
;;;188        }
;;;189        if (c == '.') {
;;;190          /*
;;;191           * Internet format:
;;;192           *  a.b.c.d
;;;193           *  a.b.c   (with c treated as 16 bits)
;;;194           *  a.b (with b treated as 24 bits)
;;;195           */
;;;196          if (pp >= parts + 3) {
;;;197            return (0);
;;;198          }
;;;199          *pp++ = val;
;;;200          c = *++cp;
;;;201        } else
;;;202          break;
;;;203      }
;;;204      /*
;;;205       * Check for trailing characters.
;;;206       */
;;;207      if (c != '\0' && !isspace(c)) {
;;;208        return (0);
;;;209      }
;;;210      /*
;;;211       * Concoct the address according to
;;;212       * the number of parts specified.
;;;213       */
;;;214      switch (pp - parts + 1) {
;;;215    
;;;216      case 0:
;;;217        return (0);       /* initial nondigit */
;;;218    
;;;219      case 1:             /* a -- 32 bits */
;;;220        break;
;;;221    
;;;222      case 2:             /* a.b -- 8.24 bits */
;;;223        if (val > 0xffffffUL) {
;;;224          return (0);
;;;225        }
;;;226        val |= parts[0] << 24;
;;;227        break;
;;;228    
;;;229      case 3:             /* a.b.c -- 8.8.16 bits */
;;;230        if (val > 0xffff) {
;;;231          return (0);
;;;232        }
;;;233        val |= (parts[0] << 24) | (parts[1] << 16);
;;;234        break;
;;;235    
;;;236      case 4:             /* a.b.c.d -- 8.8.8.8 bits */
;;;237        if (val > 0xff) {
;;;238          return (0);
;;;239        }
;;;240        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
;;;241        break;
;;;242      default:
;;;243        LWIP_ASSERT("unhandled", 0);
;;;244        break;
;;;245      }
;;;246      if (addr) {
;;;247        ip4_addr_set_u32(addr, htonl(val));
;;;248      }
;;;249      return (1);
;;;250    }
00a314  b004              ADD      sp,sp,#0x10
00a316  e8bd83f0          POP      {r4-r9,pc}
                  |L1.41754|
00a31a  2500              MOVS     r5,#0                 ;169
00a31c  f04f090a          MOV      r9,#0xa               ;170
00a320  2c30              CMP      r4,#0x30              ;171
00a322  d10e              BNE      |L1.41794|
00a324  1c70              ADDS     r0,r6,#1              ;172
00a326  4606              MOV      r6,r0                 ;172
00a328  7804              LDRB     r4,[r0,#0]            ;172
00a32a  2c78              CMP      r4,#0x78              ;173
00a32c  d001              BEQ      |L1.41778|
00a32e  2c58              CMP      r4,#0x58              ;173
00a330  d105              BNE      |L1.41790|
                  |L1.41778|
00a332  f04f0910          MOV      r9,#0x10              ;174
00a336  1c70              ADDS     r0,r6,#1              ;175
00a338  4606              MOV      r6,r0                 ;175
00a33a  7804              LDRB     r4,[r0,#0]            ;175
00a33c  e001              B        |L1.41794|
                  |L1.41790|
00a33e  f04f0908          MOV      r9,#8                 ;177
                  |L1.41794|
00a342  bf00              NOP                            ;179
                  |L1.41796|
00a344  2c30              CMP      r4,#0x30              ;180
00a346  db09              BLT      |L1.41820|
00a348  2c39              CMP      r4,#0x39              ;180
00a34a  dc07              BGT      |L1.41820|
00a34c  f1a40030          SUB      r0,r4,#0x30           ;181
00a350  fb050509          MLA      r5,r5,r9,r0           ;181
00a354  1c70              ADDS     r0,r6,#1              ;182
00a356  4606              MOV      r6,r0                 ;182
00a358  7804              LDRB     r4,[r0,#0]            ;182
00a35a  e7f3              B        |L1.41796|
                  |L1.41820|
00a35c  f1b90f10          CMP      r9,#0x10              ;183
00a360  d11b              BNE      |L1.41882|
00a362  2c30              CMP      r4,#0x30              ;183
00a364  db01              BLT      |L1.41834|
00a366  2c39              CMP      r4,#0x39              ;183
00a368  dd07              BLE      |L1.41850|
                  |L1.41834|
00a36a  2c61              CMP      r4,#0x61              ;183
00a36c  db01              BLT      |L1.41842|
00a36e  2c66              CMP      r4,#0x66              ;183
00a370  dd03              BLE      |L1.41850|
                  |L1.41842|
00a372  2c41              CMP      r4,#0x41              ;183
00a374  db11              BLT      |L1.41882|
00a376  2c46              CMP      r4,#0x46              ;183
00a378  dc0f              BGT      |L1.41882|
                  |L1.41850|
00a37a  2c61              CMP      r4,#0x61              ;184
00a37c  db03              BLT      |L1.41862|
00a37e  2c7a              CMP      r4,#0x7a              ;184
00a380  dc01              BGT      |L1.41862|
00a382  2161              MOVS     r1,#0x61              ;184
00a384  e000              B        |L1.41864|
                  |L1.41862|
00a386  2141              MOVS     r1,#0x41              ;184
                  |L1.41864|
00a388  f104000a          ADD      r0,r4,#0xa            ;184
00a38c  1a40              SUBS     r0,r0,r1              ;184
00a38e  ea401505          ORR      r5,r0,r5,LSL #4       ;184
00a392  1c70              ADDS     r0,r6,#1              ;185
00a394  4606              MOV      r6,r0                 ;185
00a396  7804              LDRB     r4,[r0,#0]            ;185
00a398  e7d4              B        |L1.41796|
                  |L1.41882|
00a39a  bf00              NOP                            ;187
00a39c  bf00              NOP                            ;187
00a39e  2c2e              CMP      r4,#0x2e              ;189
00a3a0  d109              BNE      |L1.41910|
00a3a2  a803              ADD      r0,sp,#0xc            ;196
00a3a4  4287              CMP      r7,r0                 ;196
00a3a6  d301              BCC      |L1.41900|
00a3a8  2000              MOVS     r0,#0                 ;197
00a3aa  e7b3              B        |L1.41748|
                  |L1.41900|
00a3ac  c720              STM      r7!,{r5}              ;199
00a3ae  1c70              ADDS     r0,r6,#1              ;200
00a3b0  4606              MOV      r6,r0                 ;200
00a3b2  7804              LDRB     r4,[r0,#0]            ;200
00a3b4  e7a9              B        |L1.41738|
                  |L1.41910|
00a3b6  bf00              NOP                            ;202
00a3b8  bf00              NOP                            ;202
00a3ba  b16c              CBZ      r4,|L1.41944|
00a3bc  2c20              CMP      r4,#0x20              ;207
00a3be  d00b              BEQ      |L1.41944|
00a3c0  2c0c              CMP      r4,#0xc               ;207
00a3c2  d009              BEQ      |L1.41944|
00a3c4  2c0a              CMP      r4,#0xa               ;207
00a3c6  d007              BEQ      |L1.41944|
00a3c8  2c0d              CMP      r4,#0xd               ;207
00a3ca  d005              BEQ      |L1.41944|
00a3cc  2c09              CMP      r4,#9                 ;207
00a3ce  d003              BEQ      |L1.41944|
00a3d0  2c0b              CMP      r4,#0xb               ;207
00a3d2  d001              BEQ      |L1.41944|
00a3d4  2000              MOVS     r0,#0                 ;208
00a3d6  e79d              B        |L1.41748|
                  |L1.41944|
00a3d8  4668              MOV      r0,sp                 ;214
00a3da  1a38              SUBS     r0,r7,r0              ;214
00a3dc  2101              MOVS     r1,#1                 ;214
00a3de  eb0100a0          ADD      r0,r1,r0,ASR #2       ;214
00a3e2  2805              CMP      r0,#5                 ;214
00a3e4  d22a              BCS      |L1.42044|
00a3e6  e8dff000          TBB      [pc,r0]               ;214
00a3ea  0305              DCB      0x03,0x05
00a3ec  060f1b00          DCB      0x06,0x0f,0x1b,0x00
00a3f0  2000              MOVS     r0,#0                 ;217
00a3f2  e78f              B        |L1.41748|
00a3f4  e025              B        |L1.42050|
00a3f6  f1b57f80          CMP      r5,#0x1000000         ;223
00a3fa  d301              BCC      |L1.41984|
00a3fc  2000              MOVS     r0,#0                 ;224
00a3fe  e789              B        |L1.41748|
                  |L1.41984|
00a400  9800              LDR      r0,[sp,#0]            ;226
00a402  ea456500          ORR      r5,r5,r0,LSL #24      ;226
00a406  e01c              B        |L1.42050|
00a408  f5b53f80          CMP      r5,#0x10000           ;230
00a40c  d301              BCC      |L1.42002|
00a40e  2000              MOVS     r0,#0                 ;231
00a410  e780              B        |L1.41748|
                  |L1.42002|
00a412  9800              LDR      r0,[sp,#0]            ;233
00a414  0600              LSLS     r0,r0,#24             ;233
00a416  9901              LDR      r1,[sp,#4]            ;233
00a418  ea404001          ORR      r0,r0,r1,LSL #16      ;233
00a41c  4305              ORRS     r5,r5,r0              ;233
00a41e  e010              B        |L1.42050|
00a420  2dff              CMP      r5,#0xff              ;237
00a422  d901              BLS      |L1.42024|
00a424  2000              MOVS     r0,#0                 ;238
00a426  e775              B        |L1.41748|
                  |L1.42024|
00a428  9800              LDR      r0,[sp,#0]            ;240
00a42a  0600              LSLS     r0,r0,#24             ;240
00a42c  9901              LDR      r1,[sp,#4]            ;240
00a42e  ea404001          ORR      r0,r0,r1,LSL #16      ;240
00a432  9902              LDR      r1,[sp,#8]            ;240
00a434  ea402001          ORR      r0,r0,r1,LSL #8       ;240
00a438  4305              ORRS     r5,r5,r0              ;240
00a43a  e002              B        |L1.42050|
                  |L1.42044|
00a43c  bf00              NOP                            ;243
00a43e  bf00              NOP                            ;243
00a440  bf00              NOP                            ;244
                  |L1.42050|
00a442  bf00              NOP                            ;220
00a444  f1b80f00          CMP      r8,#0                 ;246
00a448  d004              BEQ      |L1.42068|
00a44a  4628              MOV      r0,r5                 ;247
00a44c  f7fffffe          BL       lwip_htonl
00a450  f8c80000          STR      r0,[r8,#0]            ;247
                  |L1.42068|
00a454  2001              MOVS     r0,#1                 ;249
00a456  e75d              B        |L1.41748|
;;;251    
                          ENDP

                  ipaddr_addr PROC
;;;129    u32_t
;;;130    ipaddr_addr(const char *cp)
00a458  b518              PUSH     {r3,r4,lr}
;;;131    {
00a45a  4604              MOV      r4,r0
;;;132      ip_addr_t val;
;;;133    
;;;134      if (ipaddr_aton(cp, &val)) {
00a45c  4669              MOV      r1,sp
00a45e  4620              MOV      r0,r4
00a460  f7fffffe          BL       ipaddr_aton
00a464  b108              CBZ      r0,|L1.42090|
;;;135        return ip4_addr_get_u32(&val);
00a466  9800              LDR      r0,[sp,#0]
                  |L1.42088|
;;;136      }
;;;137      return (IPADDR_NONE);
;;;138    }
00a468  bd18              POP      {r3,r4,pc}
                  |L1.42090|
00a46a  f04f30ff          MOV      r0,#0xffffffff        ;137
00a46e  e7fb              B        |L1.42088|
;;;139    
                          ENDP

                  ipaddr_ntoa_r PROC
;;;275     */
;;;276    char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
00a470  e92d47fc          PUSH     {r2-r10,lr}
;;;277    {
00a474  4606              MOV      r6,r0
00a476  460b              MOV      r3,r1
00a478  4614              MOV      r4,r2
;;;278      u32_t s_addr;
;;;279      char inv[3];
;;;280      char *rp;
;;;281      u8_t *ap;
;;;282      u8_t rem;
;;;283      u8_t n;
;;;284      u8_t i;
;;;285      int len = 0;
00a47a  f04f0c00          MOV      r12,#0
;;;286    
;;;287      s_addr = ip4_addr_get_u32(addr);
00a47e  6830              LDR      r0,[r6,#0]
00a480  9001              STR      r0,[sp,#4]
;;;288    
;;;289      rp = buf;
00a482  4619              MOV      r1,r3
;;;290      ap = (u8_t *)&s_addr;
00a484  aa01              ADD      r2,sp,#4
;;;291      for(n = 0; n < 4; n++) {
00a486  2700              MOVS     r7,#0
00a488  e03c              B        |L1.42244|
                  |L1.42122|
;;;292        i = 0;
00a48a  2500              MOVS     r5,#0
;;;293        do {
00a48c  bf00              NOP      
                  |L1.42126|
;;;294          rem = *ap % (u8_t)10;
00a48e  7810              LDRB     r0,[r2,#0]
00a490  f04f090a          MOV      r9,#0xa
00a494  fb90faf9          SDIV     r10,r0,r9
00a498  fb09001a          MLS      r0,r9,r10,r0
00a49c  f00008ff          AND      r8,r0,#0xff
;;;295          *ap /= (u8_t)10;
00a4a0  7810              LDRB     r0,[r2,#0]
00a4a2  fb90f0f9          SDIV     r0,r0,r9
00a4a6  7010              STRB     r0,[r2,#0]
;;;296          inv[i++] = '0' + rem;
00a4a8  f1080030          ADD      r0,r8,#0x30
00a4ac  f0000aff          AND      r10,r0,#0xff
00a4b0  4628              MOV      r0,r5
00a4b2  f1050901          ADD      r9,r5,#1
00a4b6  f00905ff          AND      r5,r9,#0xff
00a4ba  f80da000          STRB     r10,[sp,r0]
;;;297        } while(*ap);
00a4be  7810              LDRB     r0,[r2,#0]
00a4c0  2800              CMP      r0,#0
00a4c2  d1e4              BNE      |L1.42126|
;;;298        while(i--) {
00a4c4  e00b              B        |L1.42206|
                  |L1.42182|
;;;299          if (len++ >= buflen) {
00a4c6  4660              MOV      r0,r12
00a4c8  f10c0c01          ADD      r12,r12,#1
00a4cc  42a0              CMP      r0,r4
00a4ce  db02              BLT      |L1.42198|
;;;300            return NULL;
00a4d0  2000              MOVS     r0,#0
                  |L1.42194|
;;;301          }
;;;302          *rp++ = inv[i];
;;;303        }
;;;304        if (len++ >= buflen) {
;;;305          return NULL;
;;;306        }
;;;307        *rp++ = '.';
;;;308        ap++;
;;;309      }
;;;310      *--rp = 0;
;;;311      return buf;
;;;312    }
00a4d2  e8bd87fc          POP      {r2-r10,pc}
                  |L1.42198|
00a4d6  f81d0005          LDRB     r0,[sp,r5]            ;302
00a4da  f8010b01          STRB     r0,[r1],#1            ;302
                  |L1.42206|
00a4de  0028              MOVS     r0,r5                 ;298
00a4e0  f1a50901          SUB      r9,r5,#1              ;298
00a4e4  f00905ff          AND      r5,r9,#0xff           ;298
00a4e8  d1ed              BNE      |L1.42182|
00a4ea  4660              MOV      r0,r12                ;304
00a4ec  f10c0c01          ADD      r12,r12,#1            ;304
00a4f0  42a0              CMP      r0,r4                 ;304
00a4f2  db01              BLT      |L1.42232|
00a4f4  2000              MOVS     r0,#0                 ;305
00a4f6  e7ec              B        |L1.42194|
                  |L1.42232|
00a4f8  202e              MOVS     r0,#0x2e              ;307
00a4fa  f8010b01          STRB     r0,[r1],#1            ;307
00a4fe  1c52              ADDS     r2,r2,#1              ;308
00a500  1c78              ADDS     r0,r7,#1              ;291
00a502  b2c7              UXTB     r7,r0                 ;291
                  |L1.42244|
00a504  2f04              CMP      r7,#4                 ;291
00a506  dbc0              BLT      |L1.42122|
00a508  f04f0900          MOV      r9,#0                 ;310
00a50c  1e48              SUBS     r0,r1,#1              ;310
00a50e  4601              MOV      r1,r0                 ;310
00a510  f8809000          STRB     r9,[r0,#0]            ;310
00a514  4618              MOV      r0,r3                 ;311
00a516  e7dc              B        |L1.42194|
;;;93     #include "third_party/lwip-1.4.1/src/core/ipv4/ip_frag.c"
                          ENDP

                  ipaddr_ntoa PROC
;;;260    char *
;;;261    ipaddr_ntoa(const ip_addr_t *addr)
00a518  b510              PUSH     {r4,lr}
;;;262    {
00a51a  4604              MOV      r4,r0
;;;263      static char str[16];
;;;264      return ipaddr_ntoa_r(addr, str, 16);
00a51c  2210              MOVS     r2,#0x10
00a51e  4903              LDR      r1,|L1.42284|
00a520  4620              MOV      r0,r4
00a522  f7fffffe          BL       ipaddr_ntoa_r
;;;265    }
00a526  bd10              POP      {r4,pc}
                  |L1.42280|
                          DCD      igmp_group_list
                  |L1.42284|
                          DCD      ||str||
                          ENDP

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
00a530  e92d41f0          PUSH     {r4-r8,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
00a534  4680              MOV      r8,r0
00a536  460d              MOV      r5,r1
00a538  4616              MOV      r6,r2
00a53a  461f              MOV      r7,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
00a53c  bf00              NOP      
00a53e  bf00              NOP      
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
00a540  2102              MOVS     r1,#2
00a542  4628              MOV      r0,r5
00a544  f7fffffe          BL       etharp_find_entry
00a548  4604              MOV      r4,r0
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
00a54a  2c00              CMP      r4,#0
00a54c  db16              BLT      |L1.42364|
00a54e  eb040084          ADD      r0,r4,r4,LSL #2
00a552  49fe              LDR      r1,|L1.43340|
00a554  eb010080          ADD      r0,r1,r0,LSL #2
00a558  7c80              LDRB     r0,[r0,#0x12]
00a55a  2802              CMP      r0,#2
00a55c  db0e              BLT      |L1.42364|
;;;615          *eth_ret = &arp_table[i].ethaddr;
00a55e  eb040084          ADD      r0,r4,r4,LSL #2
00a562  eb010080          ADD      r0,r1,r0,LSL #2
00a566  300c              ADDS     r0,r0,#0xc
00a568  6030              STR      r0,[r6,#0]
;;;616          *ip_ret = &arp_table[i].ipaddr;
00a56a  eb040084          ADD      r0,r4,r4,LSL #2
00a56e  eb010080          ADD      r0,r1,r0,LSL #2
00a572  1d00              ADDS     r0,r0,#4
00a574  6038              STR      r0,[r7,#0]
;;;617          return i;
00a576  4620              MOV      r0,r4
                  |L1.42360|
;;;618      }
;;;619      return -1;
;;;620    }
00a578  e8bd81f0          POP      {r4-r8,pc}
                  |L1.42364|
00a57c  f04f30ff          MOV      r0,#0xffffffff        ;619
00a580  e7fa              B        |L1.42360|
;;;621    
                          ENDP

                  etharp_output_to_arp_index PROC
;;;842    static err_t
;;;843    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
00a582  b570              PUSH     {r4-r6,lr}
;;;844    {
00a584  4605              MOV      r5,r0
00a586  460e              MOV      r6,r1
00a588  4614              MOV      r4,r2
;;;845      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
00a58a  bf00              NOP      
00a58c  bf00              NOP      
;;;846                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;847      /* if arp table entry is about to expire: re-request it,
;;;848         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;849         network with ARP requests if this address is used frequently. */
;;;850      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00a58e  eb040084          ADD      r0,r4,r4,LSL #2
00a592  49ee              LDR      r1,|L1.43340|
00a594  eb010080          ADD      r0,r1,r0,LSL #2
00a598  7c80              LDRB     r0,[r0,#0x12]
00a59a  2802              CMP      r0,#2
00a59c  d117              BNE      |L1.42446|
;;;851          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
00a59e  eb040084          ADD      r0,r4,r4,LSL #2
00a5a2  eb010080          ADD      r0,r1,r0,LSL #2
00a5a6  7cc0              LDRB     r0,[r0,#0x13]
00a5a8  28e4              CMP      r0,#0xe4
00a5aa  db10              BLT      |L1.42446|
;;;852        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
00a5ac  eb040084          ADD      r0,r4,r4,LSL #2
00a5b0  460a              MOV      r2,r1
00a5b2  eb020080          ADD      r0,r2,r0,LSL #2
00a5b6  1d01              ADDS     r1,r0,#4
00a5b8  4628              MOV      r0,r5
00a5ba  f7fffffe          BL       etharp_request
00a5be  b930              CBNZ     r0,|L1.42446|
;;;853          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
00a5c0  2003              MOVS     r0,#3
00a5c2  eb040184          ADD      r1,r4,r4,LSL #2
00a5c6  4ae1              LDR      r2,|L1.43340|
00a5c8  eb020181          ADD      r1,r2,r1,LSL #2
00a5cc  7488              STRB     r0,[r1,#0x12]
                  |L1.42446|
;;;854        }
;;;855      }
;;;856      
;;;857      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
00a5ce  eb040084          ADD      r0,r4,r4,LSL #2
00a5d2  49de              LDR      r1,|L1.43340|
00a5d4  eb010080          ADD      r0,r1,r0,LSL #2
00a5d8  f100030c          ADD      r3,r0,#0xc
00a5dc  f105022b          ADD      r2,r5,#0x2b
00a5e0  4631              MOV      r1,r6
00a5e2  4628              MOV      r0,r5
00a5e4  f7fffffe          BL       etharp_send_ip
;;;858        &arp_table[arp_idx].ethaddr);
;;;859    }
00a5e8  bd70              POP      {r4-r6,pc}
;;;860    
                          ENDP

                  etharp_output PROC
;;;879    err_t
;;;880    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
00a5ea  e92d47fc          PUSH     {r2-r10,lr}
;;;881    {
00a5ee  4604              MOV      r4,r0
00a5f0  460f              MOV      r7,r1
00a5f2  4615              MOV      r5,r2
;;;882      struct eth_addr *dest;
;;;883      struct eth_addr mcastaddr;
;;;884      ip_addr_t *dst_addr = ipaddr;
00a5f4  46a9              MOV      r9,r5
;;;885    
;;;886      LWIP_ASSERT("netif != NULL", netif != NULL);
00a5f6  bf00              NOP      
00a5f8  bf00              NOP      
;;;887      LWIP_ASSERT("q != NULL", q != NULL);
00a5fa  bf00              NOP      
00a5fc  bf00              NOP      
;;;888      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00a5fe  bf00              NOP      
00a600  bf00              NOP      
;;;889    
;;;890      /* make room for Ethernet header - should not fail */
;;;891      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
00a602  210e              MOVS     r1,#0xe
00a604  4638              MOV      r0,r7
00a606  f7fffffe          BL       pbuf_header
00a60a  b150              CBZ      r0,|L1.42530|
;;;892        /* bail out */
;;;893        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
00a60c  bf00              NOP      
00a60e  bf00              NOP      
;;;894          ("etharp_output: could not allocate room for header.\n"));
;;;895        LINK_STATS_INC(link.lenerr);
00a610  48cf              LDR      r0,|L1.43344|
00a612  8940              LDRH     r0,[r0,#0xa]  ; lwip_stats
00a614  1c40              ADDS     r0,r0,#1
00a616  49ce              LDR      r1,|L1.43344|
00a618  8148              STRH     r0,[r1,#0xa]
;;;896        return ERR_BUF;
00a61a  f06f0001          MVN      r0,#1
                  |L1.42526|
;;;897      }
;;;898    
;;;899      /* Determine on destination hardware address. Broadcasts and multicasts
;;;900       * are special, other IP addresses are looked up in the ARP table. */
;;;901    
;;;902      /* broadcast destination IP address? */
;;;903      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;904        /* broadcast on Ethernet also */
;;;905        dest = (struct eth_addr *)&ethbroadcast;
;;;906      /* multicast destination IP address? */
;;;907      } else if (ip_addr_ismulticast(ipaddr)) {
;;;908        /* Hash IP multicast address to MAC address.*/
;;;909        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;910        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;911        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;912        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;913        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;914        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;915        /* destination Ethernet address is multicast */
;;;916        dest = &mcastaddr;
;;;917      /* unicast destination IP address? */
;;;918      } else {
;;;919        s8_t i;
;;;920        /* outside local network? if so, this can neither be a global broadcast nor
;;;921           a subnet broadcast. */
;;;922        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;923            !ip_addr_islinklocal(ipaddr)) {
;;;924    #if LWIP_AUTOIP
;;;925          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;926            sizeof(struct eth_hdr));
;;;927          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;928             a link-local source address must always be "directly to its destination
;;;929             on the same physical link. The host MUST NOT send the packet to any
;;;930             router for forwarding". */
;;;931          if (!ip_addr_islinklocal(&iphdr->src))
;;;932    #endif /* LWIP_AUTOIP */
;;;933          {
;;;934            /* interface has default gateway? */
;;;935            if (!ip_addr_isany(&netif->gw)) {
;;;936              /* send to hardware address of default gateway IP address */
;;;937              dst_addr = &(netif->gw);
;;;938            /* no default gateway available */
;;;939            } else {
;;;940              /* no route to destination error (default gateway missing) */
;;;941              return ERR_RTE;
;;;942            }
;;;943          }
;;;944        }
;;;945    #if LWIP_NETIF_HWADDRHINT
;;;946        if (netif->addr_hint != NULL) {
;;;947          /* per-pcb cached entry was given */
;;;948          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;949          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;950    #endif /* LWIP_NETIF_HWADDRHINT */
;;;951            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;952                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;953              /* the per-pcb-cached entry is stable and the right one! */
;;;954              ETHARP_STATS_INC(etharp.cachehit);
;;;955              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;956            }
;;;957    #if LWIP_NETIF_HWADDRHINT
;;;958          }
;;;959        }
;;;960    #endif /* LWIP_NETIF_HWADDRHINT */
;;;961    
;;;962        /* find stable entry: do this here since this is a critical path for
;;;963           throughput and etharp_find_entry() is kind of slow */
;;;964        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;965          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;966              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;967            /* found an existing, stable entry */
;;;968            ETHARP_SET_HINT(netif, i);
;;;969            return etharp_output_to_arp_index(netif, q, i);
;;;970          }
;;;971        }
;;;972        /* no stable entry found, use the (slower) query function:
;;;973           queue on destination Ethernet address belonging to ipaddr */
;;;974        return etharp_query(netif, dst_addr, q);
;;;975      }
;;;976    
;;;977      /* continuation for multicast/broadcast destinations */
;;;978      /* obtain source Ethernet address of the given interface */
;;;979      /* send packet directly on the link */
;;;980      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;981    }
00a61e  e8bd87fc          POP      {r2-r10,pc}
                  |L1.42530|
00a622  4621              MOV      r1,r4                 ;903
00a624  6828              LDR      r0,[r5,#0]            ;903
00a626  f7fffffe          BL       ip4_addr_isbroadcast
00a62a  b110              CBZ      r0,|L1.42546|
00a62c  f8df8324          LDR      r8,|L1.43348|
00a630  e087              B        |L1.42818|
                  |L1.42546|
00a632  7828              LDRB     r0,[r5,#0]            ;907
00a634  f00000f0          AND      r0,r0,#0xf0           ;907
00a638  28e0              CMP      r0,#0xe0              ;907
00a63a  d115              BNE      |L1.42600|
00a63c  2001              MOVS     r0,#1                 ;909
00a63e  f88d0000          STRB     r0,[sp,#0]            ;909
00a642  2000              MOVS     r0,#0                 ;910
00a644  f88d0001          STRB     r0,[sp,#1]            ;910
00a648  205e              MOVS     r0,#0x5e              ;911
00a64a  f88d0002          STRB     r0,[sp,#2]            ;911
00a64e  7868              LDRB     r0,[r5,#1]            ;912
00a650  f000007f          AND      r0,r0,#0x7f           ;912
00a654  f88d0003          STRB     r0,[sp,#3]            ;912
00a658  78a8              LDRB     r0,[r5,#2]            ;913
00a65a  f88d0004          STRB     r0,[sp,#4]            ;913
00a65e  78e8              LDRB     r0,[r5,#3]            ;914
00a660  f88d0005          STRB     r0,[sp,#5]            ;914
00a664  46e8              MOV      r8,sp                 ;916
00a666  e06b              B        |L1.42816|
                  |L1.42600|
00a668  6828              LDR      r0,[r5,#0]            ;922
00a66a  68a1              LDR      r1,[r4,#8]            ;922
00a66c  4008              ANDS     r0,r0,r1              ;922
00a66e  e9d41201          LDRD     r1,r2,[r4,#4]         ;922
00a672  4011              ANDS     r1,r1,r2              ;922
00a674  4288              CMP      r0,r1                 ;922
00a676  d01a              BEQ      |L1.42670|
00a678  8828              LDRH     r0,[r5,#0]            ;923
00a67a  b280              UXTH     r0,r0                 ;923
00a67c  f5a0417e          SUB      r1,r0,#0xfe00         ;923
00a680  39a9              SUBS     r1,r1,#0xa9           ;923
00a682  d014              BEQ      |L1.42670|
00a684  6878              LDR      r0,[r7,#4]            ;925
00a686  f100010e          ADD      r1,r0,#0xe            ;925
00a68a  8988              LDRH     r0,[r1,#0xc]          ;931
00a68c  b280              UXTH     r0,r0                 ;931
00a68e  f5a0427e          SUB      r2,r0,#0xfe00         ;931
00a692  3aa9              SUBS     r2,r2,#0xa9           ;931
00a694  d00a              BEQ      |L1.42668|
00a696  f114000c          ADDS     r0,r4,#0xc            ;935
00a69a  d004              BEQ      |L1.42662|
00a69c  68e0              LDR      r0,[r4,#0xc]          ;935
00a69e  b110              CBZ      r0,|L1.42662|
00a6a0  f104090c          ADD      r9,r4,#0xc            ;937
00a6a4  e002              B        |L1.42668|
                  |L1.42662|
00a6a6  f06f0003          MVN      r0,#3                 ;941
00a6aa  e7b8              B        |L1.42526|
                  |L1.42668|
00a6ac  bf00              NOP                            ;944
                  |L1.42670|
00a6ae  48aa              LDR      r0,|L1.43352|
00a6b0  7800              LDRB     r0,[r0,#0]            ;951  ; etharp_cached_entry
00a6b2  eb000080          ADD      r0,r0,r0,LSL #2       ;951
00a6b6  49a5              LDR      r1,|L1.43340|
00a6b8  eb010080          ADD      r0,r1,r0,LSL #2       ;951
00a6bc  7c80              LDRB     r0,[r0,#0x12]         ;951
00a6be  2802              CMP      r0,#2                 ;951
00a6c0  db18              BLT      |L1.42740|
00a6c2  49a5              LDR      r1,|L1.43352|
00a6c4  7809              LDRB     r1,[r1,#0]            ;952  ; etharp_cached_entry
00a6c6  eb010181          ADD      r1,r1,r1,LSL #2       ;952
00a6ca  4aa0              LDR      r2,|L1.43340|
00a6cc  eb020181          ADD      r1,r2,r1,LSL #2       ;952
00a6d0  f8d90000          LDR      r0,[r9,#0]            ;952
00a6d4  6849              LDR      r1,[r1,#4]            ;952
00a6d6  4288              CMP      r0,r1                 ;952
00a6d8  d10c              BNE      |L1.42740|
00a6da  489d              LDR      r0,|L1.43344|
00a6dc  8dc0              LDRH     r0,[r0,#0x2e]         ;954
00a6de  1c40              ADDS     r0,r0,#1              ;954
00a6e0  b281              UXTH     r1,r0                 ;954
00a6e2  489b              LDR      r0,|L1.43344|
00a6e4  85c1              STRH     r1,[r0,#0x2e]         ;954
00a6e6  489c              LDR      r0,|L1.43352|
00a6e8  7802              LDRB     r2,[r0,#0]            ;955  ; etharp_cached_entry
00a6ea  4639              MOV      r1,r7                 ;955
00a6ec  4620              MOV      r0,r4                 ;955
00a6ee  f7fffffe          BL       etharp_output_to_arp_index
00a6f2  e794              B        |L1.42526|
                  |L1.42740|
00a6f4  2600              MOVS     r6,#0                 ;964
00a6f6  e01b              B        |L1.42800|
                  |L1.42744|
00a6f8  eb060086          ADD      r0,r6,r6,LSL #2       ;965
00a6fc  4993              LDR      r1,|L1.43340|
00a6fe  eb010080          ADD      r0,r1,r0,LSL #2       ;965
00a702  7c80              LDRB     r0,[r0,#0x12]         ;965
00a704  2802              CMP      r0,#2                 ;965
00a706  db11              BLT      |L1.42796|
00a708  eb060186          ADD      r1,r6,r6,LSL #2       ;966
00a70c  4a8f              LDR      r2,|L1.43340|
00a70e  eb020181          ADD      r1,r2,r1,LSL #2       ;966
00a712  f8d90000          LDR      r0,[r9,#0]            ;966
00a716  6849              LDR      r1,[r1,#4]            ;966
00a718  4288              CMP      r0,r1                 ;966
00a71a  d107              BNE      |L1.42796|
00a71c  498e              LDR      r1,|L1.43352|
00a71e  700e              STRB     r6,[r1,#0]            ;968
00a720  b2f2              UXTB     r2,r6                 ;969
00a722  4639              MOV      r1,r7                 ;969
00a724  4620              MOV      r0,r4                 ;969
00a726  f7fffffe          BL       etharp_output_to_arp_index
00a72a  e778              B        |L1.42526|
                  |L1.42796|
00a72c  1c70              ADDS     r0,r6,#1              ;964
00a72e  b246              SXTB     r6,r0                 ;964
                  |L1.42800|
00a730  2e0a              CMP      r6,#0xa               ;964
00a732  dbe1              BLT      |L1.42744|
00a734  463a              MOV      r2,r7                 ;974
00a736  4649              MOV      r1,r9                 ;974
00a738  4620              MOV      r0,r4                 ;974
00a73a  f7fffffe          BL       etharp_query
00a73e  e76e              B        |L1.42526|
                  |L1.42816|
00a740  bf00              NOP                            ;975
                  |L1.42818|
00a742  4643              MOV      r3,r8                 ;980
00a744  f104022b          ADD      r2,r4,#0x2b           ;980
00a748  4639              MOV      r1,r7                 ;980
00a74a  4620              MOV      r0,r4                 ;980
00a74c  f7fffffe          BL       etharp_send_ip
00a750  e765              B        |L1.42526|
;;;982    
                          ENDP

                  perf_init PROC
;;;35     void
;;;36     perf_init(char *fname)
00a752  4770              BX       lr
;;;37     {
;;;38     }
;;;153    #include "third_party/lwip-1.4.1/ports/tiva-tm4c129/sys_arch.c"
                          ENDP

                  sys_now PROC
;;;146    u32_t
;;;147    sys_now(void)
00a754  b510              PUSH     {r4,lr}
;;;148    {
;;;149        return(xTaskGetTickCount());
00a756  f7fffffe          BL       xTaskGetTickCount
;;;150    }
00a75a  bd10              POP      {r4,pc}
;;;151    
                          ENDP

                  InitDMADescriptors PROC
;;;231    void
;;;232    InitDMADescriptors(void)
00a75c  b510              PUSH     {r4,lr}
;;;233    {
;;;234        uint32_t ui32Loop;
;;;235    
;;;236        /* Transmit list -  mark all descriptors as not owned by the hardware */
;;;237       for(ui32Loop = 0; ui32Loop < NUM_TX_DESCRIPTORS; ui32Loop++)
00a75e  2400              MOVS     r4,#0
00a760  e026              B        |L1.42928|
                  |L1.42850|
;;;238       {
;;;239           g_pTxDescriptors[ui32Loop].pBuf = (struct pbuf *)0;
00a762  2000              MOVS     r0,#0
00a764  eb0401c4          ADD      r1,r4,r4,LSL #3
00a768  4a7c              LDR      r2,|L1.43356|
00a76a  eb020181          ADD      r1,r2,r1,LSL #2
00a76e  6208              STR      r0,[r1,#0x20]
;;;240           g_pTxDescriptors[ui32Loop].Desc.ui32Count = 0;
00a770  eb0401c4          ADD      r1,r4,r4,LSL #3
00a774  eb020181          ADD      r1,r2,r1,LSL #2
00a778  6048              STR      r0,[r1,#4]
;;;241           g_pTxDescriptors[ui32Loop].Desc.pvBuffer1 = 0;
00a77a  eb0401c4          ADD      r1,r4,r4,LSL #3
00a77e  eb020181          ADD      r1,r2,r1,LSL #2
00a782  6088              STR      r0,[r1,#8]
;;;242           g_pTxDescriptors[ui32Loop].Desc.DES3.pLink =
00a784  2c17              CMP      r4,#0x17
00a786  d101              BNE      |L1.42892|
;;;243                   ((ui32Loop == (NUM_TX_DESCRIPTORS - 1)) ?
;;;244                   &g_pTxDescriptors[0].Desc : &g_pTxDescriptors[ui32Loop + 1].Desc);
00a788  4610              MOV      r0,r2
00a78a  e005              B        |L1.42904|
                  |L1.42892|
00a78c  1c60              ADDS     r0,r4,#1
00a78e  eb0000c0          ADD      r0,r0,r0,LSL #3
00a792  4972              LDR      r1,|L1.43356|
00a794  eb010080          ADD      r0,r1,r0,LSL #2
                  |L1.42904|
00a798  eb0401c4          ADD      r1,r4,r4,LSL #3
00a79c  4a6f              LDR      r2,|L1.43356|
00a79e  eb020181          ADD      r1,r2,r1,LSL #2
00a7a2  60c8              STR      r0,[r1,#0xc]
;;;245           g_pTxDescriptors[ui32Loop].Desc.ui32CtrlStatus = DES0_TX_CTRL_INTERRUPT |
00a7a4  486e              LDR      r0,|L1.43360|
00a7a6  eb0401c4          ADD      r1,r4,r4,LSL #3
00a7aa  f8420021          STR      r0,[r2,r1,LSL #2]
00a7ae  1c64              ADDS     r4,r4,#1              ;237
                  |L1.42928|
00a7b0  2c18              CMP      r4,#0x18              ;237
00a7b2  d3d6              BCC      |L1.42850|
;;;246                   DES0_TX_CTRL_CHAINED | DES0_TX_CTRL_IP_ALL_CKHSUMS;
;;;247    
;;;248       }
;;;249    
;;;250       g_TxDescList.ui32Read = 0;
00a7b4  2000              MOVS     r0,#0
00a7b6  496b              LDR      r1,|L1.43364|
00a7b8  6088              STR      r0,[r1,#8]  ; g_TxDescList
;;;251       g_TxDescList.ui32Write = 0;
00a7ba  60c8              STR      r0,[r1,#0xc]  ; g_TxDescList
;;;252    
;;;253    
;;;254       /* Receive list -  tag each descriptor with a pbuf and set all fields to
;;;255        * allow packets to be received.
;;;256        */
;;;257      for(ui32Loop = 0; ui32Loop < NUM_RX_DESCRIPTORS; ui32Loop++)
00a7bc  2400              MOVS     r4,#0
00a7be  e05b              B        |L1.43128|
                  |L1.42944|
;;;258      {
;;;259          g_pRxDescriptors[ui32Loop].pBuf = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE,
00a7c0  2203              MOVS     r2,#3
00a7c2  f44f7100          MOV      r1,#0x200
00a7c6  4610              MOV      r0,r2
00a7c8  f7fffffe          BL       pbuf_alloc
00a7cc  eb0401c4          ADD      r1,r4,r4,LSL #3
00a7d0  4a65              LDR      r2,|L1.43368|
00a7d2  eb020181          ADD      r1,r2,r1,LSL #2
00a7d6  6208              STR      r0,[r1,#0x20]
;;;260                                                     PBUF_POOL);
;;;261          g_pRxDescriptors[ui32Loop].Desc.ui32Count = DES1_RX_CTRL_CHAINED;
00a7d8  f44f4080          MOV      r0,#0x4000
00a7dc  eb0401c4          ADD      r1,r4,r4,LSL #3
00a7e0  eb020181          ADD      r1,r2,r1,LSL #2
00a7e4  6048              STR      r0,[r1,#4]
;;;262          if(g_pRxDescriptors[ui32Loop].pBuf)
00a7e6  eb0400c4          ADD      r0,r4,r4,LSL #3
00a7ea  4611              MOV      r1,r2
00a7ec  eb010080          ADD      r0,r1,r0,LSL #2
00a7f0  6a00              LDR      r0,[r0,#0x20]
00a7f2  b318              CBZ      r0,|L1.43068|
;;;263          {
;;;264              /* Set the DMA to write directly into the pbuf payload. */
;;;265              g_pRxDescriptors[ui32Loop].Desc.pvBuffer1 =
00a7f4  eb0400c4          ADD      r0,r4,r4,LSL #3
00a7f8  eb010080          ADD      r0,r1,r0,LSL #2
00a7fc  6a00              LDR      r0,[r0,#0x20]
00a7fe  6840              LDR      r0,[r0,#4]
00a800  eb0401c4          ADD      r1,r4,r4,LSL #3
00a804  eb020181          ADD      r1,r2,r1,LSL #2
00a808  6088              STR      r0,[r1,#8]
;;;266                      g_pRxDescriptors[ui32Loop].pBuf->payload;
;;;267              g_pRxDescriptors[ui32Loop].Desc.ui32Count |=
00a80a  eb0400c4          ADD      r0,r4,r4,LSL #3
00a80e  4611              MOV      r1,r2
00a810  eb010080          ADD      r0,r1,r0,LSL #2
00a814  6840              LDR      r0,[r0,#4]
00a816  eb0401c4          ADD      r1,r4,r4,LSL #3
00a81a  eb020181          ADD      r1,r2,r1,LSL #2
00a81e  6a09              LDR      r1,[r1,#0x20]
00a820  8949              LDRH     r1,[r1,#0xa]
00a822  4308              ORRS     r0,r0,r1
00a824  eb0401c4          ADD      r1,r4,r4,LSL #3
00a828  eb020181          ADD      r1,r2,r1,LSL #2
00a82c  6048              STR      r0,[r1,#4]
;;;268                 (g_pRxDescriptors[ui32Loop].pBuf->len << DES1_RX_CTRL_BUFF1_SIZE_S);
;;;269              g_pRxDescriptors[ui32Loop].Desc.ui32CtrlStatus = DES0_RX_CTRL_OWN;
00a82e  f04f4000          MOV      r0,#0x80000000
00a832  eb0401c4          ADD      r1,r4,r4,LSL #3
00a836  f8420021          STR      r0,[r2,r1,LSL #2]
00a83a  e00c              B        |L1.43094|
                  |L1.43068|
;;;270          }
;;;271          else
;;;272          {
;;;273              LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_init: pbuf_alloc error\n"));
00a83c  bf00              NOP      
00a83e  bf00              NOP      
;;;274    
;;;275              /* No pbuf available so leave the buffer pointer empty. */
;;;276              g_pRxDescriptors[ui32Loop].Desc.pvBuffer1 = 0;
00a840  2000              MOVS     r0,#0
00a842  eb0401c4          ADD      r1,r4,r4,LSL #3
00a846  4a48              LDR      r2,|L1.43368|
00a848  eb020181          ADD      r1,r2,r1,LSL #2
00a84c  6088              STR      r0,[r1,#8]
;;;277              g_pRxDescriptors[ui32Loop].Desc.ui32CtrlStatus = 0;
00a84e  eb0401c4          ADD      r1,r4,r4,LSL #3
00a852  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L1.43094|
;;;278          }
;;;279          g_pRxDescriptors[ui32Loop].Desc.DES3.pLink =
00a856  2c07              CMP      r4,#7
00a858  d101              BNE      |L1.43102|
;;;280                  ((ui32Loop == (NUM_RX_DESCRIPTORS - 1)) ?
;;;281                  &g_pRxDescriptors[0].Desc : &g_pRxDescriptors[ui32Loop + 1].Desc);
00a85a  4843              LDR      r0,|L1.43368|
00a85c  e005              B        |L1.43114|
                  |L1.43102|
00a85e  1c60              ADDS     r0,r4,#1
00a860  eb0000c0          ADD      r0,r0,r0,LSL #3
00a864  4940              LDR      r1,|L1.43368|
00a866  eb010080          ADD      r0,r1,r0,LSL #2
                  |L1.43114|
00a86a  eb0401c4          ADD      r1,r4,r4,LSL #3
00a86e  4a3e              LDR      r2,|L1.43368|
00a870  eb020181          ADD      r1,r2,r1,LSL #2
00a874  60c8              STR      r0,[r1,#0xc]
00a876  1c64              ADDS     r4,r4,#1              ;257
                  |L1.43128|
00a878  2c08              CMP      r4,#8                 ;257
00a87a  d3a1              BCC      |L1.42944|
;;;282      }
;;;283    
;;;284      g_TxDescList.ui32Read = 0;
00a87c  2000              MOVS     r0,#0
00a87e  4939              LDR      r1,|L1.43364|
00a880  6088              STR      r0,[r1,#8]  ; g_TxDescList
;;;285      g_TxDescList.ui32Write = 0;
00a882  60c8              STR      r0,[r1,#0xc]  ; g_TxDescList
;;;286    
;;;287      //
;;;288      // Set the descriptor pointers in the hardware.
;;;289      //
;;;290      EMACRxDMADescriptorListSet(EMAC0_BASE, &g_pRxDescriptors[0].Desc);
00a884  4938              LDR      r1,|L1.43368|
00a886  4839              LDR      r0,|L1.43372|
00a888  f7fffffe          BL       EMACRxDMADescriptorListSet
;;;291      EMACTxDMADescriptorListSet(EMAC0_BASE, &g_pTxDescriptors[0].Desc);
00a88c  4933              LDR      r1,|L1.43356|
00a88e  4837              LDR      r0,|L1.43372|
00a890  f7fffffe          BL       EMACTxDMADescriptorListSet
;;;292    }
00a894  bd10              POP      {r4,pc}
;;;293    
                          ENDP

                  tivaif_hwinit PROC
;;;301    static void
;;;302    tivaif_hwinit(struct netif *psNetif)
00a896  b570              PUSH     {r4-r6,lr}
;;;303    {
00a898  4604              MOV      r4,r0
;;;304      uint16_t ui16Val;
;;;305    
;;;306      /* Set MAC hardware address length */
;;;307      psNetif->hwaddr_len = ETHARP_HWADDR_LEN;
00a89a  2006              MOVS     r0,#6
00a89c  f884002a          STRB     r0,[r4,#0x2a]
;;;308    
;;;309      /* Set MAC hardware address */
;;;310      EMACAddrGet(EMAC0_BASE, 0, &(psNetif->hwaddr[0]));
00a8a0  f104022b          ADD      r2,r4,#0x2b
00a8a4  2100              MOVS     r1,#0
00a8a6  4831              LDR      r0,|L1.43372|
00a8a8  f7fffffe          BL       EMACAddrGet
;;;311    
;;;312      /* Maximum transfer unit */
;;;313      psNetif->mtu = 1500;
00a8ac  f24050dc          MOV      r0,#0x5dc
00a8b0  8520              STRH     r0,[r4,#0x28]
;;;314    
;;;315      /* Device capabilities */
;;;316      psNetif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
00a8b2  2032              MOVS     r0,#0x32
00a8b4  f8840031          STRB     r0,[r4,#0x31]
;;;317    
;;;318      /* Initialize the DMA descriptors. */
;;;319      InitDMADescriptors();
00a8b8  f7fffffe          BL       InitDMADescriptors
;;;320    
;;;321      /* Clear any stray PHY interrupts that may be set. */
;;;322      ui16Val = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_MISR1);
00a8bc  2212              MOVS     r2,#0x12
00a8be  2100              MOVS     r1,#0
00a8c0  482a              LDR      r0,|L1.43372|
00a8c2  f7fffffe          BL       EMACPHYRead
00a8c6  4605              MOV      r5,r0
;;;323      ui16Val = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_MISR2);
00a8c8  2213              MOVS     r2,#0x13
00a8ca  2100              MOVS     r1,#0
00a8cc  4827              LDR      r0,|L1.43372|
00a8ce  f7fffffe          BL       EMACPHYRead
00a8d2  4605              MOV      r5,r0
;;;324    
;;;325      /* Configure and enable the link status change interrupt in the PHY. */
;;;326      ui16Val = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_SCR);
00a8d4  2211              MOVS     r2,#0x11
00a8d6  2100              MOVS     r1,#0
00a8d8  4824              LDR      r0,|L1.43372|
00a8da  f7fffffe          BL       EMACPHYRead
00a8de  4605              MOV      r5,r0
;;;327      ui16Val |= (EPHY_SCR_INTEN_EXT | EPHY_SCR_INTOE_EXT);
00a8e0  f0450503          ORR      r5,r5,#3
;;;328      EMACPHYWrite(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_SCR, ui16Val);
00a8e4  462b              MOV      r3,r5
00a8e6  2211              MOVS     r2,#0x11
00a8e8  2100              MOVS     r1,#0
00a8ea  4820              LDR      r0,|L1.43372|
00a8ec  f7fffffe          BL       EMACPHYWrite
;;;329      EMACPHYWrite(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_MISR1, (EPHY_MISR1_LINKSTATEN |
00a8f0  233c              MOVS     r3,#0x3c
00a8f2  2212              MOVS     r2,#0x12
00a8f4  2100              MOVS     r1,#0
00a8f6  481d              LDR      r0,|L1.43372|
00a8f8  f7fffffe          BL       EMACPHYWrite
;;;330                   EPHY_MISR1_SPEEDEN | EPHY_MISR1_DUPLEXMEN | EPHY_MISR1_ANCEN));
;;;331    
;;;332      /* Read the PHY interrupt status to clear any stray events. */
;;;333      ui16Val = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_MISR1);
00a8fc  2212              MOVS     r2,#0x12
00a8fe  2100              MOVS     r1,#0
00a900  481a              LDR      r0,|L1.43372|
00a902  f7fffffe          BL       EMACPHYRead
00a906  4605              MOV      r5,r0
;;;334    
;;;335      /**
;;;336       * Set MAC filtering options.  We receive all broadcast and mui32ticast
;;;337       * packets along with those addressed specifically for us.
;;;338       */
;;;339      EMACFrameFilterSet(EMAC0_BASE, (EMAC_FRMFILTER_HASH_AND_PERFECT |
00a908  f44f6182          MOV      r1,#0x410
00a90c  4817              LDR      r0,|L1.43372|
00a90e  f7fffffe          BL       EMACFrameFilterSet
;;;340                         EMAC_FRMFILTER_PASS_MULTICAST));
;;;341    
;;;342    #if LWIP_PTPD
;;;343      //
;;;344      // Enable timestamping on all received packets.
;;;345      //
;;;346      // We set the fine clock adjustment mode and configure the subsecond
;;;347      // increment to half the 25MHz PTPD clock.  This will give us maximum control
;;;348      // over the clock rate adjustment and keep the arithmetic easy later.  It
;;;349      // should be possible to synchronize with higher accuracy than this with
;;;350      // appropriate juggling of the subsecond increment count and the addend
;;;351      // register value, though.
;;;352      //
;;;353      EMACTimestampConfigSet(EMAC0_BASE, (EMAC_TS_ALL_RX_FRAMES |
;;;354                             EMAC_TS_DIGITAL_ROLLOVER |
;;;355                             EMAC_TS_PROCESS_IPV4_UDP | EMAC_TS_ALL |
;;;356                             EMAC_TS_PTP_VERSION_1 | EMAC_TS_UPDATE_FINE),
;;;357                             (1000000000 / (25000000 / 2)));
;;;358      EMACTimestampAddendSet(EMAC0_BASE, 0x80000000);
;;;359      EMACTimestampEnable(EMAC0_BASE);
;;;360    #endif
;;;361    
;;;362      /* Clear any pending MAC interrupts. */
;;;363      EMACIntClear(EMAC0_BASE, EMACIntStatus(EMAC0_BASE, false));
00a912  2100              MOVS     r1,#0
00a914  4815              LDR      r0,|L1.43372|
00a916  f7fffffe          BL       EMACIntStatus
00a91a  4606              MOV      r6,r0
00a91c  4631              MOV      r1,r6
00a91e  4813              LDR      r0,|L1.43372|
00a920  f7fffffe          BL       EMACIntClear
;;;364    
;;;365      /* Enable the Ethernet MAC transmitter and receiver. */
;;;366      EMACTxEnable(EMAC0_BASE);
00a924  4811              LDR      r0,|L1.43372|
00a926  f7fffffe          BL       EMACTxEnable
;;;367      EMACRxEnable(EMAC0_BASE);
00a92a  4810              LDR      r0,|L1.43372|
00a92c  f7fffffe          BL       EMACRxEnable
;;;368    
;;;369      /* Enable the Ethernet RX and TX interrupt source. */
;;;370      EMACIntEnable(EMAC0_BASE, (EMAC_INT_RECEIVE | EMAC_INT_TRANSMIT |
00a930  490f              LDR      r1,|L1.43376|
00a932  480e              LDR      r0,|L1.43372|
00a934  f7fffffe          BL       EMACIntEnable
;;;371                    EMAC_INT_TX_STOPPED | EMAC_INT_RX_NO_BUFFER |
;;;372                    EMAC_INT_RX_STOPPED | EMAC_INT_PHY));
;;;373    
;;;374      /* Enable the Ethernet interrupt. */
;;;375      IntEnable(INT_EMAC0);
00a938  2038              MOVS     r0,#0x38
00a93a  f7fffffe          BL       IntEnable
;;;376    
;;;377      /* Enable all processor interrupts. */
;;;378      IntMasterEnable();
00a93e  f7fffffe          BL       IntMasterEnable
;;;379    
;;;380      /* Tell the PHY to start an auto-negotiation cycle. */
;;;381      EMACPHYWrite(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_BMCR, (EPHY_BMCR_ANEN |
00a942  f44f5390          MOV      r3,#0x1200
00a946  2200              MOVS     r2,#0
00a948  4611              MOV      r1,r2
00a94a  e013              B        |L1.43380|
                  |L1.43340|
                          DCD      arp_table
                  |L1.43344|
                          DCD      lwip_stats
                  |L1.43348|
                          DCD      ethbroadcast
                  |L1.43352|
                          DCD      etharp_cached_entry
                  |L1.43356|
                          DCD      g_pTxDescriptors
                  |L1.43360|
                          DCD      0x40d00000
                  |L1.43364|
                          DCD      g_TxDescList
                  |L1.43368|
                          DCD      g_pRxDescriptors
                  |L1.43372|
                          DCD      0x400ec000
                  |L1.43376|
                          DCD      0x800001c3
                  |L1.43380|
00a974  48fe              LDR      r0,|L1.44400|
00a976  f7fffffe          BL       EMACPHYWrite
;;;382                   EPHY_BMCR_RESTARTAN));
;;;383    }
00a97a  bd70              POP      {r4-r6,pc}
;;;384    
                          ENDP

                  tivaif_check_pbuf PROC
;;;421    static struct pbuf *
;;;422    tivaif_check_pbuf(struct pbuf *p)
00a97c  b570              PUSH     {r4-r6,lr}
;;;423    {
00a97e  4605              MOV      r5,r0
;;;424        struct pbuf *pBuf;
;;;425        err_t Err;
;;;426    
;;;427        pBuf = p;
00a980  462c              MOV      r4,r5
;;;428    
;;;429    #ifdef DEBUG
;;;430        tivaif_trace_pbuf("Original:", p);
;;;431    #endif
;;;432    
;;;433        /* Walk the list of buffers in the pbuf checking each. */
;;;434        do
00a982  bf00              NOP      
                  |L1.43396|
;;;435        {
;;;436            /* Does this pbuf's payload reside in memory that the Ethernet DMA
;;;437             * can access?
;;;438             */
;;;439            if(!PTR_SAFE_FOR_EMAC_DMA(pBuf->payload))
00a984  6860              LDR      r0,[r4,#4]
00a986  f1b07f00          CMP      r0,#0x2000000
00a98a  d303              BCC      |L1.43412|
00a98c  49f9              LDR      r1,|L1.44404|
00a98e  6860              LDR      r0,[r4,#4]
00a990  4288              CMP      r0,r1
00a992  d316              BCC      |L1.43458|
                  |L1.43412|
;;;440            {
;;;441                /* This buffer is outside the DMA-able memory space so we need
;;;442                 * to copy the pbuf.
;;;443                 */
;;;444                pBuf = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_POOL);
00a994  8929              LDRH     r1,[r5,#8]
00a996  2203              MOVS     r2,#3
00a998  4610              MOV      r0,r2
00a99a  f7fffffe          BL       pbuf_alloc
00a99e  4604              MOV      r4,r0
;;;445    
;;;446                /* If we got a new pbuf... */
;;;447                if(pBuf)
00a9a0  b16c              CBZ      r4,|L1.43454|
;;;448                {
;;;449                    /* ...copy the old pbuf into the new one. */
;;;450                    Err = pbuf_copy(pBuf, p);
00a9a2  4629              MOV      r1,r5
00a9a4  4620              MOV      r0,r4
00a9a6  f7fffffe          BL       pbuf_copy
00a9aa  4606              MOV      r6,r0
;;;451    
;;;452                    /* If we failed to copy the pbuf, free the newly allocated one
;;;453                     * and make sure we return a NULL to show a problem.
;;;454                     */
;;;455                    if(Err != ERR_OK)
00a9ac  b126              CBZ      r6,|L1.43448|
;;;456                    {
;;;457                        DRIVER_STATS_INC(TXCopyFailCount);
;;;458                        pbuf_free(pBuf);
00a9ae  4620              MOV      r0,r4
00a9b0  f7fffffe          BL       pbuf_free
;;;459                        pBuf = NULL;
00a9b4  2400              MOVS     r4,#0
00a9b6  e002              B        |L1.43454|
                  |L1.43448|
;;;460                    }
;;;461                    else
;;;462                    {
;;;463    #ifdef DEBUG
;;;464                        tivaif_trace_pbuf("Copied:", pBuf);
;;;465    #endif
;;;466                        DRIVER_STATS_INC(TXCopyCount);
;;;467    
;;;468                        /* Reduce the reference count on the original pbuf since
;;;469                         * we're not going to hold on to it after returning from
;;;470                         * tivaif_transmit.  Note that we already bumped
;;;471                         * the reference count at the top of tivaif_transmit.
;;;472                         */
;;;473                        pbuf_free(p);
00a9b8  4628              MOV      r0,r5
00a9ba  f7fffffe          BL       pbuf_free
                  |L1.43454|
;;;474                    }
;;;475                }
;;;476    
;;;477                /* Send back the new pbuf pointer or NULL if an error occurred. */
;;;478                return(pBuf);
00a9be  4620              MOV      r0,r4
                  |L1.43456|
;;;479            }
;;;480    
;;;481            /* Move on to the next buffer in the queue */
;;;482            pBuf = pBuf->next;
;;;483        }
;;;484        while(pBuf);
;;;485    
;;;486        /**
;;;487         * If we get here, the passed pbuf can be safely used without needing to
;;;488         * be copied.
;;;489         */
;;;490        return(p);
;;;491    }
00a9c0  bd70              POP      {r4-r6,pc}
                  |L1.43458|
00a9c2  6824              LDR      r4,[r4,#0]            ;482
00a9c4  2c00              CMP      r4,#0                 ;484
00a9c6  d1dd              BNE      |L1.43396|
00a9c8  4628              MOV      r0,r5                 ;490
00a9ca  e7f9              B        |L1.43456|
;;;492    
                          ENDP

                  tivaif_transmit PROC
;;;503    static err_t
;;;504    tivaif_transmit(struct netif *psNetif, struct pbuf *p)
00a9cc  e92d4ff8          PUSH     {r3-r11,lr}
;;;505    {
00a9d0  4681              MOV      r9,r0
00a9d2  460e              MOV      r6,r1
;;;506      tStellarisIF *pIF;
;;;507      tDescriptor *pDesc;
;;;508      struct pbuf *pBuf;
;;;509      uint32_t ui32NumChained, ui32NumDescs;
;;;510      bool bFirst;
;;;511      SYS_ARCH_DECL_PROTECT(lev);
;;;512    
;;;513      LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_transmit 0x%08x, len %d\n", p,
00a9d4  bf00              NOP      
00a9d6  bf00              NOP      
;;;514                  p->tot_len));
;;;515    
;;;516      /**
;;;517       * This entire function must run within a "critical section" to preserve
;;;518       * the integrity of the transmit pbuf queue.
;;;519       */
;;;520      SYS_ARCH_PROTECT(lev);
00a9d8  f7fffffe          BL       sys_arch_protect
00a9dc  9000              STR      r0,[sp,#0]
;;;521    
;;;522      /* Update our transmit attempt counter. */
;;;523      DRIVER_STATS_INC(TXCount);
;;;524    
;;;525      /**
;;;526       * Increase the reference count on the packet provided so that we can
;;;527       * hold on to it until we are finished transmitting its content.
;;;528       */
;;;529      pbuf_ref(p);
00a9de  4630              MOV      r0,r6
00a9e0  f7fffffe          BL       pbuf_ref
;;;530    
;;;531      /**
;;;532       * Determine whether all buffers passed are within SRAM and, if not, copy
;;;533       * the pbuf into SRAM-resident buffers so that the Ethernet DMA can access
;;;534       * the data.
;;;535       */
;;;536      p = tivaif_check_pbuf(p);
00a9e4  4630              MOV      r0,r6
00a9e6  f7fffffe          BL       tivaif_check_pbuf
00a9ea  4606              MOV      r6,r0
;;;537    
;;;538      /* Make sure we still have a valid buffer (it may have been copied) */
;;;539      if(!p)
00a9ec  b95e              CBNZ     r6,|L1.43526|
;;;540      {
;;;541          LINK_STATS_INC(link.memerr);
00a9ee  48e2              LDR      r0,|L1.44408|
00a9f0  8980              LDRH     r0,[r0,#0xc]  ; lwip_stats
00a9f2  1c40              ADDS     r0,r0,#1
00a9f4  49e0              LDR      r1,|L1.44408|
00a9f6  8188              STRH     r0,[r1,#0xc]
;;;542          SYS_ARCH_UNPROTECT(lev);
00a9f8  9800              LDR      r0,[sp,#0]
00a9fa  f7fffffe          BL       sys_arch_unprotect
;;;543          return(ERR_MEM);
00a9fe  f04f30ff          MOV      r0,#0xffffffff
                  |L1.43522|
;;;544      }
;;;545    
;;;546      /* Get our state data from the netif structure we were passed. */
;;;547      pIF = (tStellarisIF *)psNetif->state;
;;;548    
;;;549      /* Make sure that the transmit descriptors are not all in use */
;;;550      pDesc = &(pIF->pTxDescList->pDescriptors[pIF->pTxDescList->ui32Write]);
;;;551      if(pDesc->pBuf)
;;;552      {
;;;553          /**
;;;554           * The current write descriptor has a pbuf attached to it so this
;;;555           * implies that the ring is fui32l. Reject this transmit request with a
;;;556           * memory error since we can't satisfy it just now.
;;;557           */
;;;558          pbuf_free(p);
;;;559          LINK_STATS_INC(link.memerr);
;;;560          DRIVER_STATS_INC(TXNoDescCount);
;;;561          SYS_ARCH_UNPROTECT(lev);
;;;562          return (ERR_MEM);
;;;563      }
;;;564    
;;;565      /* How many pbufs are in the chain passed? */
;;;566      ui32NumChained = (uint32_t)pbuf_clen(p);
;;;567    
;;;568      /* How many free transmit descriptors do we have? */
;;;569      ui32NumDescs = (pIF->pTxDescList->ui32Read > pIF->pTxDescList->ui32Write) ?
;;;570              (pIF->pTxDescList->ui32Read - pIF->pTxDescList->ui32Write) :
;;;571              ((NUM_TX_DESCRIPTORS - pIF->pTxDescList->ui32Write) +
;;;572               pIF->pTxDescList->ui32Read);
;;;573    
;;;574      /* Do we have enough free descriptors to send the whole packet? */
;;;575      if(ui32NumDescs < ui32NumChained)
;;;576      {
;;;577          /* No - we can't transmit this whole packet so return an error. */
;;;578          pbuf_free(p);
;;;579          LINK_STATS_INC(link.memerr);
;;;580          DRIVER_STATS_INC(TXNoDescCount);
;;;581          SYS_ARCH_UNPROTECT(lev);
;;;582          return (ERR_MEM);
;;;583      }
;;;584    
;;;585      /* Tag the first descriptor as the start of the packet. */
;;;586      bFirst = true;
;;;587      pDesc->Desc.ui32CtrlStatus = DES0_TX_CTRL_FIRST_SEG;
;;;588    
;;;589      /* Here, we know we can send the packet so write it to the descriptors */
;;;590      pBuf = p;
;;;591    
;;;592      while(ui32NumChained)
;;;593      {
;;;594          /* Get a pointer to the descriptor we will write next. */
;;;595          pDesc = &(pIF->pTxDescList->pDescriptors[pIF->pTxDescList->ui32Write]);
;;;596    
;;;597          /* Fill in the buffer pointer and length */
;;;598          pDesc->Desc.ui32Count = (uint32_t)pBuf->len;
;;;599          pDesc->Desc.pvBuffer1 = pBuf->payload;
;;;600    
;;;601          /* Tag the first descriptor as the start of the packet. */
;;;602          if(bFirst)
;;;603          {
;;;604              bFirst = false;
;;;605              pDesc->Desc.ui32CtrlStatus = DES0_TX_CTRL_FIRST_SEG;
;;;606          }
;;;607          else
;;;608          {
;;;609              pDesc->Desc.ui32CtrlStatus = 0;
;;;610          }
;;;611    
;;;612          pDesc->Desc.ui32CtrlStatus |= (DES0_TX_CTRL_IP_ALL_CKHSUMS |
;;;613                                         DES0_TX_CTRL_CHAINED);
;;;614    
;;;615          /* Decrement our descriptor counter, move on to the next buffer in the
;;;616           * pbuf chain. */
;;;617          ui32NumChained--;
;;;618          pBuf = pBuf->next;
;;;619    
;;;620          /* Update the descriptor list write index. */
;;;621          pIF->pTxDescList->ui32Write++;
;;;622          if(pIF->pTxDescList->ui32Write == NUM_TX_DESCRIPTORS)
;;;623          {
;;;624              pIF->pTxDescList->ui32Write = 0;
;;;625          }
;;;626    
;;;627          /* If this is the last descriptor, mark it as the end of the packet. */
;;;628          if(!ui32NumChained)
;;;629          {
;;;630              pDesc->Desc.ui32CtrlStatus |= (DES0_TX_CTRL_LAST_SEG |
;;;631                                             DES0_TX_CTRL_INTERRUPT);
;;;632    
;;;633              /* Tag the descriptor with the original pbuf pointer. */
;;;634              pDesc->pBuf = p;
;;;635          }
;;;636          else
;;;637          {
;;;638              /* Set the lsb of the pbuf pointer.  We use this as a signal that
;;;639               * we should not free the pbuf when we are walking the descriptor
;;;640               * list while processing the transmit interrupt.  We only free the
;;;641               * pbuf when processing the last descriptor used to transmit its
;;;642               * chain.
;;;643               */
;;;644              pDesc->pBuf = (struct pbuf *)((uint32_t)p + 1);
;;;645          }
;;;646    
;;;647          DRIVER_STATS_INC(TXBufQueuedCount);
;;;648    
;;;649          /* Hand the descriptor over to the hardware. */
;;;650          pDesc->Desc.ui32CtrlStatus |= DES0_TX_CTRL_OWN;
;;;651      }
;;;652    
;;;653      /* Tell the transmitter to start (in case it had stopped). */
;;;654      EMACTxDMAPollDemand(EMAC0_BASE);
;;;655    
;;;656      /* Update lwIP statistics */
;;;657      LINK_STATS_INC(link.xmit);
;;;658    
;;;659      SYS_ARCH_UNPROTECT(lev);
;;;660    
;;;661      return(ERR_OK);
;;;662    }
00aa02  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.43526|
00aa06  f8d9401c          LDR      r4,[r9,#0x1c]         ;547
00aa0a  6860              LDR      r0,[r4,#4]            ;550
00aa0c  6800              LDR      r0,[r0,#0]            ;550
00aa0e  6861              LDR      r1,[r4,#4]            ;550
00aa10  68c9              LDR      r1,[r1,#0xc]          ;550
00aa12  eb0101c1          ADD      r1,r1,r1,LSL #3       ;550
00aa16  eb000581          ADD      r5,r0,r1,LSL #2       ;550
00aa1a  6a28              LDR      r0,[r5,#0x20]         ;551
00aa1c  b168              CBZ      r0,|L1.43578|
00aa1e  4630              MOV      r0,r6                 ;558
00aa20  f7fffffe          BL       pbuf_free
00aa24  48d4              LDR      r0,|L1.44408|
00aa26  8980              LDRH     r0,[r0,#0xc]          ;559  ; lwip_stats
00aa28  1c40              ADDS     r0,r0,#1              ;559
00aa2a  49d3              LDR      r1,|L1.44408|
00aa2c  8188              STRH     r0,[r1,#0xc]          ;559
00aa2e  9800              LDR      r0,[sp,#0]            ;561
00aa30  f7fffffe          BL       sys_arch_unprotect
00aa34  f04f30ff          MOV      r0,#0xffffffff        ;562
00aa38  e7e3              B        |L1.43522|
                  |L1.43578|
00aa3a  4630              MOV      r0,r6                 ;566
00aa3c  f7fffffe          BL       pbuf_clen
00aa40  4607              MOV      r7,r0                 ;566
00aa42  6860              LDR      r0,[r4,#4]            ;569
00aa44  6880              LDR      r0,[r0,#8]            ;569
00aa46  6861              LDR      r1,[r4,#4]            ;569
00aa48  68c9              LDR      r1,[r1,#0xc]          ;569
00aa4a  4288              CMP      r0,r1                 ;569
00aa4c  d905              BLS      |L1.43610|
00aa4e  6860              LDR      r0,[r4,#4]            ;570
00aa50  6880              LDR      r0,[r0,#8]            ;570
00aa52  6861              LDR      r1,[r4,#4]            ;570
00aa54  68c9              LDR      r1,[r1,#0xc]          ;570
00aa56  1a40              SUBS     r0,r0,r1              ;570
00aa58  e006              B        |L1.43624|
                  |L1.43610|
00aa5a  6860              LDR      r0,[r4,#4]            ;571
00aa5c  68c0              LDR      r0,[r0,#0xc]          ;571
00aa5e  f1c00018          RSB      r0,r0,#0x18           ;571
00aa62  6861              LDR      r1,[r4,#4]            ;571
00aa64  6889              LDR      r1,[r1,#8]            ;571
00aa66  4408              ADD      r0,r0,r1              ;571
                  |L1.43624|
00aa68  4683              MOV      r11,r0                ;571
00aa6a  45bb              CMP      r11,r7                ;575
00aa6c  d20d              BCS      |L1.43658|
00aa6e  4630              MOV      r0,r6                 ;578
00aa70  f7fffffe          BL       pbuf_free
00aa74  48c0              LDR      r0,|L1.44408|
00aa76  8980              LDRH     r0,[r0,#0xc]          ;579  ; lwip_stats
00aa78  1c40              ADDS     r0,r0,#1              ;579
00aa7a  49bf              LDR      r1,|L1.44408|
00aa7c  8188              STRH     r0,[r1,#0xc]          ;579
00aa7e  9800              LDR      r0,[sp,#0]            ;581
00aa80  f7fffffe          BL       sys_arch_unprotect
00aa84  f04f30ff          MOV      r0,#0xffffffff        ;582
00aa88  e7bb              B        |L1.43522|
                  |L1.43658|
00aa8a  f04f0a01          MOV      r10,#1                ;586
00aa8e  f04f5080          MOV      r0,#0x10000000        ;587
00aa92  6028              STR      r0,[r5,#0]            ;587
00aa94  46b0              MOV      r8,r6                 ;590
00aa96  e038              B        |L1.43786|
                  |L1.43672|
00aa98  6860              LDR      r0,[r4,#4]            ;595
00aa9a  6800              LDR      r0,[r0,#0]            ;595
00aa9c  6861              LDR      r1,[r4,#4]            ;595
00aa9e  68c9              LDR      r1,[r1,#0xc]          ;595
00aaa0  eb0101c1          ADD      r1,r1,r1,LSL #3       ;595
00aaa4  eb000581          ADD      r5,r0,r1,LSL #2       ;595
00aaa8  f8b8000a          LDRH     r0,[r8,#0xa]          ;598
00aaac  6068              STR      r0,[r5,#4]            ;598
00aaae  f8d80004          LDR      r0,[r8,#4]            ;599
00aab2  60a8              STR      r0,[r5,#8]            ;599
00aab4  f1ba0f00          CMP      r10,#0                ;602
00aab8  d005              BEQ      |L1.43718|
00aaba  f04f0a00          MOV      r10,#0                ;604
00aabe  f04f5080          MOV      r0,#0x10000000        ;605
00aac2  6028              STR      r0,[r5,#0]            ;605
00aac4  e001              B        |L1.43722|
                  |L1.43718|
00aac6  2000              MOVS     r0,#0                 ;609
00aac8  6028              STR      r0,[r5,#0]            ;609
                  |L1.43722|
00aaca  6828              LDR      r0,[r5,#0]            ;612
00aacc  f4400050          ORR      r0,r0,#0xd00000       ;612
00aad0  6028              STR      r0,[r5,#0]            ;612
00aad2  1e7f              SUBS     r7,r7,#1              ;617
00aad4  f8d88000          LDR      r8,[r8,#0]            ;618
00aad8  6860              LDR      r0,[r4,#4]            ;621
00aada  68c0              LDR      r0,[r0,#0xc]          ;621
00aadc  1c40              ADDS     r0,r0,#1              ;621
00aade  6861              LDR      r1,[r4,#4]            ;621
00aae0  60c8              STR      r0,[r1,#0xc]          ;621
00aae2  6860              LDR      r0,[r4,#4]            ;622
00aae4  68c0              LDR      r0,[r0,#0xc]          ;622
00aae6  2818              CMP      r0,#0x18              ;622
00aae8  d102              BNE      |L1.43760|
00aaea  2000              MOVS     r0,#0                 ;624
00aaec  6861              LDR      r1,[r4,#4]            ;624
00aaee  60c8              STR      r0,[r1,#0xc]          ;624
                  |L1.43760|
00aaf0  b92f              CBNZ     r7,|L1.43774|
00aaf2  6828              LDR      r0,[r5,#0]            ;630
00aaf4  f04040c0          ORR      r0,r0,#0x60000000     ;630
00aaf8  6028              STR      r0,[r5,#0]            ;630
00aafa  622e              STR      r6,[r5,#0x20]         ;634
00aafc  e001              B        |L1.43778|
                  |L1.43774|
00aafe  1c70              ADDS     r0,r6,#1              ;644
00ab00  6228              STR      r0,[r5,#0x20]         ;644
                  |L1.43778|
00ab02  6828              LDR      r0,[r5,#0]            ;650
00ab04  f0404000          ORR      r0,r0,#0x80000000     ;650
00ab08  6028              STR      r0,[r5,#0]            ;650
                  |L1.43786|
00ab0a  2f00              CMP      r7,#0                 ;592
00ab0c  d1c4              BNE      |L1.43672|
00ab0e  4898              LDR      r0,|L1.44400|
00ab10  f7fffffe          BL       EMACTxDMAPollDemand
00ab14  4898              LDR      r0,|L1.44408|
00ab16  8800              LDRH     r0,[r0,#0]            ;657  ; lwip_stats
00ab18  1c40              ADDS     r0,r0,#1              ;657
00ab1a  4997              LDR      r1,|L1.44408|
00ab1c  8008              STRH     r0,[r1,#0]            ;657
00ab1e  9800              LDR      r0,[sp,#0]            ;659
00ab20  f7fffffe          BL       sys_arch_unprotect
00ab24  2000              MOVS     r0,#0                 ;661
00ab26  e76c              B        |L1.43522|
;;;663    
                          ENDP

                  tivaif_process_transmit PROC
;;;673    static void
;;;674    tivaif_process_transmit(tStellarisIF *pIF)
00ab28  b570              PUSH     {r4-r6,lr}
;;;675    {
00ab2a  4605              MOV      r5,r0
;;;676        tDescriptorList *pDescList;
;;;677        uint32_t ui32NumDescs;
;;;678    
;;;679        /* Get a pointer to the transmit descriptor list. */
;;;680        pDescList = pIF->pTxDescList;
00ab2c  686c              LDR      r4,[r5,#4]
;;;681    
;;;682        /* Walk the list until we have checked all descriptors or we reach the
;;;683         * write pointer or find a descriptor that the hardware is still working
;;;684         * on.
;;;685         */
;;;686        for(ui32NumDescs = 0; ui32NumDescs < pDescList->ui32NumDescs; ui32NumDescs++)
00ab2e  2600              MOVS     r6,#0
00ab30  e039              B        |L1.43942|
                  |L1.43826|
;;;687        {
;;;688            /* Has the buffer attached to this descriptor been transmitted? */
;;;689            if(pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
00ab32  68a1              LDR      r1,[r4,#8]
00ab34  eb0101c1          ADD      r1,r1,r1,LSL #3
00ab38  6820              LDR      r0,[r4,#0]
00ab3a  f8500021          LDR      r0,[r0,r1,LSL #2]
00ab3e  f0104f00          TST      r0,#0x80000000
00ab42  d000              BEQ      |L1.43846|
;;;690               DES0_TX_CTRL_OWN)
;;;691            {
;;;692                /* No - we're finished. */
;;;693                break;
00ab44  e032              B        |L1.43948|
                  |L1.43846|
;;;694            }
;;;695    
;;;696            /* Does this descriptor have a buffer attached to it? */
;;;697            if(pDescList->pDescriptors[pDescList->ui32Read].pBuf)
00ab46  68a1              LDR      r1,[r4,#8]
00ab48  eb0101c1          ADD      r1,r1,r1,LSL #3
00ab4c  6820              LDR      r0,[r4,#0]
00ab4e  eb000081          ADD      r0,r0,r1,LSL #2
00ab52  6a00              LDR      r0,[r0,#0x20]
00ab54  b1e0              CBZ      r0,|L1.43920|
;;;698            {
;;;699                /* Yes - free it if it's not marked as an intermediate pbuf */
;;;700                if(!((uint32_t)(pDescList->pDescriptors[pDescList->ui32Read].pBuf) & 1))
00ab56  68a1              LDR      r1,[r4,#8]
00ab58  eb0101c1          ADD      r1,r1,r1,LSL #3
00ab5c  6820              LDR      r0,[r4,#0]
00ab5e  eb000081          ADD      r0,r0,r1,LSL #2
00ab62  f8900020          LDRB     r0,[r0,#0x20]
00ab66  f0100f01          TST      r0,#1
00ab6a  d108              BNE      |L1.43902|
;;;701                {
;;;702                    pbuf_free(pDescList->pDescriptors[pDescList->ui32Read].pBuf);
00ab6c  68a2              LDR      r2,[r4,#8]
00ab6e  eb0202c2          ADD      r2,r2,r2,LSL #3
00ab72  6821              LDR      r1,[r4,#0]
00ab74  eb010182          ADD      r1,r1,r2,LSL #2
00ab78  6a08              LDR      r0,[r1,#0x20]
00ab7a  f7fffffe          BL       pbuf_free
                  |L1.43902|
;;;703                    DRIVER_STATS_INC(TXBufFreedCount);
;;;704                }
;;;705                pDescList->pDescriptors[pDescList->ui32Read].pBuf = NULL;
00ab7e  2000              MOVS     r0,#0
00ab80  68a2              LDR      r2,[r4,#8]
00ab82  eb0202c2          ADD      r2,r2,r2,LSL #3
00ab86  6821              LDR      r1,[r4,#0]
00ab88  eb010182          ADD      r1,r1,r2,LSL #2
00ab8c  6208              STR      r0,[r1,#0x20]
00ab8e  e000              B        |L1.43922|
                  |L1.43920|
;;;706            }
;;;707            else
;;;708            {
;;;709                /* If the descriptor has no buffer, we are finished. */
;;;710                break;
00ab90  e00c              B        |L1.43948|
                  |L1.43922|
;;;711            }
;;;712    
;;;713            /* Move on to the next descriptor. */
;;;714            pDescList->ui32Read++;
00ab92  68a0              LDR      r0,[r4,#8]
00ab94  1c40              ADDS     r0,r0,#1
00ab96  60a0              STR      r0,[r4,#8]
;;;715            if(pDescList->ui32Read == pDescList->ui32NumDescs)
00ab98  e9d41001          LDRD     r1,r0,[r4,#4]
00ab9c  4288              CMP      r0,r1
00ab9e  d101              BNE      |L1.43940|
;;;716            {
;;;717                pDescList->ui32Read = 0;
00aba0  2000              MOVS     r0,#0
00aba2  60a0              STR      r0,[r4,#8]
                  |L1.43940|
00aba4  1c76              ADDS     r6,r6,#1              ;686
                  |L1.43942|
00aba6  6860              LDR      r0,[r4,#4]            ;686
00aba8  42b0              CMP      r0,r6                 ;686
00abaa  d8c2              BHI      |L1.43826|
                  |L1.43948|
00abac  bf00              NOP                            ;693
;;;718            }
;;;719        }
;;;720    }
00abae  bd70              POP      {r4-r6,pc}
;;;721    
                          ENDP

                  tivaif_receive PROC
;;;733    static void
;;;734    tivaif_receive(struct netif *psNetif)
00abb0  e92d41f0          PUSH     {r4-r8,lr}
;;;735    {
00abb4  4605              MOV      r5,r0
;;;736      tDescriptorList *pDescList;
;;;737      tStellarisIF *pIF;
;;;738      struct pbuf *pBuf;
;;;739      uint32_t ui32DescEnd;
;;;740    
;;;741      /* Get a pointer to our state data */
;;;742      pIF = (tStellarisIF *)(psNetif->state);
00abb6  69ef              LDR      r7,[r5,#0x1c]
;;;743    
;;;744      /* Get a pointer to the receive descriptor list. */
;;;745      pDescList = pIF->pRxDescList;
00abb8  68bc              LDR      r4,[r7,#8]
;;;746    
;;;747      /* Start with a NULL pbuf so that we don't try to link chain the first
;;;748       * time round.
;;;749       */
;;;750      pBuf = NULL;
00abba  2600              MOVS     r6,#0
;;;751    
;;;752      /* Determine where we start and end our walk of the descriptor list */
;;;753       ui32DescEnd = pDescList->ui32Read ? (pDescList->ui32Read - 1) : (pDescList->ui32NumDescs - 1);
00abbc  68a0              LDR      r0,[r4,#8]
00abbe  b110              CBZ      r0,|L1.43974|
00abc0  68a0              LDR      r0,[r4,#8]
00abc2  1e40              SUBS     r0,r0,#1
00abc4  e001              B        |L1.43978|
                  |L1.43974|
00abc6  6860              LDR      r0,[r4,#4]
00abc8  1e40              SUBS     r0,r0,#1
                  |L1.43978|
00abca  4680              MOV      r8,r0
;;;754    
;;;755      /* Step through the descriptors that are marked for CPU attention. */
;;;756      while(pDescList->ui32Read != ui32DescEnd)
00abcc  e0f8              B        |L1.44480|
                  |L1.43982|
;;;757      {
;;;758          /* Does the current descriptor have a buffer attached to it? */
;;;759          if(pDescList->pDescriptors[pDescList->ui32Read].pBuf)
00abce  68a1              LDR      r1,[r4,#8]
00abd0  eb0101c1          ADD      r1,r1,r1,LSL #3
00abd4  6820              LDR      r0,[r4,#0]
00abd6  eb000081          ADD      r0,r0,r1,LSL #2
00abda  6a00              LDR      r0,[r0,#0x20]
00abdc  2800              CMP      r0,#0
00abde  d067              BEQ      |L1.44208|
;;;760          {
;;;761              /* Yes - determine if the host has filled it yet. */
;;;762              if(pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
00abe0  68a1              LDR      r1,[r4,#8]
00abe2  eb0101c1          ADD      r1,r1,r1,LSL #3
00abe6  6820              LDR      r0,[r4,#0]
00abe8  f8500021          LDR      r0,[r0,r1,LSL #2]
00abec  f0104f00          TST      r0,#0x80000000
00abf0  d000              BEQ      |L1.44020|
;;;763                 DES0_RX_CTRL_OWN)
;;;764              {
;;;765                  /* The DMA engine still owns the descriptor so we are finished */
;;;766                  break;
00abf2  e0e9              B        |L1.44488|
                  |L1.44020|
;;;767              }
;;;768    
;;;769              DRIVER_STATS_INC(RXBufReadCount);
;;;770    
;;;771              /* If this descriptor contains the end of the packet, fix up the
;;;772               * buffer size accordingly.
;;;773               */
;;;774              if(pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
00abf4  68a1              LDR      r1,[r4,#8]
00abf6  eb0101c1          ADD      r1,r1,r1,LSL #3
00abfa  6820              LDR      r0,[r4,#0]
00abfc  f8300021          LDRH     r0,[r0,r1,LSL #2]
00ac00  f4107f80          TST      r0,#0x100
00ac04  d01f              BEQ      |L1.44102|
;;;775                 DES0_RX_STAT_LAST_DESC)
;;;776              {
;;;777                  /* This is the last descriptor for the frame so fix up the
;;;778                   * length.  It is safe for us to modify the internal fields
;;;779                   * directly here (rather than calling pbuf_realloc) since we
;;;780                   * know each of these pbufs is never chained.
;;;781                   */
;;;782                  pDescList->pDescriptors[pDescList->ui32Read].pBuf->len =
00ac06  68a1              LDR      r1,[r4,#8]
00ac08  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac0c  6820              LDR      r0,[r4,#0]
00ac0e  f8500021          LDR      r0,[r0,r1,LSL #2]
00ac12  f3c0400d          UBFX     r0,r0,#16,#14
00ac16  68a2              LDR      r2,[r4,#8]
00ac18  eb0202c2          ADD      r2,r2,r2,LSL #3
00ac1c  6821              LDR      r1,[r4,#0]
00ac1e  eb010182          ADD      r1,r1,r2,LSL #2
00ac22  6a09              LDR      r1,[r1,#0x20]
00ac24  8148              STRH     r0,[r1,#0xa]
;;;783                           (pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
;;;784                            DES0_RX_STAT_FRAME_LENGTH_M) >>
;;;785                            DES0_RX_STAT_FRAME_LENGTH_S;
;;;786                  pDescList->pDescriptors[pDescList->ui32Read].pBuf->tot_len =
00ac26  68a1              LDR      r1,[r4,#8]
00ac28  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac2c  6820              LDR      r0,[r4,#0]
00ac2e  eb000081          ADD      r0,r0,r1,LSL #2
00ac32  6a00              LDR      r0,[r0,#0x20]
00ac34  8940              LDRH     r0,[r0,#0xa]
00ac36  68a2              LDR      r2,[r4,#8]
00ac38  eb0202c2          ADD      r2,r2,r2,LSL #3
00ac3c  6821              LDR      r1,[r4,#0]
00ac3e  eb010182          ADD      r1,r1,r2,LSL #2
00ac42  6a09              LDR      r1,[r1,#0x20]
00ac44  8108              STRH     r0,[r1,#8]
                  |L1.44102|
;;;787                            pDescList->pDescriptors[pDescList->ui32Read].pBuf->len;
;;;788              }
;;;789    
;;;790              if(pBuf)
00ac46  b186              CBZ      r6,|L1.44138|
;;;791              {
;;;792                  /* Link this pbuf to the last one we looked at since this buffer
;;;793                   * is a continuation of an existing frame (split across mui32tiple
;;;794                   * pbufs).  Note that we use pbuf_cat() here rather than
;;;795                   * pbuf_chain() since we don't want to increase the reference
;;;796                   * count of either pbuf - we only want to link them together.
;;;797                   */
;;;798                  pbuf_cat(pBuf, pDescList->pDescriptors[pDescList->ui32Read].pBuf);
00ac48  68a2              LDR      r2,[r4,#8]
00ac4a  eb0202c2          ADD      r2,r2,r2,LSL #3
00ac4e  6820              LDR      r0,[r4,#0]
00ac50  eb000082          ADD      r0,r0,r2,LSL #2
00ac54  6a01              LDR      r1,[r0,#0x20]
00ac56  4630              MOV      r0,r6
00ac58  f7fffffe          BL       pbuf_cat
;;;799                  pDescList->pDescriptors[pDescList->ui32Read].pBuf = pBuf;
00ac5c  68a1              LDR      r1,[r4,#8]
00ac5e  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac62  6820              LDR      r0,[r4,#0]
00ac64  eb000081          ADD      r0,r0,r1,LSL #2
00ac68  6206              STR      r6,[r0,#0x20]
                  |L1.44138|
;;;800              }
;;;801    
;;;802              /* Remember the buffer associated with this descriptor. */
;;;803              pBuf = pDescList->pDescriptors[pDescList->ui32Read].pBuf;
00ac6a  68a1              LDR      r1,[r4,#8]
00ac6c  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac70  6820              LDR      r0,[r4,#0]
00ac72  eb000081          ADD      r0,r0,r1,LSL #2
00ac76  6a06              LDR      r6,[r0,#0x20]
;;;804    
;;;805              /* Is this the last descriptor for the current frame? */
;;;806              if(pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
00ac78  68a1              LDR      r1,[r4,#8]
00ac7a  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac7e  6820              LDR      r0,[r4,#0]
00ac80  f8300021          LDRH     r0,[r0,r1,LSL #2]
00ac84  f4107f80          TST      r0,#0x100
00ac88  d02c              BEQ      |L1.44260|
;;;807                 DES0_RX_STAT_LAST_DESC)
;;;808              {
;;;809                  /* Yes - does the frame contain errors? */
;;;810                  if(pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus &
00ac8a  68a1              LDR      r1,[r4,#8]
00ac8c  eb0101c1          ADD      r1,r1,r1,LSL #3
00ac90  6820              LDR      r0,[r4,#0]
00ac92  f8300021          LDRH     r0,[r0,r1,LSL #2]
00ac96  f4104f00          TST      r0,#0x8000
00ac9a  d00a              BEQ      |L1.44210|
;;;811                     DES0_RX_STAT_ERR)
;;;812                  {
;;;813                      /* This is a bad frame so discard it and update the relevant
;;;814                       * statistics.
;;;815                       */
;;;816                      LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_receive: packet error\n"));
00ac9c  bf00              NOP      
00ac9e  bf00              NOP      
;;;817                      pbuf_free(pBuf);
00aca0  4630              MOV      r0,r6
00aca2  f7fffffe          BL       pbuf_free
;;;818                      LINK_STATS_INC(link.drop);
00aca6  4834              LDR      r0,|L1.44408|
00aca8  88c0              LDRH     r0,[r0,#6]  ; lwip_stats
00acaa  1c40              ADDS     r0,r0,#1
00acac  4932              LDR      r1,|L1.44408|
00acae  80c8              STRH     r0,[r1,#6]
                  |L1.44208|
00acb0  e018              B        |L1.44260|
                  |L1.44210|
;;;819                      DRIVER_STATS_INC(RXPacketErrCount);
;;;820                  }
;;;821                  else
;;;822                  {
;;;823                      /* This is a good frame so pass it up the stack. */
;;;824                      LINK_STATS_INC(link.recv);
00acb2  4831              LDR      r0,|L1.44408|
00acb4  8840              LDRH     r0,[r0,#2]  ; lwip_stats
00acb6  1c40              ADDS     r0,r0,#1
00acb8  492f              LDR      r1,|L1.44408|
00acba  8048              STRH     r0,[r1,#2]
;;;825                      DRIVER_STATS_INC(RXPacketReadCount);
;;;826    
;;;827    #if LWIP_PTPD
;;;828                      /* Place the timestamp in the PBUF if PTPD is enabled */
;;;829                      pBuf->time_s =
;;;830                           pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32IEEE1588TimeHi;
;;;831                      pBuf->time_ns =
;;;832                           pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32IEEE1588TimeLo;
;;;833    #endif
;;;834    
;;;835    #if NO_SYS
;;;836                      if(ethernet_input(pBuf, psNetif) != ERR_OK)
;;;837                      {
;;;838    #else
;;;839                      if(tcpip_input(pBuf, psNetif) != ERR_OK)
00acbc  4629              MOV      r1,r5
00acbe  4630              MOV      r0,r6
00acc0  f7fffffe          BL       tcpip_input
00acc4  b168              CBZ      r0,|L1.44258|
;;;840                      {
;;;841    #endif
;;;842                          /* drop the packet */
;;;843                          LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_input: input error\n"));
00acc6  bf00              NOP      
00acc8  bf00              NOP      
;;;844                          pbuf_free(pBuf);
00acca  4630              MOV      r0,r6
00accc  f7fffffe          BL       pbuf_free
;;;845    
;;;846                          /* Adjust the link statistics */
;;;847                          LINK_STATS_INC(link.memerr);
00acd0  4829              LDR      r0,|L1.44408|
00acd2  8980              LDRH     r0,[r0,#0xc]  ; lwip_stats
00acd4  1c40              ADDS     r0,r0,#1
00acd6  4928              LDR      r1,|L1.44408|
00acd8  8188              STRH     r0,[r1,#0xc]
;;;848                          LINK_STATS_INC(link.drop);
00acda  4608              MOV      r0,r1
00acdc  88c0              LDRH     r0,[r0,#6]  ; lwip_stats
00acde  1c40              ADDS     r0,r0,#1
00ace0  80c8              STRH     r0,[r1,#6]
                  |L1.44258|
;;;849                          DRIVER_STATS_INC(RXPacketCBErrCount);
;;;850                      }
;;;851    
;;;852                      /* We're finished with this packet so make sure we don't try
;;;853                       * to link the next buffer to it.
;;;854                       */
;;;855                      pBuf = NULL;
00ace2  2600              MOVS     r6,#0
                  |L1.44260|
;;;856                  }
;;;857              }
;;;858          }
;;;859    
;;;860          /* Allocate a new buffer for this descriptor */
;;;861          pDescList->pDescriptors[pDescList->ui32Read].pBuf = pbuf_alloc(PBUF_RAW,
00ace4  2203              MOVS     r2,#3
00ace6  f44f7100          MOV      r1,#0x200
00acea  4610              MOV      r0,r2
00acec  f7fffffe          BL       pbuf_alloc
00acf0  68a2              LDR      r2,[r4,#8]
00acf2  eb0202c2          ADD      r2,r2,r2,LSL #3
00acf6  6821              LDR      r1,[r4,#0]
00acf8  eb010182          ADD      r1,r1,r2,LSL #2
00acfc  6208              STR      r0,[r1,#0x20]
;;;862                                                            PBUF_POOL_BUFSIZE,
;;;863                                                            PBUF_POOL);
;;;864          pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32Count =
00acfe  f44f4080          MOV      r0,#0x4000
00ad02  68a2              LDR      r2,[r4,#8]
00ad04  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad08  6821              LDR      r1,[r4,#0]
00ad0a  eb010182          ADD      r1,r1,r2,LSL #2
00ad0e  6048              STR      r0,[r1,#4]
;;;865                                                            DES1_RX_CTRL_CHAINED;
;;;866          if(pDescList->pDescriptors[pDescList->ui32Read].pBuf)
00ad10  68a1              LDR      r1,[r4,#8]
00ad12  eb0101c1          ADD      r1,r1,r1,LSL #3
00ad16  6820              LDR      r0,[r4,#0]
00ad18  eb000081          ADD      r0,r0,r1,LSL #2
00ad1c  6a00              LDR      r0,[r0,#0x20]
00ad1e  b330              CBZ      r0,|L1.44398|
;;;867          {
;;;868              /* We got a buffer so fill in the payload pointer and size. */
;;;869              pDescList->pDescriptors[pDescList->ui32Read].Desc.pvBuffer1 =
00ad20  68a1              LDR      r1,[r4,#8]
00ad22  eb0101c1          ADD      r1,r1,r1,LSL #3
00ad26  6820              LDR      r0,[r4,#0]
00ad28  eb000081          ADD      r0,r0,r1,LSL #2
00ad2c  6a00              LDR      r0,[r0,#0x20]
00ad2e  6840              LDR      r0,[r0,#4]
00ad30  68a2              LDR      r2,[r4,#8]
00ad32  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad36  6821              LDR      r1,[r4,#0]
00ad38  eb010182          ADD      r1,r1,r2,LSL #2
00ad3c  6088              STR      r0,[r1,#8]
;;;870                                  pDescList->pDescriptors[pDescList->ui32Read].pBuf->payload;
;;;871              pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32Count |=
00ad3e  68a1              LDR      r1,[r4,#8]
00ad40  eb0101c1          ADD      r1,r1,r1,LSL #3
00ad44  6820              LDR      r0,[r4,#0]
00ad46  eb000081          ADD      r0,r0,r1,LSL #2
00ad4a  6840              LDR      r0,[r0,#4]
00ad4c  68a2              LDR      r2,[r4,#8]
00ad4e  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad52  6821              LDR      r1,[r4,#0]
00ad54  eb010182          ADD      r1,r1,r2,LSL #2
00ad58  6a09              LDR      r1,[r1,#0x20]
00ad5a  8949              LDRH     r1,[r1,#0xa]
00ad5c  4308              ORRS     r0,r0,r1
00ad5e  68a2              LDR      r2,[r4,#8]
00ad60  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad64  6821              LDR      r1,[r4,#0]
00ad66  eb010182          ADD      r1,r1,r2,LSL #2
00ad6a  6048              STR      r0,[r1,#4]
;;;872                                  (pDescList->pDescriptors[pDescList->ui32Read].pBuf->len <<
;;;873                                   DES1_RX_CTRL_BUFF1_SIZE_S);
;;;874    
;;;875              /* Give this descriptor back to the hardware */
;;;876              pDescList->pDescriptors[pDescList->ui32Read].Desc.ui32CtrlStatus =
00ad6c  e006              B        |L1.44412|
                  |L1.44398|
00ad6e  e00e              B        |L1.44430|
                  |L1.44400|
                          DCD      0x400ec000
                  |L1.44404|
                          DCD      0x20070000
                  |L1.44408|
                          DCD      lwip_stats
                  |L1.44412|
00ad7c  f04f4000          MOV      r0,#0x80000000
00ad80  68a2              LDR      r2,[r4,#8]
00ad82  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad86  6821              LDR      r1,[r4,#0]
00ad88  f8410022          STR      r0,[r1,r2,LSL #2]
00ad8c  e00f              B        |L1.44462|
                  |L1.44430|
;;;877                                  DES0_RX_CTRL_OWN;
;;;878          }
;;;879          else
;;;880          {
;;;881              LWIP_DEBUGF(NETIF_DEBUG, ("tivaif_receive: pbuf_alloc error\n"));
00ad8e  bf00              NOP      
00ad90  bf00              NOP      
;;;882    
;;;883              pDescList->pDescriptors[pDescList->ui32Read].Desc.pvBuffer1 = 0;
00ad92  2000              MOVS     r0,#0
00ad94  68a2              LDR      r2,[r4,#8]
00ad96  eb0202c2          ADD      r2,r2,r2,LSL #3
00ad9a  6821              LDR      r1,[r4,#0]
00ad9c  eb010182          ADD      r1,r1,r2,LSL #2
00ada0  6088              STR      r0,[r1,#8]
;;;884    
;;;885              /* Update the stats to show we coui32dn't allocate a pbuf. */
;;;886              DRIVER_STATS_INC(RXNoBufCount);
;;;887              LINK_STATS_INC(link.memerr);
00ada2  48fe              LDR      r0,|L1.45468|
00ada4  8980              LDRH     r0,[r0,#0xc]  ; lwip_stats
00ada6  1c40              ADDS     r0,r0,#1
00ada8  49fc              LDR      r1,|L1.45468|
00adaa  8188              STRH     r0,[r1,#0xc]
;;;888    
;;;889              /* Stop parsing here since we can't leave a broken descriptor in
;;;890               * the chain.
;;;891               */
;;;892              break;
00adac  e00c              B        |L1.44488|
                  |L1.44462|
;;;893          }
;;;894    
;;;895    		
;;;896          /* Move on to the next descriptor in the chain, taking care to wrap. */
;;;897          pDescList->ui32Read++;
00adae  68a0              LDR      r0,[r4,#8]
00adb0  1c40              ADDS     r0,r0,#1
00adb2  60a0              STR      r0,[r4,#8]
;;;898          if(pDescList->ui32Read == pDescList->ui32NumDescs)
00adb4  e9d41001          LDRD     r1,r0,[r4,#4]
00adb8  4288              CMP      r0,r1
00adba  d101              BNE      |L1.44480|
;;;899          {
;;;900              pDescList->ui32Read = 0;
00adbc  2000              MOVS     r0,#0
00adbe  60a0              STR      r0,[r4,#8]
                  |L1.44480|
00adc0  68a0              LDR      r0,[r4,#8]            ;756
00adc2  4540              CMP      r0,r8                 ;756
00adc4  f47faf03          BNE      |L1.43982|
                  |L1.44488|
00adc8  bf00              NOP                            ;766
;;;901          }
;;;902      }
;;;903    }
00adca  e8bd81f0          POP      {r4-r8,pc}
;;;904    
                          ENDP

                  tivaif_init PROC
;;;917    err_t
;;;918    tivaif_init(struct netif *psNetif)
00adce  b510              PUSH     {r4,lr}
;;;919    {
00add0  4604              MOV      r4,r0
;;;920      LWIP_ASSERT("psNetif != NULL", (psNetif != NULL));
00add2  bf00              NOP      
00add4  bf00              NOP      
;;;921    
;;;922    #if LWIP_NETIF_HOSTNAME
;;;923      /* Initialize interface hostname */
;;;924      psNetif->hostname = "lwip";
;;;925    #endif /* LWIP_NETIF_HOSTNAME */
;;;926    
;;;927      /*
;;;928       * Initialize the snmp variables and counters inside the struct netif.
;;;929       * The last argument should be replaced with your link speed, in units
;;;930       * of bits per second.
;;;931       */
;;;932      NETIF_INIT_SNMP(psNetif, snmp_ifType_ethernet_csmacd, 1000000);
;;;933    
;;;934      psNetif->state = &g_StellarisIFData;
00add6  48f2              LDR      r0,|L1.45472|
00add8  61e0              STR      r0,[r4,#0x1c]
;;;935      psNetif->name[0] = IFNAME0;
00adda  2074              MOVS     r0,#0x74
00addc  f8840032          STRB     r0,[r4,#0x32]
;;;936      psNetif->name[1] = IFNAME1;
00ade0  2169              MOVS     r1,#0x69
00ade2  2033              MOVS     r0,#0x33
00ade4  5501              STRB     r1,[r0,r4]
;;;937      /* We directly use etharp_output() here to save a function call.
;;;938       * You can instead declare your own function an call etharp_output()
;;;939       * from it if you have to do some checks before sending (e.g. if link
;;;940       * is available...) */
;;;941      psNetif->output = etharp_output;
00ade6  f2af70fd          ADR      r0,etharp_output + 1
00adea  6160              STR      r0,[r4,#0x14]
;;;942      psNetif->linkoutput = tivaif_transmit;
00adec  48ed              LDR      r0,|L1.45476|
00adee  61a0              STR      r0,[r4,#0x18]
;;;943    
;;;944      /* Remember our MAC address. */
;;;945      g_StellarisIFData.ethaddr = (struct eth_addr *)&(psNetif->hwaddr[0]);
00adf0  f104002b          ADD      r0,r4,#0x2b
00adf4  49ea              LDR      r1,|L1.45472|
00adf6  6008              STR      r0,[r1,#0]  ; g_StellarisIFData
;;;946    
;;;947      /* Initialize the hardware */
;;;948      tivaif_hwinit(psNetif);
00adf8  4620              MOV      r0,r4
00adfa  f7fffffe          BL       tivaif_hwinit
;;;949    
;;;950      return ERR_OK;
00adfe  2000              MOVS     r0,#0
;;;951    }
00ae00  bd10              POP      {r4,pc}
;;;952    
                          ENDP

                  tivaif_process_phy_interrupt PROC
;;;963    void
;;;964    tivaif_process_phy_interrupt(struct netif *psNetif)
00ae02  b5fe              PUSH     {r1-r7,lr}
;;;965    {
00ae04  4605              MOV      r5,r0
;;;966        uint16_t ui16Val, ui16Status;
;;;967        uint32_t ui32Config, ui32Mode, ui32RxMaxFrameSize;
;;;968    
;;;969        /* Read the PHY interrupt status.  This clears all interrupt sources.
;;;970         * Note that we are only enabling sources in EPHY_MISR1 so we don't
;;;971         * read EPHY_MISR2.
;;;972         */
;;;973        ui16Val = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_MISR1);
00ae06  2212              MOVS     r2,#0x12
00ae08  2100              MOVS     r1,#0
00ae0a  48e7              LDR      r0,|L1.45480|
00ae0c  f7fffffe          BL       EMACPHYRead
00ae10  4606              MOV      r6,r0
;;;974    
;;;975        /* Read the current PHY status. */
;;;976        ui16Status = EMACPHYRead(EMAC0_BASE, PHY_PHYS_ADDR, EPHY_STS);
00ae12  2210              MOVS     r2,#0x10
00ae14  2100              MOVS     r1,#0
00ae16  48e4              LDR      r0,|L1.45480|
00ae18  f7fffffe          BL       EMACPHYRead
00ae1c  4604              MOV      r4,r0
;;;977    
;;;978        /* Has the link status changed? */
;;;979        if(ui16Val & EPHY_MISR1_LINKSTAT)
00ae1e  f4165f00          TST      r6,#0x2000
00ae22  d00f              BEQ      |L1.44612|
;;;980        {
;;;981            /* Is link up or down now? */
;;;982            if(ui16Status & EPHY_STS_LINK)
00ae24  f0140f01          TST      r4,#1
00ae28  d006              BEQ      |L1.44600|
;;;983            {
;;;984                /* Tell lwIP the link is up. */
;;;985    #if NO_SYS
;;;986                netif_set_link_up(psNetif);
;;;987    #else
;;;988                tcpip_callback((tcpip_callback_fn)netif_set_link_up, psNetif);
00ae2a  2201              MOVS     r2,#1
00ae2c  4629              MOV      r1,r5
00ae2e  f6af70c5          ADR      r0,netif_set_link_up + 1
00ae32  f7fffffe          BL       tcpip_callback_with_block
00ae36  e005              B        |L1.44612|
                  |L1.44600|
;;;989    #endif
;;;990    
;;;991                /* In this case we drop through since we may need to reconfigure
;;;992                 * the MAC depending upon the speed and half/fui32l-duplex settings.
;;;993                 */
;;;994            }
;;;995            else
;;;996            {
;;;997                /* Tell lwIP the link is down */
;;;998    #if NO_SYS
;;;999                netif_set_link_down(psNetif);
;;;1000   #else
;;;1001               tcpip_callback((tcpip_callback_fn)netif_set_link_down, psNetif);
00ae38  2201              MOVS     r2,#1
00ae3a  4629              MOV      r1,r5
00ae3c  f6af7079          ADR      r0,netif_set_link_down + 1
00ae40  f7fffffe          BL       tcpip_callback_with_block
                  |L1.44612|
;;;1002   #endif
;;;1003           }
;;;1004       }
;;;1005   
;;;1006       /* Has the speed or duplex status changed? */
;;;1007       if(ui16Val & (EPHY_MISR1_SPEED | EPHY_MISR1_SPEED | EPHY_MISR1_ANC))
00ae44  f4165fa0          TST      r6,#0x1400
00ae48  d023              BEQ      |L1.44690|
;;;1008       {
;;;1009           /* Get the current MAC configuration. */
;;;1010           EMACConfigGet(EMAC0_BASE, &ui32Config, &ui32Mode,
00ae4a  466b              MOV      r3,sp
00ae4c  aa01              ADD      r2,sp,#4
00ae4e  a902              ADD      r1,sp,#8
00ae50  48d5              LDR      r0,|L1.45480|
00ae52  f7fffffe          BL       EMACConfigGet
;;;1011                           &ui32RxMaxFrameSize);
;;;1012   
;;;1013           /* What speed is the interface running at now?
;;;1014            */
;;;1015           if(ui16Status & EPHY_STS_SPEED)
00ae56  f0140f02          TST      r4,#2
00ae5a  d004              BEQ      |L1.44646|
;;;1016           {
;;;1017               /* 10Mbps is selected */
;;;1018               ui32Config &= ~EMAC_CONFIG_100MBPS;
00ae5c  9802              LDR      r0,[sp,#8]
00ae5e  f4204080          BIC      r0,r0,#0x4000
00ae62  9002              STR      r0,[sp,#8]
00ae64  e003              B        |L1.44654|
                  |L1.44646|
;;;1019           }
;;;1020           else
;;;1021           {
;;;1022               /* 100Mbps is selected */
;;;1023               ui32Config |= EMAC_CONFIG_100MBPS;
00ae66  9802              LDR      r0,[sp,#8]
00ae68  f4404080          ORR      r0,r0,#0x4000
00ae6c  9002              STR      r0,[sp,#8]
                  |L1.44654|
;;;1024           }
;;;1025   
;;;1026           /* Are we in fui32l- or half-duplex mode? */
;;;1027           if(ui16Status & EPHY_STS_DUPLEX)
00ae6e  f0140f04          TST      r4,#4
00ae72  d004              BEQ      |L1.44670|
;;;1028           {
;;;1029               /* Fui32l duplex. */
;;;1030               ui32Config |= EMAC_CONFIG_FULL_DUPLEX;
00ae74  9802              LDR      r0,[sp,#8]
00ae76  f4406000          ORR      r0,r0,#0x800
00ae7a  9002              STR      r0,[sp,#8]
00ae7c  e003              B        |L1.44678|
                  |L1.44670|
;;;1031           }
;;;1032           else
;;;1033           {
;;;1034               /* Half duplex. */
;;;1035               ui32Config &= ~EMAC_CONFIG_FULL_DUPLEX;
00ae7e  9802              LDR      r0,[sp,#8]
00ae80  f4206000          BIC      r0,r0,#0x800
00ae84  9002              STR      r0,[sp,#8]
                  |L1.44678|
;;;1036           }
;;;1037   
;;;1038           /* Reconfigure the MAC */
;;;1039           EMACConfigSet(EMAC0_BASE, ui32Config, ui32Mode, ui32RxMaxFrameSize);
00ae86  48c8              LDR      r0,|L1.45480|
00ae88  e9dd3200          LDRD     r3,r2,[sp,#0]
00ae8c  9902              LDR      r1,[sp,#8]
00ae8e  f7fffffe          BL       EMACConfigSet
                  |L1.44690|
;;;1040       }
;;;1041   }
00ae92  bdfe              POP      {r1-r7,pc}
;;;1042   
                          ENDP

                  tivaif_interrupt PROC
;;;1053   void
;;;1054   tivaif_interrupt(struct netif *psNetif, uint32_t ui32Status)
00ae94  b570              PUSH     {r4-r6,lr}
;;;1055   {
00ae96  4605              MOV      r5,r0
00ae98  460c              MOV      r4,r1
;;;1056     tStellarisIF *tivaif;
;;;1057   
;;;1058     /* setup pointer to the if state data */
;;;1059     tivaif = psNetif->state;
00ae9a  69ee              LDR      r6,[r5,#0x1c]
;;;1060   
;;;1061     /* Update our debug interrupt counters. */
;;;1062     if(ui32Status & EMAC_INT_NORMAL_INT)
00ae9c  f4143f80          TST      r4,#0x10000
00aea0  d004              BEQ      |L1.44716|
;;;1063     {
;;;1064         g_ui32NormalInts++;
00aea2  48c2              LDR      r0,|L1.45484|
00aea4  6800              LDR      r0,[r0,#0]  ; g_ui32NormalInts
00aea6  1c40              ADDS     r0,r0,#1
00aea8  49c0              LDR      r1,|L1.45484|
00aeaa  6008              STR      r0,[r1,#0]  ; g_ui32NormalInts
                  |L1.44716|
;;;1065     }
;;;1066   
;;;1067     if(ui32Status & EMAC_INT_ABNORMAL_INT)
00aeac  f4144f00          TST      r4,#0x8000
00aeb0  d004              BEQ      |L1.44732|
;;;1068     {
;;;1069         g_ui32AbnormalInts++;
00aeb2  48bf              LDR      r0,|L1.45488|
00aeb4  6800              LDR      r0,[r0,#0]  ; g_ui32AbnormalInts
00aeb6  1c40              ADDS     r0,r0,#1
00aeb8  49bd              LDR      r1,|L1.45488|
00aeba  6008              STR      r0,[r1,#0]  ; g_ui32AbnormalInts
                  |L1.44732|
;;;1070     }
;;;1071   
;;;1072     /* Is this an interrupt from the PHY? */
;;;1073     if(ui32Status & EMAC_INT_PHY)
00aebc  f0144f00          TST      r4,#0x80000000
00aec0  d002              BEQ      |L1.44744|
;;;1074     {
;;;1075         tivaif_process_phy_interrupt(psNetif);
00aec2  4628              MOV      r0,r5
00aec4  f7fffffe          BL       tivaif_process_phy_interrupt
                  |L1.44744|
;;;1076     }
;;;1077   
;;;1078     /* Process the transmit DMA list, freeing any buffers that have been
;;;1079      * transmitted since our last interrupt.
;;;1080      */
;;;1081     if(ui32Status & EMAC_INT_TRANSMIT)
00aec8  f0140f01          TST      r4,#1
00aecc  d002              BEQ      |L1.44756|
;;;1082     {
;;;1083         tivaif_process_transmit(tivaif);
00aece  4630              MOV      r0,r6
00aed0  f7fffffe          BL       tivaif_process_transmit
                  |L1.44756|
;;;1084     }
;;;1085   
;;;1086     /**
;;;1087      * Process the receive DMA list and pass all successfui32ly received packets
;;;1088      * up the stack.  We also call this function in cases where the receiver has
;;;1089      * stalled due to missing buffers since the receive function will attempt to
;;;1090      * allocate new pbufs for descriptor entries which have none.
;;;1091      */
;;;1092     if(ui32Status & (EMAC_INT_RECEIVE | EMAC_INT_RX_NO_BUFFER |
00aed4  f4147fe0          TST      r4,#0x1c0
00aed8  d002              BEQ      |L1.44768|
;;;1093        EMAC_INT_RX_STOPPED))
;;;1094     {
;;;1095         tivaif_receive(psNetif);
00aeda  4628              MOV      r0,r5
00aedc  f7fffffe          BL       tivaif_receive
                  |L1.44768|
;;;1096     }
;;;1097   }
00aee0  bd70              POP      {r4-r6,pc}
;;;1098   
                          ENDP

                  lwIPInterruptTask PROC
;;;418    static void
;;;419    lwIPInterruptTask(void *pvArg)
00aee2  b501              PUSH     {r0,lr}
;;;420    {
;;;421        //
;;;422        // Loop forever.
;;;423        //
;;;424        while(1)
00aee4  e011              B        |L1.44810|
                  |L1.44774|
;;;425        {
;;;426            //
;;;427            // Wait until the semaphore has been signaled.
;;;428            //
;;;429            while(xQueueReceive(g_pInterrupt, &pvArg, portMAX_DELAY) != pdPASS)
00aee6  bf00              NOP      
                  |L1.44776|
00aee8  2300              MOVS     r3,#0
00aeea  1e5a              SUBS     r2,r3,#1
00aeec  4669              MOV      r1,sp
00aeee  48b1              LDR      r0,|L1.45492|
00aef0  6800              LDR      r0,[r0,#0]  ; g_pInterrupt
00aef2  f7fffffe          BL       xQueueGenericReceive
00aef6  2801              CMP      r0,#1
00aef8  d1f6              BNE      |L1.44776|
;;;430            {
;;;431            }
;;;432    
;;;433    				//s_printf("will call tivaif_interrupt\r\n");
;;;434    				
;;;435            //
;;;436            // Processes any packets waiting to be sent or received.
;;;437            //
;;;438            tivaif_interrupt(&g_sNetIF, (uint32_t)pvArg);
00aefa  48af              LDR      r0,|L1.45496|
00aefc  9900              LDR      r1,[sp,#0]
00aefe  f7fffffe          BL       tivaif_interrupt
;;;439    
;;;440            //
;;;441            // Re-enable the Ethernet interrupts.
;;;442            //
;;;443            EMACIntEnable(EMAC0_BASE, (EMAC_INT_RECEIVE | EMAC_INT_TRANSMIT |
00af02  49ae              LDR      r1,|L1.45500|
00af04  48a8              LDR      r0,|L1.45480|
00af06  f7fffffe          BL       EMACIntEnable
                  |L1.44810|
00af0a  e7ec              B        |L1.44774|
;;;444                                           EMAC_INT_TX_STOPPED |
;;;445                                           EMAC_INT_RX_NO_BUFFER |
;;;446                                           EMAC_INT_RX_STOPPED | EMAC_INT_PHY));
;;;447        }
;;;448    }
;;;449    #endif
                          ENDP

                  lwIPLinkDetect PROC
;;;458    static void
;;;459    lwIPLinkDetect(void)
00af0c  b53e              PUSH     {r1-r5,lr}
;;;460    {
;;;461        bool bHaveLink;
;;;462        struct ip_addr ip_addr;
;;;463        struct ip_addr net_mask;
;;;464        struct ip_addr gw_addr;
;;;465    
;;;466        //
;;;467        // See if there is an active link.
;;;468        //
;;;469        bHaveLink = MAP_EMACPHYRead(EMAC0_BASE, 0, EPHY_BMSR) & EPHY_BMSR_LINKSTAT;
00af0e  f04f7080          MOV      r0,#0x1000000
00af12  f8d000b8          LDR      r0,[r0,#0xb8]
00af16  2201              MOVS     r2,#1
00af18  2100              MOVS     r1,#0
00af1a  6bc3              LDR      r3,[r0,#0x3c]
00af1c  48a2              LDR      r0,|L1.45480|
00af1e  4798              BLX      r3
00af20  f3c00480          UBFX     r4,r0,#2,#1
;;;470    
;;;471        //
;;;472        // Return without doing anything else if the link state hasn't changed.
;;;473        //
;;;474        if(bHaveLink == g_bLinkActive)
00af24  48a6              LDR      r0,|L1.45504|
00af26  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00af28  4284              CMP      r4,r0
00af2a  d100              BNE      |L1.44846|
                  |L1.44844|
;;;475        {
;;;476            return;
;;;477        }
;;;478    
;;;479        //
;;;480        // Save the new link state.
;;;481        //
;;;482        g_bLinkActive = bHaveLink;
;;;483    		
;;;484    		
;;;485    		/*when in static ip mode, no need do the below handler*/
;;;486    		if(g_ui32IPMode == IPADDR_USE_STATIC){
;;;487    			return;
;;;488    		}
;;;489    
;;;490        //
;;;491        // Clear any address information from the network interface.
;;;492        //
;;;493        ip_addr.addr = 0;
;;;494        net_mask.addr = 0;
;;;495        gw_addr.addr = 0;
;;;496        netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
;;;497    
;;;498        //
;;;499        // See if there is a link now.
;;;500        //
;;;501        if(bHaveLink)
;;;502        {
;;;503            //
;;;504            // Start DHCP, if enabled.
;;;505            //
;;;506    #if LWIP_DHCP
;;;507            if(g_ui32IPMode == IPADDR_USE_DHCP)
;;;508            {
;;;509                dhcp_start(&g_sNetIF);
;;;510            }
;;;511    #endif
;;;512    
;;;513            //
;;;514            // Start AutoIP, if enabled and DHCP is not.
;;;515            //
;;;516    #if LWIP_AUTOIP
;;;517            if(g_ui32IPMode == IPADDR_USE_AUTOIP)
;;;518            {
;;;519                autoip_start(&g_sNetIF);
;;;520            }
;;;521    #endif
;;;522        }
;;;523        else
;;;524        {
;;;525            //
;;;526            // Stop DHCP, if enabled.
;;;527            //
;;;528    #if LWIP_DHCP
;;;529            if(g_ui32IPMode == IPADDR_USE_DHCP)
;;;530            {
;;;531                dhcp_stop(&g_sNetIF);
;;;532            }
;;;533    #endif
;;;534    
;;;535            //
;;;536            // Stop AutoIP, if enabled and DHCP is not.
;;;537            //
;;;538    #if LWIP_AUTOIP
;;;539            if(g_ui32IPMode == IPADDR_USE_AUTOIP)
;;;540            {
;;;541                autoip_stop(&g_sNetIF);
;;;542            }
;;;543    #endif
;;;544        }
;;;545    }
00af2c  bd3e              POP      {r1-r5,pc}
                  |L1.44846|
00af2e  48a4              LDR      r0,|L1.45504|
00af30  7004              STRB     r4,[r0,#0]            ;482
00af32  48a4              LDR      r0,|L1.45508|
00af34  6800              LDR      r0,[r0,#0]            ;486  ; g_ui32IPMode
00af36  b900              CBNZ     r0,|L1.44858|
00af38  e7f8              B        |L1.44844|
                  |L1.44858|
00af3a  2000              MOVS     r0,#0                 ;493
00af3c  9002              STR      r0,[sp,#8]            ;493
00af3e  9001              STR      r0,[sp,#4]            ;494
00af40  9000              STR      r0,[sp,#0]            ;495
00af42  466b              MOV      r3,sp                 ;496
00af44  aa01              ADD      r2,sp,#4              ;496
00af46  a902              ADD      r1,sp,#8              ;496
00af48  489b              LDR      r0,|L1.45496|
00af4a  f7fffffe          BL       netif_set_addr
00af4e  b174              CBZ      r4,|L1.44910|
00af50  489c              LDR      r0,|L1.45508|
00af52  6800              LDR      r0,[r0,#0]            ;507  ; g_ui32IPMode
00af54  2801              CMP      r0,#1                 ;507
00af56  d102              BNE      |L1.44894|
00af58  4897              LDR      r0,|L1.45496|
00af5a  f7fffffe          BL       dhcp_start
                  |L1.44894|
00af5e  4899              LDR      r0,|L1.45508|
00af60  6800              LDR      r0,[r0,#0]            ;517  ; g_ui32IPMode
00af62  2802              CMP      r0,#2                 ;517
00af64  d111              BNE      |L1.44938|
00af66  4894              LDR      r0,|L1.45496|
00af68  f7fffffe          BL       autoip_start
00af6c  e00d              B        |L1.44938|
                  |L1.44910|
00af6e  4895              LDR      r0,|L1.45508|
00af70  6800              LDR      r0,[r0,#0]            ;529  ; g_ui32IPMode
00af72  2801              CMP      r0,#1                 ;529
00af74  d102              BNE      |L1.44924|
00af76  4890              LDR      r0,|L1.45496|
00af78  f7fffffe          BL       dhcp_stop
                  |L1.44924|
00af7c  4891              LDR      r0,|L1.45508|
00af7e  6800              LDR      r0,[r0,#0]            ;539  ; g_ui32IPMode
00af80  2802              CMP      r0,#2                 ;539
00af82  d102              BNE      |L1.44938|
00af84  488c              LDR      r0,|L1.45496|
00af86  f7fffffe          BL       autoip_stop
                  |L1.44938|
00af8a  bf00              NOP      
00af8c  e7ce              B        |L1.44844|
;;;546    #endif
                          ENDP

                  lwIPPrivateHostTimer PROC
;;;678    static void
;;;679    lwIPPrivateHostTimer(void *pvArg)
00af8e  b510              PUSH     {r4,lr}
;;;680    {
00af90  4604              MOV      r4,r0
;;;681        //
;;;682        // Call the application-supplied host timer callback function.
;;;683        //
;;;684        lwIPHostTimerHandler();
00af92  f7fffffe          BL       lwIPHostTimerHandler
;;;685    
;;;686        //
;;;687        // Re-schedule the host timer callback function timeout.
;;;688        //
;;;689        sys_timeout(HOST_TMR_INTERVAL, lwIPPrivateHostTimer, NULL);
00af96  2200              MOVS     r2,#0
00af98  498b              LDR      r1,|L1.45512|
00af9a  2064              MOVS     r0,#0x64
00af9c  f7fffffe          BL       sys_timeout
;;;690    }
00afa0  bd10              POP      {r4,pc}
;;;691    #endif
                          ENDP

                  lwIPPrivateLinkTimer PROC
;;;699    static void
;;;700    lwIPPrivateLinkTimer(void *pvArg)
00afa2  b510              PUSH     {r4,lr}
;;;701    {
00afa4  4604              MOV      r4,r0
;;;702        //
;;;703        // Perform the link detection.
;;;704        //
;;;705        lwIPLinkDetect();
00afa6  f7fffffe          BL       lwIPLinkDetect
;;;706    
;;;707        //
;;;708        // Re-schedule the link detect timer timeout.
;;;709        //
;;;710        sys_timeout(LINK_TMR_INTERVAL, lwIPPrivateLinkTimer, NULL);
00afaa  2200              MOVS     r2,#0
00afac  4987              LDR      r1,|L1.45516|
00afae  200a              MOVS     r0,#0xa
00afb0  f7fffffe          BL       sys_timeout
;;;711    }
00afb4  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

                  LwIP_DHCP_task PROC
;;;1455   static int static_ip_timeout=0;
;;;1456   void LwIP_DHCP_task(void *arg)
00afb6  e92d41f0          PUSH     {r4-r8,lr}
;;;1457   {
00afba  4604              MOV      r4,r0
;;;1458     static struct ip_addr ip={0};
;;;1459     unsigned char static_ip = arg? true:false;
00afbc  b10c              CBZ      r4,|L1.44994|
00afbe  2001              MOVS     r0,#1
00afc0  e000              B        |L1.44996|
                  |L1.44994|
00afc2  2000              MOVS     r0,#0
                  |L1.44996|
00afc4  4605              MOV      r5,r0
;;;1460     if((!ip_addr_isany(&g_sNetIF.ip_addr)&&
00afc6  487c              LDR      r0,|L1.45496|
00afc8  1d00              ADDS     r0,r0,#4
00afca  b140              CBZ      r0,|L1.45022|
00afcc  1f00              SUBS     r0,r0,#4
00afce  6840              LDR      r0,[r0,#4]  ; g_sNetIF
00afd0  b128              CBZ      r0,|L1.45022|
;;;1461        !ip_addr_cmp(&g_sNetIF.ip_addr,&ip)) || (++static_ip_timeout > 60 && static_ip)){
00afd2  4879              LDR      r0,|L1.45496|
00afd4  6840              LDR      r0,[r0,#4]  ; g_sNetIF
00afd6  497e              LDR      r1,|L1.45520|
00afd8  6809              LDR      r1,[r1,#0]  ; ip
00afda  4288              CMP      r0,r1
00afdc  d108              BNE      |L1.45040|
                  |L1.45022|
00afde  487d              LDR      r0,|L1.45524|
00afe0  6800              LDR      r0,[r0,#0]  ; static_ip_timeout
00afe2  1c40              ADDS     r0,r0,#1
00afe4  497b              LDR      r1,|L1.45524|
00afe6  6008              STR      r0,[r1,#0]  ; static_ip_timeout
00afe8  283c              CMP      r0,#0x3c
00afea  dd3a              BLE      |L1.45154|
00afec  2d00              CMP      r5,#0
00afee  d038              BEQ      |L1.45154|
                  |L1.45040|
;;;1462          if(!static_ip){   
00aff0  b9cd              CBNZ     r5,|L1.45094|
;;;1463            LWIP_DEBUGF(DHCP_DEBUG, ("Lwip dhcp task: static_ip %d\n"));
00aff2  bf00              NOP      
00aff4  bf00              NOP      
;;;1464            ip_addr_set(&ip,&g_sNetIF.ip_addr);
00aff6  4870              LDR      r0,|L1.45496|
00aff8  1d00              ADDS     r0,r0,#4
00affa  b908              CBNZ     r0,|L1.45056|
00affc  2000              MOVS     r0,#0
00affe  e001              B        |L1.45060|
                  |L1.45056|
00b000  486d              LDR      r0,|L1.45496|
00b002  6840              LDR      r0,[r0,#4]  ; g_sNetIF
                  |L1.45060|
00b004  4972              LDR      r1,|L1.45520|
00b006  6008              STR      r0,[r1,#0]  ; ip
;;;1465            SetLocalhost(&g_sNetIF.ip_addr);
00b008  486b              LDR      r0,|L1.45496|
00b00a  1d00              ADDS     r0,r0,#4
00b00c  f7fffffe          BL       SetLocalhost
;;;1466            SetNetMask(&g_sNetIF.netmask);
00b010  4869              LDR      r0,|L1.45496|
00b012  3008              ADDS     r0,r0,#8
00b014  f7fffffe          BL       SetNetMask
;;;1467            SetGateway(&g_sNetIF.gw);
00b018  4867              LDR      r0,|L1.45496|
00b01a  300c              ADDS     r0,r0,#0xc
00b01c  f7fffffe          BL       SetGateway
;;;1468   				 update_ip_menu();
00b020  f7fffffe          BL       update_ip_menu
00b024  e01d              B        |L1.45154|
                  |L1.45094|
;;;1469          }else{
;;;1470            ip_addr_set(&ip,Localhost());
00b026  f7fffffe          BL       Localhost
00b02a  b908              CBNZ     r0,|L1.45104|
00b02c  2000              MOVS     r0,#0
00b02e  e002              B        |L1.45110|
                  |L1.45104|
00b030  f7fffffe          BL       Localhost
00b034  6800              LDR      r0,[r0,#0]
                  |L1.45110|
00b036  4966              LDR      r1,|L1.45520|
00b038  6008              STR      r0,[r1,#0]  ; ip
;;;1471            netif_set_addr(&g_sNetIF, Localhost(),GetNetMask(),GetGateway());
00b03a  f7fffffe          BL       GetGateway
00b03e  4606              MOV      r6,r0
00b040  f7fffffe          BL       GetNetMask
00b044  4607              MOV      r7,r0
00b046  f7fffffe          BL       Localhost
00b04a  4680              MOV      r8,r0
00b04c  4633              MOV      r3,r6
00b04e  463a              MOV      r2,r7
00b050  4641              MOV      r1,r8
00b052  4859              LDR      r0,|L1.45496|
00b054  f7fffffe          BL       netif_set_addr
;;;1472            dhcp_stop(&g_sNetIF);
00b058  4857              LDR      r0,|L1.45496|
00b05a  f7fffffe          BL       dhcp_stop
                  |L1.45150|
;;;1473            return;
;;;1474          }
;;;1475     }
;;;1476     tcpip_timeout(1000, LwIP_DHCP_task, arg); 
;;;1477   }  
00b05e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.45154|
00b062  4622              MOV      r2,r4                 ;1476
00b064  f2af01b1          ADR      r1,LwIP_DHCP_task + 1
00b068  f44f707a          MOV      r0,#0x3e8             ;1476
00b06c  f7fffffe          BL       tcpip_timeout
00b070  bf00              NOP      
00b072  e7f4              B        |L1.45150|
;;;1478   
                          ENDP

                  lwIPPrivateInit PROC
;;;723    static void
;;;724    lwIPPrivateInit(void *pvArg)
00b074  b510              PUSH     {r4,lr}
;;;725    {
00b076  b088              SUB      sp,sp,#0x20
00b078  4604              MOV      r4,r0
;;;726        struct ip_addr ip_addr;
;;;727        struct ip_addr net_mask;
;;;728        struct ip_addr gw_addr;
;;;729    
;;;730    	  s_printf("in lwIPPrivateInit\r\n");
00b07a  a057              ADR      r0,|L1.45528|
00b07c  f7fffffe          BL       s_printf
;;;731    	
;;;732        //
;;;733        // If not using a RTOS, initialize the lwIP stack.
;;;734        //
;;;735    #if NO_SYS
;;;736        lwip_init();
;;;737    #endif
;;;738    
;;;739        //
;;;740        // If using a RTOS, create a queue (to be used as a semaphore) to signal
;;;741        // the Ethernet interrupt task from the Ethernet interrupt handler.
;;;742        //
;;;743    #if !NO_SYS
;;;744    #if RTOS_FREERTOS
;;;745        g_pInterrupt = xQueueCreate(1, sizeof(void *));
00b080  2200              MOVS     r2,#0
00b082  2104              MOVS     r1,#4
00b084  2001              MOVS     r0,#1
00b086  f7fffffe          BL       xQueueGenericCreate
00b08a  494a              LDR      r1,|L1.45492|
00b08c  6008              STR      r0,[r1,#0]  ; g_pInterrupt
;;;746    #endif
;;;747    #endif
;;;748    
;;;749        //
;;;750        // If using a RTOS, create the Ethernet interrupt task.
;;;751        //
;;;752    #if !NO_SYS
;;;753    #if RTOS_FREERTOS
;;;754        xTaskCreate(lwIPInterruptTask, (signed portCHAR *)"eth_int",
00b08e  2000              MOVS     r0,#0
00b090  2302              MOVS     r3,#2
00b092  e9cd3000          STRD     r3,r0,[sp,#0]
00b096  9002              STR      r0,[sp,#8]
00b098  4603              MOV      r3,r0
00b09a  f44f6280          MOV      r2,#0x400
00b09e  a154              ADR      r1,|L1.45552|
00b0a0  9003              STR      r0,[sp,#0xc]
00b0a2  4855              LDR      r0,|L1.45560|
00b0a4  f7fffffe          BL       xTaskGenericCreate
;;;755                    STACKSIZE_LWIPINTTASK, 0, 2,
;;;756                    0);
;;;757    #endif
;;;758    #endif
;;;759    
;;;760        //
;;;761        // Setup the network address values.
;;;762        //
;;;763        if(g_ui32IPMode == IPADDR_USE_STATIC)
00b0a8  4846              LDR      r0,|L1.45508|
00b0aa  6800              LDR      r0,[r0,#0]  ; g_ui32IPMode
00b0ac  b978              CBNZ     r0,|L1.45262|
;;;764        {
;;;765            ip_addr.addr = htonl(g_ui32IPAddr);
00b0ae  4853              LDR      r0,|L1.45564|
00b0b0  6800              LDR      r0,[r0,#0]  ; g_ui32IPAddr
00b0b2  f7fffffe          BL       lwip_htonl
00b0b6  9007              STR      r0,[sp,#0x1c]
;;;766            net_mask.addr = htonl(g_ui32NetMask);
00b0b8  4851              LDR      r0,|L1.45568|
00b0ba  6800              LDR      r0,[r0,#0]  ; g_ui32NetMask
00b0bc  f7fffffe          BL       lwip_htonl
00b0c0  9006              STR      r0,[sp,#0x18]
;;;767            gw_addr.addr = htonl(g_ui32GWAddr);
00b0c2  4850              LDR      r0,|L1.45572|
00b0c4  6800              LDR      r0,[r0,#0]  ; g_ui32GWAddr
00b0c6  f7fffffe          BL       lwip_htonl
00b0ca  9005              STR      r0,[sp,#0x14]
00b0cc  e003              B        |L1.45270|
                  |L1.45262|
;;;768        }
;;;769        else
;;;770        {
;;;771            ip_addr.addr = 0;
00b0ce  2000              MOVS     r0,#0
00b0d0  9007              STR      r0,[sp,#0x1c]
;;;772            net_mask.addr = 0;
00b0d2  9006              STR      r0,[sp,#0x18]
;;;773            gw_addr.addr = 0;
00b0d4  9005              STR      r0,[sp,#0x14]
                  |L1.45270|
;;;774        }
;;;775    
;;;776        //
;;;777        // Create, configure and add the Ethernet controller interface with
;;;778        // default settings.  ip_input should be used to send packets directly to
;;;779        // the stack when not using a RTOS and tcpip_input should be used to send
;;;780        // packets to the TCP/IP thread's queue when using a RTOS.
;;;781        //
;;;782    #if NO_SYS
;;;783        netif_add(&g_sNetIF, &ip_addr, &net_mask, &gw_addr, NULL, tivaif_init,
;;;784                  ip_input);
;;;785    #else
;;;786        netif_add(&g_sNetIF, &ip_addr, &net_mask, &gw_addr, NULL, tivaif_init,
00b0d6  484c              LDR      r0,|L1.45576|
00b0d8  f2af310d          ADR      r1,tivaif_init + 1
00b0dc  2200              MOVS     r2,#0
00b0de  ab05              ADD      r3,sp,#0x14
00b0e0  e9cd2100          STRD     r2,r1,[sp,#0]
00b0e4  9002              STR      r0,[sp,#8]
00b0e6  aa06              ADD      r2,sp,#0x18
00b0e8  a907              ADD      r1,sp,#0x1c
00b0ea  4833              LDR      r0,|L1.45496|
00b0ec  f7fffffe          BL       netif_add
;;;787                  tcpip_input);
;;;788    #endif
;;;789        netif_set_default(&g_sNetIF);
00b0f0  4831              LDR      r0,|L1.45496|
00b0f2  f7fffffe          BL       netif_set_default
;;;790    
;;;791        //
;;;792        // Bring the interface up.
;;;793        //
;;;794        netif_set_up(&g_sNetIF);
00b0f6  4830              LDR      r0,|L1.45496|
00b0f8  f7fffffe          BL       netif_set_up
;;;795    
;;;796        //
;;;797        // Setup a timeout for the host timer callback function if using a RTOS.
;;;798        //
;;;799    #if !NO_SYS && HOST_TMR_INTERVAL
;;;800        sys_timeout(HOST_TMR_INTERVAL, lwIPPrivateHostTimer, NULL);
00b0fc  2200              MOVS     r2,#0
00b0fe  4932              LDR      r1,|L1.45512|
00b100  2064              MOVS     r0,#0x64
00b102  f7fffffe          BL       sys_timeout
;;;801    #endif
;;;802    
;;;803        //
;;;804        // Setup a timeout for the link detect callback function if using a RTOS.
;;;805        //
;;;806    #if !NO_SYS && (LWIP_AUTOIP || LWIP_DHCP)
;;;807       sys_timeout(LINK_TMR_INTERVAL, lwIPPrivateLinkTimer, NULL);
00b106  2200              MOVS     r2,#0
00b108  4930              LDR      r1,|L1.45516|
00b10a  200a              MOVS     r0,#0xa
00b10c  f7fffffe          BL       sys_timeout
;;;808    #endif
;;;809    
;;;810    #if LWIP_SSDP
;;;811    
;;;812     // SsdpInit(&g_sNetIF);
;;;813      
;;;814    	tcpip_timeout(1000, LwIP_DHCP_task, NULL);
00b110  2200              MOVS     r2,#0
00b112  f2af115d          ADR      r1,LwIP_DHCP_task + 1
00b116  f44f707a          MOV      r0,#0x3e8
00b11a  f7fffffe          BL       tcpip_timeout
;;;815    #endif
;;;816    
;;;817    
;;;818    s_printf("lwIPPrivateInit init done\r\n");
00b11e  a03b              ADR      r0,|L1.45580|
00b120  f7fffffe          BL       s_printf
;;;819    
;;;820    }
00b124  b008              ADD      sp,sp,#0x20
00b126  bd10              POP      {r4,pc}
;;;821    
                          ENDP

                  lwIPInit PROC
;;;843    void
;;;844    lwIPInit(uint32_t ui32SysClkHz, const uint8_t *pui8MAC, uint32_t ui32IPAddr,
00b128  e92d47fc          PUSH     {r2-r10,lr}
;;;845             uint32_t ui32NetMask, uint32_t ui32GWAddr, uint32_t ui32IPMode)
;;;846    {
00b12c  4604              MOV      r4,r0
00b12e  460d              MOV      r5,r1
00b130  4616              MOV      r6,r2
00b132  461f              MOV      r7,r3
00b134  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;847        //
;;;848        // Check the parameters.
;;;849        //
;;;850    #if LWIP_DHCP && LWIP_AUTOIP
;;;851        ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;852               (ui32IPMode == IPADDR_USE_DHCP) ||
;;;853               (ui32IPMode == IPADDR_USE_AUTOIP));
;;;854    #elif LWIP_DHCP
;;;855        ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;856               (ui32IPMode == IPADDR_USE_DHCP));
;;;857    #elif LWIP_AUTOIP
;;;858        ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;859               (ui32IPMode == IPADDR_USE_AUTOIP));
;;;860    #else
;;;861        ASSERT(ui32IPMode == IPADDR_USE_STATIC);
;;;862    #endif
;;;863    
;;;864        //
;;;865        // Enable the ethernet peripheral.
;;;866        //
;;;867        SysCtlPeripheralEnable(SYSCTL_PERIPH_EMAC0);
00b138  483b              LDR      r0,|L1.45608|
00b13a  f7fffffe          BL       SysCtlPeripheralEnable
;;;868        SysCtlPeripheralReset(SYSCTL_PERIPH_EMAC0);
00b13e  483a              LDR      r0,|L1.45608|
00b140  f7fffffe          BL       SysCtlPeripheralReset
;;;869    
;;;870        //
;;;871        // Enable the internal PHY if it's present and we're being
;;;872        // asked to use it.
;;;873        //
;;;874        if((EMAC_PHY_CONFIG & EMAC_PHY_TYPE_MASK) == EMAC_PHY_TYPE_INTERNAL)
;;;875        {
;;;876            //
;;;877            // We've been asked to configure for use with the internal
;;;878            // PHY.  Is it present?
;;;879            //
;;;880            if(SysCtlPeripheralPresent(SYSCTL_PERIPH_EPHY0))
00b144  4839              LDR      r0,|L1.45612|
00b146  f7fffffe          BL       SysCtlPeripheralPresent
00b14a  b130              CBZ      r0,|L1.45402|
;;;881            {
;;;882                //
;;;883                // Yes - enable and reset it.
;;;884                //
;;;885                SysCtlPeripheralEnable(SYSCTL_PERIPH_EPHY0);
00b14c  4837              LDR      r0,|L1.45612|
00b14e  f7fffffe          BL       SysCtlPeripheralEnable
;;;886                SysCtlPeripheralReset(SYSCTL_PERIPH_EPHY0);
00b152  4836              LDR      r0,|L1.45612|
00b154  f7fffffe          BL       SysCtlPeripheralReset
00b158  e004              B        |L1.45412|
                  |L1.45402|
;;;887            }
;;;888            else
;;;889            {
;;;890                //
;;;891                // Internal PHY is not present on this part so hang here.
;;;892                //
;;;893                while(1)
00b15a  e002              B        |L1.45410|
                  |L1.45404|
;;;894                {
;;;895    							 s_printf("Internal PHY is not present on this part\r\n");
00b15c  a034              ADR      r0,|L1.45616|
00b15e  f7fffffe          BL       s_printf
                  |L1.45410|
00b162  e7fb              B        |L1.45404|
                  |L1.45412|
;;;896                }
;;;897            }
;;;898        }
;;;899    
;;;900        //
;;;901        // Wait for the MAC to come out of reset.
;;;902        //
;;;903        while(!SysCtlPeripheralReady(SYSCTL_PERIPH_EMAC0))
00b164  bf00              NOP      
                  |L1.45414|
00b166  4830              LDR      r0,|L1.45608|
00b168  f7fffffe          BL       SysCtlPeripheralReady
00b16c  2800              CMP      r0,#0
00b16e  d0fa              BEQ      |L1.45414|
;;;904        {
;;;905        }
;;;906    
;;;907        //
;;;908        // Configure for use with whichever PHY the user requires.
;;;909        //
;;;910        EMACPHYConfigSet(EMAC0_BASE, EMAC_PHY_CONFIG);
00b170  f240410e          MOV      r1,#0x40e
00b174  480c              LDR      r0,|L1.45480|
00b176  f7fffffe          BL       EMACPHYConfigSet
;;;911    
;;;912        //
;;;913        // Initialize the MAC and set the DMA mode.
;;;914        //
;;;915        EMACInit(EMAC0_BASE, ui32SysClkHz,
00b17a  2000              MOVS     r0,#0
00b17c  2104              MOVS     r1,#4
00b17e  460b              MOV      r3,r1
00b180  4a36              LDR      r2,|L1.45660|
00b182  e9cd1000          STRD     r1,r0,[sp,#0]
00b186  4621              MOV      r1,r4
00b188  4807              LDR      r0,|L1.45480|
00b18a  f7fffffe          BL       EMACInit
;;;916                     EMAC_BCONFIG_MIXED_BURST | EMAC_BCONFIG_PRIORITY_FIXED,
;;;917                     4, 4, 0);
;;;918    
;;;919        //
;;;920        // Set MAC configuration options.
;;;921        //
;;;922        EMACConfigSet(EMAC0_BASE, (EMAC_CONFIG_FULL_DUPLEX |
00b18e  2300              MOVS     r3,#0
00b190  f04f7208          MOV      r2,#0x2200000
00b194  f44f6140          MOV      r1,#0xc00
00b198  4803              LDR      r0,|L1.45480|
00b19a  e061              B        |L1.45664|
                  |L1.45468|
                          DCD      lwip_stats
                  |L1.45472|
                          DCD      g_StellarisIFData
                  |L1.45476|
                          DCD      tivaif_transmit
                  |L1.45480|
                          DCD      0x400ec000
                  |L1.45484|
                          DCD      g_ui32NormalInts
                  |L1.45488|
                          DCD      g_ui32AbnormalInts
                  |L1.45492|
                          DCD      g_pInterrupt
                  |L1.45496|
                          DCD      g_sNetIF
                  |L1.45500|
                          DCD      0x800001c3
                  |L1.45504|
                          DCD      g_bLinkActive
                  |L1.45508|
                          DCD      g_ui32IPMode
                  |L1.45512|
                          DCD      lwIPPrivateHostTimer
                  |L1.45516|
                          DCD      lwIPPrivateLinkTimer
                  |L1.45520|
                          DCD      ||ip||
                  |L1.45524|
                          DCD      static_ip_timeout
                  |L1.45528|
00b1d8  696e206c          DCB      "in lwIPPrivateInit\r\n",0
00b1dc  77495050
00b1e0  72697661
00b1e4  7465496e
00b1e8  69740d0a
00b1ec  00      
00b1ed  00                DCB      0
00b1ee  00                DCB      0
00b1ef  00                DCB      0
                  |L1.45552|
00b1f0  6574685f          DCB      "eth_int",0
00b1f4  696e7400
                  |L1.45560|
                          DCD      lwIPInterruptTask
                  |L1.45564|
                          DCD      g_ui32IPAddr
                  |L1.45568|
                          DCD      g_ui32NetMask
                  |L1.45572|
                          DCD      g_ui32GWAddr
                  |L1.45576|
                          DCD      tcpip_input
                  |L1.45580|
00b20c  6c774950          DCB      "lwIPPrivateInit init done\r\n",0
00b210  50726976
00b214  61746549
00b218  6e697420
00b21c  696e6974
00b220  20646f6e
00b224  650d0a00
                  |L1.45608|
                          DCD      0xf0009c00
                  |L1.45612|
                          DCD      0xf0003000
                  |L1.45616|
00b230  496e7465          DCB      "Internal PHY is not present on this part\r\n",0
00b234  726e616c
00b238  20504859
00b23c  20697320
00b240  6e6f7420
00b244  70726573
00b248  656e7420
00b24c  6f6e2074
00b250  68697320
00b254  70617274
00b258  0d0a00  
00b25b  00                DCB      0
                  |L1.45660|
                          DCD      0x04000002
                  |L1.45664|
00b260  f7fffffe          BL       EMACConfigSet
;;;923                                       EMAC_CONFIG_CHECKSUM_OFFLOAD |
;;;924                                       EMAC_CONFIG_7BYTE_PREAMBLE |
;;;925                                       EMAC_CONFIG_IF_GAP_96BITS |
;;;926                                       EMAC_CONFIG_USE_MACADDR0 |
;;;927                                       EMAC_CONFIG_SA_FROM_DESCRIPTOR |
;;;928                                       EMAC_CONFIG_BO_LIMIT_1024),
;;;929                          (EMAC_MODE_RX_STORE_FORWARD |
;;;930                           EMAC_MODE_TX_STORE_FORWARD |
;;;931                           EMAC_MODE_TX_THRESHOLD_64_BYTES |
;;;932                           EMAC_MODE_RX_THRESHOLD_64_BYTES), 0);
;;;933    
;;;934        //
;;;935        // Program the hardware with its MAC address (for filtering).
;;;936        //
;;;937        EMACAddrSet(EMAC0_BASE, 0, (uint8_t *)pui8MAC);
00b264  462a              MOV      r2,r5
00b266  2100              MOVS     r1,#0
00b268  4877              LDR      r0,|L1.46152|
00b26a  f7fffffe          BL       EMACAddrSet
;;;938    
;;;939        //
;;;940        // Save the network configuration for later use by the private
;;;941        // initialization.
;;;942        //
;;;943        g_ui32IPMode = ui32IPMode;
00b26e  4877              LDR      r0,|L1.46156|
00b270  f8c09000          STR      r9,[r0,#0]  ; g_ui32IPMode
;;;944        g_ui32IPAddr = ui32IPAddr;
00b274  4876              LDR      r0,|L1.46160|
00b276  6006              STR      r6,[r0,#0]  ; g_ui32IPAddr
;;;945        g_ui32NetMask = ui32NetMask;
00b278  4876              LDR      r0,|L1.46164|
00b27a  6007              STR      r7,[r0,#0]  ; g_ui32NetMask
;;;946        g_ui32GWAddr = ui32GWAddr;
00b27c  4876              LDR      r0,|L1.46168|
00b27e  f8c08000          STR      r8,[r0,#0]  ; g_ui32GWAddr
;;;947    
;;;948        //
;;;949        // Initialize lwIP.  The remainder of initialization is done immediately if
;;;950        // not using a RTOS and it is deferred to the TCP/IP thread's context if
;;;951        // using a RTOS.
;;;952        //
;;;953    #if NO_SYS
;;;954        lwIPPrivateInit(0);
;;;955    #else
;;;956        s_printf("will call tcpip_init\r\n");
00b282  a076              ADR      r0,|L1.46172|
00b284  f7fffffe          BL       s_printf
;;;957        tcpip_init(lwIPPrivateInit, 0);
00b288  2100              MOVS     r1,#0
00b28a  487a              LDR      r0,|L1.46196|
00b28c  f7fffffe          BL       tcpip_init
;;;958    #endif
;;;959    }
00b290  e8bd87fc          POP      {r2-r10,pc}
;;;960    
                          ENDP

                  lwIPTimerCallbackRegister PROC
;;;986    void
;;;987    lwIPTimerCallbackRegister(tHardwareTimerHandler pfnTimerFunc)
00b294  4978              LDR      r1,|L1.46200|
;;;988    {
;;;989        //
;;;990        // Remember the callback function address passed.
;;;991        //
;;;992        g_pfnTimerHandler = pfnTimerFunc;
00b296  6008              STR      r0,[r1,#0]  ; g_pfnTimerHandler
;;;993    }
00b298  4770              BX       lr
;;;994    
                          ENDP

                  lwIPEthernetIntHandler PROC
;;;1046   void
;;;1047   lwIPEthernetIntHandler(void)
00b29a  b51c              PUSH     {r2-r4,lr}
;;;1048   {
;;;1049       uint32_t ui32Status;
;;;1050       uint32_t ui32TimerStatus;
;;;1051   #if !NO_SYS
;;;1052       portBASE_TYPE xWake;
;;;1053   #endif
;;;1054   
;;;1055   	 // s_printf("in eth int\r\n");
;;;1056   	
;;;1057       //
;;;1058       // Read and Clear the interrupt.
;;;1059       //
;;;1060       ui32Status = EMACIntStatus(EMAC0_BASE, true);
00b29c  2101              MOVS     r1,#1
00b29e  486a              LDR      r0,|L1.46152|
00b2a0  f7fffffe          BL       EMACIntStatus
00b2a4  9001              STR      r0,[sp,#4]
;;;1061   
;;;1062       //
;;;1063       // If the interrupt really came from the Ethernet and not our
;;;1064       // timer, clear it.
;;;1065       //
;;;1066       if(ui32Status)
00b2a6  9801              LDR      r0,[sp,#4]
00b2a8  b118              CBZ      r0,|L1.45746|
;;;1067       {
;;;1068           EMACIntClear(EMAC0_BASE, ui32Status);
00b2aa  4867              LDR      r0,|L1.46152|
00b2ac  9901              LDR      r1,[sp,#4]
00b2ae  f7fffffe          BL       EMACIntClear
                  |L1.45746|
;;;1069       }
;;;1070   
;;;1071       //
;;;1072       // Check to see whether a hardware timer interrupt has been reported.
;;;1073       //
;;;1074       if(ui32Status & EMAC_INT_TIMESTAMP)
00b2b2  9801              LDR      r0,[sp,#4]
00b2b4  f0105f00          TST      r0,#0x20000000
00b2b8  d00b              BEQ      |L1.45778|
;;;1075       {
;;;1076           //
;;;1077           // Yes - read and clear the timestamp interrupt status.
;;;1078           //
;;;1079           ui32TimerStatus = EMACTimestampIntStatus(EMAC0_BASE);
00b2ba  4863              LDR      r0,|L1.46152|
00b2bc  f7fffffe          BL       EMACTimestampIntStatus
00b2c0  4604              MOV      r4,r0
;;;1080   
;;;1081           //
;;;1082           // If a timer interrupt handler has been registered, call it.
;;;1083           //
;;;1084           if(g_pfnTimerHandler)
00b2c2  486d              LDR      r0,|L1.46200|
00b2c4  6800              LDR      r0,[r0,#0]  ; g_pfnTimerHandler
00b2c6  b120              CBZ      r0,|L1.45778|
;;;1085           {
;;;1086               g_pfnTimerHandler(EMAC0_BASE, ui32TimerStatus);
00b2c8  4621              MOV      r1,r4
00b2ca  485f              LDR      r0,|L1.46152|
00b2cc  4a6a              LDR      r2,|L1.46200|
00b2ce  6812              LDR      r2,[r2,#0]  ; g_pfnTimerHandler
00b2d0  4790              BLX      r2
                  |L1.45778|
;;;1087           }
;;;1088       }
;;;1089   
;;;1090       //
;;;1091       // The handling of the interrupt is different based on the use of a RTOS.
;;;1092       //
;;;1093   #if NO_SYS
;;;1094       //
;;;1095       // No RTOS is being used.  If a transmit/receive interrupt was active,
;;;1096       // run the low-level interrupt handler.
;;;1097       //
;;;1098       if(ui32Status)
;;;1099       {
;;;1100           tivaif_interrupt(&g_sNetIF, ui32Status);
;;;1101       }
;;;1102   
;;;1103       //
;;;1104       // Service the lwIP timers.
;;;1105       //
;;;1106       lwIPServiceTimers();
;;;1107   #else
;;;1108       //
;;;1109       // A RTOS is being used.  Signal the Ethernet interrupt task.
;;;1110       //
;;;1111       xQueueSendFromISR(g_pInterrupt, (void *)&ui32Status, &xWake);
00b2d2  2300              MOVS     r3,#0
00b2d4  466a              MOV      r2,sp
00b2d6  a901              ADD      r1,sp,#4
00b2d8  4868              LDR      r0,|L1.46204|
00b2da  6800              LDR      r0,[r0,#0]  ; g_pInterrupt
00b2dc  f7fffffe          BL       xQueueGenericSendFromISR
;;;1112   
;;;1113       //
;;;1114       // Disable the Ethernet interrupts.  Since the interrupts have not been
;;;1115       // handled, they are not asserted.  Once they are handled by the Ethernet
;;;1116       // interrupt task, it will re-enable the interrupts.
;;;1117       //
;;;1118       EMACIntDisable(EMAC0_BASE, (EMAC_INT_RECEIVE | EMAC_INT_TRANSMIT |
00b2e0  4967              LDR      r1,|L1.46208|
00b2e2  4859              LDR      r0,|L1.46152|
00b2e4  f7fffffe          BL       EMACIntDisable
;;;1119                                       EMAC_INT_TX_STOPPED |
;;;1120                                       EMAC_INT_RX_NO_BUFFER |
;;;1121                                       EMAC_INT_RX_STOPPED | EMAC_INT_PHY));
;;;1122   
;;;1123       //
;;;1124       // Potentially task switch as a result of the above queue write.
;;;1125       //
;;;1126   #if RTOS_FREERTOS
;;;1127       if(xWake == pdTRUE)
00b2e8  9800              LDR      r0,[sp,#0]
00b2ea  2801              CMP      r0,#1
00b2ec  d102              BNE      |L1.45812|
;;;1128       {
;;;1129   			 portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00b2ee  0700              LSLS     r0,r0,#28
00b2f0  4964              LDR      r1,|L1.46212|
00b2f2  6008              STR      r0,[r1,#0]
                  |L1.45812|
;;;1130           //vPortYieldFromISR();
;;;1131       }
;;;1132   #endif
;;;1133   #endif
;;;1134   }
00b2f4  bd1c              POP      {r2-r4,pc}
;;;1135   
                          ENDP

                  lwIPLocalIPAddrGet PROC
;;;1146   uint32_t
;;;1147   lwIPLocalIPAddrGet(void)
00b2f6  4864              LDR      r0,|L1.46216|
;;;1148   {
;;;1149   #if LWIP_AUTOIP || LWIP_DHCP
;;;1150       if(g_bLinkActive)
00b2f8  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00b2fa  b110              CBZ      r0,|L1.45826|
;;;1151       {
;;;1152           return((uint32_t)g_sNetIF.ip_addr.addr);
00b2fc  4863              LDR      r0,|L1.46220|
00b2fe  6840              LDR      r0,[r0,#4]  ; g_sNetIF
                  |L1.45824|
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           return(0xffffffff);
;;;1157       }
;;;1158   #else
;;;1159       return((uint32_t)g_sNetIF.ip_addr.addr);
;;;1160   #endif
;;;1161   }
00b300  4770              BX       lr
                  |L1.45826|
00b302  f04f30ff          MOV      r0,#0xffffffff        ;1156
00b306  e7fb              B        |L1.45824|
;;;1162   
                          ENDP

                  lwIPLocalNetMaskGet PROC
;;;1173   uint32_t
;;;1174   lwIPLocalNetMaskGet(void)
00b308  4860              LDR      r0,|L1.46220|
;;;1175   {
;;;1176       return((uint32_t)g_sNetIF.netmask.addr);
00b30a  6880              LDR      r0,[r0,#8]  ; g_sNetIF
;;;1177   }
00b30c  4770              BX       lr
;;;1178   
                          ENDP

                  lwIPLocalGWAddrGet PROC
;;;1189   uint32_t
;;;1190   lwIPLocalGWAddrGet(void)
00b30e  485f              LDR      r0,|L1.46220|
;;;1191   {
;;;1192       return((uint32_t)g_sNetIF.gw.addr);
00b310  68c0              LDR      r0,[r0,#0xc]  ; g_sNetIF
;;;1193   }
00b312  4770              BX       lr
;;;1194   
                          ENDP

                  lwIPLocalMACGet PROC
;;;1208   void
;;;1209   lwIPLocalMACGet(uint8_t *pui8MAC)
00b314  b510              PUSH     {r4,lr}
;;;1210   {
00b316  4604              MOV      r4,r0
;;;1211       MAP_EMACAddrGet(EMAC0_BASE, 0, pui8MAC);
00b318  f04f7080          MOV      r0,#0x1000000
00b31c  f8d000b8          LDR      r0,[r0,#0xb8]
00b320  4622              MOV      r2,r4
00b322  2100              MOVS     r1,#0
00b324  6843              LDR      r3,[r0,#4]
00b326  4848              LDR      r0,|L1.46152|
00b328  4798              BLX      r3
;;;1212   }
00b32a  bd10              POP      {r4,pc}
;;;1213   
                          ENDP

                  lwIPPrivateNetworkConfigChange PROC
;;;1221   static void
;;;1222   lwIPPrivateNetworkConfigChange(void *pvArg)
00b32c  b53e              PUSH     {r1-r5,lr}
;;;1223   {
00b32e  4605              MOV      r5,r0
;;;1224       uint32_t ui32IPMode;
;;;1225       struct ip_addr ip_addr;
;;;1226       struct ip_addr net_mask;
;;;1227       struct ip_addr gw_addr;
;;;1228   
;;;1229       //
;;;1230       // Get the new address mode.
;;;1231       //
;;;1232       ui32IPMode = (uint32_t)pvArg;
00b330  462c              MOV      r4,r5
;;;1233   
;;;1234       //
;;;1235       // Setup the network address values.
;;;1236       //
;;;1237       if(ui32IPMode == IPADDR_USE_STATIC)
00b332  b97c              CBNZ     r4,|L1.45908|
;;;1238       {
;;;1239           ip_addr.addr = htonl(g_ui32IPAddr);
00b334  4846              LDR      r0,|L1.46160|
00b336  6800              LDR      r0,[r0,#0]  ; g_ui32IPAddr
00b338  f7fffffe          BL       lwip_htonl
00b33c  9002              STR      r0,[sp,#8]
;;;1240           net_mask.addr = htonl(g_ui32NetMask);
00b33e  4845              LDR      r0,|L1.46164|
00b340  6800              LDR      r0,[r0,#0]  ; g_ui32NetMask
00b342  f7fffffe          BL       lwip_htonl
00b346  9001              STR      r0,[sp,#4]
;;;1241           gw_addr.addr = htonl(g_ui32GWAddr);
00b348  4843              LDR      r0,|L1.46168|
00b34a  6800              LDR      r0,[r0,#0]  ; g_ui32GWAddr
00b34c  f7fffffe          BL       lwip_htonl
00b350  9000              STR      r0,[sp,#0]
00b352  e003              B        |L1.45916|
                  |L1.45908|
;;;1242       }
;;;1243   #if LWIP_DHCP || LWIP_AUTOIP
;;;1244       else
;;;1245       {
;;;1246           ip_addr.addr = 0;
00b354  2000              MOVS     r0,#0
00b356  9002              STR      r0,[sp,#8]
;;;1247           net_mask.addr = 0;
00b358  9001              STR      r0,[sp,#4]
;;;1248           gw_addr.addr = 0;
00b35a  9000              STR      r0,[sp,#0]
                  |L1.45916|
;;;1249       }
;;;1250   #endif
;;;1251   
;;;1252       //
;;;1253       // Switch on the current IP Address Aquisition mode.
;;;1254       //
;;;1255       switch(g_ui32IPMode)
00b35c  483b              LDR      r0,|L1.46156|
00b35e  6800              LDR      r0,[r0,#0]  ; g_ui32IPMode
00b360  b120              CBZ      r0,|L1.45932|
00b362  2801              CMP      r0,#1
00b364  d019              BEQ      |L1.45978|
00b366  2802              CMP      r0,#2
00b368  d151              BNE      |L1.46094|
00b36a  e033              B        |L1.46036|
                  |L1.45932|
;;;1256       {
;;;1257           //
;;;1258           // Static IP
;;;1259           //
;;;1260           case IPADDR_USE_STATIC:
;;;1261           {
;;;1262               //
;;;1263               // Set the new address parameters.  This will change the address
;;;1264               // configuration in lwIP, and if necessary, will reset any links
;;;1265               // that are active.  This is valid for all three modes.
;;;1266               //
;;;1267               netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
00b36c  466b              MOV      r3,sp
00b36e  aa01              ADD      r2,sp,#4
00b370  a902              ADD      r1,sp,#8
00b372  4846              LDR      r0,|L1.46220|
00b374  f7fffffe          BL       netif_set_addr
;;;1268   
;;;1269               //
;;;1270               // If we are going to DHCP mode, then start the DHCP server now.
;;;1271               //
;;;1272   #if LWIP_DHCP
;;;1273               if((ui32IPMode == IPADDR_USE_DHCP) && g_bLinkActive)
00b378  2c01              CMP      r4,#1
00b37a  d105              BNE      |L1.45960|
00b37c  4842              LDR      r0,|L1.46216|
00b37e  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00b380  b110              CBZ      r0,|L1.45960|
;;;1274               {
;;;1275                   dhcp_start(&g_sNetIF);
00b382  4842              LDR      r0,|L1.46220|
00b384  f7fffffe          BL       dhcp_start
                  |L1.45960|
;;;1276               }
;;;1277   #endif
;;;1278   
;;;1279               //
;;;1280               // If we are going to AutoIP mode, then start the AutoIP process
;;;1281               // now.
;;;1282               //
;;;1283   #if LWIP_AUTOIP
;;;1284               if((ui32IPMode == IPADDR_USE_AUTOIP) && g_bLinkActive)
00b388  2c02              CMP      r4,#2
00b38a  d105              BNE      |L1.45976|
00b38c  483e              LDR      r0,|L1.46216|
00b38e  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00b390  b110              CBZ      r0,|L1.45976|
;;;1285               {
;;;1286                   autoip_start(&g_sNetIF);
00b392  483e              LDR      r0,|L1.46220|
00b394  f7fffffe          BL       autoip_start
                  |L1.45976|
;;;1287               }
;;;1288   #endif
;;;1289   
;;;1290               //
;;;1291               // And we're done.
;;;1292               //
;;;1293               break;
00b398  e039              B        |L1.46094|
                  |L1.45978|
;;;1294           }
;;;1295   
;;;1296           //
;;;1297           // DHCP (with AutoIP fallback).
;;;1298           //
;;;1299   #if LWIP_DHCP
;;;1300           case IPADDR_USE_DHCP:
;;;1301           {
;;;1302               //
;;;1303               // If we are going to static IP addressing, then disable DHCP and
;;;1304               // force the new static IP address.
;;;1305               //
;;;1306               if(ui32IPMode == IPADDR_USE_STATIC)
00b39a  b94c              CBNZ     r4,|L1.46000|
;;;1307               {
;;;1308                   dhcp_stop(&g_sNetIF);
00b39c  483b              LDR      r0,|L1.46220|
00b39e  f7fffffe          BL       dhcp_stop
;;;1309                   netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
00b3a2  466b              MOV      r3,sp
00b3a4  aa01              ADD      r2,sp,#4
00b3a6  a902              ADD      r1,sp,#8
00b3a8  4838              LDR      r0,|L1.46220|
00b3aa  f7fffffe          BL       netif_set_addr
00b3ae  e010              B        |L1.46034|
                  |L1.46000|
;;;1310               }
;;;1311   
;;;1312               //
;;;1313               // If we are going to AUTO IP addressing, then disable DHCP, set
;;;1314               // the default addresses, and start AutoIP.
;;;1315               //
;;;1316   #if LWIP_AUTOIP
;;;1317               else if(ui32IPMode == IPADDR_USE_AUTOIP)
00b3b0  2c02              CMP      r4,#2
00b3b2  d10e              BNE      |L1.46034|
;;;1318               {
;;;1319                   dhcp_stop(&g_sNetIF);
00b3b4  4835              LDR      r0,|L1.46220|
00b3b6  f7fffffe          BL       dhcp_stop
;;;1320                   netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
00b3ba  466b              MOV      r3,sp
00b3bc  aa01              ADD      r2,sp,#4
00b3be  a902              ADD      r1,sp,#8
00b3c0  4832              LDR      r0,|L1.46220|
00b3c2  f7fffffe          BL       netif_set_addr
;;;1321                   if(g_bLinkActive)
00b3c6  4830              LDR      r0,|L1.46216|
00b3c8  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00b3ca  b110              CBZ      r0,|L1.46034|
;;;1322                   {
;;;1323                       autoip_start(&g_sNetIF);
00b3cc  482f              LDR      r0,|L1.46220|
00b3ce  f7fffffe          BL       autoip_start
                  |L1.46034|
;;;1324                   }
;;;1325               }
;;;1326   #endif
;;;1327               break;
00b3d2  e01c              B        |L1.46094|
                  |L1.46036|
;;;1328           }
;;;1329   #endif
;;;1330   
;;;1331           //
;;;1332           // AUTOIP
;;;1333           //
;;;1334   #if LWIP_AUTOIP
;;;1335           case IPADDR_USE_AUTOIP:
;;;1336           {
;;;1337               //
;;;1338               // If we are going to static IP addressing, then disable AutoIP and
;;;1339               // force the new static IP address.
;;;1340               //
;;;1341               if(ui32IPMode == IPADDR_USE_STATIC)
00b3d4  b94c              CBNZ     r4,|L1.46058|
;;;1342               {
;;;1343                   autoip_stop(&g_sNetIF);
00b3d6  482d              LDR      r0,|L1.46220|
00b3d8  f7fffffe          BL       autoip_stop
;;;1344                   netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
00b3dc  466b              MOV      r3,sp
00b3de  aa01              ADD      r2,sp,#4
00b3e0  a902              ADD      r1,sp,#8
00b3e2  482a              LDR      r0,|L1.46220|
00b3e4  f7fffffe          BL       netif_set_addr
00b3e8  e010              B        |L1.46092|
                  |L1.46058|
;;;1345               }
;;;1346   
;;;1347               //
;;;1348               // If we are going to DHCP addressing, then disable AutoIP, set the
;;;1349               // default addresses, and start dhcp.
;;;1350               //
;;;1351   #if LWIP_DHCP
;;;1352               else if(ui32IPMode == IPADDR_USE_DHCP)
00b3ea  2c01              CMP      r4,#1
00b3ec  d10e              BNE      |L1.46092|
;;;1353               {
;;;1354                   autoip_stop(&g_sNetIF);
00b3ee  4827              LDR      r0,|L1.46220|
00b3f0  f7fffffe          BL       autoip_stop
;;;1355                   netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
00b3f4  466b              MOV      r3,sp
00b3f6  aa01              ADD      r2,sp,#4
00b3f8  a902              ADD      r1,sp,#8
00b3fa  4824              LDR      r0,|L1.46220|
00b3fc  f7fffffe          BL       netif_set_addr
;;;1356                   if(g_bLinkActive)
00b400  4821              LDR      r0,|L1.46216|
00b402  7800              LDRB     r0,[r0,#0]  ; g_bLinkActive
00b404  b110              CBZ      r0,|L1.46092|
;;;1357                   {
;;;1358                       dhcp_start(&g_sNetIF);
00b406  4821              LDR      r0,|L1.46220|
00b408  f7fffffe          BL       dhcp_start
                  |L1.46092|
;;;1359                   }
;;;1360               }
;;;1361   #endif
;;;1362               break;
00b40c  bf00              NOP      
                  |L1.46094|
00b40e  bf00              NOP                            ;1293
;;;1363           }
;;;1364   #endif
;;;1365       }
;;;1366   
;;;1367       //
;;;1368       // Bring the interface up.
;;;1369       //
;;;1370       netif_set_up(&g_sNetIF);
00b410  481e              LDR      r0,|L1.46220|
00b412  f7fffffe          BL       netif_set_up
;;;1371   
;;;1372       //
;;;1373       // Save the new mode.
;;;1374       //
;;;1375       g_ui32IPMode = ui32IPMode;
00b416  480d              LDR      r0,|L1.46156|
00b418  6004              STR      r4,[r0,#0]  ; g_ui32IPMode
;;;1376   }
00b41a  bd3e              POP      {r1-r5,pc}
;;;1377   
                          ENDP

                  lwIPNetworkConfigChange PROC
;;;1397   void
;;;1398   lwIPNetworkConfigChange(uint32_t ui32IPAddr, uint32_t ui32NetMask,
00b41c  e92d41f0          PUSH     {r4-r8,lr}
;;;1399                           uint32_t ui32GWAddr, uint32_t ui32IPMode)
;;;1400   {
00b420  4607              MOV      r7,r0
00b422  460c              MOV      r4,r1
00b424  4615              MOV      r5,r2
00b426  461e              MOV      r6,r3
;;;1401       //
;;;1402       // Check the parameters.
;;;1403       //
;;;1404   #if LWIP_DHCP && LWIP_AUTOIP
;;;1405       ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;1406              (ui32IPMode == IPADDR_USE_DHCP) ||
;;;1407              (ui32IPMode == IPADDR_USE_AUTOIP));
;;;1408   #elif LWIP_DHCP
;;;1409       ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;1410              (ui32IPMode == IPADDR_USE_DHCP));
;;;1411   #elif LWIP_AUTOIP
;;;1412       ASSERT((ui32IPMode == IPADDR_USE_STATIC) ||
;;;1413              (ui32IPMode == IPADDR_USE_AUTOIP));
;;;1414   #else
;;;1415       ASSERT(ui32IPMode == IPADDR_USE_STATIC);
;;;1416   #endif
;;;1417   
;;;1418       //
;;;1419       // Save the network configuration for later use by the private network
;;;1420       // configuration change.
;;;1421       //
;;;1422       g_ui32IPAddr = ui32IPAddr;
00b428  4809              LDR      r0,|L1.46160|
00b42a  6007              STR      r7,[r0,#0]  ; g_ui32IPAddr
;;;1423       g_ui32NetMask = ui32NetMask;
00b42c  4809              LDR      r0,|L1.46164|
00b42e  6004              STR      r4,[r0,#0]  ; g_ui32NetMask
;;;1424       g_ui32GWAddr = ui32GWAddr;
00b430  4809              LDR      r0,|L1.46168|
00b432  6005              STR      r5,[r0,#0]  ; g_ui32GWAddr
;;;1425   
;;;1426       //
;;;1427       // Complete the network configuration change.  The remainder is done
;;;1428       // immediately if not using a RTOS and it is deferred to the TCP/IP
;;;1429       // thread's context if using a RTOS.
;;;1430       //
;;;1431   #if NO_SYS
;;;1432       lwIPPrivateNetworkConfigChange((void *)ui32IPMode);
;;;1433   #else
;;;1434       tcpip_callback(lwIPPrivateNetworkConfigChange, (void *)ui32IPMode);
00b434  2201              MOVS     r2,#1
00b436  4631              MOV      r1,r6
00b438  4815              LDR      r0,|L1.46224|
00b43a  f7fffffe          BL       tcpip_callback_with_block
;;;1435   #endif
;;;1436   }
00b43e  e8bd81f0          POP      {r4-r8,pc}
;;;1437   
                          ENDP

                  get_cur_ip PROC
;;;1438   
;;;1439   ip_addr_t *get_cur_ip(void)
00b442  4812              LDR      r0,|L1.46220|
;;;1440   {
;;;1441   	  return &g_sNetIF.ip_addr;
00b444  1d00              ADDS     r0,r0,#4
;;;1442   }
00b446  4770              BX       lr
;;;1443   
                          ENDP

                  |L1.46152|
                          DCD      0x400ec000
                  |L1.46156|
                          DCD      g_ui32IPMode
                  |L1.46160|
                          DCD      g_ui32IPAddr
                  |L1.46164|
                          DCD      g_ui32NetMask
                  |L1.46168|
                          DCD      g_ui32GWAddr
                  |L1.46172|
00b45c  77696c6c          DCB      "will call tcpip_init\r\n",0
00b460  2063616c
00b464  6c207463
00b468  7069705f
00b46c  696e6974
00b470  0d0a00  
00b473  00                DCB      0
                  |L1.46196|
                          DCD      lwIPPrivateInit
                  |L1.46200|
                          DCD      g_pfnTimerHandler
                  |L1.46204|
                          DCD      g_pInterrupt
                  |L1.46208|
                          DCD      0x800001c3
                  |L1.46212|
                          DCD      0xe000ed04
                  |L1.46216|
                          DCD      g_bLinkActive
                  |L1.46220|
                          DCD      g_sNetIF
                  |L1.46224|
                          DCD      lwIPPrivateNetworkConfigChange

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||str||
                          %        16
                  mbox
                          %        136
                  dhcp_rx_options_val
                          %        40
                  dhcp_rx_options_given
                          %        10
                  ram_heap
                          %        65566
                  mem_mutex
                          %        12
                  memp_tab
                          %        52
                  memp_memory
                          %        35732
                  lwip_stats
                          %        472
                  inseg
                          %        20
                  arp_table
                          %        200
                  sems
                          %        192
                  mboxes
                          %        2176
                  threads
                          %        140
                  g_sDriverStats
                          %        44
                  g_pTxDescriptors
                          %        864
                  g_pRxDescriptors
                          %        288
                  g_sNetIF
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memp_sizes
000000  001c0024          DCW      0x001c,0x0024
000004  00980020          DCW      0x0098,0x0020
000008  00140010          DCW      0x0014,0x0010
00000c  013c0014          DCW      0x013c,0x0014
000010  00140014          DCW      0x0014,0x0014
000014  00100010          DCW      0x0010,0x0010
000018  0210              DCW      0x0210
                  memp_num
00001a  0004              DCW      0x0004
00001c  00040010          DCW      0x0004,0x0010
000020  00080020          DCW      0x0008,0x0020
000024  00100010          DCW      0x0010,0x0010
000028  00080008          DCW      0x0008,0x0008
00002c  0008000f          DCW      0x0008,0x000f
000030  00300030          DCW      0x0030,0x0030
                  tcp_state_str
                          DCD      ||.conststring||+0x19c
                          DCD      ||.conststring||+0x1a3
                          DCD      ||.conststring||+0x1aa
                          DCD      ||.conststring||+0x1b3
                          DCD      ||.conststring||+0x1bc
                          DCD      ||.conststring||+0x1c8
                          DCD      ||.conststring||+0x1d3
                          DCD      ||.conststring||+0x1de
                          DCD      ||.conststring||+0x1e9
                          DCD      ||.conststring||+0x1f1
                          DCD      ||.conststring||+0x1fa
                  tcp_backoff
000060  01020304          DCB      0x01,0x02,0x03,0x04
000064  05060707          DCB      0x05,0x06,0x07,0x07
000068  07070707          DCB      0x07,0x07,0x07,0x07
00006c  07                DCB      0x07
                  tcp_persist_backoff
00006d  03060c            DCB      0x03,0x06,0x0c
000070  18306078          DCB      0x18,0x30,0x60,0x78
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs
                  ip_addr_any
                          DCD      0x00000000
                  ip_addr_broadcast
                          DCD      0xffffffff
                  ethbroadcast
00008c  ffffffff          DCB      0xff,0xff,0xff,0xff
000090  ffff              DCB      0xff,0xff
                  ethzero
000092  0000              DCB      0x00,0x00
000094  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      ||.conststring||+0x112
                          DCD      ||.conststring||+0x11a
                          DCD      ||.conststring||+0x122
                          DCD      ||.conststring||+0x12a
                          DCD      ||.conststring||+0x139
                          DCD      ||.conststring||+0x141
                          DCD      ||.conststring||+0x148
                          DCD      ||.conststring||+0x150
                          DCD      ||.conststring||+0x15e
                          DCD      ||.conststring||+0x16e
                          DCD      ||.conststring||+0x179
                          DCD      ||.conststring||+0x185
                          DCD      ||.conststring||+0x192

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  4f6b2e00          DCB      "Ok.",0
000004  4f757420          DCB      "Out of memory error.",0
000008  6f66206d
00000c  656d6f72
000010  79206572
000014  726f722e
000018  00      
000019  42756666          DCB      "Buffer error.",0
00001d  65722065
000021  72726f72
000025  2e00    
000027  54696d65          DCB      "Timeout.",0
00002b  6f75742e
00002f  00      
000030  526f7574          DCB      "Routing problem.",0
000034  696e6720
000038  70726f62
00003c  6c656d2e
000040  00      
000041  4f706572          DCB      "Operation in progress.",0
000045  6174696f
000049  6e20696e
00004d  2070726f
000051  67726573
000055  732e00  
000058  496c6c65          DCB      "Illegal value.",0
00005c  67616c20
000060  76616c75
000064  652e00  
000067  4f706572          DCB      "Operation would block.",0
00006b  6174696f
00006f  6e20776f
000073  756c6420
000077  626c6f63
00007b  6b2e00  
00007e  41646472          DCB      "Address in use.",0
000082  65737320
000086  696e2075
00008a  73652e00
00008e  416c7265          DCB      "Already connected.",0
000092  61647920
000096  636f6e6e
00009a  65637465
00009e  642e00  
0000a1  436f6e6e          DCB      "Connection aborted.",0
0000a5  65637469
0000a9  6f6e2061
0000ad  626f7274
0000b1  65642e00
0000b5  436f6e6e          DCB      "Connection reset.",0
0000b9  65637469
0000bd  6f6e2072
0000c1  65736574
0000c5  2e00    
0000c7  436f6e6e          DCB      "Connection closed.",0
0000cb  65637469
0000cf  6f6e2063
0000d3  6c6f7365
0000d7  642e00  
0000da  4e6f7420          DCB      "Not connected.",0
0000de  636f6e6e
0000e2  65637465
0000e6  642e00  
0000e9  496c6c65          DCB      "Illegal argument.",0
0000ed  67616c20
0000f1  61726775
0000f5  6d656e74
0000f9  2e00    
0000fb  4c6f772d          DCB      "Low-level netif error.",0
0000ff  6c657665
000103  6c206e65
000107  74696620
00010b  6572726f
00010f  722e00  
000112  5241575f          DCB      "RAW_PCB",0
000116  50434200
00011a  5544505f          DCB      "UDP_PCB",0
00011e  50434200
000122  5443505f          DCB      "TCP_PCB",0
000126  50434200
00012a  5443505f          DCB      "TCP_PCB_LISTEN",0
00012e  5043425f
000132  4c495354
000136  454e00  
000139  5443505f          DCB      "TCP_SEG",0
00013d  53454700
000141  4e455442          DCB      "NETBUF",0
000145  554600  
000148  4e455443          DCB      "NETCONN",0
00014c  4f4e4e00
000150  54435049          DCB      "TCPIP_MSG_API",0
000154  505f4d53
000158  475f4150
00015c  4900    
00015e  54435049          DCB      "TCPIP_MSG_INPKT",0
000162  505f4d53
000166  475f494e
00016a  504b5400
00016e  49474d50          DCB      "IGMP_GROUP",0
000172  5f47524f
000176  555000  
000179  5359535f          DCB      "SYS_TIMEOUT",0
00017d  54494d45
000181  4f555400
000185  50425546          DCB      "PBUF_REF/ROM",0
000189  5f524546
00018d  2f524f4d
000191  00      
000192  50425546          DCB      "PBUF_POOL",0
000196  5f504f4f
00019a  4c00    
00019c  434c4f53          DCB      "CLOSED",0
0001a0  454400  
0001a3  4c495354          DCB      "LISTEN",0
0001a7  454e00  
0001aa  53594e5f          DCB      "SYN_SENT",0
0001ae  53454e54
0001b2  00      
0001b3  53594e5f          DCB      "SYN_RCVD",0
0001b7  52435644
0001bb  00      
0001bc  45535441          DCB      "ESTABLISHED",0
0001c0  424c4953
0001c4  48454400
0001c8  46494e5f          DCB      "FIN_WAIT_1",0
0001cc  57414954
0001d0  5f3100  
0001d3  46494e5f          DCB      "FIN_WAIT_2",0
0001d7  57414954
0001db  5f3200  
0001de  434c4f53          DCB      "CLOSE_WAIT",0
0001e2  455f5741
0001e6  495400  
0001e9  434c4f53          DCB      "CLOSING",0
0001ed  494e4700
0001f1  4c415354          DCB      "LAST_ACK",0
0001f5  5f41434b
0001f9  00      
0001fa  54494d45          DCB      "TIME_WAIT",0
0001fe  5f574149
000202  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  err_strerr
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x4
                          DCD      ||.conststring||+0x19
                          DCD      ||.conststring||+0x27
                          DCD      ||.conststring||+0x30
                          DCD      ||.conststring||+0x41
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x67
                          DCD      ||.conststring||+0x7e
                          DCD      ||.conststring||+0x8e
                          DCD      ||.conststring||+0xa1
                          DCD      ||.conststring||+0xb5
                          DCD      ||.conststring||+0xc7
                          DCD      ||.conststring||+0xda
                          DCD      ||.conststring||+0xe9
                          DCD      ||.conststring||+0xfb
                  memp_desc
                          DCD      ||.conststring||+0x112
                          DCD      ||.conststring||+0x11a
                          DCD      ||.conststring||+0x122
                          DCD      ||.conststring||+0x12a
                          DCD      ||.conststring||+0x139
                          DCD      ||.conststring||+0x141
                          DCD      ||.conststring||+0x148
                          DCD      ||.conststring||+0x150
                          DCD      ||.conststring||+0x15e
                          DCD      ||.conststring||+0x16e
                          DCD      ||.conststring||+0x179
                          DCD      ||.conststring||+0x185
                          DCD      ||.conststring||+0x192
                  tcp_port
000074  c000              DCW      0xc000
                  udp_port
000076  c000              DCW      0xc000
                  g_TxDescList
                          DCD      g_pTxDescriptors
                          DCD      0x00000018
                          DCD      0x00000000
                          DCD      0x00000000
                  g_RxDescList
                          DCD      g_pRxDescriptors
                          DCD      0x00000008
                          DCD      0x00000000
                          DCD      0x00000000
                  g_StellarisIFData
                          DCD      0x00000000
                          DCD      g_TxDescList
                          DCD      g_RxDescList
                  g_ui32IPMode
                          DCD      0x00000000
                  g_bLinkActive
0000a8  00000000          DCB      0x00,0x00,0x00,0x00
                  static_ip_timeout
                          DCD      0x00000000
                  xid
                          DCD      0x00000000
                  iss
                          DCD      0x0000196e
                  ||ip||
                          DCD      0x00000000
                  tcpip_init_done
                          DCD      0x00000000
                  tcpip_init_done_arg
                          DCD      0x00000000
                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  netif_list
                          DCD      0x00000000
                  netif_default
                          DCD      0x00000000
                  netif_num
0000d8  00                DCB      0x00
                  pbuf_free_ooseq_pending
0000d9  000000            DCB      0x00,0x00,0x00
                  raw_pcbs
                          DCD      0x00000000
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_active_pcbs_changed
0000f8  00                DCB      0x00
                  tcp_timer
0000f9  00                DCB      0x00
                  tcp_timer_ctr
0000fa  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  flags
00010c  0000              DCB      0x00,0x00
                  tcplen
00010e  0000              DCB      0x00,0x00
                  recv_flags
000110  00000000          DCB      0x00,0x00,0x00,0x00
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
                  next_timeout
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000
                  udp_pcbs
                          DCD      0x00000000
                  igmp_group_list
                          DCD      0x00000000
                  allsystems
                          DCD      0x00000000
                  allrouters
                          DCD      0x00000000
                  current_netif
                          DCD      0x00000000
                  current_header
                          DCD      0x00000000
                  current_iphdr_src
                          DCD      0x00000000
                  current_iphdr_dest
                          DCD      0x00000000
                  ip_id
000144  0000              DCB      0x00,0x00
                  etharp_cached_entry
000146  0000              DCB      0x00,0x00
                  g_ui32NormalInts
                          DCD      0x00000000
                  g_ui32AbnormalInts
                          DCD      0x00000000
                  g_pfnTimerHandler
                          DCD      0x00000000
                  g_ui32IPAddr
                          DCD      0x00000000
                  g_ui32NetMask
                          DCD      0x00000000
                  g_ui32GWAddr
                          DCD      0x00000000
                  g_pInterrupt
                          DCD      0x00000000
