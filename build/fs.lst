L 1 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c"
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#include "lwip/opt.h"
L 1 ".\third_party\lwip-1.4.1\src\include\lwip/opt.h" 1
N/**
N * @file
N *
N * lwIP Options Configuration
N */
N
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_OPT_H__
N#define __LWIP_OPT_H__
N
N/*
N * Include user defined options first. Anything not defined in these files
N * will be set to standard values. Override anything you dont like!
N */
N#include "lwipopts.h"
L 1 ".\web\lwipopts.h" 1
N//*****************************************************************************
N//
N// lwipopts.h - Configuration file for lwIP
N//
N// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
N// Software License Agreement
N// 
N// Texas Instruments (TI) is supplying this software for use solely and
N// exclusively on TI's microcontroller products. The software is owned by
N// TI and/or its suppliers, and is protected under applicable copyright
N// laws. You may not combine this software with "viral" open-source
N// software in order to form a larger program.
N// 
N// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
N// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
N// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
N// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
N// DAMAGES, FOR ANY REASON WHATSOEVER.
N// 
N// This is part of revision 2.0.1.11577 of the DK-TM4C129X Firmware Package.
N//
N//*****************************************************************************
N//
N// NOTE:  This file has been derived from the lwIP/src/include/lwip/opt.h
N// header file.
N//
N// For additional details, refer to the original "opt.h" file, and lwIP
N// documentation.
N//
N//*****************************************************************************
N
N#ifndef __LWIPOPTS_H__
N#define __LWIPOPTS_H__
N
N//*****************************************************************************
N//
N// ---------- Stellaris / lwIP Port Options ----------
N//
N//*****************************************************************************
N#define HOST_TMR_INTERVAL               100         // default is 0
N#define DHCP_EXPIRE_TIMER_MSECS         (10 * 1000)
N//#define LWIP_HTTPD_SSI                  1
N//#define LWIP_HTTPD_CGI                  1
N//#define LWIP_HTTPD_DYNAMIC_HEADERS      1
N
N#define DYNAMIC_HTTP_HEADERS
N#define INCLUDE_HTTPD_POST
N//#define INCLUDE_HTTPD_CGI
N#define INCLUDE_HTTPD_SSI
N#define INCLUDE_HTTPD_SSI_TAG
N
N//#define HTTPD_DEBUG                     LWIP_DBG_ON
N#define EMAC_PHY_CONFIG (EMAC_PHY_TYPE_INTERNAL | EMAC_PHY_INT_MDIX_EN |      \
N                         EMAC_PHY_AN_100B_T_FULL_DUPLEX)
X#define EMAC_PHY_CONFIG (EMAC_PHY_TYPE_INTERNAL | EMAC_PHY_INT_MDIX_EN |                               EMAC_PHY_AN_100B_T_FULL_DUPLEX)
N#define PHY_PHYS_ADDR      0
N#define NUM_TX_DESCRIPTORS 24
N#define NUM_RX_DESCRIPTORS 8
N
N//*****************************************************************************
N//
N// ---------- Platform specific locking ----------
N//
N//*****************************************************************************
N#define SYS_LIGHTWEIGHT_PROT            1           // default is 0
N#define NO_SYS                          0           // default is 0
N//#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
N//#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
N
N//*****************************************************************************
N//
N// ---------- Memory options ----------
N//
N//*****************************************************************************
N//#define MEM_LIBC_MALLOC                 0
N#define MEM_ALIGNMENT                   4           // default is 1
N#define MEM_SIZE                        (64 * 1024)  // default is 1600
N//#define MEMP_OVERFLOW_CHECK             0
N//#define MEMP_SANITY_CHECK               0
N//#define MEM_USE_POOLS                   0
N//#define MEMP_USE_CUSTOM_POOLS           0
N
N//*****************************************************************************
N//
N// ---------- Internal Memory Pool Sizes ----------
N//
N//*****************************************************************************
N#define MEMP_NUM_PBUF                     48    // Default 16
N//#define MEMP_NUM_RAW_PCB                4
N//#define MEMP_NUM_UDP_PCB                4
N#define MEMP_NUM_TCP_PCB                  16    // Default 5
N//#define MEMP_NUM_TCP_PCB_LISTEN         8
N#define MEMP_NUM_TCP_SEG                  32  // Default 16
N//#define MEMP_NUM_REASSDATA              5
N//#define MEMP_NUM_ARP_QUEUE              30
N//#define MEMP_NUM_IGMP_GROUP             8
N#define MEMP_NUM_SYS_TIMEOUT              15
N//#define MEMP_NUM_NETBUF                 2
N//#define MEMP_NUM_NETCONN                4
N//#define MEMP_NUM_TCPIP_MSG_API          8
N//#define MEMP_NUM_TCPIP_MSG_INPKT        8
N#define PBUF_POOL_SIZE                    48    // Default 16
N
N//*****************************************************************************
N//
N// ---------- ARP options ----------
N//
N//*****************************************************************************
N//#define LWIP_ARP                        1
N//#define ARP_TABLE_SIZE                  10
N//#define ARP_QUEUEING                    1
N//#define ETHARP_TRUST_IP_MAC             1
N
N//*****************************************************************************
N//
N// ---------- IP options ----------
N//
N//*****************************************************************************
N//#define IP_FORWARD                      0
N//#define IP_OPTIONS_ALLOWED              1
N#define IP_REASSEMBLY                   0           // default is 1
N#define IP_FRAG                         0           // default is 1
N//#define IP_REASS_MAXAGE                 3
N//#define IP_REASS_MAX_PBUFS              10
N//#define IP_FRAG_USES_STATIC_BUF         1
N//#define IP_FRAG_MAX_MTU                 1500
N//#define IP_DEFAULT_TTL                  255
N
N//*****************************************************************************
N//
N// ---------- ICMP options ----------
N//
N//*****************************************************************************
N//#define LWIP_ICMP                       1
N//#define ICMP_TTL                       (IP_DEFAULT_TTL)
N
N//*****************************************************************************
N//
N// ---------- RAW options ----------
N//
N//*****************************************************************************
N//#define LWIP_RAW                        1
N//#define RAW_TTL                        (IP_DEFAULT_TTL)
N
N//*****************************************************************************
N//
N// ---------- DHCP options ----------
N//
N//*****************************************************************************
N#define LWIP_DHCP                       1           // default is 0
N//#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
N
N//*****************************************************************************
N//
N// ---------- UPNP options ----------
N//
N//*****************************************************************************
N//#define LWIP_UPNP                       0
N
N//*****************************************************************************
N//
N// ---------- PTPD options ----------
N//
N//*****************************************************************************
N//#define LWIP_PTPD                       0
N
N//*****************************************************************************
N//
N// ---------- AUTOIP options ----------
N//
N//*****************************************************************************
N#define LWIP_AUTOIP                     1          // default is 0
N#define LWIP_DHCP_AUTOIP_COOP           ((LWIP_DHCP) && (LWIP_AUTOIP))
N                                                    // default is 0
N#define LWIP_DHCP_AUTOIP_COOP_TRIES     5           // default is 9
N
N//*****************************************************************************
N//
N// ---------- SNMP options ----------
N//
N//*****************************************************************************
N//#define LWIP_SNMP                       0
N//#define SNMP_CONCURRENT_REQUESTS        1
N//#define SNMP_TRAP_DESTINATIONS          1
N//#define SNMP_PRIVATE_MIB                0
N//#define SNMP_SAFE_REQUESTS              1
N
N//*****************************************************************************
N//
N// ---------- IGMP options ----------
N//
N//*****************************************************************************
N//#define LWIP_IGMP                       0
N
N//*****************************************************************************
N//
N// ---------- DNS options -----------
N//
N//*****************************************************************************
N//#define LWIP_DNS                        0
N//#define DNS_TABLE_SIZE                  4
N//#define DNS_MAX_NAME_LENGTH             256
N//#define DNS_MAX_SERVERS                 2
N//#define DNS_DOES_NAME_CHECK             1
N//#define DNS_USES_STATIC_BUF             1
N//#define DNS_MSG_SIZE                    512
N
N//*****************************************************************************
N//
N// ---------- UDP options ----------
N//
N//*****************************************************************************
N//#define LWIP_UDP                        1
N//#define LWIP_UDPLITE                    0
N//#define UDP_TTL                         (IP_DEFAULT_TTL)
N
N//*****************************************************************************
N//
N// ---------- TCP options ----------
N//
N//*****************************************************************************
N//#define LWIP_TCP                        1
N//#define TCP_TTL                         (IP_DEFAULT_TTL)
N#define TCP_WND                         4096   // default is 2048
N//#define TCP_MAXRTX                      12
N//#define TCP_SYNMAXRTX                   6
N//#define TCP_QUEUE_OOSEQ                 1
N#define TCP_MSS                        1500        // default is 128
N//#define TCP_CALCULATE_EFF_SEND_MSS      1
N#define TCP_SND_BUF                     (8 * TCP_MSS)
N                                                    // default is 256
N//#define TCP_SND_QUEUELEN                (4 * (TCP_SND_BUF/TCP_MSS))
N//#define TCP_SNDLOWAT                    (TCP_SND_BUF/2)
N//#define TCP_LISTEN_BACKLOG              0
N//#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
N
N//*****************************************************************************
N//
N// ---------- API options ----------
N//
N//*****************************************************************************
N//#define LWIP_EVENT_API                  1
N//#define LWIP_CALLBACK_API               0
N
N//*****************************************************************************
N//
N// ---------- Pbuf options ----------
N//
N//*****************************************************************************
N#define PBUF_LINK_HLEN                  16          // default is 14
N#define PBUF_POOL_BUFSIZE               512
N                                                    // default is LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
N#define ETH_PAD_SIZE                    0           // default is 0
N
N//*****************************************************************************
N//
N// ---------- Network Interfaces options ----------
N//
N//*****************************************************************************
N//#define LWIP_NETIF_HOSTNAME             0
N//#define LWIP_NETIF_API                  0
N//#define LWIP_NETIF_STATUS_CALLBACK      0
N//#define LWIP_NETIF_LINK_CALLBACK        0
N//#define LWIP_NETIF_HWADDRHINT           0
N
N//*****************************************************************************
N//
N// ---------- LOOPIF options ----------
N//
N//*****************************************************************************
N//#define LWIP_HAVE_LOOPIF                0
N//#define LWIP_LOOPIF_MULTITHREADING      1
N
N//*****************************************************************************
N//
N// ---------- Thread options ----------
N//
N//*****************************************************************************
N#define TCPIP_THREAD_NAME              "tcpip_thread"
N#define TCPIP_THREAD_STACKSIZE          (5*1024)
N#define TCPIP_THREAD_PRIO               4
N#define TCPIP_MBOX_SIZE                 32
N//#define SLIPIF_THREAD_NAME             "slipif_loop"
N//#define SLIPIF_THREAD_STACKSIZE         0
N//#define SLIPIF_THREAD_PRIO              1
N//#define PPP_THREAD_NAME                "pppMain"
N//#define PPP_THREAD_STACKSIZE            0
N//#define PPP_THREAD_PRIO                 1
N//#define DEFAULT_THREAD_NAME            "lwIP"
N//#define DEFAULT_THREAD_STACKSIZE        0
N//#define DEFAULT_THREAD_PRIO             1
N//#define DEFAULT_RAW_RECVMBOX_SIZE       0
N//#define DEFAULT_UDP_RECVMBOX_SIZE       0
N//#define DEFAULT_TCP_RECVMBOX_SIZE       0
N//#define DEFAULT_ACCEPTMBOX_SIZE         0
N
N//*****************************************************************************
N//
N// ---------- Sequential layer options ----------
N//
N//*****************************************************************************
N//#define LWIP_TCPIP_CORE_LOCKING         0
N#define LWIP_NETCONN                    1           // default is 1
N#define LWIP_SSDP                       1
N#define LWIP_SDDP                       0
N//*****************************************************************************
N//
N// ---------- Socket Options ----------
N//
N//*****************************************************************************
N#define LWIP_SOCKET                     0           // default is 1
N//#define LWIP_COMPAT_SOCKETS             1
N//#define LWIP_POSIX_SOCKETS_IO_NAMES     1
N//#define LWIP_TCP_KEEPALIVE              0
N//#define LWIP_SO_RCVTIMEO                0
N//#define LWIP_SO_RCVBUF                  0
N//#define SO_REUSE                        0
N
N//*****************************************************************************
N//
N// ---------- Statistics options ----------
N//
N//*****************************************************************************
N//#define LWIP_STATS                      1
N//#define LWIP_STATS_DISPLAY              0
N//#define LINK_STATS                      1
N//#define ETHARP_STATS                    (LWIP_ARP)
N//#define IP_STATS                        1
N//#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
N//#define ICMP_STATS                      1
N//#define IGMP_STATS                      (LWIP_IGMP)
N//#define UDP_STATS                       (LWIP_UDP)
N//#define TCP_STATS                       (LWIP_TCP)
N//#define MEM_STATS                       1
N//#define MEMP_STATS                      1
N//#define SYS_STATS                       1
N
N//*****************************************************************************
N//
N// ---------- PPP options ----------
N//
N//*****************************************************************************
N//#define PPP_SUPPORT                     0
N//#define PPPOE_SUPPORT                   0
N//#define PPPOS_SUPPORT                   PPP_SUPPORT
N
N#if PPP_SUPPORT
S//#define NUM_PPP                         1
S//#define PAP_SUPPORT                     0
S//#define CHAP_SUPPORT                    0
S//#define MSCHAP_SUPPORT                  0
S//#define CBCP_SUPPORT                    0
S//#define CCP_SUPPORT                     0
S//#define VJ_SUPPORT                      0
S//#define MD5_SUPPORT                     0
S//#define FSM_DEFTIMEOUT                  6
S//#define FSM_DEFMAXTERMREQS              2
S//#define FSM_DEFMAXCONFREQS              10
S//#define FSM_DEFMAXNAKLOOPS              5
S//#define UPAP_DEFTIMEOUT                 6
S//#define UPAP_DEFREQTIME                 30
S//#define CHAP_DEFTIMEOUT                 6
S//#define CHAP_DEFTRANSMITS               10
S//#define LCP_ECHOINTERVAL                0
S//#define LCP_MAXECHOFAILS                3
S//#define PPP_MAXIDLEFLAG                 100
S
S//#define PPP_MAXMTU                      1500
S//#define PPP_DEFMRU                      296
N#endif
N
N//*****************************************************************************
N//
N// ---------- checksum options ----------
N//
N//*****************************************************************************
N#define CHECKSUM_GEN_IP                 0
N#define CHECKSUM_GEN_ICMP               0
N#define CHECKSUM_GEN_UDP                0
N#define CHECKSUM_GEN_TCP                0
N#define CHECKSUM_CHECK_IP               0
N#define CHECKSUM_CHECK_UDP              0
N#define CHECKSUM_CHECK_TCP              0
N
N//*****************************************************************************
N//
N// ---------- Debugging options ----------
N//
N//*****************************************************************************
N#if 0
S#define U8_F "c"
S#define S8_F "c"
S#define X8_F "x"
S#define U16_F "u"
S#define S16_F "d"
S#define X16_F "x"
S#define U32_F "u"
S#define S32_F "d"
S#define X32_F "x"
Sextern void UARTprintf(const char *pcString, ...);
S#define LWIP_DEBUG
N#endif
N
N#if 1
N#define U8_F "c"
N#define S8_F "c"
N#ifndef X8_F
N#define X8_F "x"
N#endif
N#define U16_F "u"
N#define S16_F "d"
N#define X16_F "x"
N#define U32_F "u"
N#define S32_F "d"
N#define X32_F "x"
N#endif
Nextern int uUartsprintf(const char *pcString, ...);
N#define LWIP_DEBUG
N
N//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
N#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
N//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_WARNING
N//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SERIOUS
N//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SEVERE
N
N//#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
N#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON //(LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH)
N
N#if 0
S//#define ETHARP_DEBUG                    LWIP_DBG_ON     // default is OFF
S//#define NETIF_DEBUG                     LWIP_DBG_ON     // default is OFF
S//#define PBUF_DEBUG                      LWIP_DBG_OFF
S//#define API_LIB_DEBUG                   LWIP_DBG_OFF
S//#define API_MSG_DEBUG                   LWIP_DBG_OFF
S//#define SOCKETS_DEBUG                   LWIP_DBG_OFF
S//#define ICMP_DEBUG                      LWIP_DBG_OFF
S//#define IGMP_DEBUG                      LWIP_DBG_OFF
S//#define INET_DEBUG                      LWIP_DBG_OFF
S//#define IP_DEBUG                        LWIP_DBG_ON     // default is OFF
S//#define IP_REASS_DEBUG                  LWIP_DBG_OFF
S//#define RAW_DEBUG                       LWIP_DBG_OFF
S//#define MEM_DEBUG                       LWIP_DBG_OFF
S//#define MEMP_DEBUG                      LWIP_DBG_OFF
S//#define SYS_DEBUG                       LWIP_DBG_OFF
S//#define TCP_DEBUG                       LWIP_DBG_OFF
S//#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
S//#define TCP_FR_DEBUG                    LWIP_DBG_OFF
S//#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
S//#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
S//#define TCP_WND_DEBUG                   LWIP_DBG_OFF
S//#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
S//#define TCP_RST_DEBUG                   LWIP_DBG_OFF
S//#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
S//#define UDP_DEBUG                       LWIP_DBG_ON     // default is OFF
S//#define TCPIP_DEBUG                     LWIP_DBG_OFF
S//#define PPP_DEBUG                       LWIP_DBG_OFF
S//#define SLIP_DEBUG                      LWIP_DBG_OFF
S//#define DHCP_DEBUG                      LWIP_DBG_ON     // default is OFF
S//#define AUTOIP_DEBUG                    LWIP_DBG_OFF
S//#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
S//#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
S//#define DNS_DEBUG                       LWIP_DBG_OFF
N#else
N
N#if 0
S#define ETHARP_DEBUG                    LWIP_DBG_OFF// default is OFF
S#define NETIF_DEBUG                     LWIP_DBG_OFF   // default is OFF
S#define PBUF_DEBUG                      LWIP_DBG_OFF
S#define API_LIB_DEBUG                   LWIP_DBG_OFF
S#define API_MSG_DEBUG                   LWIP_DBG_OFF
S#define SOCKETS_DEBUG                   LWIP_DBG_OFF
S#define ICMP_DEBUG                      LWIP_DBG_OFF
S#define IGMP_DEBUG                      LWIP_DBG_OFF
S#define INET_DEBUG                      LWIP_DBG_OFF
S#define IP_DEBUG                        LWIP_DBG_OFF     // default is OFF
S#define IP_REASS_DEBUG                  LWIP_DBG_OFF
S#define RAW_DEBUG                       LWIP_DBG_OFF
S#define MEM_DEBUG                       LWIP_DBG_OFF
S#define MEMP_DEBUG                      LWIP_DBG_OFF
S#define SYS_DEBUG                       LWIP_DBG_OFF
S#define TCP_DEBUG                       LWIP_DBG_OFF
S#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
S#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
S#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
S#define TCP_WND_DEBUG                   LWIP_DBG_OFF
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
S#define TCP_RST_DEBUG                   LWIP_DBG_OFF
S#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
S#define UDP_DEBUG                       LWIP_DBG_OFF// default is OFF
S#define TCPIP_DEBUG                     LWIP_DBG_OFF
S#define PPP_DEBUG                       LWIP_DBG_OFF
S#define SLIP_DEBUG                      LWIP_DBG_OFF
S#define DHCP_DEBUG                      LWIP_DBG_OFF// default is OFF
S#define AUTOIP_DEBUG                    LWIP_DBG_OFF
S#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
S#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
S#define DNS_DEBUG                       LWIP_DBG_OFF
S#define HTTPD_DEBUG                     LWIP_DBG_ON
S#define SSDP_DEBUG                      LWIP_DBG_OFF
N#endif
N#if 1
N#define ETHARP_DEBUG                    LWIP_DBG_OFF// default is OFF
N#define NETIF_DEBUG                     LWIP_DBG_OFF// default is OFF
N#define PBUF_DEBUG                      LWIP_DBG_OFF
N#define API_LIB_DEBUG                   LWIP_DBG_OFF
N#define API_MSG_DEBUG                   LWIP_DBG_OFF
N#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N#define ICMP_DEBUG                      LWIP_DBG_OFF
N#define IGMP_DEBUG                      LWIP_DBG_OFF
N#define INET_DEBUG                      LWIP_DBG_OFF
N#define IP_DEBUG                        LWIP_DBG_OFF     // default is OFF
N#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N#define RAW_DEBUG                       LWIP_DBG_OFF
N#define MEM_DEBUG                       LWIP_DBG_OFF
N#define MEMP_DEBUG                      LWIP_DBG_OFF
N#define SYS_DEBUG                       LWIP_DBG_OFF
N#define TCP_DEBUG                       LWIP_DBG_OFF
N#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N#define UDP_DEBUG                       LWIP_DBG_OFF// default is OFF
N#define TCPIP_DEBUG                     LWIP_DBG_OFF
N#define PPP_DEBUG                       LWIP_DBG_OFF
N#define SLIP_DEBUG                      LWIP_DBG_OFF
N#define DHCP_DEBUG                      LWIP_DBG_OFF// default is OFF
N#define AUTOIP_DEBUG                    LWIP_DBG_OFF
N#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
N#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
N#define DNS_DEBUG                       LWIP_DBG_OFF
N#define HTTPD_DEBUG                     LWIP_DBG_OFF
N#define SSDP_DEBUG                      LWIP_DBG_OFF
N#define CGI_GeneralSetting_TEST         LWIP_DBG_ON
N#define CGI_InOutputSetting_TEST        LWIP_DBG_ON
N
N
N#define CGI_TEST                        LWIP_DBG_ON
N#define CGI_HOME                        LWIP_DBG_ON
N#endif
N
N#endif
N#endif /* __LWIPOPTS_H__ */
L 46 ".\third_party\lwip-1.4.1\src\include\lwip/opt.h" 2
N#include "lwip/debug.h"
L 1 ".\third_party\lwip-1.4.1\src\include\lwip/debug.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEBUG_H__
N#define __LWIP_DEBUG_H__
N
N#include "lwip/arch.h"
L 1 ".\third_party\lwip-1.4.1\src\include\lwip/arch.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ARCH_H__
N#define __LWIP_ARCH_H__
N
N#ifndef LITTLE_ENDIAN
N#define LITTLE_ENDIAN 1234
N#endif
N
N#ifndef BIG_ENDIAN
N#define BIG_ENDIAN 4321
N#endif
N
N#include "arch/cc.h"
L 1 ".\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch/cc.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __CC_H__
N#define __CC_H__
N
Ntypedef unsigned    char    u8_t;
Ntypedef signed      char    s8_t;
Ntypedef unsigned    short   u16_t;
Ntypedef signed      short   s16_t;
Ntypedef unsigned    long    u32_t;
Ntypedef signed      long    s32_t;
Ntypedef u32_t               mem_ptr_t;
Ntypedef u8_t                sys_prot_t;
N
N#ifndef BYTE_ORDER
N#define BYTE_ORDER LITTLE_ENDIAN
N#endif
N
N#if defined(__arm__) && defined(__ARMCC_VERSION)
X#if 1L && 1L
N    //
N    // Setup PACKing macros for KEIL/RVMDK Tools
N    //
N    #define PACK_STRUCT_BEGIN __packed
N    #define PACK_STRUCT_STRUCT
N    #define PACK_STRUCT_END
N    #define PACK_STRUCT_FIELD(x) x
N#elif defined (__IAR_SYSTEMS_ICC__)
S    //
S    // Setup PACKing macros for IAR Tools
S    //
S    #define PACK_STRUCT_BEGIN
S    #define PACK_STRUCT_STRUCT
S    #define PACK_STRUCT_END
S    #define PACK_STRUCT_FIELD(x) x
S    #define PACK_STRUCT_USE_INCLUDES
S#else
S    //
S    // Setup PACKing macros for GCC Tools
S    //
S    #define PACK_STRUCT_BEGIN
S    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
S    #define PACK_STRUCT_END
S    #define PACK_STRUCT_FIELD(x) x
N#endif
N
N//*****************************************************************************
N//
N// Define LWIP_PLATFORM_DIAG and LWIP_PLATFORM_ASSERT macros.  Both of these
N// are expected to display the message argument using a platform/app specific
N// display routine.  The ASSERT macro should then abort execution.
N//
N// In general, the user should define these in the target/application specific
N// LWIPOPTS.H file, using whatever display mechanisms are availble for the
N// board/application.  However, some general default macros are provided here
N// to allow the LWIP code to build properly with/without the DEBUG macro
N// defined.
N//
N//*****************************************************************************
Nextern void s_printf(const char *fmt, ...);
N//
N// Define an empty DIAG display maro here ... since we have no knowledge of
N// what display routines are available.
N//
N#ifndef LWIP_PLATFORM_DIAG
N#define LWIP_PLATFORM_DIAG(msg)  s_printf msg 
N#endif
N
N//
N// Define a generic ASSERT display macro here ... use the DIAG macro to display
N// the message, then use the __error__ function, which should always be
N// defined by the user application for DEBUG builds, to abandon execution.
N//
N#ifndef LWIP_PLATFORM_ASSERT
N#ifdef DEBUG
S
S#include <stdint.h>
S#include <stdbool.h>
S
Sextern void __error__(char *pcFilename, uint32_t ui32Line);
S#define LWIP_PLATFORM_ASSERT(msg)       \
S{                                       \
S    LWIP_PLATFORM_DIAG(msg);            \
S    __error__(__FILE__, __LINE__);      \
S}
X#define LWIP_PLATFORM_ASSERT(msg)       {                                           LWIP_PLATFORM_DIAG(msg);                __error__(__FILE__, __LINE__);      }
N#else
N#define LWIP_PLATFORM_ASSERT(msg)
N#endif
N#endif
N
N#endif /* __CC_H__ */
L 44 ".\third_party\lwip-1.4.1\src\include\lwip/arch.h" 2
N
N/** Temporary: define format string for size_t if not defined in cc.h */
N#ifndef SZT_F
N#define SZT_F U32_F
N#endif /* SZT_F */
N/** Temporary upgrade helper: define format string for u8_t as hex if not
N    defined in cc.h */
N#ifndef X8_F
S#define X8_F  "02x"
N#endif /* X8_F */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef PACK_STRUCT_BEGIN
S#define PACK_STRUCT_BEGIN
N#endif /* PACK_STRUCT_BEGIN */
N
N#ifndef PACK_STRUCT_END
S#define PACK_STRUCT_END
N#endif /* PACK_STRUCT_END */
N
N#ifndef PACK_STRUCT_FIELD
S#define PACK_STRUCT_FIELD(x) x
N#endif /* PACK_STRUCT_FIELD */
N
N
N#ifndef LWIP_UNUSED_ARG
N#define LWIP_UNUSED_ARG(x) (void)x
N#endif /* LWIP_UNUSED_ARG */ 
N
N
N#ifdef LWIP_PROVIDE_ERRNO
S
S#define  EPERM         1  /* Operation not permitted */
S#define  ENOENT        2  /* No such file or directory */
S#define  ESRCH         3  /* No such process */
S#define  EINTR         4  /* Interrupted system call */
S#define  EIO           5  /* I/O error */
S#define  ENXIO         6  /* No such device or address */
S#define  E2BIG         7  /* Arg list too long */
S#define  ENOEXEC       8  /* Exec format error */
S#define  EBADF         9  /* Bad file number */
S#define  ECHILD       10  /* No child processes */
S#define  EAGAIN       11  /* Try again */
S#define  ENOMEM       12  /* Out of memory */
S#define  EACCES       13  /* Permission denied */
S#define  EFAULT       14  /* Bad address */
S#define  ENOTBLK      15  /* Block device required */
S#define  EBUSY        16  /* Device or resource busy */
S#define  EEXIST       17  /* File exists */
S#define  EXDEV        18  /* Cross-device link */
S#define  ENODEV       19  /* No such device */
S#define  ENOTDIR      20  /* Not a directory */
S#define  EISDIR       21  /* Is a directory */
S#define  EINVAL       22  /* Invalid argument */
S#define  ENFILE       23  /* File table overflow */
S#define  EMFILE       24  /* Too many open files */
S#define  ENOTTY       25  /* Not a typewriter */
S#define  ETXTBSY      26  /* Text file busy */
S#define  EFBIG        27  /* File too large */
S#define  ENOSPC       28  /* No space left on device */
S#define  ESPIPE       29  /* Illegal seek */
S#define  EROFS        30  /* Read-only file system */
S#define  EMLINK       31  /* Too many links */
S#define  EPIPE        32  /* Broken pipe */
S#define  EDOM         33  /* Math argument out of domain of func */
S#define  ERANGE       34  /* Math result not representable */
S#define  EDEADLK      35  /* Resource deadlock would occur */
S#define  ENAMETOOLONG 36  /* File name too long */
S#define  ENOLCK       37  /* No record locks available */
S#define  ENOSYS       38  /* Function not implemented */
S#define  ENOTEMPTY    39  /* Directory not empty */
S#define  ELOOP        40  /* Too many symbolic links encountered */
S#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
S#define  ENOMSG       42  /* No message of desired type */
S#define  EIDRM        43  /* Identifier removed */
S#define  ECHRNG       44  /* Channel number out of range */
S#define  EL2NSYNC     45  /* Level 2 not synchronized */
S#define  EL3HLT       46  /* Level 3 halted */
S#define  EL3RST       47  /* Level 3 reset */
S#define  ELNRNG       48  /* Link number out of range */
S#define  EUNATCH      49  /* Protocol driver not attached */
S#define  ENOCSI       50  /* No CSI structure available */
S#define  EL2HLT       51  /* Level 2 halted */
S#define  EBADE        52  /* Invalid exchange */
S#define  EBADR        53  /* Invalid request descriptor */
S#define  EXFULL       54  /* Exchange full */
S#define  ENOANO       55  /* No anode */
S#define  EBADRQC      56  /* Invalid request code */
S#define  EBADSLT      57  /* Invalid slot */
S
S#define  EDEADLOCK    EDEADLK
S
S#define  EBFONT       59  /* Bad font file format */
S#define  ENOSTR       60  /* Device not a stream */
S#define  ENODATA      61  /* No data available */
S#define  ETIME        62  /* Timer expired */
S#define  ENOSR        63  /* Out of streams resources */
S#define  ENONET       64  /* Machine is not on the network */
S#define  ENOPKG       65  /* Package not installed */
S#define  EREMOTE      66  /* Object is remote */
S#define  ENOLINK      67  /* Link has been severed */
S#define  EADV         68  /* Advertise error */
S#define  ESRMNT       69  /* Srmount error */
S#define  ECOMM        70  /* Communication error on send */
S#define  EPROTO       71  /* Protocol error */
S#define  EMULTIHOP    72  /* Multihop attempted */
S#define  EDOTDOT      73  /* RFS specific error */
S#define  EBADMSG      74  /* Not a data message */
S#define  EOVERFLOW    75  /* Value too large for defined data type */
S#define  ENOTUNIQ     76  /* Name not unique on network */
S#define  EBADFD       77  /* File descriptor in bad state */
S#define  EREMCHG      78  /* Remote address changed */
S#define  ELIBACC      79  /* Can not access a needed shared library */
S#define  ELIBBAD      80  /* Accessing a corrupted shared library */
S#define  ELIBSCN      81  /* .lib section in a.out corrupted */
S#define  ELIBMAX      82  /* Attempting to link in too many shared libraries */
S#define  ELIBEXEC     83  /* Cannot exec a shared library directly */
S#define  EILSEQ       84  /* Illegal byte sequence */
S#define  ERESTART     85  /* Interrupted system call should be restarted */
S#define  ESTRPIPE     86  /* Streams pipe error */
S#define  EUSERS       87  /* Too many users */
S#define  ENOTSOCK     88  /* Socket operation on non-socket */
S#define  EDESTADDRREQ 89  /* Destination address required */
S#define  EMSGSIZE     90  /* Message too long */
S#define  EPROTOTYPE   91  /* Protocol wrong type for socket */
S#define  ENOPROTOOPT  92  /* Protocol not available */
S#define  EPROTONOSUPPORT 93  /* Protocol not supported */
S#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
S#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
S#define  EPFNOSUPPORT    96  /* Protocol family not supported */
S#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
S#define  EADDRINUSE      98  /* Address already in use */
S#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
S#define  ENETDOWN       100  /* Network is down */
S#define  ENETUNREACH    101  /* Network is unreachable */
S#define  ENETRESET      102  /* Network dropped connection because of reset */
S#define  ECONNABORTED   103  /* Software caused connection abort */
S#define  ECONNRESET     104  /* Connection reset by peer */
S#define  ENOBUFS        105  /* No buffer space available */
S#define  EISCONN        106  /* Transport endpoint is already connected */
S#define  ENOTCONN       107  /* Transport endpoint is not connected */
S#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
S#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
S#define  ETIMEDOUT      110  /* Connection timed out */
S#define  ECONNREFUSED   111  /* Connection refused */
S#define  EHOSTDOWN      112  /* Host is down */
S#define  EHOSTUNREACH   113  /* No route to host */
S#define  EALREADY       114  /* Operation already in progress */
S#define  EINPROGRESS    115  /* Operation now in progress */
S#define  ESTALE         116  /* Stale NFS file handle */
S#define  EUCLEAN        117  /* Structure needs cleaning */
S#define  ENOTNAM        118  /* Not a XENIX named type file */
S#define  ENAVAIL        119  /* No XENIX semaphores available */
S#define  EISNAM         120  /* Is a named type file */
S#define  EREMOTEIO      121  /* Remote I/O error */
S#define  EDQUOT         122  /* Quota exceeded */
S
S#define  ENOMEDIUM      123  /* No medium found */
S#define  EMEDIUMTYPE    124  /* Wrong medium type */
S
S#ifndef errno
Sextern int errno;
S#endif
S
N#endif /* LWIP_PROVIDE_ERRNO */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ARCH_H__ */
L 36 ".\third_party\lwip-1.4.1\src\include\lwip/debug.h" 2
N#include "lwip/opt.h"
L 1 ".\third_party\lwip-1.4.1\src\include\lwip/opt.h" 1
N/**
N * @file
N *
N * lwIP Options Configuration
N */
N
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_OPT_H__
S#define __LWIP_OPT_H__
S
S/*
S * Include user defined options first. Anything not defined in these files
S * will be set to standard values. Override anything you dont like!
S */
S#include "lwipopts.h"
S#include "lwip/debug.h"
S
S/*
S   -----------------------------------------------
S   ---------- Platform specific locking ----------
S   -----------------------------------------------
S*/
S
S/**
S * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
S * critical regions during buffer allocation, deallocation and memory
S * allocation and deallocation.
S */
S#ifndef SYS_LIGHTWEIGHT_PROT
S#define SYS_LIGHTWEIGHT_PROT            0
S#endif
S
S/** 
S * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
S * use lwIP facilities.
S */
S#ifndef NO_SYS
S#define NO_SYS                          0
S#endif
S
S/**
S * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
S * Mainly for compatibility to old versions.
S */
S#ifndef NO_SYS_NO_TIMERS
S#define NO_SYS_NO_TIMERS                0
S#endif
S
S/**
S * MEMCPY: override this if you have a faster implementation at hand than the
S * one included in your C library
S */
S#ifndef MEMCPY
S#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
S#endif
S
S/**
S * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
S * call to memcpy() if the length is known at compile time and is small.
S */
S#ifndef SMEMCPY
S#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
S#endif
S
S/*
S   ------------------------------------
S   ---------- Memory options ----------
S   ------------------------------------
S*/
S/**
S * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
S * instead of the lwip internal allocator. Can save code size if you
S * already use it.
S */
S#ifndef MEM_LIBC_MALLOC
S#define MEM_LIBC_MALLOC                 0
S#endif
S
S/**
S* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
S* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
S* speed and usage from interrupts!
S*/
S#ifndef MEMP_MEM_MALLOC
S#define MEMP_MEM_MALLOC                 0
S#endif
S
S/**
S * MEM_ALIGNMENT: should be set to the alignment of the CPU
S *    4 byte alignment -> #define MEM_ALIGNMENT 4
S *    2 byte alignment -> #define MEM_ALIGNMENT 2
S */
S#ifndef MEM_ALIGNMENT
S#define MEM_ALIGNMENT                   1
S#endif
S
S/**
S * MEM_SIZE: the size of the heap memory. If the application will send
S * a lot of data that needs to be copied, this should be set high.
S */
S#ifndef MEM_SIZE
S#define MEM_SIZE                        1600
S#endif
S
S/**
S * MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
S * This can be used to individually change the location of each pool.
S * Default is one big array for all pools
S */
S#ifndef MEMP_SEPARATE_POOLS
S#define MEMP_SEPARATE_POOLS             0
S#endif
S
S/**
S * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
S * amount of bytes before and after each memp element in every pool and fills
S * it with a prominent default value.
S *    MEMP_OVERFLOW_CHECK == 0 no checking
S *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
S *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
S *      memp_malloc() or memp_free() is called (useful but slow!)
S */
S#ifndef MEMP_OVERFLOW_CHECK
S#define MEMP_OVERFLOW_CHECK             0
S#endif
S
S/**
S * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
S * sure that there are no cycles in the linked lists.
S */
S#ifndef MEMP_SANITY_CHECK
S#define MEMP_SANITY_CHECK               0
S#endif
S
S/**
S * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
S * of memory pools of various sizes. When mem_malloc is called, an element of
S * the smallest pool that can provide the length needed is returned.
S * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
S */
S#ifndef MEM_USE_POOLS
S#define MEM_USE_POOLS                   0
S#endif
S
S/**
S * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
S * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
S * reliable. */
S#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
S#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
S#endif
S
S/**
S * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
S * that defines additional pools beyond the "standard" ones required
S * by lwIP. If you set this to 1, you must have lwippools.h in your 
S * inlude path somewhere. 
S */
S#ifndef MEMP_USE_CUSTOM_POOLS
S#define MEMP_USE_CUSTOM_POOLS           0
S#endif
S
S/**
S * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
S * interrupt context (or another context that doesn't allow waiting for a
S * semaphore).
S * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
S * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
S * with each loop so that mem_free can run.
S *
S * ATTENTION: As you can see from the above description, this leads to dis-/
S * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
S * can need longer.
S *
S * If you don't want that, at least for NO_SYS=0, you can still use the following
S * functions to enqueue a deallocation call which then runs in the tcpip_thread
S * context:
S * - pbuf_free_callback(p);
S * - mem_free_callback(m);
S */
S#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
S#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
S#endif
S
S/*
S   ------------------------------------------------
S   ---------- Internal Memory Pool Sizes ----------
S   ------------------------------------------------
S*/
S/**
S * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
S * If the application sends a lot of data out of ROM (or other static memory),
S * this should be set high.
S */
S#ifndef MEMP_NUM_PBUF
S#define MEMP_NUM_PBUF                   16
S#endif
S
S/**
S * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
S * (requires the LWIP_RAW option)
S */
S#ifndef MEMP_NUM_RAW_PCB
S#define MEMP_NUM_RAW_PCB                4
S#endif
S
S/**
S * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
S * per active UDP "connection".
S * (requires the LWIP_UDP option)
S */
S#ifndef MEMP_NUM_UDP_PCB
S#define MEMP_NUM_UDP_PCB                4
S#endif
S
S/**
S * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
S * (requires the LWIP_TCP option)
S */
S#ifndef MEMP_NUM_TCP_PCB
S#define MEMP_NUM_TCP_PCB                5
S#endif
S
S/**
S * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
S * (requires the LWIP_TCP option)
S */
S#ifndef MEMP_NUM_TCP_PCB_LISTEN
S#define MEMP_NUM_TCP_PCB_LISTEN         8
S#endif
S
S/**
S * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
S * (requires the LWIP_TCP option)
S */
S#ifndef MEMP_NUM_TCP_SEG
S#define MEMP_NUM_TCP_SEG                16
S#endif
S
S/**
S * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
S * reassembly (whole packets, not fragments!)
S */
S#ifndef MEMP_NUM_REASSDATA
S#define MEMP_NUM_REASSDATA              5
S#endif
S
S/**
S * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
S * (fragments, not whole packets!).
S * This is only used with IP_FRAG_USES_STATIC_BUF==0 and
S * LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
S * where the packet is not yet sent when netif->output returns.
S */
S#ifndef MEMP_NUM_FRAG_PBUF
S#define MEMP_NUM_FRAG_PBUF              15
S#endif
S
S/**
S * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
S * packets (pbufs) that are waiting for an ARP request (to resolve
S * their destination address) to finish.
S * (requires the ARP_QUEUEING option)
S */
S#ifndef MEMP_NUM_ARP_QUEUE
S#define MEMP_NUM_ARP_QUEUE              30
S#endif
S
S/**
S * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
S * can be members et the same time (one per netif - allsystems group -, plus one
S * per netif membership).
S * (requires the LWIP_IGMP option)
S */
S#ifndef MEMP_NUM_IGMP_GROUP
S#define MEMP_NUM_IGMP_GROUP             8
S#endif
S
S/**
S * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
S * (requires NO_SYS==0)
S * The default number of timeouts is calculated here for all enabled modules.
S * The formula expects settings to be either '0' or '1'.
S */
S#ifndef MEMP_NUM_SYS_TIMEOUT
S#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
S#endif
S
S/**
S * MEMP_NUM_NETBUF: the number of struct netbufs.
S * (only needed if you use the sequential API, like api_lib.c)
S */
S#ifndef MEMP_NUM_NETBUF
S#define MEMP_NUM_NETBUF                 16
S#endif
S
S/**
S * MEMP_NUM_NETCONN: the number of struct netconns.
S * (only needed if you use the sequential API, like api_lib.c)
S */
S#ifndef MEMP_NUM_NETCONN
S#define MEMP_NUM_NETCONN                16
S#endif
S
S/**
S * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
S * for callback/timeout API communication. 
S * (only needed if you use tcpip.c)
S */
S#ifndef MEMP_NUM_TCPIP_MSG_API
S#define MEMP_NUM_TCPIP_MSG_API          8
S#endif
S
S/**
S * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
S * for incoming packets. 
S * (only needed if you use tcpip.c)
S */
S#ifndef MEMP_NUM_TCPIP_MSG_INPKT
S#define MEMP_NUM_TCPIP_MSG_INPKT        8
S#endif
S
S/**
S * MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
S */
S#ifndef MEMP_NUM_SNMP_NODE
S#define MEMP_NUM_SNMP_NODE              50
S#endif
S
S/**
S * MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
S * Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
S */
S#ifndef MEMP_NUM_SNMP_ROOTNODE
S#define MEMP_NUM_SNMP_ROOTNODE          30
S#endif
S
S/**
S * MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
S * be changed normally) - 2 of these are used per request (1 for input,
S * 1 for output)
S */
S#ifndef MEMP_NUM_SNMP_VARBIND
S#define MEMP_NUM_SNMP_VARBIND           2
S#endif
S
S/**
S * MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
S * (does not have to be changed normally) - 3 of these are used per request
S * (1 for the value read and 2 for OIDs - input and output)
S */
S#ifndef MEMP_NUM_SNMP_VALUE
S#define MEMP_NUM_SNMP_VALUE             3
S#endif
S
S/**
S * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
S * (before freeing the corresponding memory using lwip_freeaddrinfo()).
S */
S#ifndef MEMP_NUM_NETDB
S#define MEMP_NUM_NETDB                  1
S#endif
S
S/**
S * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
S * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
S */
S#ifndef MEMP_NUM_LOCALHOSTLIST
S#define MEMP_NUM_LOCALHOSTLIST          1
S#endif
S
S/**
S * MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
S * interfaces (only used with PPPOE_SUPPORT==1)
S */
S#ifndef MEMP_NUM_PPPOE_INTERFACES
S#define MEMP_NUM_PPPOE_INTERFACES       1
S#endif
S
S/**
S * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
S */
S#ifndef PBUF_POOL_SIZE
S#define PBUF_POOL_SIZE                  16
S#endif
S
S/*
S   ---------------------------------
S   ---------- ARP options ----------
S   ---------------------------------
S*/
S/**
S * LWIP_ARP==1: Enable ARP functionality.
S */
S#ifndef LWIP_ARP
S#define LWIP_ARP                        1
S#endif
S
S/**
S * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
S */
S#ifndef ARP_TABLE_SIZE
S#define ARP_TABLE_SIZE                  10
S#endif
S
S/**
S * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
S * resolution. By default, only the most recent packet is queued per IP address.
S * This is sufficient for most protocols and mainly reduces TCP connection
S * startup time. Set this to 1 if you know your application sends more than one
S * packet in a row to an IP address that is not in the ARP cache.
S */
S#ifndef ARP_QUEUEING
S#define ARP_QUEUEING                    0
S#endif
S
S/**
S * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
S * updated with the source MAC and IP addresses supplied in the packet.
S * You may want to disable this if you do not trust LAN peers to have the
S * correct addresses, or as a limited approach to attempt to handle
S * spoofing. If disabled, lwIP will need to make a new ARP request if
S * the peer is not already in the ARP table, adding a little latency.
S * The peer *is* in the ARP table if it requested our address before.
S * Also notice that this slows down input processing of every IP packet!
S */
S#ifndef ETHARP_TRUST_IP_MAC
S#define ETHARP_TRUST_IP_MAC             0
S#endif
S
S/**
S * ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
S * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
S * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
S * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
S * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
S * that returns 1 to accept a packet or 0 to drop a packet.
S */
S#ifndef ETHARP_SUPPORT_VLAN
S#define ETHARP_SUPPORT_VLAN             0
S#endif
S
S/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
S * might be disabled
S */
S#ifndef LWIP_ETHERNET
S#define LWIP_ETHERNET                   (LWIP_ARP || PPPOE_SUPPORT)
S#endif
S
S/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
S * alignment of payload after that header. Since the header is 14 bytes long,
S * without this padding e.g. addresses in the IP header will not be aligned
S * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
S */
S#ifndef ETH_PAD_SIZE
S#define ETH_PAD_SIZE                    0
S#endif
S
S/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
S * entries (using etharp_add_static_entry/etharp_remove_static_entry).
S */
S#ifndef ETHARP_SUPPORT_STATIC_ENTRIES
S#define ETHARP_SUPPORT_STATIC_ENTRIES   0
S#endif
S
S
S/*
S   --------------------------------
S   ---------- IP options ----------
S   --------------------------------
S*/
S/**
S * IP_FORWARD==1: Enables the ability to forward IP packets across network
S * interfaces. If you are going to run lwIP on a device with only one network
S * interface, define this to 0.
S */
S#ifndef IP_FORWARD
S#define IP_FORWARD                      0
S#endif
S
S/**
S * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
S *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
S *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
S */
S#ifndef IP_OPTIONS_ALLOWED
S#define IP_OPTIONS_ALLOWED              1
S#endif
S
S/**
S * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
S * this option does not affect outgoing packet sizes, which can be controlled
S * via IP_FRAG.
S */
S#ifndef IP_REASSEMBLY
S#define IP_REASSEMBLY                   1
S#endif
S
S/**
S * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
S * that this option does not affect incoming packet sizes, which can be
S * controlled via IP_REASSEMBLY.
S */
S#ifndef IP_FRAG
S#define IP_FRAG                         1
S#endif
S
S/**
S * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
S * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
S * in this time, the whole packet is discarded.
S */
S#ifndef IP_REASS_MAXAGE
S#define IP_REASS_MAXAGE                 3
S#endif
S
S/**
S * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
S * Since the received pbufs are enqueued, be sure to configure
S * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
S * packets even if the maximum amount of fragments is enqueued for reassembly!
S */
S#ifndef IP_REASS_MAX_PBUFS
S#define IP_REASS_MAX_PBUFS              10
S#endif
S
S/**
S * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
S * fragmentation. Otherwise pbufs are allocated and reference the original
S * packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
S * new PBUF_RAM pbufs are used for fragments).
S * ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
S */
S#ifndef IP_FRAG_USES_STATIC_BUF
S#define IP_FRAG_USES_STATIC_BUF         0
S#endif
S
S/**
S * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
S * (requires IP_FRAG_USES_STATIC_BUF==1)
S */
S#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
S#define IP_FRAG_MAX_MTU                 1500
S#endif
S
S/**
S * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
S */
S#ifndef IP_DEFAULT_TTL
S#define IP_DEFAULT_TTL                  255
S#endif
S
S/**
S * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
S * filter per pcb on udp and raw send operations. To enable broadcast filter
S * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
S */
S#ifndef IP_SOF_BROADCAST
S#define IP_SOF_BROADCAST                0
S#endif
S
S/**
S * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
S * filter on recv operations.
S */
S#ifndef IP_SOF_BROADCAST_RECV
S#define IP_SOF_BROADCAST_RECV           0
S#endif
S
S/**
S * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
S * out on the netif where it was received. This should only be used for
S * wireless networks.
S * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
S * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
S */
S#ifndef IP_FORWARD_ALLOW_TX_ON_RX_NETIF
S#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
S#endif
S
S/**
S * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
S * local TCP/UDP pcb (default==0). This can prevent creating predictable port
S * numbers after booting a device.
S */
S#ifndef LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS
S#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
S#endif
S
S/*
S   ----------------------------------
S   ---------- ICMP options ----------
S   ----------------------------------
S*/
S/**
S * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
S * Be careful, disable that make your product non-compliant to RFC1122
S */
S#ifndef LWIP_ICMP
S#define LWIP_ICMP                       1
S#endif
S
S/**
S * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
S */
S#ifndef ICMP_TTL
S#define ICMP_TTL                       (IP_DEFAULT_TTL)
S#endif
S
S/**
S * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
S */
S#ifndef LWIP_BROADCAST_PING
S#define LWIP_BROADCAST_PING             0
S#endif
S
S/**
S * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
S */
S#ifndef LWIP_MULTICAST_PING
S#define LWIP_MULTICAST_PING             0
S#endif
S
S/*
S   ---------------------------------
S   ---------- RAW options ----------
S   ---------------------------------
S*/
S/**
S * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
S */
S#ifndef LWIP_RAW
S#define LWIP_RAW                        1
S#endif
S
S/**
S * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
S */
S#ifndef RAW_TTL
S#define RAW_TTL                        (IP_DEFAULT_TTL)
S#endif
S
S/*
S   ----------------------------------
S   ---------- DHCP options ----------
S   ----------------------------------
S*/
S/**
S * LWIP_DHCP==1: Enable DHCP module.
S */
S#ifndef LWIP_DHCP
S#define LWIP_DHCP                       0
S#endif
S
S/**
S * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
S */
S#ifndef DHCP_DOES_ARP_CHECK
S#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
S#endif
S
S/*
S   ------------------------------------
S   ---------- AUTOIP options ----------
S   ------------------------------------
S*/
S/**
S * LWIP_AUTOIP==1: Enable AUTOIP module.
S */
S#ifndef LWIP_AUTOIP
S#define LWIP_AUTOIP                     0
S#endif
S
S/**
S * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
S * the same interface at the same time.
S */
S#ifndef LWIP_DHCP_AUTOIP_COOP
S#define LWIP_DHCP_AUTOIP_COOP           0
S#endif
S
S/**
S * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
S * that should be sent before falling back on AUTOIP. This can be set
S * as low as 1 to get an AutoIP address very quickly, but you should
S * be prepared to handle a changing IP address when DHCP overrides
S * AutoIP.
S */
S#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
S#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
S#endif
S
S/*
S   ----------------------------------
S   ---------- SNMP options ----------
S   ----------------------------------
S*/
S/**
S * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
S * transport.
S */
S#ifndef LWIP_SNMP
S#define LWIP_SNMP                       0
S#endif
S
S/**
S * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
S * allow. At least one request buffer is required.
S * Does not have to be changed unless external MIBs answer request asynchronously
S */
S#ifndef SNMP_CONCURRENT_REQUESTS
S#define SNMP_CONCURRENT_REQUESTS        1
S#endif
S
S/**
S * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
S * destination is required
S */
S#ifndef SNMP_TRAP_DESTINATIONS
S#define SNMP_TRAP_DESTINATIONS          1
S#endif
S
S/**
S * SNMP_PRIVATE_MIB: 
S * When using a private MIB, you have to create a file 'private_mib.h' that contains
S * a 'struct mib_array_node mib_private' which contains your MIB.
S */
S#ifndef SNMP_PRIVATE_MIB
S#define SNMP_PRIVATE_MIB                0
S#endif
S
S/**
S * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
S * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
S * Unsafe requests are disabled by default!
S */
S#ifndef SNMP_SAFE_REQUESTS
S#define SNMP_SAFE_REQUESTS              1
S#endif
S
S/**
S * The maximum length of strings used. This affects the size of
S * MEMP_SNMP_VALUE elements.
S */
S#ifndef SNMP_MAX_OCTET_STRING_LEN
S#define SNMP_MAX_OCTET_STRING_LEN       127
S#endif
S
S/**
S * The maximum depth of the SNMP tree.
S * With private MIBs enabled, this depends on your MIB!
S * This affects the size of MEMP_SNMP_VALUE elements.
S */
S#ifndef SNMP_MAX_TREE_DEPTH
S#define SNMP_MAX_TREE_DEPTH             15
S#endif
S
S/**
S * The size of the MEMP_SNMP_VALUE elements, normally calculated from
S * SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
S */
S#ifndef SNMP_MAX_VALUE_SIZE
S#define SNMP_MAX_VALUE_SIZE             LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN)+1, sizeof(s32_t)*(SNMP_MAX_TREE_DEPTH))
S#endif
S
S/*
S   ----------------------------------
S   ---------- IGMP options ----------
S   ----------------------------------
S*/
S/**
S * LWIP_IGMP==1: Turn on IGMP module. 
S */
S#ifndef LWIP_IGMP
S#define LWIP_IGMP                       1
S#endif
S
S/*
S   ----------------------------------
S   ---------- DNS options -----------
S   ----------------------------------
S*/
S/**
S * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
S * transport.
S */
S#ifndef LWIP_DNS
S#define LWIP_DNS                        0
S#endif
S
S/** DNS maximum number of entries to maintain locally. */
S#ifndef DNS_TABLE_SIZE
S#define DNS_TABLE_SIZE                  4
S#endif
S
S/** DNS maximum host name length supported in the name table. */
S#ifndef DNS_MAX_NAME_LENGTH
S#define DNS_MAX_NAME_LENGTH             256
S#endif
S
S/** The maximum of DNS servers */
S#ifndef DNS_MAX_SERVERS
S#define DNS_MAX_SERVERS                 2
S#endif
S
S/** DNS do a name checking between the query and the response. */
S#ifndef DNS_DOES_NAME_CHECK
S#define DNS_DOES_NAME_CHECK             1
S#endif
S
S/** DNS message max. size. Default value is RFC compliant. */
S#ifndef DNS_MSG_SIZE
S#define DNS_MSG_SIZE                    512
S#endif
S
S/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
S *  you have to define
S *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
S *  (an array of structs name/address, where address is an u32_t in network
S *  byte order).
S *
S *  Instead, you can also use an external function:
S *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
S *  that returns the IP address or INADDR_NONE if not found.
S */
S#ifndef DNS_LOCAL_HOSTLIST
S#define DNS_LOCAL_HOSTLIST              0
S#endif /* DNS_LOCAL_HOSTLIST */
S
S/** If this is turned on, the local host-list can be dynamically changed
S *  at runtime. */
S#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
S#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
S#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
S
S/*
S   ---------------------------------
S   ---------- UDP options ----------
S   ---------------------------------
S*/
S/**
S * LWIP_UDP==1: Turn on UDP.
S */
S#ifndef LWIP_UDP
S#define LWIP_UDP                        1
S#endif
S
S/**
S * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
S */
S#ifndef LWIP_UDPLITE
S#define LWIP_UDPLITE                    0
S#endif
S
S/**
S * UDP_TTL: Default Time-To-Live value.
S */
S#ifndef UDP_TTL
S#define UDP_TTL                         (IP_DEFAULT_TTL)
S#endif
S
S/**
S * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
S */
S#ifndef LWIP_NETBUF_RECVINFO
S#define LWIP_NETBUF_RECVINFO            0
S#endif
S
S/*
S   ---------------------------------
S   ---------- TCP options ----------
S   ---------------------------------
S*/
S/**
S * LWIP_TCP==1: Turn on TCP.
S */
S#ifndef LWIP_TCP
S#define LWIP_TCP                        1
S#endif
S
S/**
S * TCP_TTL: Default Time-To-Live value.
S */
S#ifndef TCP_TTL
S#define TCP_TTL                         (IP_DEFAULT_TTL)
S#endif
S
S/**
S * TCP_WND: The size of a TCP window.  This must be at least 
S * (2 * TCP_MSS) for things to work well
S */
S#ifndef TCP_WND
S#define TCP_WND                         (4 * TCP_MSS)
S#endif 
S
S/**
S * TCP_MAXRTX: Maximum number of retransmissions of data segments.
S */
S#ifndef TCP_MAXRTX
S#define TCP_MAXRTX                      12
S#endif
S
S/**
S * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
S */
S#ifndef TCP_SYNMAXRTX
S#define TCP_SYNMAXRTX                   6
S#endif
S
S/**
S * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
S * Define to 0 if your device is low on memory.
S */
S#ifndef TCP_QUEUE_OOSEQ
S#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
S#endif
S
S/**
S * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
S * you might want to increase this.)
S * For the receive side, this MSS is advertised to the remote side
S * when opening a connection. For the transmit size, this MSS sets
S * an upper limit on the MSS advertised by the remote host.
S */
S#ifndef TCP_MSS
S#define TCP_MSS                         536
S#endif
S
S/**
S * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
S * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
S * reflects the available reassembly buffer size at the remote host) and the
S * largest size permitted by the IP layer" (RFC 1122)
S * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
S * netif used for a connection and limits the MSS if it would be too big otherwise.
S */
S#ifndef TCP_CALCULATE_EFF_SEND_MSS
S#define TCP_CALCULATE_EFF_SEND_MSS      1
S#endif
S
S
S/**
S * TCP_SND_BUF: TCP sender buffer space (bytes).
S * To achieve good performance, this should be at least 2 * TCP_MSS.
S */
S#ifndef TCP_SND_BUF
S#define TCP_SND_BUF                     (2 * TCP_MSS)
S#endif
S
S/**
S * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
S * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
S */
S#ifndef TCP_SND_QUEUELEN
S#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
S#endif
S
S/**
S * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
S * TCP_SND_BUF. It is the amount of space which must be available in the
S * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
S */
S#ifndef TCP_SNDLOWAT
S#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
S#endif
S
S/**
S * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
S * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
S * this number, select returns writable (combined with TCP_SNDLOWAT).
S */
S#ifndef TCP_SNDQUEUELOWAT
S#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
S#endif
S
S/**
S * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
S * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
S */
S#ifndef TCP_OOSEQ_MAX_BYTES
S#define TCP_OOSEQ_MAX_BYTES             0
S#endif
S
S/**
S * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
S * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
S */
S#ifndef TCP_OOSEQ_MAX_PBUFS
S#define TCP_OOSEQ_MAX_PBUFS             0
S#endif
S
S/**
S * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
S */
S#ifndef TCP_LISTEN_BACKLOG
S#define TCP_LISTEN_BACKLOG              1
S#endif
S
S/**
S * The maximum allowed backlog for TCP listen netconns.
S * This backlog is used unless another is explicitly specified.
S * 0xff is the maximum (u8_t).
S */
S#ifndef TCP_DEFAULT_LISTEN_BACKLOG
S#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
S#endif
S
S/**
S * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
S * allocate ahead of time in an attempt to create shorter pbuf chains
S * for transmission. The meaningful range is 0 to TCP_MSS. Some
S * suggested values are:
S *
S * 0:         Disable oversized allocation. Each tcp_write() allocates a new
S              pbuf (old behaviour).
S * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
S *            scatter-gather DMA requires aligned fragments.
S * 128:       Limit the pbuf/memory overhead to 20%.
S * TCP_MSS:   Try to create unfragmented TCP packets.
S * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
S */
S#ifndef TCP_OVERSIZE
S#define TCP_OVERSIZE                    TCP_MSS
S#endif
S
S/**
S * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
S */
S#ifndef LWIP_TCP_TIMESTAMPS
S#define LWIP_TCP_TIMESTAMPS             0
S#endif
S
S/**
S * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
S * explicit window update
S */
S#ifndef TCP_WND_UPDATE_THRESHOLD
S#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
S#endif
S
S/**
S * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
S *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
S *         events (accept, sent, etc) that happen in the system.
S *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
S *         for the event. This is the default.
S */
S#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API)
S#define LWIP_EVENT_API                  0
S#define LWIP_CALLBACK_API               1
S#endif
S
S
S/*
S   ----------------------------------
S   ---------- Pbuf options ----------
S   ----------------------------------
S*/
S/**
S * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
S * link level header. The default is 14, the standard value for
S * Ethernet.
S */
S#ifndef PBUF_LINK_HLEN
S#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
S#endif
S
S/**
S * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
S * designed to accomodate single full size TCP frame in one pbuf, including
S * TCP_MSS, IP header, and link header.
S */
S#ifndef PBUF_POOL_BUFSIZE
S#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
S#endif
S
S/*
S   ------------------------------------------------
S   ---------- Network Interfaces options ----------
S   ------------------------------------------------
S*/
S/**
S * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
S * field.
S */
S#ifndef LWIP_NETIF_HOSTNAME
S#define LWIP_NETIF_HOSTNAME             0
S#endif
S
S/**
S * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
S */
S#ifndef LWIP_NETIF_API
S#define LWIP_NETIF_API                  0
S#endif
S
S/**
S * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
S * changes its up/down status (i.e., due to DHCP IP acquistion)
S */
S#ifndef LWIP_NETIF_STATUS_CALLBACK
S#define LWIP_NETIF_STATUS_CALLBACK      0
S#endif
S
S/**
S * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
S * whenever the link changes (i.e., link down)
S */
S#ifndef LWIP_NETIF_LINK_CALLBACK
S#define LWIP_NETIF_LINK_CALLBACK        0
S#endif
S
S/**
S * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
S * when a netif has been removed
S */
S#ifndef LWIP_NETIF_REMOVE_CALLBACK
S#define LWIP_NETIF_REMOVE_CALLBACK      0
S#endif
S
S/**
S * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
S * indices) in struct netif. TCP and UDP can make use of this to prevent
S * scanning the ARP table for every sent packet. While this is faster for big
S * ARP tables or many concurrent connections, it might be counterproductive
S * if you have a tiny ARP table or if there never are concurrent connections.
S */
S#ifndef LWIP_NETIF_HWADDRHINT
S#define LWIP_NETIF_HWADDRHINT           0
S#endif
S
S/**
S * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
S * address equal to the netif IP address, looping them back up the stack.
S */
S#ifndef LWIP_NETIF_LOOPBACK
S#define LWIP_NETIF_LOOPBACK             0
S#endif
S
S/**
S * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
S * sending for each netif (0 = disabled)
S */
S#ifndef LWIP_LOOPBACK_MAX_PBUFS
S#define LWIP_LOOPBACK_MAX_PBUFS         0
S#endif
S
S/**
S * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
S * the system, as netifs must change how they behave depending on this setting
S * for the LWIP_NETIF_LOOPBACK option to work.
S * Setting this is needed to avoid reentering non-reentrant functions like
S * tcp_input().
S *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
S *       multithreaded environment like tcpip.c. In this case, netif->input()
S *       is called directly.
S *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
S *       The packets are put on a list and netif_poll() must be called in
S *       the main application loop.
S */
S#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
S#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
S#endif
S
S/**
S * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
S * to be sent into one single pbuf. This is for compatibility with DMA-enabled
S * MACs that do not support scatter-gather.
S * Beware that this might involve CPU-memcpy before transmitting that would not
S * be needed without this flag! Use this only if you need to!
S *
S * @todo: TCP and IP-frag do not work with this, yet:
S */
S#ifndef LWIP_NETIF_TX_SINGLE_PBUF
S#define LWIP_NETIF_TX_SINGLE_PBUF             0
S#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
S
S/*
S   ------------------------------------
S   ---------- LOOPIF options ----------
S   ------------------------------------
S*/
S/**
S * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
S */
S#ifndef LWIP_HAVE_LOOPIF
S#define LWIP_HAVE_LOOPIF                0
S#endif
S
S/*
S   ------------------------------------
S   ---------- SLIPIF options ----------
S   ------------------------------------
S*/
S/**
S * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
S */
S#ifndef LWIP_HAVE_SLIPIF
S#define LWIP_HAVE_SLIPIF                0
S#endif
S
S/*
S   ------------------------------------
S   ---------- Thread options ----------
S   ------------------------------------
S*/
S/**
S * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
S */
S#ifndef TCPIP_THREAD_NAME
S#define TCPIP_THREAD_NAME              "tcpip_thread"
S#endif
S
S/**
S * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
S * The stack size value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef TCPIP_THREAD_STACKSIZE
S#define TCPIP_THREAD_STACKSIZE          0
S#endif
S
S/**
S * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
S * The priority value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef TCPIP_THREAD_PRIO
S#define TCPIP_THREAD_PRIO               1
S#endif
S
S/**
S * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
S * The queue size value itself is platform-dependent, but is passed to
S * sys_mbox_new() when tcpip_init is called.
S */
S#ifndef TCPIP_MBOX_SIZE
S#define TCPIP_MBOX_SIZE                 0
S#endif
S
S/**
S * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
S */
S#ifndef SLIPIF_THREAD_NAME
S#define SLIPIF_THREAD_NAME             "slipif_loop"
S#endif
S
S/**
S * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
S * The stack size value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef SLIPIF_THREAD_STACKSIZE
S#define SLIPIF_THREAD_STACKSIZE         0
S#endif
S
S/**
S * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
S * The priority value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef SLIPIF_THREAD_PRIO
S#define SLIPIF_THREAD_PRIO              1
S#endif
S
S/**
S * PPP_THREAD_NAME: The name assigned to the pppInputThread.
S */
S#ifndef PPP_THREAD_NAME
S#define PPP_THREAD_NAME                "pppInputThread"
S#endif
S
S/**
S * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
S * The stack size value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef PPP_THREAD_STACKSIZE
S#define PPP_THREAD_STACKSIZE            0
S#endif
S
S/**
S * PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
S * The priority value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef PPP_THREAD_PRIO
S#define PPP_THREAD_PRIO                 1
S#endif
S
S/**
S * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
S */
S#ifndef DEFAULT_THREAD_NAME
S#define DEFAULT_THREAD_NAME            "lwIP"
S#endif
S
S/**
S * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
S * The stack size value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef DEFAULT_THREAD_STACKSIZE
S#define DEFAULT_THREAD_STACKSIZE        0
S#endif
S
S/**
S * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
S * The priority value itself is platform-dependent, but is passed to
S * sys_thread_new() when the thread is created.
S */
S#ifndef DEFAULT_THREAD_PRIO
S#define DEFAULT_THREAD_PRIO             1
S#endif
S
S/**
S * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
S * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
S * to sys_mbox_new() when the recvmbox is created.
S */
S#ifndef DEFAULT_RAW_RECVMBOX_SIZE
S#define DEFAULT_RAW_RECVMBOX_SIZE       0
S#endif
S
S/**
S * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
S * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
S * to sys_mbox_new() when the recvmbox is created.
S */
S#ifndef DEFAULT_UDP_RECVMBOX_SIZE
S#define DEFAULT_UDP_RECVMBOX_SIZE       24
S#endif
S
S/**
S * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
S * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
S * to sys_mbox_new() when the recvmbox is created.
S */
S#ifndef DEFAULT_TCP_RECVMBOX_SIZE
S#define DEFAULT_TCP_RECVMBOX_SIZE       24
S#endif
S
S/**
S * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
S * The queue size value itself is platform-dependent, but is passed to
S * sys_mbox_new() when the acceptmbox is created.
S */
S#ifndef DEFAULT_ACCEPTMBOX_SIZE
S#define DEFAULT_ACCEPTMBOX_SIZE         16
S#endif
S
S/*
S   ----------------------------------------------
S   ---------- Sequential layer options ----------
S   ----------------------------------------------
S*/
S/**
S * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
S * Don't use it if you're not an active lwIP project member
S */
S#ifndef LWIP_TCPIP_CORE_LOCKING
S#define LWIP_TCPIP_CORE_LOCKING         0
S#endif
S
S/**
S * LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
S * Don't use it if you're not an active lwIP project member
S */
S#ifndef LWIP_TCPIP_CORE_LOCKING_INPUT
S#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
S#endif
S
S/**
S * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
S */
S#ifndef LWIP_NETCONN
S#define LWIP_NETCONN                    0
S#endif
S
S/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
S * timers running in tcpip_thread from another thread.
S */
S#ifndef LWIP_TCPIP_TIMEOUT
S#define LWIP_TCPIP_TIMEOUT              1
S#endif
S
S/*
S   ------------------------------------
S   ---------- Socket options ----------
S   ------------------------------------
S*/
S/**
S * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
S */
S#ifndef LWIP_SOCKET
S#define LWIP_SOCKET                     1
S#endif
S
S/**
S * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
S * (only used if you use sockets.c)
S */
S#ifndef LWIP_COMPAT_SOCKETS
S#define LWIP_COMPAT_SOCKETS             0
S#endif
S
S/**
S * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
S * Disable this option if you use a POSIX operating system that uses the same
S * names (read, write & close). (only used if you use sockets.c)
S */
S#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
S#define LWIP_POSIX_SOCKETS_IO_NAMES     1
S#endif
S
S/**
S * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
S * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
S * in seconds. (does not require sockets.c, and will affect tcp.c)
S */
S#ifndef LWIP_TCP_KEEPALIVE
S#define LWIP_TCP_KEEPALIVE              0
S#endif
S
S/**
S * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
S * SO_SNDTIMEO processing.
S */
S#ifndef LWIP_SO_SNDTIMEO
S#define LWIP_SO_SNDTIMEO                0
S#endif
S
S/**
S * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
S * SO_RCVTIMEO processing.
S */
S#ifndef LWIP_SO_RCVTIMEO
S#define LWIP_SO_RCVTIMEO                1
S#endif
S
S/**
S * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
S */
S#ifndef LWIP_SO_RCVBUF
S#define LWIP_SO_RCVBUF                  0
S#endif
S
S/**
S * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
S */
S#ifndef RECV_BUFSIZE_DEFAULT
S#define RECV_BUFSIZE_DEFAULT            INT_MAX
S#endif
S
S/**
S * SO_REUSE==1: Enable SO_REUSEADDR option.
S */
S#ifndef SO_REUSE
S#define SO_REUSE                        0
S#endif
S
S/**
S * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
S * to all local matches if SO_REUSEADDR is turned on.
S * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
S */
S#ifndef SO_REUSE_RXTOALL
S#define SO_REUSE_RXTOALL                0
S#endif
S
S/*
S   ----------------------------------------
S   ---------- Statistics options ----------
S   ----------------------------------------
S*/
S/**
S * LWIP_STATS==1: Enable statistics collection in lwip_stats.
S */
S#ifndef LWIP_STATS
S#define LWIP_STATS                      1
S#endif
S
S#if LWIP_STATS
S
S/**
S * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
S */
S#ifndef LWIP_STATS_DISPLAY
S#define LWIP_STATS_DISPLAY              0
S#endif
S
S/**
S * LINK_STATS==1: Enable link stats.
S */
S#ifndef LINK_STATS
S#define LINK_STATS                      1
S#endif
S
S/**
S * ETHARP_STATS==1: Enable etharp stats.
S */
S#ifndef ETHARP_STATS
S#define ETHARP_STATS                    (LWIP_ARP)
S#endif
S
S/**
S * IP_STATS==1: Enable IP stats.
S */
S#ifndef IP_STATS
S#define IP_STATS                        1
S#endif
S
S/**
S * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
S * on if using either frag or reass.
S */
S#ifndef IPFRAG_STATS
S#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
S#endif
S
S/**
S * ICMP_STATS==1: Enable ICMP stats.
S */
S#ifndef ICMP_STATS
S#define ICMP_STATS                      1
S#endif
S
S/**
S * IGMP_STATS==1: Enable IGMP stats.
S */
S#ifndef IGMP_STATS
S#define IGMP_STATS                      (LWIP_IGMP)
S#endif
S
S/**
S * UDP_STATS==1: Enable UDP stats. Default is on if
S * UDP enabled, otherwise off.
S */
S#ifndef UDP_STATS
S#define UDP_STATS                       (LWIP_UDP)
S#endif
S
S/**
S * TCP_STATS==1: Enable TCP stats. Default is on if TCP
S * enabled, otherwise off.
S */
S#ifndef TCP_STATS
S#define TCP_STATS                       (LWIP_TCP)
S#endif
S
S/**
S * MEM_STATS==1: Enable mem.c stats.
S */
S#ifndef MEM_STATS
S#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
S#endif
S
S/**
S * MEMP_STATS==1: Enable memp.c pool stats.
S */
S#ifndef MEMP_STATS
S#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
S#endif
S
S/**
S * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
S */
S#ifndef SYS_STATS
S#define SYS_STATS                       (NO_SYS == 0)
S#endif
S
S#else
S
S#define LINK_STATS                      0
S#define IP_STATS                        0
S#define IPFRAG_STATS                    0
S#define ICMP_STATS                      0
S#define IGMP_STATS                      0
S#define UDP_STATS                       0
S#define TCP_STATS                       0
S#define MEM_STATS                       0
S#define MEMP_STATS                      0
S#define SYS_STATS                       0
S#define LWIP_STATS_DISPLAY              0
S
S#endif /* LWIP_STATS */
S
S/*
S   ---------------------------------
S   ---------- PPP options ----------
S   ---------------------------------
S*/
S/**
S * PPP_SUPPORT==1: Enable PPP.
S */
S#ifndef PPP_SUPPORT
S#define PPP_SUPPORT                     0
S#endif
S
S/**
S * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
S */
S#ifndef PPPOE_SUPPORT
S#define PPPOE_SUPPORT                   0
S#endif
S
S/**
S * PPPOS_SUPPORT==1: Enable PPP Over Serial
S */
S#ifndef PPPOS_SUPPORT
S#define PPPOS_SUPPORT                   PPP_SUPPORT
S#endif
S
S#if PPP_SUPPORT
S
S/**
S * NUM_PPP: Max PPP sessions.
S */
S#ifndef NUM_PPP
S#define NUM_PPP                         1
S#endif
S
S/**
S * PAP_SUPPORT==1: Support PAP.
S */
S#ifndef PAP_SUPPORT
S#define PAP_SUPPORT                     0
S#endif
S
S/**
S * CHAP_SUPPORT==1: Support CHAP.
S */
S#ifndef CHAP_SUPPORT
S#define CHAP_SUPPORT                    0
S#endif
S
S/**
S * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef MSCHAP_SUPPORT
S#define MSCHAP_SUPPORT                  0
S#endif
S
S/**
S * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CBCP_SUPPORT
S#define CBCP_SUPPORT                    0
S#endif
S
S/**
S * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CCP_SUPPORT
S#define CCP_SUPPORT                     0
S#endif
S
S/**
S * VJ_SUPPORT==1: Support VJ header compression.
S */
S#ifndef VJ_SUPPORT
S#define VJ_SUPPORT                      0
S#endif
S
S/**
S * MD5_SUPPORT==1: Support MD5 (see also CHAP).
S */
S#ifndef MD5_SUPPORT
S#define MD5_SUPPORT                     0
S#endif
S
S/*
S * Timeouts
S */
S#ifndef FSM_DEFTIMEOUT
S#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
S#endif
S
S#ifndef FSM_DEFMAXTERMREQS
S#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXCONFREQS
S#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXNAKLOOPS
S#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
S#endif
S
S#ifndef UPAP_DEFTIMEOUT
S#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
S#endif
S
S#ifndef UPAP_DEFREQTIME
S#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
S#endif
S
S#ifndef CHAP_DEFTIMEOUT
S#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
S#endif
S
S#ifndef CHAP_DEFTRANSMITS
S#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
S#endif
S
S/* Interval in seconds between keepalive echo requests, 0 to disable. */
S#ifndef LCP_ECHOINTERVAL
S#define LCP_ECHOINTERVAL                0
S#endif
S
S/* Number of unanswered echo requests before failure. */
S#ifndef LCP_MAXECHOFAILS
S#define LCP_MAXECHOFAILS                3
S#endif
S
S/* Max Xmit idle time (in jiffies) before resend flag char. */
S#ifndef PPP_MAXIDLEFLAG
S#define PPP_MAXIDLEFLAG                 100
S#endif
S
S/*
S * Packet sizes
S *
S * Note - lcp shouldn't be allowed to negotiate stuff outside these
S *    limits.  See lcp.h in the pppd directory.
S * (XXX - these constants should simply be shared by lcp.c instead
S *    of living in lcp.h)
S */
S#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
S#ifndef PPP_MAXMTU
S/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
S#define PPP_MAXMTU                      1500 /* Largest MTU we allow */
S#endif
S#define PPP_MINMTU                      64
S#define PPP_MRU                         1500     /* default MRU = max length of info field */
S#define PPP_MAXMRU                      1500     /* Largest MRU we allow */
S#ifndef PPP_DEFMRU
S#define PPP_DEFMRU                      296             /* Try for this */
S#endif
S#define PPP_MINMRU                      128             /* No MRUs below this */
S
S#ifndef MAXNAMELEN
S#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
S#endif
S#ifndef MAXSECRETLEN
S#define MAXSECRETLEN                    256     /* max length of password or secret */
S#endif
S
S#endif /* PPP_SUPPORT */
S
S/*
S   --------------------------------------
S   ---------- Checksum options ----------
S   --------------------------------------
S*/
S/**
S * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
S */
S#ifndef CHECKSUM_GEN_IP
S#define CHECKSUM_GEN_IP                 1
S#endif
S 
S/**
S * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
S */
S#ifndef CHECKSUM_GEN_UDP
S#define CHECKSUM_GEN_UDP                1
S#endif
S 
S/**
S * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
S */
S#ifndef CHECKSUM_GEN_TCP
S#define CHECKSUM_GEN_TCP                1
S#endif
S
S/**
S * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
S */
S#ifndef CHECKSUM_GEN_ICMP
S#define CHECKSUM_GEN_ICMP               1
S#endif
S 
S/**
S * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
S */
S#ifndef CHECKSUM_CHECK_IP
S#define CHECKSUM_CHECK_IP               1
S#endif
S 
S/**
S * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
S */
S#ifndef CHECKSUM_CHECK_UDP
S#define CHECKSUM_CHECK_UDP              1
S#endif
S
S/**
S * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
S */
S#ifndef CHECKSUM_CHECK_TCP
S#define CHECKSUM_CHECK_TCP              1
S#endif
S
S/**
S * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
S * application buffers to pbufs.
S */
S#ifndef LWIP_CHECKSUM_ON_COPY
S#define LWIP_CHECKSUM_ON_COPY           0
S#endif
S
S/*
S   ---------------------------------------
S   ---------- Hook options ---------------
S   ---------------------------------------
S*/
S
S/* Hooks are undefined by default, define them to a function if you need them. */
S
S/**
S * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
S * - called from ip_input() (IPv4)
S * - pbuf: received struct pbuf passed to ip_input()
S * - input_netif: struct netif on which the packet has been received
S * Return values:
S * - 0: Hook has not consumed the packet, packet is processed as normal
S * - != 0: Hook has consumed the packet.
S * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
S * (i.e. free it when done).
S */
S
S/**
S * LWIP_HOOK_IP4_ROUTE(dest):
S * - called from ip_route() (IPv4)
S * - dest: destination IPv4 address
S * Returns the destination netif or NULL if no destination netif is found. In
S * that case, ip_route() continues as normal.
S */
S
S/*
S   ---------------------------------------
S   ---------- Debugging options ----------
S   ---------------------------------------
S*/
S/**
S * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
S * compared against this value. If it is smaller, then debugging
S * messages are written.
S */
S#ifndef LWIP_DBG_MIN_LEVEL
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
S#endif
S
S/**
S * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
S * debug messages of certain types.
S */
S#ifndef LWIP_DBG_TYPES_ON
S#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
S#endif
S
S/**
S * ETHARP_DEBUG: Enable debugging in etharp.c.
S */
S#ifndef ETHARP_DEBUG
S#define ETHARP_DEBUG                    LWIP_DBG_OFF
S#endif
S
S/**
S * NETIF_DEBUG: Enable debugging in netif.c.
S */
S#ifndef NETIF_DEBUG
S#define NETIF_DEBUG                     LWIP_DBG_OFF
S#endif
S
S/**
S * PBUF_DEBUG: Enable debugging in pbuf.c.
S */
S#ifndef PBUF_DEBUG
S#define PBUF_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * API_LIB_DEBUG: Enable debugging in api_lib.c.
S */
S#ifndef API_LIB_DEBUG
S#define API_LIB_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * API_MSG_DEBUG: Enable debugging in api_msg.c.
S */
S#ifndef API_MSG_DEBUG
S#define API_MSG_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * SOCKETS_DEBUG: Enable debugging in sockets.c.
S */
S#ifndef SOCKETS_DEBUG
S#define SOCKETS_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * ICMP_DEBUG: Enable debugging in icmp.c.
S */
S#ifndef ICMP_DEBUG
S#define ICMP_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * IGMP_DEBUG: Enable debugging in igmp.c.
S */
S#ifndef IGMP_DEBUG
S#define IGMP_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * INET_DEBUG: Enable debugging in inet.c.
S */
S#ifndef INET_DEBUG
S#define INET_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * IP_DEBUG: Enable debugging for IP.
S */
S#ifndef IP_DEBUG
S#define IP_DEBUG                        LWIP_DBG_OFF
S#endif
S
S/**
S * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
S */
S#ifndef IP_REASS_DEBUG
S#define IP_REASS_DEBUG                  LWIP_DBG_OFF
S#endif
S
S/**
S * RAW_DEBUG: Enable debugging in raw.c.
S */
S#ifndef RAW_DEBUG
S#define RAW_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * MEM_DEBUG: Enable debugging in mem.c.
S */
S#ifndef MEM_DEBUG
S#define MEM_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * MEMP_DEBUG: Enable debugging in memp.c.
S */
S#ifndef MEMP_DEBUG
S#define MEMP_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * SYS_DEBUG: Enable debugging in sys.c.
S */
S#ifndef SYS_DEBUG
S#define SYS_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * TIMERS_DEBUG: Enable debugging in timers.c.
S */
S#ifndef TIMERS_DEBUG
S#define TIMERS_DEBUG                    LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_DEBUG: Enable debugging for TCP.
S */
S#ifndef TCP_DEBUG
S#define TCP_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
S */
S#ifndef TCP_INPUT_DEBUG
S#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
S */
S#ifndef TCP_FR_DEBUG
S#define TCP_FR_DEBUG                    LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
S * timeout.
S */
S#ifndef TCP_RTO_DEBUG
S#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
S */
S#ifndef TCP_CWND_DEBUG
S#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
S */
S#ifndef TCP_WND_DEBUG
S#define TCP_WND_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
S */
S#ifndef TCP_OUTPUT_DEBUG
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
S */
S#ifndef TCP_RST_DEBUG
S#define TCP_RST_DEBUG                   LWIP_DBG_OFF
S#endif
S
S/**
S * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
S */
S#ifndef TCP_QLEN_DEBUG
S#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
S#endif
S
S/**
S * UDP_DEBUG: Enable debugging in UDP.
S */
S#ifndef UDP_DEBUG
S#define UDP_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * TCPIP_DEBUG: Enable debugging in tcpip.c.
S */
S#ifndef TCPIP_DEBUG
S#define TCPIP_DEBUG                     LWIP_DBG_OFF
S#endif
S
S/**
S * PPP_DEBUG: Enable debugging for PPP.
S */
S#ifndef PPP_DEBUG
S#define PPP_DEBUG                       LWIP_DBG_OFF
S#endif
S
S/**
S * SLIP_DEBUG: Enable debugging in slipif.c.
S */
S#ifndef SLIP_DEBUG
S#define SLIP_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * DHCP_DEBUG: Enable debugging in dhcp.c.
S */
S#ifndef DHCP_DEBUG
S#define DHCP_DEBUG                      LWIP_DBG_OFF
S#endif
S
S/**
S * AUTOIP_DEBUG: Enable debugging in autoip.c.
S */
S#ifndef AUTOIP_DEBUG
S#define AUTOIP_DEBUG                    LWIP_DBG_OFF
S#endif
S
S/**
S * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
S */
S#ifndef SNMP_MSG_DEBUG
S#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
S#endif
S
S/**
S * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
S */
S#ifndef SNMP_MIB_DEBUG
S#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
S#endif
S
S/**
S * DNS_DEBUG: Enable debugging for DNS.
S */
S#ifndef DNS_DEBUG
S#define DNS_DEBUG                       LWIP_DBG_OFF
S#endif
S
N#endif /* __LWIP_OPT_H__ */
L 37 ".\third_party\lwip-1.4.1\src\include\lwip/debug.h" 2
N
N/** lower two bits indicate debug level
N * - 0 all
N * - 1 warning
N * - 2 serious
N * - 3 severe
N */
N#define LWIP_DBG_LEVEL_ALL     0x00
N#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL /* compatibility define only */
N#define LWIP_DBG_LEVEL_WARNING 0x01 /* bad checksums, dropped packets, ... */
N#define LWIP_DBG_LEVEL_SERIOUS 0x02 /* memory allocation failures, ... */
N#define LWIP_DBG_LEVEL_SEVERE  0x03
N#define LWIP_DBG_MASK_LEVEL    0x03
N
N/** flag for LWIP_DEBUGF to enable that debug message */
N#define LWIP_DBG_ON            0x80U
N/** flag for LWIP_DEBUGF to disable that debug message */
N#define LWIP_DBG_OFF           0x00U
N
N/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
N#define LWIP_DBG_TRACE         0x40U
N/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
N#define LWIP_DBG_STATE         0x20U
N/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
N#define LWIP_DBG_FRESH         0x10U
N/** flag for LWIP_DEBUGF to halt after printing this debug message */
N#define LWIP_DBG_HALT          0x08U
N
N#ifndef LWIP_NOASSERT
N#define LWIP_ASSERT(message, assertion) do { if(!(assertion)) \
N  LWIP_PLATFORM_ASSERT(message); } while(0)
X#define LWIP_ASSERT(message, assertion) do { if(!(assertion))   LWIP_PLATFORM_ASSERT(message); } while(0)
N#else  /* LWIP_NOASSERT */
S#define LWIP_ASSERT(message, assertion) 
N#endif /* LWIP_NOASSERT */
N
N/** if "expression" isn't true, then print "message" and execute "handler" expression */
N#ifndef LWIP_ERROR
N#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
N  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
X#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) {   LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
N#endif /* LWIP_ERROR */
N
N#ifdef LWIP_DEBUG
N/** print debug message only if debug message type is enabled...
N *  AND is of correct type AND is at least LWIP_DBG_LEVEL
N */
N#define LWIP_DEBUGF(debug, message) do { \
N                               if ( \
N                                   ((debug) & LWIP_DBG_ON) && \
N                                   ((debug) & LWIP_DBG_TYPES_ON) && \
N                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
N                                 LWIP_PLATFORM_DIAG(message); \
N                                 if ((debug) & LWIP_DBG_HALT) { \
N                                   while(1); \
N                                 } \
N                               } \
N                             } while(0)
X#define LWIP_DEBUGF(debug, message) do {                                if (                                    ((debug) & LWIP_DBG_ON) &&                                    ((debug) & LWIP_DBG_TYPES_ON) &&                                    ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) {                                  LWIP_PLATFORM_DIAG(message);                                  if ((debug) & LWIP_DBG_HALT) {                                    while(1);                                  }                                }                              } while(0)
N
N#else  /* LWIP_DEBUG */
S#define LWIP_DEBUGF(debug, message) 
N#endif /* LWIP_DEBUG */
N
N#endif /* __LWIP_DEBUG_H__ */
N
L 47 ".\third_party\lwip-1.4.1\src\include\lwip/opt.h" 2
N
N/*
N   -----------------------------------------------
N   ---------- Platform specific locking ----------
N   -----------------------------------------------
N*/
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#ifndef SYS_LIGHTWEIGHT_PROT
S#define SYS_LIGHTWEIGHT_PROT            0
N#endif
N
N/** 
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#ifndef NO_SYS
S#define NO_SYS                          0
N#endif
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#ifndef NO_SYS_NO_TIMERS
N#define NO_SYS_NO_TIMERS                0
N#endif
N
N/**
N * MEMCPY: override this if you have a faster implementation at hand than the
N * one included in your C library
N */
N#ifndef MEMCPY
N#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
N#endif
N
N/**
N * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
N * call to memcpy() if the length is known at compile time and is small.
N */
N#ifndef SMEMCPY
N#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
N#endif
N
N/*
N   ------------------------------------
N   ---------- Memory options ----------
N   ------------------------------------
N*/
N/**
N * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
N * instead of the lwip internal allocator. Can save code size if you
N * already use it.
N */
N#ifndef MEM_LIBC_MALLOC
N#define MEM_LIBC_MALLOC                 0
N#endif
N
N/**
N* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
N* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
N* speed and usage from interrupts!
N*/
N#ifndef MEMP_MEM_MALLOC
N#define MEMP_MEM_MALLOC                 0
N#endif
N
N/**
N * MEM_ALIGNMENT: should be set to the alignment of the CPU
N *    4 byte alignment -> #define MEM_ALIGNMENT 4
N *    2 byte alignment -> #define MEM_ALIGNMENT 2
N */
N#ifndef MEM_ALIGNMENT
S#define MEM_ALIGNMENT                   1
N#endif
N
N/**
N * MEM_SIZE: the size of the heap memory. If the application will send
N * a lot of data that needs to be copied, this should be set high.
N */
N#ifndef MEM_SIZE
S#define MEM_SIZE                        1600
N#endif
N
N/**
N * MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
N * This can be used to individually change the location of each pool.
N * Default is one big array for all pools
N */
N#ifndef MEMP_SEPARATE_POOLS
N#define MEMP_SEPARATE_POOLS             0
N#endif
N
N/**
N * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
N * amount of bytes before and after each memp element in every pool and fills
N * it with a prominent default value.
N *    MEMP_OVERFLOW_CHECK == 0 no checking
N *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
N *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
N *      memp_malloc() or memp_free() is called (useful but slow!)
N */
N#ifndef MEMP_OVERFLOW_CHECK
N#define MEMP_OVERFLOW_CHECK             0
N#endif
N
N/**
N * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
N * sure that there are no cycles in the linked lists.
N */
N#ifndef MEMP_SANITY_CHECK
N#define MEMP_SANITY_CHECK               0
N#endif
N
N/**
N * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
N * of memory pools of various sizes. When mem_malloc is called, an element of
N * the smallest pool that can provide the length needed is returned.
N * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
N */
N#ifndef MEM_USE_POOLS
N#define MEM_USE_POOLS                   0
N#endif
N
N/**
N * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
N * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
N * reliable. */
N#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
N#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
N#endif
N
N/**
N * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
N * that defines additional pools beyond the "standard" ones required
N * by lwIP. If you set this to 1, you must have lwippools.h in your 
N * inlude path somewhere. 
N */
N#ifndef MEMP_USE_CUSTOM_POOLS
N#define MEMP_USE_CUSTOM_POOLS           0
N#endif
N
N/**
N * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
N * interrupt context (or another context that doesn't allow waiting for a
N * semaphore).
N * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
N * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
N * with each loop so that mem_free can run.
N *
N * ATTENTION: As you can see from the above description, this leads to dis-/
N * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
N * can need longer.
N *
N * If you don't want that, at least for NO_SYS=0, you can still use the following
N * functions to enqueue a deallocation call which then runs in the tcpip_thread
N * context:
N * - pbuf_free_callback(p);
N * - mem_free_callback(m);
N */
N#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
N#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Internal Memory Pool Sizes ----------
N   ------------------------------------------------
N*/
N/**
N * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
N * If the application sends a lot of data out of ROM (or other static memory),
N * this should be set high.
N */
N#ifndef MEMP_NUM_PBUF
S#define MEMP_NUM_PBUF                   16
N#endif
N
N/**
N * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
N * (requires the LWIP_RAW option)
N */
N#ifndef MEMP_NUM_RAW_PCB
N#define MEMP_NUM_RAW_PCB                4
N#endif
N
N/**
N * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N * per active UDP "connection".
N * (requires the LWIP_UDP option)
N */
N#ifndef MEMP_NUM_UDP_PCB
N#define MEMP_NUM_UDP_PCB                4
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB
S#define MEMP_NUM_TCP_PCB                5
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB_LISTEN
N#define MEMP_NUM_TCP_PCB_LISTEN         8
N#endif
N
N/**
N * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_SEG
S#define MEMP_NUM_TCP_SEG                16
N#endif
N
N/**
N * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
N * reassembly (whole packets, not fragments!)
N */
N#ifndef MEMP_NUM_REASSDATA
N#define MEMP_NUM_REASSDATA              5
N#endif
N
N/**
N * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
N * (fragments, not whole packets!).
N * This is only used with IP_FRAG_USES_STATIC_BUF==0 and
N * LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
N * where the packet is not yet sent when netif->output returns.
N */
N#ifndef MEMP_NUM_FRAG_PBUF
N#define MEMP_NUM_FRAG_PBUF              15
N#endif
N
N/**
N * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
N * packets (pbufs) that are waiting for an ARP request (to resolve
N * their destination address) to finish.
N * (requires the ARP_QUEUEING option)
N */
N#ifndef MEMP_NUM_ARP_QUEUE
N#define MEMP_NUM_ARP_QUEUE              30
N#endif
N
N/**
N * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
N * can be members et the same time (one per netif - allsystems group -, plus one
N * per netif membership).
N * (requires the LWIP_IGMP option)
N */
N#ifndef MEMP_NUM_IGMP_GROUP
N#define MEMP_NUM_IGMP_GROUP             8
N#endif
N
N/**
N * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
N * (requires NO_SYS==0)
N * The default number of timeouts is calculated here for all enabled modules.
N * The formula expects settings to be either '0' or '1'.
N */
N#ifndef MEMP_NUM_SYS_TIMEOUT
S#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
N#endif
N
N/**
N * MEMP_NUM_NETBUF: the number of struct netbufs.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETBUF
N#define MEMP_NUM_NETBUF                 16
N#endif
N
N/**
N * MEMP_NUM_NETCONN: the number of struct netconns.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETCONN
N#define MEMP_NUM_NETCONN                16
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
N * for callback/timeout API communication. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_API
N#define MEMP_NUM_TCPIP_MSG_API          8
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
N * for incoming packets. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_INPKT
N#define MEMP_NUM_TCPIP_MSG_INPKT        8
N#endif
N
N/**
N * MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
N */
N#ifndef MEMP_NUM_SNMP_NODE
N#define MEMP_NUM_SNMP_NODE              50
N#endif
N
N/**
N * MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
N * Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
N */
N#ifndef MEMP_NUM_SNMP_ROOTNODE
N#define MEMP_NUM_SNMP_ROOTNODE          30
N#endif
N
N/**
N * MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
N * be changed normally) - 2 of these are used per request (1 for input,
N * 1 for output)
N */
N#ifndef MEMP_NUM_SNMP_VARBIND
N#define MEMP_NUM_SNMP_VARBIND           2
N#endif
N
N/**
N * MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
N * (does not have to be changed normally) - 3 of these are used per request
N * (1 for the value read and 2 for OIDs - input and output)
N */
N#ifndef MEMP_NUM_SNMP_VALUE
N#define MEMP_NUM_SNMP_VALUE             3
N#endif
N
N/**
N * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
N * (before freeing the corresponding memory using lwip_freeaddrinfo()).
N */
N#ifndef MEMP_NUM_NETDB
N#define MEMP_NUM_NETDB                  1
N#endif
N
N/**
N * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
N * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
N */
N#ifndef MEMP_NUM_LOCALHOSTLIST
N#define MEMP_NUM_LOCALHOSTLIST          1
N#endif
N
N/**
N * MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
N * interfaces (only used with PPPOE_SUPPORT==1)
N */
N#ifndef MEMP_NUM_PPPOE_INTERFACES
N#define MEMP_NUM_PPPOE_INTERFACES       1
N#endif
N
N/**
N * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
N */
N#ifndef PBUF_POOL_SIZE
S#define PBUF_POOL_SIZE                  16
N#endif
N
N/*
N   ---------------------------------
N   ---------- ARP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_ARP==1: Enable ARP functionality.
N */
N#ifndef LWIP_ARP
N#define LWIP_ARP                        1
N#endif
N
N/**
N * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
N */
N#ifndef ARP_TABLE_SIZE
N#define ARP_TABLE_SIZE                  10
N#endif
N
N/**
N * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
N * resolution. By default, only the most recent packet is queued per IP address.
N * This is sufficient for most protocols and mainly reduces TCP connection
N * startup time. Set this to 1 if you know your application sends more than one
N * packet in a row to an IP address that is not in the ARP cache.
N */
N#ifndef ARP_QUEUEING
N#define ARP_QUEUEING                    0
N#endif
N
N/**
N * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
N * updated with the source MAC and IP addresses supplied in the packet.
N * You may want to disable this if you do not trust LAN peers to have the
N * correct addresses, or as a limited approach to attempt to handle
N * spoofing. If disabled, lwIP will need to make a new ARP request if
N * the peer is not already in the ARP table, adding a little latency.
N * The peer *is* in the ARP table if it requested our address before.
N * Also notice that this slows down input processing of every IP packet!
N */
N#ifndef ETHARP_TRUST_IP_MAC
N#define ETHARP_TRUST_IP_MAC             0
N#endif
N
N/**
N * ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
N * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
N * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
N * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
N * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
N * that returns 1 to accept a packet or 0 to drop a packet.
N */
N#ifndef ETHARP_SUPPORT_VLAN
N#define ETHARP_SUPPORT_VLAN             0
N#endif
N
N/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
N * might be disabled
N */
N#ifndef LWIP_ETHERNET
N#define LWIP_ETHERNET                   (LWIP_ARP || PPPOE_SUPPORT)
N#endif
N
N/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
N * alignment of payload after that header. Since the header is 14 bytes long,
N * without this padding e.g. addresses in the IP header will not be aligned
N * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
N */
N#ifndef ETH_PAD_SIZE
S#define ETH_PAD_SIZE                    0
N#endif
N
N/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
N * entries (using etharp_add_static_entry/etharp_remove_static_entry).
N */
N#ifndef ETHARP_SUPPORT_STATIC_ENTRIES
N#define ETHARP_SUPPORT_STATIC_ENTRIES   0
N#endif
N
N
N/*
N   --------------------------------
N   ---------- IP options ----------
N   --------------------------------
N*/
N/**
N * IP_FORWARD==1: Enables the ability to forward IP packets across network
N * interfaces. If you are going to run lwIP on a device with only one network
N * interface, define this to 0.
N */
N#ifndef IP_FORWARD
N#define IP_FORWARD                      0
N#endif
N
N/**
N * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
N *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
N *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
N */
N#ifndef IP_OPTIONS_ALLOWED
N#define IP_OPTIONS_ALLOWED              1
N#endif
N
N/**
N * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
N * this option does not affect outgoing packet sizes, which can be controlled
N * via IP_FRAG.
N */
N#ifndef IP_REASSEMBLY
S#define IP_REASSEMBLY                   1
N#endif
N
N/**
N * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
N * that this option does not affect incoming packet sizes, which can be
N * controlled via IP_REASSEMBLY.
N */
N#ifndef IP_FRAG
S#define IP_FRAG                         1
N#endif
N
N/**
N * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
N * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
N * in this time, the whole packet is discarded.
N */
N#ifndef IP_REASS_MAXAGE
N#define IP_REASS_MAXAGE                 3
N#endif
N
N/**
N * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
N * Since the received pbufs are enqueued, be sure to configure
N * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
N * packets even if the maximum amount of fragments is enqueued for reassembly!
N */
N#ifndef IP_REASS_MAX_PBUFS
N#define IP_REASS_MAX_PBUFS              10
N#endif
N
N/**
N * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
N * fragmentation. Otherwise pbufs are allocated and reference the original
N * packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
N * new PBUF_RAM pbufs are used for fragments).
N * ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
N */
N#ifndef IP_FRAG_USES_STATIC_BUF
N#define IP_FRAG_USES_STATIC_BUF         0
N#endif
N
N/**
N * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
N * (requires IP_FRAG_USES_STATIC_BUF==1)
N */
N#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
X#if 0 && !0L
S#define IP_FRAG_MAX_MTU                 1500
N#endif
N
N/**
N * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
N */
N#ifndef IP_DEFAULT_TTL
N#define IP_DEFAULT_TTL                  255
N#endif
N
N/**
N * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
N * filter per pcb on udp and raw send operations. To enable broadcast filter
N * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
N */
N#ifndef IP_SOF_BROADCAST
N#define IP_SOF_BROADCAST                0
N#endif
N
N/**
N * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
N * filter on recv operations.
N */
N#ifndef IP_SOF_BROADCAST_RECV
N#define IP_SOF_BROADCAST_RECV           0
N#endif
N
N/**
N * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
N * out on the netif where it was received. This should only be used for
N * wireless networks.
N * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
N * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
N */
N#ifndef IP_FORWARD_ALLOW_TX_ON_RX_NETIF
N#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
N#endif
N
N/**
N * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
N * local TCP/UDP pcb (default==0). This can prevent creating predictable port
N * numbers after booting a device.
N */
N#ifndef LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS
N#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
N#endif
N
N/*
N   ----------------------------------
N   ---------- ICMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
N * Be careful, disable that make your product non-compliant to RFC1122
N */
N#ifndef LWIP_ICMP
N#define LWIP_ICMP                       1
N#endif
N
N/**
N * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
N */
N#ifndef ICMP_TTL
N#define ICMP_TTL                       (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
N */
N#ifndef LWIP_BROADCAST_PING
N#define LWIP_BROADCAST_PING             0
N#endif
N
N/**
N * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
N */
N#ifndef LWIP_MULTICAST_PING
N#define LWIP_MULTICAST_PING             0
N#endif
N
N/*
N   ---------------------------------
N   ---------- RAW options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef LWIP_RAW
N#define LWIP_RAW                        1
N#endif
N
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef RAW_TTL
N#define RAW_TTL                        (IP_DEFAULT_TTL)
N#endif
N
N/*
N   ----------------------------------
N   ---------- DHCP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_DHCP==1: Enable DHCP module.
N */
N#ifndef LWIP_DHCP
S#define LWIP_DHCP                       0
N#endif
N
N/**
N * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
N */
N#ifndef DHCP_DOES_ARP_CHECK
N#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
N#endif
N
N/*
N   ------------------------------------
N   ---------- AUTOIP options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_AUTOIP==1: Enable AUTOIP module.
N */
N#ifndef LWIP_AUTOIP
S#define LWIP_AUTOIP                     0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
N * the same interface at the same time.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP
S#define LWIP_DHCP_AUTOIP_COOP           0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
N * that should be sent before falling back on AUTOIP. This can be set
N * as low as 1 to get an AutoIP address very quickly, but you should
N * be prepared to handle a changing IP address when DHCP overrides
N * AutoIP.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
S#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
N#endif
N
N/*
N   ----------------------------------
N   ---------- SNMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
N * transport.
N */
N#ifndef LWIP_SNMP
N#define LWIP_SNMP                       0
N#endif
N
N/**
N * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
N * allow. At least one request buffer is required.
N * Does not have to be changed unless external MIBs answer request asynchronously
N */
N#ifndef SNMP_CONCURRENT_REQUESTS
N#define SNMP_CONCURRENT_REQUESTS        1
N#endif
N
N/**
N * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
N * destination is required
N */
N#ifndef SNMP_TRAP_DESTINATIONS
N#define SNMP_TRAP_DESTINATIONS          1
N#endif
N
N/**
N * SNMP_PRIVATE_MIB: 
N * When using a private MIB, you have to create a file 'private_mib.h' that contains
N * a 'struct mib_array_node mib_private' which contains your MIB.
N */
N#ifndef SNMP_PRIVATE_MIB
N#define SNMP_PRIVATE_MIB                0
N#endif
N
N/**
N * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
N * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
N * Unsafe requests are disabled by default!
N */
N#ifndef SNMP_SAFE_REQUESTS
N#define SNMP_SAFE_REQUESTS              1
N#endif
N
N/**
N * The maximum length of strings used. This affects the size of
N * MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_OCTET_STRING_LEN
N#define SNMP_MAX_OCTET_STRING_LEN       127
N#endif
N
N/**
N * The maximum depth of the SNMP tree.
N * With private MIBs enabled, this depends on your MIB!
N * This affects the size of MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_TREE_DEPTH
N#define SNMP_MAX_TREE_DEPTH             15
N#endif
N
N/**
N * The size of the MEMP_SNMP_VALUE elements, normally calculated from
N * SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
N */
N#ifndef SNMP_MAX_VALUE_SIZE
N#define SNMP_MAX_VALUE_SIZE             LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN)+1, sizeof(s32_t)*(SNMP_MAX_TREE_DEPTH))
N#endif
N
N/*
N   ----------------------------------
N   ---------- IGMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_IGMP==1: Turn on IGMP module. 
N */
N#ifndef LWIP_IGMP
N#define LWIP_IGMP                       1
N#endif
N
N/*
N   ----------------------------------
N   ---------- DNS options -----------
N   ----------------------------------
N*/
N/**
N * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
N * transport.
N */
N#ifndef LWIP_DNS
N#define LWIP_DNS                        0
N#endif
N
N/** DNS maximum number of entries to maintain locally. */
N#ifndef DNS_TABLE_SIZE
N#define DNS_TABLE_SIZE                  4
N#endif
N
N/** DNS maximum host name length supported in the name table. */
N#ifndef DNS_MAX_NAME_LENGTH
N#define DNS_MAX_NAME_LENGTH             256
N#endif
N
N/** The maximum of DNS servers */
N#ifndef DNS_MAX_SERVERS
N#define DNS_MAX_SERVERS                 2
N#endif
N
N/** DNS do a name checking between the query and the response. */
N#ifndef DNS_DOES_NAME_CHECK
N#define DNS_DOES_NAME_CHECK             1
N#endif
N
N/** DNS message max. size. Default value is RFC compliant. */
N#ifndef DNS_MSG_SIZE
N#define DNS_MSG_SIZE                    512
N#endif
N
N/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
N *  you have to define
N *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
N *  (an array of structs name/address, where address is an u32_t in network
N *  byte order).
N *
N *  Instead, you can also use an external function:
N *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
N *  that returns the IP address or INADDR_NONE if not found.
N */
N#ifndef DNS_LOCAL_HOSTLIST
N#define DNS_LOCAL_HOSTLIST              0
N#endif /* DNS_LOCAL_HOSTLIST */
N
N/** If this is turned on, the local host-list can be dynamically changed
N *  at runtime. */
N#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
N#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
N#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N
N/*
N   ---------------------------------
N   ---------- UDP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_UDP==1: Turn on UDP.
N */
N#ifndef LWIP_UDP
N#define LWIP_UDP                        1
N#endif
N
N/**
N * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
N */
N#ifndef LWIP_UDPLITE
N#define LWIP_UDPLITE                    0
N#endif
N
N/**
N * UDP_TTL: Default Time-To-Live value.
N */
N#ifndef UDP_TTL
N#define UDP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
N */
N#ifndef LWIP_NETBUF_RECVINFO
N#define LWIP_NETBUF_RECVINFO            0
N#endif
N
N/*
N   ---------------------------------
N   ---------- TCP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_TCP==1: Turn on TCP.
N */
N#ifndef LWIP_TCP
N#define LWIP_TCP                        1
N#endif
N
N/**
N * TCP_TTL: Default Time-To-Live value.
N */
N#ifndef TCP_TTL
N#define TCP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * TCP_WND: The size of a TCP window.  This must be at least 
N * (2 * TCP_MSS) for things to work well
N */
N#ifndef TCP_WND
S#define TCP_WND                         (4 * TCP_MSS)
N#endif 
N
N/**
N * TCP_MAXRTX: Maximum number of retransmissions of data segments.
N */
N#ifndef TCP_MAXRTX
N#define TCP_MAXRTX                      12
N#endif
N
N/**
N * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
N */
N#ifndef TCP_SYNMAXRTX
N#define TCP_SYNMAXRTX                   6
N#endif
N
N/**
N * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
N * Define to 0 if your device is low on memory.
N */
N#ifndef TCP_QUEUE_OOSEQ
N#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
N#endif
N
N/**
N * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
N * you might want to increase this.)
N * For the receive side, this MSS is advertised to the remote side
N * when opening a connection. For the transmit size, this MSS sets
N * an upper limit on the MSS advertised by the remote host.
N */
N#ifndef TCP_MSS
S#define TCP_MSS                         536
N#endif
N
N/**
N * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
N * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
N * reflects the available reassembly buffer size at the remote host) and the
N * largest size permitted by the IP layer" (RFC 1122)
N * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
N * netif used for a connection and limits the MSS if it would be too big otherwise.
N */
N#ifndef TCP_CALCULATE_EFF_SEND_MSS
N#define TCP_CALCULATE_EFF_SEND_MSS      1
N#endif
N
N
N/**
N * TCP_SND_BUF: TCP sender buffer space (bytes).
N * To achieve good performance, this should be at least 2 * TCP_MSS.
N */
N#ifndef TCP_SND_BUF
S#define TCP_SND_BUF                     (2 * TCP_MSS)
N#endif
N
N/**
N * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
N */
N#ifndef TCP_SND_QUEUELEN
N#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
N#endif
N
N/**
N * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
N * TCP_SND_BUF. It is the amount of space which must be available in the
N * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
N */
N#ifndef TCP_SNDLOWAT
N#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
N#endif
N
N/**
N * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
N * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
N * this number, select returns writable (combined with TCP_SNDLOWAT).
N */
N#ifndef TCP_SNDQUEUELOWAT
N#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
N#endif
N
N/**
N * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_BYTES
N#define TCP_OOSEQ_MAX_BYTES             0
N#endif
N
N/**
N * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_PBUFS
N#define TCP_OOSEQ_MAX_PBUFS             0
N#endif
N
N/**
N * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
N */
N#ifndef TCP_LISTEN_BACKLOG
N#define TCP_LISTEN_BACKLOG              1
N#endif
N
N/**
N * The maximum allowed backlog for TCP listen netconns.
N * This backlog is used unless another is explicitly specified.
N * 0xff is the maximum (u8_t).
N */
N#ifndef TCP_DEFAULT_LISTEN_BACKLOG
N#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
N#endif
N
N/**
N * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
N * allocate ahead of time in an attempt to create shorter pbuf chains
N * for transmission. The meaningful range is 0 to TCP_MSS. Some
N * suggested values are:
N *
N * 0:         Disable oversized allocation. Each tcp_write() allocates a new
N              pbuf (old behaviour).
N * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
N *            scatter-gather DMA requires aligned fragments.
N * 128:       Limit the pbuf/memory overhead to 20%.
N * TCP_MSS:   Try to create unfragmented TCP packets.
N * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
N */
N#ifndef TCP_OVERSIZE
N#define TCP_OVERSIZE                    TCP_MSS
N#endif
N
N/**
N * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
N */
N#ifndef LWIP_TCP_TIMESTAMPS
N#define LWIP_TCP_TIMESTAMPS             0
N#endif
N
N/**
N * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
N * explicit window update
N */
N#ifndef TCP_WND_UPDATE_THRESHOLD
N#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
N#endif
N
N/**
N * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
N *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
N *         events (accept, sent, etc) that happen in the system.
N *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
N *         for the event. This is the default.
N */
N#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API)
X#if !0L && !0L
N#define LWIP_EVENT_API                  0
N#define LWIP_CALLBACK_API               1
N#endif
N
N
N/*
N   ----------------------------------
N   ---------- Pbuf options ----------
N   ----------------------------------
N*/
N/**
N * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
N * link level header. The default is 14, the standard value for
N * Ethernet.
N */
N#ifndef PBUF_LINK_HLEN
S#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
N#endif
N
N/**
N * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
N * designed to accomodate single full size TCP frame in one pbuf, including
N * TCP_MSS, IP header, and link header.
N */
N#ifndef PBUF_POOL_BUFSIZE
S#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Network Interfaces options ----------
N   ------------------------------------------------
N*/
N/**
N * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
N * field.
N */
N#ifndef LWIP_NETIF_HOSTNAME
N#define LWIP_NETIF_HOSTNAME             0
N#endif
N
N/**
N * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
N */
N#ifndef LWIP_NETIF_API
N#define LWIP_NETIF_API                  0
N#endif
N
N/**
N * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
N * changes its up/down status (i.e., due to DHCP IP acquistion)
N */
N#ifndef LWIP_NETIF_STATUS_CALLBACK
N#define LWIP_NETIF_STATUS_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#ifndef LWIP_NETIF_LINK_CALLBACK
N#define LWIP_NETIF_LINK_CALLBACK        0
N#endif
N
N/**
N * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
N * when a netif has been removed
N */
N#ifndef LWIP_NETIF_REMOVE_CALLBACK
N#define LWIP_NETIF_REMOVE_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
N * indices) in struct netif. TCP and UDP can make use of this to prevent
N * scanning the ARP table for every sent packet. While this is faster for big
N * ARP tables or many concurrent connections, it might be counterproductive
N * if you have a tiny ARP table or if there never are concurrent connections.
N */
N#ifndef LWIP_NETIF_HWADDRHINT
N#define LWIP_NETIF_HWADDRHINT           0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
N * address equal to the netif IP address, looping them back up the stack.
N */
N#ifndef LWIP_NETIF_LOOPBACK
N#define LWIP_NETIF_LOOPBACK             0
N#endif
N
N/**
N * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
N * sending for each netif (0 = disabled)
N */
N#ifndef LWIP_LOOPBACK_MAX_PBUFS
N#define LWIP_LOOPBACK_MAX_PBUFS         0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
N * the system, as netifs must change how they behave depending on this setting
N * for the LWIP_NETIF_LOOPBACK option to work.
N * Setting this is needed to avoid reentering non-reentrant functions like
N * tcp_input().
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
N *       multithreaded environment like tcpip.c. In this case, netif->input()
N *       is called directly.
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
N *       The packets are put on a list and netif_poll() must be called in
N *       the main application loop.
N */
N#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
N#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
N#endif
N
N/**
N * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
N * to be sent into one single pbuf. This is for compatibility with DMA-enabled
N * MACs that do not support scatter-gather.
N * Beware that this might involve CPU-memcpy before transmitting that would not
N * be needed without this flag! Use this only if you need to!
N *
N * @todo: TCP and IP-frag do not work with this, yet:
N */
N#ifndef LWIP_NETIF_TX_SINGLE_PBUF
N#define LWIP_NETIF_TX_SINGLE_PBUF             0
N#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
N
N/*
N   ------------------------------------
N   ---------- LOOPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
N */
N#ifndef LWIP_HAVE_LOOPIF
N#define LWIP_HAVE_LOOPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- SLIPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
N */
N#ifndef LWIP_HAVE_SLIPIF
N#define LWIP_HAVE_SLIPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- Thread options ----------
N   ------------------------------------
N*/
N/**
N * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
N */
N#ifndef TCPIP_THREAD_NAME
S#define TCPIP_THREAD_NAME              "tcpip_thread"
N#endif
N
N/**
N * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_STACKSIZE
S#define TCPIP_THREAD_STACKSIZE          0
N#endif
N
N/**
N * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_PRIO
S#define TCPIP_THREAD_PRIO               1
N#endif
N
N/**
N * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when tcpip_init is called.
N */
N#ifndef TCPIP_MBOX_SIZE
S#define TCPIP_MBOX_SIZE                 0
N#endif
N
N/**
N * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
N */
N#ifndef SLIPIF_THREAD_NAME
N#define SLIPIF_THREAD_NAME             "slipif_loop"
N#endif
N
N/**
N * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_STACKSIZE
N#define SLIPIF_THREAD_STACKSIZE         0
N#endif
N
N/**
N * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_PRIO
N#define SLIPIF_THREAD_PRIO              1
N#endif
N
N/**
N * PPP_THREAD_NAME: The name assigned to the pppInputThread.
N */
N#ifndef PPP_THREAD_NAME
N#define PPP_THREAD_NAME                "pppInputThread"
N#endif
N
N/**
N * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_STACKSIZE
N#define PPP_THREAD_STACKSIZE            0
N#endif
N
N/**
N * PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_PRIO
N#define PPP_THREAD_PRIO                 1
N#endif
N
N/**
N * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
N */
N#ifndef DEFAULT_THREAD_NAME
N#define DEFAULT_THREAD_NAME            "lwIP"
N#endif
N
N/**
N * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_STACKSIZE
N#define DEFAULT_THREAD_STACKSIZE        0
N#endif
N
N/**
N * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_PRIO
N#define DEFAULT_THREAD_PRIO             1
N#endif
N
N/**
N * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_RAW_RECVMBOX_SIZE
N#define DEFAULT_RAW_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_UDP_RECVMBOX_SIZE
N#define DEFAULT_UDP_RECVMBOX_SIZE       24
N#endif
N
N/**
N * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_TCP_RECVMBOX_SIZE
N#define DEFAULT_TCP_RECVMBOX_SIZE       24
N#endif
N
N/**
N * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when the acceptmbox is created.
N */
N#ifndef DEFAULT_ACCEPTMBOX_SIZE
N#define DEFAULT_ACCEPTMBOX_SIZE         16
N#endif
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING
N#define LWIP_TCPIP_CORE_LOCKING         0
N#endif
N
N/**
N * LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING_INPUT
N#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
N#endif
N
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#ifndef LWIP_NETCONN
S#define LWIP_NETCONN                    0
N#endif
N
N/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
N * timers running in tcpip_thread from another thread.
N */
N#ifndef LWIP_TCPIP_TIMEOUT
N#define LWIP_TCPIP_TIMEOUT              1
N#endif
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#ifndef LWIP_SOCKET
S#define LWIP_SOCKET                     1
N#endif
N
N/**
N * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
N * (only used if you use sockets.c)
N */
N#ifndef LWIP_COMPAT_SOCKETS
N#define LWIP_COMPAT_SOCKETS             0
N#endif
N
N/**
N * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
N * Disable this option if you use a POSIX operating system that uses the same
N * names (read, write & close). (only used if you use sockets.c)
N */
N#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
N#define LWIP_POSIX_SOCKETS_IO_NAMES     1
N#endif
N
N/**
N * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
N * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
N * in seconds. (does not require sockets.c, and will affect tcp.c)
N */
N#ifndef LWIP_TCP_KEEPALIVE
N#define LWIP_TCP_KEEPALIVE              0
N#endif
N
N/**
N * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
N * SO_SNDTIMEO processing.
N */
N#ifndef LWIP_SO_SNDTIMEO
N#define LWIP_SO_SNDTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
N * SO_RCVTIMEO processing.
N */
N#ifndef LWIP_SO_RCVTIMEO
N#define LWIP_SO_RCVTIMEO                1
N#endif
N
N/**
N * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
N */
N#ifndef LWIP_SO_RCVBUF
N#define LWIP_SO_RCVBUF                  0
N#endif
N
N/**
N * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
N */
N#ifndef RECV_BUFSIZE_DEFAULT
N#define RECV_BUFSIZE_DEFAULT            INT_MAX
N#endif
N
N/**
N * SO_REUSE==1: Enable SO_REUSEADDR option.
N */
N#ifndef SO_REUSE
N#define SO_REUSE                        0
N#endif
N
N/**
N * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
N * to all local matches if SO_REUSEADDR is turned on.
N * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
N */
N#ifndef SO_REUSE_RXTOALL
N#define SO_REUSE_RXTOALL                0
N#endif
N
N/*
N   ----------------------------------------
N   ---------- Statistics options ----------
N   ----------------------------------------
N*/
N/**
N * LWIP_STATS==1: Enable statistics collection in lwip_stats.
N */
N#ifndef LWIP_STATS
N#define LWIP_STATS                      1
N#endif
N
N#if LWIP_STATS
X#if 1
N
N/**
N * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
N */
N#ifndef LWIP_STATS_DISPLAY
N#define LWIP_STATS_DISPLAY              0
N#endif
N
N/**
N * LINK_STATS==1: Enable link stats.
N */
N#ifndef LINK_STATS
N#define LINK_STATS                      1
N#endif
N
N/**
N * ETHARP_STATS==1: Enable etharp stats.
N */
N#ifndef ETHARP_STATS
N#define ETHARP_STATS                    (LWIP_ARP)
N#endif
N
N/**
N * IP_STATS==1: Enable IP stats.
N */
N#ifndef IP_STATS
N#define IP_STATS                        1
N#endif
N
N/**
N * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
N * on if using either frag or reass.
N */
N#ifndef IPFRAG_STATS
N#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
N#endif
N
N/**
N * ICMP_STATS==1: Enable ICMP stats.
N */
N#ifndef ICMP_STATS
N#define ICMP_STATS                      1
N#endif
N
N/**
N * IGMP_STATS==1: Enable IGMP stats.
N */
N#ifndef IGMP_STATS
N#define IGMP_STATS                      (LWIP_IGMP)
N#endif
N
N/**
N * UDP_STATS==1: Enable UDP stats. Default is on if
N * UDP enabled, otherwise off.
N */
N#ifndef UDP_STATS
N#define UDP_STATS                       (LWIP_UDP)
N#endif
N
N/**
N * TCP_STATS==1: Enable TCP stats. Default is on if TCP
N * enabled, otherwise off.
N */
N#ifndef TCP_STATS
N#define TCP_STATS                       (LWIP_TCP)
N#endif
N
N/**
N * MEM_STATS==1: Enable mem.c stats.
N */
N#ifndef MEM_STATS
N#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
N#endif
N
N/**
N * MEMP_STATS==1: Enable memp.c pool stats.
N */
N#ifndef MEMP_STATS
N#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
N#endif
N
N/**
N * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
N */
N#ifndef SYS_STATS
N#define SYS_STATS                       (NO_SYS == 0)
N#endif
N
N#else
S
S#define LINK_STATS                      0
S#define IP_STATS                        0
S#define IPFRAG_STATS                    0
S#define ICMP_STATS                      0
S#define IGMP_STATS                      0
S#define UDP_STATS                       0
S#define TCP_STATS                       0
S#define MEM_STATS                       0
S#define MEMP_STATS                      0
S#define SYS_STATS                       0
S#define LWIP_STATS_DISPLAY              0
S
N#endif /* LWIP_STATS */
N
N/*
N   ---------------------------------
N   ---------- PPP options ----------
N   ---------------------------------
N*/
N/**
N * PPP_SUPPORT==1: Enable PPP.
N */
N#ifndef PPP_SUPPORT
N#define PPP_SUPPORT                     0
N#endif
N
N/**
N * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
N */
N#ifndef PPPOE_SUPPORT
N#define PPPOE_SUPPORT                   0
N#endif
N
N/**
N * PPPOS_SUPPORT==1: Enable PPP Over Serial
N */
N#ifndef PPPOS_SUPPORT
N#define PPPOS_SUPPORT                   PPP_SUPPORT
N#endif
N
N#if PPP_SUPPORT
X#if 0
S
S/**
S * NUM_PPP: Max PPP sessions.
S */
S#ifndef NUM_PPP
S#define NUM_PPP                         1
S#endif
S
S/**
S * PAP_SUPPORT==1: Support PAP.
S */
S#ifndef PAP_SUPPORT
S#define PAP_SUPPORT                     0
S#endif
S
S/**
S * CHAP_SUPPORT==1: Support CHAP.
S */
S#ifndef CHAP_SUPPORT
S#define CHAP_SUPPORT                    0
S#endif
S
S/**
S * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef MSCHAP_SUPPORT
S#define MSCHAP_SUPPORT                  0
S#endif
S
S/**
S * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CBCP_SUPPORT
S#define CBCP_SUPPORT                    0
S#endif
S
S/**
S * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CCP_SUPPORT
S#define CCP_SUPPORT                     0
S#endif
S
S/**
S * VJ_SUPPORT==1: Support VJ header compression.
S */
S#ifndef VJ_SUPPORT
S#define VJ_SUPPORT                      0
S#endif
S
S/**
S * MD5_SUPPORT==1: Support MD5 (see also CHAP).
S */
S#ifndef MD5_SUPPORT
S#define MD5_SUPPORT                     0
S#endif
S
S/*
S * Timeouts
S */
S#ifndef FSM_DEFTIMEOUT
S#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
S#endif
S
S#ifndef FSM_DEFMAXTERMREQS
S#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXCONFREQS
S#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXNAKLOOPS
S#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
S#endif
S
S#ifndef UPAP_DEFTIMEOUT
S#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
S#endif
S
S#ifndef UPAP_DEFREQTIME
S#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
S#endif
S
S#ifndef CHAP_DEFTIMEOUT
S#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
S#endif
S
S#ifndef CHAP_DEFTRANSMITS
S#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
S#endif
S
S/* Interval in seconds between keepalive echo requests, 0 to disable. */
S#ifndef LCP_ECHOINTERVAL
S#define LCP_ECHOINTERVAL                0
S#endif
S
S/* Number of unanswered echo requests before failure. */
S#ifndef LCP_MAXECHOFAILS
S#define LCP_MAXECHOFAILS                3
S#endif
S
S/* Max Xmit idle time (in jiffies) before resend flag char. */
S#ifndef PPP_MAXIDLEFLAG
S#define PPP_MAXIDLEFLAG                 100
S#endif
S
S/*
S * Packet sizes
S *
S * Note - lcp shouldn't be allowed to negotiate stuff outside these
S *    limits.  See lcp.h in the pppd directory.
S * (XXX - these constants should simply be shared by lcp.c instead
S *    of living in lcp.h)
S */
S#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
S#ifndef PPP_MAXMTU
S/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
S#define PPP_MAXMTU                      1500 /* Largest MTU we allow */
S#endif
S#define PPP_MINMTU                      64
S#define PPP_MRU                         1500     /* default MRU = max length of info field */
S#define PPP_MAXMRU                      1500     /* Largest MRU we allow */
S#ifndef PPP_DEFMRU
S#define PPP_DEFMRU                      296             /* Try for this */
S#endif
S#define PPP_MINMRU                      128             /* No MRUs below this */
S
S#ifndef MAXNAMELEN
S#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
S#endif
S#ifndef MAXSECRETLEN
S#define MAXSECRETLEN                    256     /* max length of password or secret */
S#endif
S
N#endif /* PPP_SUPPORT */
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N/**
N * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
N */
N#ifndef CHECKSUM_GEN_IP
S#define CHECKSUM_GEN_IP                 1
N#endif
N 
N/**
N * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
N */
N#ifndef CHECKSUM_GEN_UDP
S#define CHECKSUM_GEN_UDP                1
N#endif
N 
N/**
N * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
N */
N#ifndef CHECKSUM_GEN_TCP
S#define CHECKSUM_GEN_TCP                1
N#endif
N
N/**
N * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
N */
N#ifndef CHECKSUM_GEN_ICMP
S#define CHECKSUM_GEN_ICMP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
N */
N#ifndef CHECKSUM_CHECK_IP
S#define CHECKSUM_CHECK_IP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
N */
N#ifndef CHECKSUM_CHECK_UDP
S#define CHECKSUM_CHECK_UDP              1
N#endif
N
N/**
N * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
N */
N#ifndef CHECKSUM_CHECK_TCP
S#define CHECKSUM_CHECK_TCP              1
N#endif
N
N/**
N * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
N * application buffers to pbufs.
N */
N#ifndef LWIP_CHECKSUM_ON_COPY
N#define LWIP_CHECKSUM_ON_COPY           0
N#endif
N
N/*
N   ---------------------------------------
N   ---------- Hook options ---------------
N   ---------------------------------------
N*/
N
N/* Hooks are undefined by default, define them to a function if you need them. */
N
N/**
N * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
N * - called from ip_input() (IPv4)
N * - pbuf: received struct pbuf passed to ip_input()
N * - input_netif: struct netif on which the packet has been received
N * Return values:
N * - 0: Hook has not consumed the packet, packet is processed as normal
N * - != 0: Hook has consumed the packet.
N * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
N * (i.e. free it when done).
N */
N
N/**
N * LWIP_HOOK_IP4_ROUTE(dest):
N * - called from ip_route() (IPv4)
N * - dest: destination IPv4 address
N * Returns the destination netif or NULL if no destination netif is found. In
N * that case, ip_route() continues as normal.
N */
N
N/*
N   ---------------------------------------
N   ---------- Debugging options ----------
N   ---------------------------------------
N*/
N/**
N * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
N * compared against this value. If it is smaller, then debugging
N * messages are written.
N */
N#ifndef LWIP_DBG_MIN_LEVEL
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
N#endif
N
N/**
N * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
N * debug messages of certain types.
N */
N#ifndef LWIP_DBG_TYPES_ON
S#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
N#endif
N
N/**
N * ETHARP_DEBUG: Enable debugging in etharp.c.
N */
N#ifndef ETHARP_DEBUG
S#define ETHARP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * NETIF_DEBUG: Enable debugging in netif.c.
N */
N#ifndef NETIF_DEBUG
S#define NETIF_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PBUF_DEBUG: Enable debugging in pbuf.c.
N */
N#ifndef PBUF_DEBUG
S#define PBUF_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * API_LIB_DEBUG: Enable debugging in api_lib.c.
N */
N#ifndef API_LIB_DEBUG
S#define API_LIB_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * API_MSG_DEBUG: Enable debugging in api_msg.c.
N */
N#ifndef API_MSG_DEBUG
S#define API_MSG_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * SOCKETS_DEBUG: Enable debugging in sockets.c.
N */
N#ifndef SOCKETS_DEBUG
S#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * ICMP_DEBUG: Enable debugging in icmp.c.
N */
N#ifndef ICMP_DEBUG
S#define ICMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IGMP_DEBUG: Enable debugging in igmp.c.
N */
N#ifndef IGMP_DEBUG
S#define IGMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * INET_DEBUG: Enable debugging in inet.c.
N */
N#ifndef INET_DEBUG
S#define INET_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IP_DEBUG: Enable debugging for IP.
N */
N#ifndef IP_DEBUG
S#define IP_DEBUG                        LWIP_DBG_OFF
N#endif
N
N/**
N * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
N */
N#ifndef IP_REASS_DEBUG
S#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * RAW_DEBUG: Enable debugging in raw.c.
N */
N#ifndef RAW_DEBUG
S#define RAW_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEM_DEBUG: Enable debugging in mem.c.
N */
N#ifndef MEM_DEBUG
S#define MEM_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEMP_DEBUG: Enable debugging in memp.c.
N */
N#ifndef MEMP_DEBUG
S#define MEMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * SYS_DEBUG: Enable debugging in sys.c.
N */
N#ifndef SYS_DEBUG
S#define SYS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TIMERS_DEBUG: Enable debugging in timers.c.
N */
N#ifndef TIMERS_DEBUG
N#define TIMERS_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_DEBUG: Enable debugging for TCP.
N */
N#ifndef TCP_DEBUG
S#define TCP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
N */
N#ifndef TCP_INPUT_DEBUG
S#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
N */
N#ifndef TCP_FR_DEBUG
N#define TCP_FR_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
N * timeout.
N */
N#ifndef TCP_RTO_DEBUG
S#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
N */
N#ifndef TCP_CWND_DEBUG
S#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
N */
N#ifndef TCP_WND_DEBUG
S#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
N */
N#ifndef TCP_OUTPUT_DEBUG
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
N */
N#ifndef TCP_RST_DEBUG
S#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
N */
N#ifndef TCP_QLEN_DEBUG
S#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * UDP_DEBUG: Enable debugging in UDP.
N */
N#ifndef UDP_DEBUG
S#define UDP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCPIP_DEBUG: Enable debugging in tcpip.c.
N */
N#ifndef TCPIP_DEBUG
S#define TCPIP_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PPP_DEBUG: Enable debugging for PPP.
N */
N#ifndef PPP_DEBUG
S#define PPP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * SLIP_DEBUG: Enable debugging in slipif.c.
N */
N#ifndef SLIP_DEBUG
S#define SLIP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * DHCP_DEBUG: Enable debugging in dhcp.c.
N */
N#ifndef DHCP_DEBUG
S#define DHCP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * AUTOIP_DEBUG: Enable debugging in autoip.c.
N */
N#ifndef AUTOIP_DEBUG
S#define AUTOIP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
N */
N#ifndef SNMP_MSG_DEBUG
S#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
N */
N#ifndef SNMP_MIB_DEBUG
S#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * DNS_DEBUG: Enable debugging for DNS.
N */
N#ifndef DNS_DEBUG
S#define DNS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N#endif /* __LWIP_OPT_H__ */
L 33 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N#include "lwip/def.h"
L 1 ".\third_party\lwip-1.4.1\src\include\lwip/def.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEF_H__
N#define __LWIP_DEF_H__
N
N/* arch.h might define NULL already */
N#include "lwip/arch.h"
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
N#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
N
N#ifndef NULL
N#define NULL ((void *)0)
N#endif
N
N/* Endianess-optimized shifting of two u8_t to create one u16_t */
N#if BYTE_ORDER == LITTLE_ENDIAN
X#if 1234 == 1234
N#define LWIP_MAKE_U16(a, b) ((a << 8) | b)
N#else
S#define LWIP_MAKE_U16(a, b) ((b << 8) | a)
N#endif 
N
N#ifndef LWIP_PLATFORM_BYTESWAP
N#define LWIP_PLATFORM_BYTESWAP 0
N#endif
N
N#ifndef LWIP_PREFIX_BYTEORDER_FUNCS
N/* workaround for naming collisions on some platforms */
N
N#ifdef htons
S#undef htons
N#endif /* htons */
N#ifdef htonl
S#undef htonl
N#endif /* htonl */
N#ifdef ntohs
S#undef ntohs
N#endif /* ntohs */
N#ifdef ntohl
S#undef ntohl
N#endif /* ntohl */
N
N#define htons(x) lwip_htons(x)
N#define ntohs(x) lwip_ntohs(x)
N#define htonl(x) lwip_htonl(x)
N#define ntohl(x) lwip_ntohl(x)
N#endif /* LWIP_PREFIX_BYTEORDER_FUNCS */
N
N#if BYTE_ORDER == BIG_ENDIAN
X#if 1234 == 4321
S#define lwip_htons(x) (x)
S#define lwip_ntohs(x) (x)
S#define lwip_htonl(x) (x)
S#define lwip_ntohl(x) (x)
S#define PP_HTONS(x) (x)
S#define PP_NTOHS(x) (x)
S#define PP_HTONL(x) (x)
S#define PP_NTOHL(x) (x)
N#else /* BYTE_ORDER != BIG_ENDIAN */
N#if LWIP_PLATFORM_BYTESWAP
X#if 0
S#define lwip_htons(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_ntohs(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_htonl(x) LWIP_PLATFORM_HTONL(x)
S#define lwip_ntohl(x) LWIP_PLATFORM_HTONL(x)
N#else /* LWIP_PLATFORM_BYTESWAP */
Nu16_t lwip_htons(u16_t x);
Nu16_t lwip_ntohs(u16_t x);
Nu32_t lwip_htonl(u32_t x);
Nu32_t lwip_ntohl(u32_t x);
N#endif /* LWIP_PLATFORM_BYTESWAP */
N
N/* These macros should be calculated by the preprocessor and are used
N   with compile-time constants only (so that there is no little-endian
N   overhead at runtime). */
N#define PP_HTONS(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
N#define PP_NTOHS(x) PP_HTONS(x)
N#define PP_HTONL(x) ((((x) & 0xff) << 24) | \
N                     (((x) & 0xff00) << 8) | \
N                     (((x) & 0xff0000UL) >> 8) | \
N                     (((x) & 0xff000000UL) >> 24))
X#define PP_HTONL(x) ((((x) & 0xff) << 24) |                      (((x) & 0xff00) << 8) |                      (((x) & 0xff0000UL) >> 8) |                      (((x) & 0xff000000UL) >> 24))
N#define PP_NTOHL(x) PP_HTONL(x)
N
N#endif /* BYTE_ORDER == BIG_ENDIAN */
N
N#define LWIP_RAND   rand
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_DEF_H__ */
N
L 34 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N#include "fs.h"
L 1 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __FS_H__
N#define __FS_H__
N
N#include "lwip/opt.h"
N
N/** Set this to 1 and provide the functions:
N * - "int fs_open_custom(struct fs_file *file, const char *name)"
N *    Called first for every opened file to allow opening files
N *    that are not included in fsdata(_custom).c
N * - "void fs_close_custom(struct fs_file *file)"
N *    Called to free resources allocated by fs_open_custom().
N */
N#ifndef LWIP_HTTPD_CUSTOM_FILES
N#define LWIP_HTTPD_CUSTOM_FILES       0
N#endif
N
N/** Set this to 1 to include an application state argument per file
N * that is opened. This allows to keep a state per connection/file.
N */
N#ifndef LWIP_HTTPD_FILE_STATE
N#define LWIP_HTTPD_FILE_STATE         0
N#endif
N
N/** HTTPD_PRECALCULATED_CHECKSUM==1: include precompiled checksums for
N * predefined (MSS-sized) chunks of the files to prevent having to calculate
N * the checksums at runtime. */
N#ifndef HTTPD_PRECALCULATED_CHECKSUM
N#define HTTPD_PRECALCULATED_CHECKSUM  0
N#endif
N
N#if HTTPD_PRECALCULATED_CHECKSUM
X#if 0
Sstruct fsdata_chksum {
S  u32_t offset;
S  u16_t chksum;
S  u16_t len;
S};
N#endif /* HTTPD_PRECALCULATED_CHECKSUM */
N
Nstruct fs_file {
N  const char *data;
N  int len;
N  int index;
N  void *pextension;
N#if HTTPD_PRECALCULATED_CHECKSUM
X#if 0
S  const struct fsdata_chksum *chksum;
S  u16_t chksum_count;
N#endif /* HTTPD_PRECALCULATED_CHECKSUM */
N  u8_t http_header_included;
N#if LWIP_HTTPD_CUSTOM_FILES
X#if 0
S  u8_t is_custom_file;
N#endif /* LWIP_HTTPD_CUSTOM_FILES */
N#if LWIP_HTTPD_FILE_STATE
X#if 0
S  void *state;
N#endif /* LWIP_HTTPD_FILE_STATE */
N};
N
Nstruct fs_file *fs_open(const char *name);
Nvoid fs_close(struct fs_file *file);
Nint fs_read(struct fs_file *file, char *buffer, int count);
Nint fs_bytes_left(struct fs_file *file);
N
N#if LWIP_HTTPD_FILE_STATE
X#if 0
S/** This user-defined function is called when a file is opened. */
Svoid *fs_state_init(struct fs_file *file, const char *name);
S/** This user-defined function is called when a file is closed. */
Svoid fs_state_free(struct fs_file *file, void *state);
N#endif /* #if LWIP_HTTPD_FILE_STATE */
N
N#endif /* __FS_H__ */
L 35 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N#include "fsdata.h"
L 1 "third_party\lwip-1.4.1\apps\httpserver_raw\fsdata.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __FSDATA_H__
N#define __FSDATA_H__
N
N#include "lwip/opt.h"
N#include "fs.h"
N
Nstruct fsdata_file {
N  const struct fsdata_file *next;
N  const unsigned char *name;
N  const unsigned char *data;
N  int len;
N  u8_t http_header_included;
N#if HTTPD_PRECALCULATED_CHECKSUM
X#if 0
S  u16_t chksum_count;
S  const struct fsdata_chksum *chksum;
N#endif /* HTTPD_PRECALCULATED_CHECKSUM */
N};
N
N#endif /* __FSDATA_H__ */
L 36 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N#include <string.h>
L 1 "D:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 37 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N
N/** Set this to 1 to include "fsdata_custom.c" instead of "fsdata.c" for the
N * file system (to prevent changing the file included in CVS) */
N#ifndef HTTPD_USE_CUSTUM_FSDATA
N#define HTTPD_USE_CUSTUM_FSDATA 0
N#endif
N
N#if HTTPD_USE_CUSTUM_FSDATA
X#if 0
S#include "fsdata_custom.c"
N#else /* HTTPD_USE_CUSTUM_FSDATA */
N#include "fsdata.c"
L 1 "third_party\lwip-1.4.1\apps\httpserver_raw\fsdata.c" 1
N#include "fs.h"
N#include "lwip/def.h"
N#include "fsdata.h"
N
N
N#define file_NULL (struct fsdata_file *) NULL
N
N
Nstatic const unsigned int dummy_align__img_sics_gif = 0;
Nstatic const unsigned char data__img_sics_gif[] = {
N/* /img/sics.gif (14 chars) */
N0x2f,0x69,0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x00,0x00,0x00,
N
N/* HTTP header */
N/* "HTTP/1.0 200 OK
N" (17 bytes) */
N0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x30,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
N0x0a,
N/* "Server: lwIP/1.3.1 (http://savannah.nongnu.org/projects/lwip)
N" (63 bytes) */
N0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x31,0x2e,0x33,
N0x2e,0x31,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,
N0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,
N0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
N/* "Content-type: image/gif
N
N" (27 bytes) */
N0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x74,0x79,0x70,0x65,0x3a,0x20,0x69,0x6d,
N0x61,0x67,0x65,0x2f,0x67,0x69,0x66,0x0d,0x0a,0x0d,0x0a,
N/* raw file data (724 bytes) */
N0x47,0x49,0x46,0x38,0x39,0x61,0x46,0x00,0x22,0x00,0xa5,0x00,0x00,0xd9,0x2b,0x39,
N0x6a,0x6a,0x6a,0xbf,0xbf,0xbf,0x93,0x93,0x93,0x0f,0x0f,0x0f,0xb0,0xb0,0xb0,0xa6,
N0xa6,0xa6,0x80,0x80,0x80,0x76,0x76,0x76,0x1e,0x1e,0x1e,0x9d,0x9d,0x9d,0x2e,0x2e,
N0x2e,0x49,0x49,0x49,0x54,0x54,0x54,0x8a,0x8a,0x8a,0x60,0x60,0x60,0xc6,0xa6,0x99,
N0xbd,0xb5,0xb2,0xc2,0xab,0xa1,0xd9,0x41,0x40,0xd5,0x67,0x55,0xc0,0xb0,0xaa,0xd5,
N0x5e,0x4e,0xd6,0x50,0x45,0xcc,0x93,0x7d,0xc8,0xa1,0x90,0xce,0x8b,0x76,0xd2,0x7b,
N0x65,0xd1,0x84,0x6d,0xc9,0x99,0x86,0x3a,0x3a,0x3a,0x00,0x00,0x00,0xb8,0xb8,0xb8,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
N0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x2c,0x00,0x00,
N0x00,0x00,0x46,0x00,0x22,0x00,0x00,0x06,0xfe,0x40,0x90,0x70,0x48,0x2c,0x1a,0x8f,
N0xc8,0xa4,0x72,0xc9,0x6c,0x3a,0x9f,0xd0,0xa8,0x74,0x4a,0xad,0x5a,0xaf,0xd8,0xac,
N0x76,0xa9,0x40,0x04,0xbe,0x83,0xe2,0x60,0x3c,0x50,0x20,0x0d,0x8e,0x6f,0x00,0x31,
N0x28,0x1c,0x0d,0x07,0xb5,0xc3,0x60,0x75,0x24,0x3e,0xf8,0xfc,0x87,0x11,0x06,0xe9,
N0x3d,0x46,0x07,0x0b,0x7a,0x7a,0x7c,0x43,0x06,0x1e,0x84,0x78,0x0b,0x07,0x6e,0x51,
N0x01,0x8a,0x84,0x08,0x7e,0x79,0x80,0x87,0x89,0x91,0x7a,0x93,0x0a,0x04,0x99,0x78,
N0x96,0x4f,0x03,0x9e,0x79,0x01,0x94,0x9f,0x43,0x9c,0xa3,0xa4,0x05,0x77,0xa3,0xa0,
N0x4e,0x98,0x79,0x0b,0x1e,0x83,0xa4,0xa6,0x1f,0x96,0x05,0x9d,0xaa,0x78,0x01,0x07,
N0x84,0x04,0x1e,0x1e,0xbb,0xb8,0x51,0x84,0x0e,0x43,0x05,0x07,0x77,0xa5,0x7f,0x42,
N0xb1,0xb2,0x01,0x63,0x08,0x0d,0xbb,0x01,0x0c,0x7a,0x0d,0x44,0x0e,0xd8,0xaf,0x4c,
N0x05,0x7a,0x04,0x47,0x07,0x07,0xb7,0x80,0xa2,0xe1,0x7d,0x44,0x05,0x01,0x04,0x01,
N0xd0,0xea,0x87,0x93,0x4f,0xe0,0x9a,0x49,0xce,0xd8,0x79,0x04,0x66,0x20,0x15,0x10,
N0x10,0x11,0x92,0x29,0x80,0xb6,0xc0,0x91,0x15,0x45,0x1e,0x90,0x19,0x71,0x46,0xa8,
N0x5c,0x04,0x0e,0x00,0x22,0x4e,0xe8,0x40,0x24,0x9f,0x3e,0x04,0x06,0xa7,0x58,0xd4,
N0x93,0xa0,0x1c,0x91,0x3f,0xe8,0xf0,0x88,0x03,0xb1,0x21,0xa2,0x49,0x00,0x19,0x86,
N0xfc,0x52,0x44,0xe0,0x01,0x9d,0x29,0x21,0x15,0x25,0x50,0xf7,0x67,0x25,0x1e,0x06,
N0xfd,0x4e,0x9a,0xb4,0x90,0xac,0x15,0xfa,0xcb,0x52,0x53,0x1e,0x8c,0xf2,0xf8,0x07,
N0x92,0x2d,0x08,0x3a,0x4d,0x12,0x49,0x95,0x49,0xdb,0x14,0x04,0xc4,0x14,0x85,0x29,
N0xaa,0xe7,0x01,0x08,0xa4,0x49,0x01,0x14,0x51,0xe0,0x53,0x91,0xd5,0x29,0x06,0x1a,
N0x64,0x02,0xf4,0xc7,0x81,0x9e,0x05,0x20,0x22,0x64,0xa5,0x30,0xae,0xab,0x9e,0x97,
N0x53,0xd8,0xb9,0xfd,0x50,0xef,0x93,0x02,0x42,0x74,0x34,0xe8,0x9c,0x20,0x21,0xc9,
N0x01,0x68,0x78,0xe6,0x55,0x29,0x20,0x56,0x4f,0x4c,0x40,0x51,0x71,0x82,0xc0,0x70,
N0x21,0x22,0x85,0xbe,0x4b,0x1c,0x44,0x05,0xea,0xa4,0x01,0xbf,0x22,0xb5,0xf0,0x1c,
N0x06,0x51,0x38,0x8f,0xe0,0x22,0xec,0x18,0xac,0x39,0x22,0xd4,0xd6,0x93,0x44,0x01,
N0x32,0x82,0xc8,0xfc,0x61,0xb3,0x01,0x45,0x0c,0x2e,0x83,0x30,0xd0,0x0e,0x17,0x24,
N0x0f,0x70,0x85,0x94,0xee,0x05,0x05,0x53,0x4b,0x32,0x1b,0x3f,0x98,0xd3,0x1d,0x29,
N0x81,0xb0,0xae,0x1e,0x8c,0x7e,0x68,0xe0,0x60,0x5a,0x54,0x8f,0xb0,0x78,0x69,0x73,
N0x06,0xa2,0x00,0x6b,0x57,0xca,0x3d,0x11,0x50,0xbd,0x04,0x30,0x4b,0x3a,0xd4,0xab,
N0x5f,0x1f,0x9b,0x3d,0x13,0x74,0x27,0x88,0x3c,0x25,0xe0,0x17,0xbe,0x7a,0x79,0x45,
N0x0d,0x0c,0xb0,0x8b,0xda,0x90,0xca,0x80,0x06,0x5d,0x17,0x60,0x1c,0x22,0x4c,0xd8,
N0x57,0x22,0x06,0x20,0x00,0x98,0x07,0x08,0xe4,0x56,0x80,0x80,0x1c,0xc5,0xb7,0xc5,
N0x82,0x0c,0x36,0xe8,0xe0,0x83,0x10,0x46,0x28,0xe1,0x84,0x14,0x56,0x68,0xa1,0x10,
N0x41,0x00,0x00,0x3b,};
N
Nstatic const unsigned int dummy_align__404_html = 1;
Nstatic const unsigned char data__404_html[] = {
N/* /404.html (10 chars) */
N0x2f,0x34,0x30,0x34,0x2e,0x68,0x74,0x6d,0x6c,0x00,0x00,0x00,
N
N/* HTTP header */
N/* "HTTP/1.0 404 File not found
N" (29 bytes) */
N0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x30,0x20,0x34,0x30,0x34,0x20,0x46,0x69,0x6c,
N0x65,0x20,0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x0d,0x0a,
N/* "Server: lwIP/1.3.1 (http://savannah.nongnu.org/projects/lwip)
N" (63 bytes) */
N0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x31,0x2e,0x33,
N0x2e,0x31,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,
N0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,
N0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
N/* "Content-type: text/html
N
N" (27 bytes) */
N0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x74,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
N0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
N/* raw file data (565 bytes) */
N0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
N0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
N0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
N0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
N0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
N0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
N0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x20,
N0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,
N0x31,0x30,0x30,0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,
N0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x3c,
N0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x09,0x20,
N0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
N0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
N0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,
N0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x0d,0x0a,0x09,0x20,
N0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,
N0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,
N0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x3e,0x3c,0x2f,
N0x61,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x20,0x77,0x69,
N0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x09,0x20,0x20,0x0d,0x0a,0x09,
N0x20,0x20,0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,
N0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,
N0x50,0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,
N0x20,0x3c,0x68,0x32,0x3e,0x34,0x30,0x34,0x20,0x2d,0x20,0x50,0x61,0x67,0x65,0x20,
N0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x3c,0x2f,0x68,0x32,0x3e,0x0d,0x0a,
N0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x53,0x6f,0x72,
N0x72,0x79,0x2c,0x20,0x74,0x68,0x65,0x20,0x70,0x61,0x67,0x65,0x20,0x79,0x6f,0x75,
N0x20,0x61,0x72,0x65,0x20,0x72,0x65,0x71,0x75,0x65,0x73,0x74,0x69,0x6e,0x67,0x20,
N0x77,0x61,0x73,0x20,0x6e,0x6f,0x74,0x20,0x66,0x6f,0x75,0x6e,0x64,0x20,0x6f,0x6e,
N0x20,0x74,0x68,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x65,0x72,0x76,
N0x65,0x72,0x2e,0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,
N0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x26,0x6e,
N0x62,0x73,0x70,0x3b,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x2f,0x74,0x72,
N0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
N0x3e,0x0d,0x0a,0x3c,0x2f,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,
N0x6d,0x6c,0x3e,0x0d,0x0a,};
N
Nstatic const unsigned int dummy_align__index_html = 2;
Nstatic const unsigned char data__index_html[] = {
N/* /index.html (12 chars) */
N0x2f,0x69,0x6e,0x64,0x65,0x78,0x2e,0x68,0x74,0x6d,0x6c,0x00,
N
N/* HTTP header */
N/* "HTTP/1.0 200 OK
N" (17 bytes) */
N0x48,0x54,0x54,0x50,0x2f,0x31,0x2e,0x30,0x20,0x32,0x30,0x30,0x20,0x4f,0x4b,0x0d,
N0x0a,
N/* "Server: lwIP/1.3.1 (http://savannah.nongnu.org/projects/lwip)
N" (63 bytes) */
N0x53,0x65,0x72,0x76,0x65,0x72,0x3a,0x20,0x6c,0x77,0x49,0x50,0x2f,0x31,0x2e,0x33,
N0x2e,0x31,0x20,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,0x61,0x76,0x61,0x6e,
N0x6e,0x61,0x68,0x2e,0x6e,0x6f,0x6e,0x67,0x6e,0x75,0x2e,0x6f,0x72,0x67,0x2f,0x70,
N0x72,0x6f,0x6a,0x65,0x63,0x74,0x73,0x2f,0x6c,0x77,0x69,0x70,0x29,0x0d,0x0a,
N/* "Content-type: text/html
N
N" (27 bytes) */
N0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x74,0x79,0x70,0x65,0x3a,0x20,0x74,0x65,
N0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,0x0d,0x0a,0x0d,0x0a,
N/* raw file data (1583 bytes) */
N0x3c,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x3c,0x74,
N0x69,0x74,0x6c,0x65,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,0x69,
N0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,
N0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x3c,0x2f,
N0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x20,0x62,0x67,0x63,
N0x6f,0x6c,0x6f,0x72,0x3d,0x22,0x77,0x68,0x69,0x74,0x65,0x22,0x20,0x74,0x65,0x78,
N0x74,0x3d,0x22,0x62,0x6c,0x61,0x63,0x6b,0x22,0x3e,0x0d,0x0a,0x0d,0x0a,0x20,0x20,
N0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,
N0x31,0x30,0x30,0x25,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,
N0x72,0x20,0x76,0x61,0x6c,0x69,0x67,0x6e,0x3d,0x22,0x74,0x6f,0x70,0x22,0x3e,0x3c,
N0x74,0x64,0x20,0x77,0x69,0x64,0x74,0x68,0x3d,0x22,0x38,0x30,0x22,0x3e,0x09,0x20,
N0x20,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
N0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
N0x65,0x2f,0x22,0x3e,0x3c,0x69,0x6d,0x67,0x20,0x73,0x72,0x63,0x3d,0x22,0x2f,0x69,
N0x6d,0x67,0x2f,0x73,0x69,0x63,0x73,0x2e,0x67,0x69,0x66,0x22,0x0d,0x0a,0x09,0x20,
N0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x30,0x22,0x20,0x61,0x6c,0x74,0x3d,
N0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x20,0x74,0x69,0x74,0x6c,
N0x65,0x3d,0x22,0x53,0x49,0x43,0x53,0x20,0x6c,0x6f,0x67,0x6f,0x22,0x3e,0x3c,0x2f,
N0x61,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,0x20,0x77,0x69,
N0x64,0x74,0x68,0x3d,0x22,0x35,0x30,0x30,0x22,0x3e,0x09,0x20,0x20,0x0d,0x0a,0x09,
N0x20,0x20,0x3c,0x68,0x31,0x3e,0x6c,0x77,0x49,0x50,0x20,0x2d,0x20,0x41,0x20,0x4c,
N0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,
N0x50,0x20,0x53,0x74,0x61,0x63,0x6b,0x3c,0x2f,0x68,0x31,0x3e,0x0d,0x0a,0x09,0x20,
N0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x54,0x68,0x65,0x20,0x77,
N0x65,0x62,0x20,0x70,0x61,0x67,0x65,0x20,0x79,0x6f,0x75,0x20,0x61,0x72,0x65,0x20,
N0x77,0x61,0x74,0x63,0x68,0x69,0x6e,0x67,0x20,0x77,0x61,0x73,0x20,0x73,0x65,0x72,
N0x76,0x65,0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x73,0x69,0x6d,0x70,0x6c,0x65,0x20,
N0x77,0x65,0x62,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x65,0x72,0x76,0x65,0x72,
N0x20,0x72,0x75,0x6e,0x6e,0x69,0x6e,0x67,0x20,0x6f,0x6e,0x20,0x74,0x6f,0x70,0x20,
N0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x6c,0x69,0x67,0x68,0x74,0x77,0x65,0x69,0x67,
N0x68,0x74,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,0x73,0x74,0x61,0x63,0x6b,0x20,
N0x3c,0x61,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,
N0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,
N0x65,0x2f,0x7e,0x61,0x64,0x61,0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x6c,
N0x77,0x49,0x50,0x3c,0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x2f,0x70,
N0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
N0x6c,0x77,0x49,0x50,0x20,0x69,0x73,0x20,0x61,0x6e,0x20,0x6f,0x70,0x65,0x6e,0x20,
N0x73,0x6f,0x75,0x72,0x63,0x65,0x20,0x69,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
N0x61,0x74,0x69,0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x54,0x43,0x50,
N0x2f,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x72,0x6f,0x74,0x6f,0x63,
N0x6f,0x6c,0x20,0x73,0x75,0x69,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x77,0x61,
N0x73,0x20,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x6c,0x79,0x20,0x77,0x72,0x69,
N0x74,0x74,0x65,0x6e,0x20,0x62,0x79,0x20,0x41,0x64,0x61,0x6d,0x20,0x44,0x75,0x6e,
N0x6b,0x65,0x6c,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,0x66,0x20,0x74,0x68,
N0x65,0x20,0x53,0x77,0x65,0x64,0x69,0x73,0x68,0x20,0x49,0x6e,0x73,0x74,0x69,0x74,
N0x75,0x74,0x65,0x20,0x6f,0x66,0x20,0x43,0x6f,0x6d,0x70,0x75,0x74,0x65,0x72,0x20,
N0x53,0x63,0x69,0x65,0x6e,0x63,0x65,0x20,0x62,0x75,0x74,0x20,0x6e,0x6f,0x77,0x20,
N0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x62,0x65,0x69,0x6e,0x67,0x20,0x61,
N0x63,0x74,0x69,0x76,0x65,0x6c,0x79,0x20,0x64,0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,
N0x64,0x20,0x62,0x79,0x20,0x61,0x20,0x74,0x65,0x61,0x6d,0x20,0x6f,0x66,0x20,0x64,
N0x65,0x76,0x65,0x6c,0x6f,0x70,0x65,0x72,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,
N0x64,0x69,0x73,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x64,0x20,0x77,0x6f,0x72,0x6c,
N0x64,0x2d,0x77,0x69,0x64,0x65,0x2e,0x20,0x53,0x69,0x6e,0x63,0x65,0x20,0x69,0x74,
N0x27,0x73,0x20,0x72,0x65,0x6c,0x65,0x61,0x73,0x65,0x2c,0x20,0x6c,0x77,0x49,0x50,
N0x20,0x68,0x61,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x73,0x70,0x75,0x72,0x72,
N0x65,0x64,0x20,0x61,0x20,0x6c,0x6f,0x74,0x20,0x6f,0x66,0x20,0x69,0x6e,0x74,0x65,
N0x72,0x65,0x73,0x74,0x20,0x61,0x6e,0x64,0x20,0x68,0x61,0x73,0x20,0x62,0x65,0x65,
N0x6e,0x20,0x70,0x6f,0x72,0x74,0x65,0x64,0x20,0x74,0x6f,0x20,0x73,0x65,0x76,0x65,
N0x72,0x61,0x6c,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x70,0x6c,0x61,0x74,0x66,0x6f,
N0x72,0x6d,0x73,0x20,0x61,0x6e,0x64,0x20,0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,
N0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x2e,0x20,0x6c,0x77,0x49,0x50,0x20,
N0x63,0x61,0x6e,0x20,0x62,0x65,0x20,0x75,0x73,0x65,0x64,0x20,0x65,0x69,0x74,0x68,
N0x65,0x72,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x77,0x69,0x74,0x68,0x20,0x6f,0x72,
N0x20,0x77,0x69,0x74,0x68,0x6f,0x75,0x74,0x20,0x61,0x6e,0x20,0x75,0x6e,0x64,0x65,
N0x72,0x6c,0x79,0x69,0x6e,0x67,0x20,0x4f,0x53,0x2e,0x0d,0x0a,0x09,0x20,0x20,0x3c,
N0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,
N0x20,0x20,0x54,0x68,0x65,0x20,0x66,0x6f,0x63,0x75,0x73,0x20,0x6f,0x66,0x20,0x74,
N0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x20,0x54,0x43,0x50,0x2f,0x49,0x50,0x20,0x69,
N0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x20,0x69,0x73,
N0x20,0x74,0x6f,0x20,0x72,0x65,0x64,0x75,0x63,0x65,0x0d,0x0a,0x09,0x20,0x20,0x20,
N0x20,0x74,0x68,0x65,0x20,0x52,0x41,0x4d,0x20,0x75,0x73,0x61,0x67,0x65,0x20,0x77,
N0x68,0x69,0x6c,0x65,0x20,0x73,0x74,0x69,0x6c,0x6c,0x20,0x68,0x61,0x76,0x69,0x6e,
N0x67,0x20,0x61,0x20,0x66,0x75,0x6c,0x6c,0x20,0x73,0x63,0x61,0x6c,0x65,0x20,0x54,
N0x43,0x50,0x2e,0x20,0x54,0x68,0x69,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6d,
N0x61,0x6b,0x65,0x73,0x20,0x6c,0x77,0x49,0x50,0x20,0x73,0x75,0x69,0x74,0x61,0x62,
N0x6c,0x65,0x20,0x66,0x6f,0x72,0x20,0x75,0x73,0x65,0x20,0x69,0x6e,0x20,0x65,0x6d,
N0x62,0x65,0x64,0x64,0x65,0x64,0x20,0x73,0x79,0x73,0x74,0x65,0x6d,0x73,0x20,0x77,
N0x69,0x74,0x68,0x20,0x74,0x65,0x6e,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,
N0x66,0x20,0x6b,0x69,0x6c,0x6f,0x62,0x79,0x74,0x65,0x73,0x20,0x6f,0x66,0x20,0x66,
N0x72,0x65,0x65,0x20,0x52,0x41,0x4d,0x20,0x61,0x6e,0x64,0x20,0x72,0x6f,0x6f,0x6d,
N0x20,0x66,0x6f,0x72,0x20,0x61,0x72,0x6f,0x75,0x6e,0x64,0x20,0x34,0x30,0x20,0x6b,
N0x69,0x6c,0x6f,0x62,0x79,0x74,0x65,0x73,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x6f,
N0x66,0x20,0x63,0x6f,0x64,0x65,0x20,0x52,0x4f,0x4d,0x2e,0x0d,0x0a,0x09,0x20,0x20,
N0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x20,0x20,0x3c,0x70,0x3e,0x0d,0x0a,0x09,0x20,
N0x20,0x20,0x20,0x4d,0x6f,0x72,0x65,0x20,0x69,0x6e,0x66,0x6f,0x72,0x6d,0x61,0x74,
N0x69,0x6f,0x6e,0x20,0x61,0x62,0x6f,0x75,0x74,0x20,0x6c,0x77,0x49,0x50,0x20,0x63,
N0x61,0x6e,0x20,0x62,0x65,0x20,0x66,0x6f,0x75,0x6e,0x64,0x20,0x61,0x74,0x20,0x74,
N0x68,0x65,0x20,0x6c,0x77,0x49,0x50,0x0d,0x0a,0x09,0x20,0x20,0x20,0x20,0x68,0x6f,
N0x6d,0x65,0x70,0x61,0x67,0x65,0x20,0x61,0x74,0x20,0x3c,0x61,0x0d,0x0a,0x09,0x20,
N0x20,0x20,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
N0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,
N0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x22,0x3e,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
N0x77,0x77,0x77,0x2e,0x73,0x69,0x63,0x73,0x2e,0x73,0x65,0x2f,0x7e,0x61,0x64,0x61,
N0x6d,0x2f,0x6c,0x77,0x69,0x70,0x2f,0x3c,0x2f,0x61,0x3e,0x2e,0x0d,0x0a,0x09,0x20,
N0x20,0x3c,0x2f,0x70,0x3e,0x0d,0x0a,0x09,0x3c,0x2f,0x74,0x64,0x3e,0x3c,0x74,0x64,
N0x3e,0x0d,0x0a,0x09,0x20,0x20,0x26,0x6e,0x62,0x73,0x70,0x3b,0x0d,0x0a,0x09,0x3c,
N0x2f,0x74,0x64,0x3e,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,
N0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x62,0x6f,0x64,
N0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x74,0x6d,0x6c,0x3e,0x0d,0x0a,0x0d,0x0a,};
N
N
N
Nconst struct fsdata_file file__img_sics_gif[] = { {
Nfile_NULL,
X(struct fsdata_file *) 0,
Ndata__img_sics_gif,
Ndata__img_sics_gif + 16,
Nsizeof(data__img_sics_gif) - 16,
N1,
N}};
N
Nconst struct fsdata_file file__404_html[] = { {
Nfile__img_sics_gif,
Ndata__404_html,
Ndata__404_html + 12,
Nsizeof(data__404_html) - 12,
N1,
N}};
N
Nconst struct fsdata_file file__index_html[] = { {
Nfile__404_html,
Ndata__index_html,
Ndata__index_html + 12,
Nsizeof(data__index_html) - 12,
N1,
N}};
N
N#define FS_ROOT file__index_html
N#define FS_NUMFILES 3
N
L 48 "third_party\lwip-1.4.1\apps\httpserver_raw\fs.c" 2
N#endif /* HTTPD_USE_CUSTUM_FSDATA */
N
N/*-----------------------------------------------------------------------------------*/
N/* Define the number of open files that we can support. */
N#ifndef LWIP_MAX_OPEN_FILES
N#define LWIP_MAX_OPEN_FILES     10
N#endif
N
N/* Define the file system memory allocation structure. */
Nstruct fs_table {
N  struct fs_file file;
N  u8_t inuse;
N};
N
N/* Allocate file system memory */
Nstruct fs_table fs_memory[LWIP_MAX_OPEN_FILES];
Xstruct fs_table fs_memory[10];
N
N#if LWIP_HTTPD_CUSTOM_FILES
X#if 0
Sint fs_open_custom(struct fs_file *file, const char *name);
Svoid fs_close_custom(struct fs_file *file);
N#endif /* LWIP_HTTPD_CUSTOM_FILES */
N
N/*-----------------------------------------------------------------------------------*/
Nstatic struct fs_file *
Nfs_malloc(void)
N{
N  int i;
N  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
X  for(i = 0; i < 10; i++) {
N    if(fs_memory[i].inuse == 0) {
N      fs_memory[i].inuse = 1;
N      return(&fs_memory[i].file);
N    }
N  }
N  return(NULL);
X  return(0);
N}
N
N/*-----------------------------------------------------------------------------------*/
Nstatic void
Nfs_free(struct fs_file *file)
N{
N  int i;
N  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
X  for(i = 0; i < 10; i++) {
N    if(&fs_memory[i].file == file) {
N      fs_memory[i].inuse = 0;
N      break;
N    }
N  }
N  return;
N}
N
N/*-----------------------------------------------------------------------------------*/
Nstruct fs_file *
Nfs_open(const char *name)
N{
N  struct fs_file *file;
N  const struct fsdata_file *f;
N
N  file = fs_malloc();
N  if(file == NULL) {
X  if(file == 0) {
N    return NULL;
X    return 0;
N  }
N
N#if LWIP_HTTPD_CUSTOM_FILES
X#if 0
S  if(fs_open_custom(file, name)) {
S    file->is_custom_file = 1;
S    return file;
S  }
S  file->is_custom_file = 0;
N#endif /* LWIP_HTTPD_CUSTOM_FILES */
N
N  for(f = FS_ROOT; f != NULL; f = f->next) {
X  for(f = file__index_html; f != 0; f = f->next) {
N    if (!strcmp(name, (char *)f->name)) {
N      file->data = (const char *)f->data;
N      file->len = f->len;
N      file->index = f->len;
N      file->pextension = NULL;
X      file->pextension = 0;
N      file->http_header_included = f->http_header_included;
N#if HTTPD_PRECALCULATED_CHECKSUM
X#if 0
S      file->chksum_count = f->chksum_count;
S      file->chksum = f->chksum;
N#endif /* HTTPD_PRECALCULATED_CHECKSUM */
N#if LWIP_HTTPD_FILE_STATE
X#if 0
S      file->state = fs_state_init(file, name);
N#endif /* #if LWIP_HTTPD_FILE_STATE */
N      return file;
N    }
N  }
N  fs_free(file);
N  return NULL;
X  return 0;
N}
N
N/*-----------------------------------------------------------------------------------*/
Nvoid
Nfs_close(struct fs_file *file)
N{
N#if LWIP_HTTPD_CUSTOM_FILES
X#if 0
S  if (file->is_custom_file) {
S    fs_close_custom(file);
S  }
N#endif /* LWIP_HTTPD_CUSTOM_FILES */
N#if LWIP_HTTPD_FILE_STATE
X#if 0
S  fs_state_free(file, file->state);
N#endif /* #if LWIP_HTTPD_FILE_STATE */
N  fs_free(file);
N}
N/*-----------------------------------------------------------------------------------*/
Nint
Nfs_read(struct fs_file *file, char *buffer, int count)
N{
N  int read;
N
N  if(file->index == file->len) {
N    return -1;
N  }
N
N  read = file->len - file->index;
N  if(read > count) {
N    read = count;
N  }
N
N  MEMCPY(buffer, (file->data + file->index), read);
X  memcpy(buffer,(file ->data + file ->index),read);
N  file->index += read;
N
N  return(read);
N}
N/*-----------------------------------------------------------------------------------*/
Nint fs_bytes_left(struct fs_file *file)
N{
N  return file->len - file->index;
N}
