; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\build\heap_4.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\heap_4.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\Driver -I.\web -I.\third_party\lwip-1.4.1\src\include -I.\third_party\fatfs -I.\third_party\lwip-1.4.1\apps\httpserver_raw -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include -I.\third_party\lwip-1.4.1\ports\tiva-tm4c129\include\arch -I.\third_party\lwip-1.4.1\src\include\ipv4 -I..\MCU -I.\third_party\lwip-1.4.1\apps -I.\third_party -I.\Upnp -I.\Dsp -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C129XNCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DUSE_LWIP -DTM4C129ENCPDT --omf_browse=.\build\heap_4.crf FreeRTOS\portable\heap_4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;339    
;;;340    static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
000000  b510              PUSH     {r4,lr}
;;;341    {
000002  4601              MOV      r1,r0
;;;342    xBlockLink *pxIterator;
;;;343    unsigned char *puc;
;;;344    
;;;345    	/* Iterate through the list until a block is found that has a higher address
;;;346    	than the block being inserted. */
;;;347    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000004  4865              LDR      r0,|L1.412|
000006  e000              B        |L1.10|
                  |L1.8|
000008  6800              LDR      r0,[r0,#0]
                  |L1.10|
00000a  6803              LDR      r3,[r0,#0]
00000c  428b              CMP      r3,r1
00000e  d3fb              BCC      |L1.8|
;;;348    	{
;;;349    		/* Nothing to do here, just iterate to the right position. */
;;;350    	}
;;;351    
;;;352    	/* Do the block being inserted, and the block it is being inserted after
;;;353    	make a contiguous block of memory? */	
;;;354    	puc = ( unsigned char * ) pxIterator;
000010  4602              MOV      r2,r0
;;;355    	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
000012  6843              LDR      r3,[r0,#4]
000014  4413              ADD      r3,r3,r2
000016  428b              CMP      r3,r1
000018  d104              BNE      |L1.36|
;;;356    	{
;;;357    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
00001a  6843              LDR      r3,[r0,#4]
00001c  684c              LDR      r4,[r1,#4]
00001e  4423              ADD      r3,r3,r4
000020  6043              STR      r3,[r0,#4]
;;;358    		pxBlockToInsert = pxIterator;
000022  4601              MOV      r1,r0
                  |L1.36|
;;;359    	}
;;;360    
;;;361    	/* Do the block being inserted, and the block it is being inserted before
;;;362    	make a contiguous block of memory? */
;;;363    	puc = ( unsigned char * ) pxBlockToInsert;
000024  460a              MOV      r2,r1
;;;364    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
000026  684b              LDR      r3,[r1,#4]
000028  4413              ADD      r3,r3,r2
00002a  6804              LDR      r4,[r0,#0]
00002c  42a3              CMP      r3,r4
00002e  d111              BNE      |L1.84|
;;;365    	{
;;;366    		if( pxIterator->pxNextFreeBlock != pxEnd )
000030  4c5b              LDR      r4,|L1.416|
000032  6803              LDR      r3,[r0,#0]
000034  6824              LDR      r4,[r4,#0]  ; pxEnd
000036  42a3              CMP      r3,r4
000038  d008              BEQ      |L1.76|
;;;367    		{
;;;368    			/* Form one big block from the two blocks. */
;;;369    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
00003a  684b              LDR      r3,[r1,#4]
00003c  6804              LDR      r4,[r0,#0]
00003e  6864              LDR      r4,[r4,#4]
000040  4423              ADD      r3,r3,r4
000042  604b              STR      r3,[r1,#4]
;;;370    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000044  6803              LDR      r3,[r0,#0]
000046  681b              LDR      r3,[r3,#0]
000048  600b              STR      r3,[r1,#0]
00004a  e005              B        |L1.88|
                  |L1.76|
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
00004c  4b54              LDR      r3,|L1.416|
00004e  681b              LDR      r3,[r3,#0]  ; pxEnd
000050  600b              STR      r3,[r1,#0]
000052  e001              B        |L1.88|
                  |L1.84|
;;;375    		}
;;;376    	}
;;;377    	else
;;;378    	{
;;;379    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
000054  6803              LDR      r3,[r0,#0]
000056  600b              STR      r3,[r1,#0]
                  |L1.88|
;;;380    	}
;;;381    
;;;382    	/* If the block being inserted plugged a gab, so was merged with the block
;;;383    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;384    	already been set, and should not be set here as that would make it point
;;;385    	to itself. */
;;;386    	if( pxIterator != pxBlockToInsert )
000058  4288              CMP      r0,r1
00005a  d000              BEQ      |L1.94|
;;;387    	{
;;;388    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00005c  6001              STR      r1,[r0,#0]
                  |L1.94|
;;;389    	}
;;;390    }
00005e  bd10              POP      {r4,pc}
;;;391    
                          ENDP

                  prvHeapInit PROC
;;;303    
;;;304    static void prvHeapInit( void )
000060  b510              PUSH     {r4,lr}
;;;305    {
;;;306    xBlockLink *pxFirstFreeBlock;
;;;307    unsigned char *pucHeapEnd, *pucAlignedHeap;
;;;308    
;;;309    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;310    	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
000062  4b50              LDR      r3,|L1.420|
000064  f0230007          BIC      r0,r3,#7
;;;311    
;;;312    	/* xStart is used to hold a pointer to the first item in the list of free
;;;313    	blocks.  The void cast is used to prevent compiler warnings. */
;;;314    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000068  4b4c              LDR      r3,|L1.412|
00006a  6018              STR      r0,[r3,#0]  ; xStart
;;;315    	xStart.xBlockSize = ( size_t ) 0;
00006c  2300              MOVS     r3,#0
00006e  4c4b              LDR      r4,|L1.412|
000070  6063              STR      r3,[r4,#4]  ; xStart
;;;316    
;;;317    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;318    	at the end of the heap space. */
;;;319    	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
000072  f64a73f8          MOV      r3,#0xaff8
000076  18c2              ADDS     r2,r0,r3
;;;320    	pucHeapEnd -= heapSTRUCT_SIZE;
000078  3a08              SUBS     r2,r2,#8
;;;321    	pxEnd = ( void * ) pucHeapEnd;
00007a  4b49              LDR      r3,|L1.416|
00007c  601a              STR      r2,[r3,#0]  ; pxEnd
;;;322    	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
;;;323    	pxEnd->xBlockSize = 0;
00007e  2300              MOVS     r3,#0
000080  4c47              LDR      r4,|L1.416|
000082  6824              LDR      r4,[r4,#0]  ; pxEnd
000084  6063              STR      r3,[r4,#4]
;;;324    	pxEnd->pxNextFreeBlock = NULL;
000086  4c46              LDR      r4,|L1.416|
000088  6824              LDR      r4,[r4,#0]  ; pxEnd
00008a  6023              STR      r3,[r4,#0]
;;;325    
;;;326    	/* To start with there is a single free block that is sized to take up the
;;;327    	entire heap space, minus the space taken by pxEnd. */
;;;328    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
00008c  4601              MOV      r1,r0
;;;329    	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
00008e  f64a73f0          MOV      r3,#0xaff0
000092  604b              STR      r3,[r1,#4]
;;;330    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
000094  4b42              LDR      r3,|L1.416|
000096  681b              LDR      r3,[r3,#0]  ; pxEnd
000098  600b              STR      r3,[r1,#0]
;;;331    
;;;332    	/* The heap now contains pxEnd. */
;;;333    	xFreeBytesRemaining -= heapSTRUCT_SIZE;
00009a  4b43              LDR      r3,|L1.424|
00009c  681b              LDR      r3,[r3,#0]  ; xFreeBytesRemaining
00009e  3b08              SUBS     r3,r3,#8
0000a0  4c41              LDR      r4,|L1.424|
0000a2  6023              STR      r3,[r4,#0]  ; xFreeBytesRemaining
;;;334    
;;;335    	/* Work out the position of the top bit in a size_t variable. */
;;;336    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
0000a4  f04f4300          MOV      r3,#0x80000000
0000a8  4c40              LDR      r4,|L1.428|
0000aa  6023              STR      r3,[r4,#0]  ; xBlockAllocatedBit
;;;337    }
0000ac  bd10              POP      {r4,pc}
;;;338    /*-----------------------------------------------------------*/
                          ENDP

                  pvPortMalloc PROC
;;;145    
;;;146    void *pvPortMalloc( size_t xWantedSize )
0000ae  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
0000b2  4605              MOV      r5,r0
;;;148    xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;149    void *pvReturn = NULL;
0000b4  f04f0800          MOV      r8,#0
;;;150    
;;;151    	vTaskSuspendAll();
0000b8  f7fffffe          BL       vTaskSuspendAll
;;;152    	{
;;;153    		/* If this is the first call to malloc then the heap will require
;;;154    		initialisation to setup the list of free blocks. */
;;;155    		if( pxEnd == NULL )
0000bc  4838              LDR      r0,|L1.416|
0000be  6800              LDR      r0,[r0,#0]  ; pxEnd
0000c0  b908              CBNZ     r0,|L1.198|
;;;156    		{
;;;157    			prvHeapInit();
0000c2  f7fffffe          BL       prvHeapInit
                  |L1.198|
;;;158    		}
;;;159    
;;;160    		/* Check the requested block size is not so large that the top bit is
;;;161    		set.  The top bit of the block size member of the xBlockLink structure 
;;;162    		is used to determine who owns the block - the application or the
;;;163    		kernel, so it must be free. */
;;;164    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
0000c6  4839              LDR      r0,|L1.428|
0000c8  6800              LDR      r0,[r0,#0]  ; xBlockAllocatedBit
0000ca  4205              TST      r5,r0
0000cc  d13c              BNE      |L1.328|
;;;165    		{
;;;166    			/* The wanted size is increased so it can contain a xBlockLink
;;;167    			structure in addition to the requested amount of bytes. */
;;;168    			if( xWantedSize > 0 )
0000ce  b145              CBZ      r5,|L1.226|
;;;169    			{
;;;170    				xWantedSize += heapSTRUCT_SIZE;
0000d0  3508              ADDS     r5,r5,#8
;;;171    
;;;172    				/* Ensure that blocks are always aligned to the required number 
;;;173    				of bytes. */
;;;174    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
0000d2  f0150f07          TST      r5,#7
0000d6  d004              BEQ      |L1.226|
;;;175    				{
;;;176    					/* Byte alignment required. */
;;;177    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
0000d8  f0050007          AND      r0,r5,#7
0000dc  f1c00008          RSB      r0,r0,#8
0000e0  4405              ADD      r5,r5,r0
                  |L1.226|
;;;178    				}
;;;179    			}
;;;180    
;;;181    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
0000e2  b38d              CBZ      r5,|L1.328|
0000e4  4830              LDR      r0,|L1.424|
0000e6  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000e8  4285              CMP      r5,r0
0000ea  d82d              BHI      |L1.328|
;;;182    			{
;;;183    				/* Traverse the list from the start	(lowest address) block until 
;;;184    				one	of adequate size is found. */
;;;185    				pxPreviousBlock = &xStart;
0000ec  4e2b              LDR      r6,|L1.412|
;;;186    				pxBlock = xStart.pxNextFreeBlock;
0000ee  4630              MOV      r0,r6
0000f0  6804              LDR      r4,[r0,#0]  ; xStart
;;;187    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
0000f2  e001              B        |L1.248|
                  |L1.244|
;;;188    				{
;;;189    					pxPreviousBlock = pxBlock;
0000f4  4626              MOV      r6,r4
;;;190    					pxBlock = pxBlock->pxNextFreeBlock;
0000f6  6824              LDR      r4,[r4,#0]
                  |L1.248|
0000f8  6860              LDR      r0,[r4,#4]            ;187
0000fa  42a8              CMP      r0,r5                 ;187
0000fc  d202              BCS      |L1.260|
0000fe  6820              LDR      r0,[r4,#0]            ;187
000100  2800              CMP      r0,#0                 ;187
000102  d1f7              BNE      |L1.244|
                  |L1.260|
;;;191    				}
;;;192    
;;;193    				/* If the end marker was reached then a block of adequate size 
;;;194    				was	not found. */
;;;195    				if( pxBlock != pxEnd )
000104  4826              LDR      r0,|L1.416|
000106  6800              LDR      r0,[r0,#0]  ; pxEnd
000108  4284              CMP      r4,r0
00010a  d01d              BEQ      |L1.328|
;;;196    				{
;;;197    					/* Return the memory space pointed to - jumping over the 
;;;198    					xBlockLink structure at its start. */
;;;199    					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
00010c  6830              LDR      r0,[r6,#0]
00010e  f1000808          ADD      r8,r0,#8
;;;200    
;;;201    					/* This block is being returned for use so must be taken out 
;;;202    					of the list of free blocks. */
;;;203    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000112  6820              LDR      r0,[r4,#0]
000114  6030              STR      r0,[r6,#0]
;;;204    
;;;205    					/* If the block is larger than required it can be split into 
;;;206    					two. */
;;;207    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
000116  6860              LDR      r0,[r4,#4]
000118  1b40              SUBS     r0,r0,r5
00011a  2810              CMP      r0,#0x10
00011c  d907              BLS      |L1.302|
;;;208    					{
;;;209    						/* This block is to be split into two.  Create a new 
;;;210    						block following the number of bytes requested. The void 
;;;211    						cast is used to prevent byte alignment warnings from the 
;;;212    						compiler. */
;;;213    						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
00011e  1967              ADDS     r7,r4,r5
;;;214    
;;;215    						/* Calculate the sizes of two blocks split from the 
;;;216    						single block. */
;;;217    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
000120  6860              LDR      r0,[r4,#4]
000122  1b40              SUBS     r0,r0,r5
000124  6078              STR      r0,[r7,#4]
;;;218    						pxBlock->xBlockSize = xWantedSize;
000126  6065              STR      r5,[r4,#4]
;;;219    
;;;220    						/* Insert the new block into the list of free blocks. */
;;;221    						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
000128  4638              MOV      r0,r7
00012a  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L1.302|
;;;222    					}
;;;223    
;;;224    					xFreeBytesRemaining -= pxBlock->xBlockSize;
00012e  491e              LDR      r1,|L1.424|
000130  6860              LDR      r0,[r4,#4]
000132  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
000134  1a08              SUBS     r0,r1,r0
000136  491c              LDR      r1,|L1.424|
000138  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;225    
;;;226    					/* The block is being returned - it is allocated and owned
;;;227    					by the application and has no "next" block. */
;;;228    					pxBlock->xBlockSize |= xBlockAllocatedBit;
00013a  491c              LDR      r1,|L1.428|
00013c  6860              LDR      r0,[r4,#4]
00013e  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000140  4308              ORRS     r0,r0,r1
000142  6060              STR      r0,[r4,#4]
;;;229    					pxBlock->pxNextFreeBlock = NULL;
000144  2000              MOVS     r0,#0
000146  6020              STR      r0,[r4,#0]
                  |L1.328|
;;;230    				}
;;;231    			}
;;;232    		}
;;;233    
;;;234    		traceMALLOC( pvReturn, xWantedSize );
;;;235    	}
;;;236    	xTaskResumeAll();
000148  f7fffffe          BL       xTaskResumeAll
;;;237    
;;;238    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;239    	{
;;;240    		if( pvReturn == NULL )
;;;241    		{
;;;242    			extern void vApplicationMallocFailedHook( void );
;;;243    			vApplicationMallocFailedHook();
;;;244    		}
;;;245    	}
;;;246    	#endif
;;;247    
;;;248    	return pvReturn;
00014c  4640              MOV      r0,r8
;;;249    }
00014e  e8bd81f0          POP      {r4-r8,pc}
;;;250    /*-----------------------------------------------------------*/
                          ENDP

                  vPortFree PROC
;;;251    
;;;252    void vPortFree( void *pv )
000152  b570              PUSH     {r4-r6,lr}
;;;253    {
000154  4606              MOV      r6,r0
;;;254    unsigned char *puc = ( unsigned char * ) pv;
000156  4635              MOV      r5,r6
;;;255    xBlockLink *pxLink;
;;;256    
;;;257    	if( pv != NULL )
000158  b1d6              CBZ      r6,|L1.400|
;;;258    	{
;;;259    		/* The memory being freed will have an xBlockLink structure immediately
;;;260    		before it. */
;;;261    		puc -= heapSTRUCT_SIZE;
00015a  3d08              SUBS     r5,r5,#8
;;;262    
;;;263    		/* This casting is to keep the compiler from issuing warnings. */
;;;264    		pxLink = ( void * ) puc;
00015c  462c              MOV      r4,r5
;;;265    
;;;266    		/* Check the block is actually allocated. */
;;;267    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
;;;268    		configASSERT( pxLink->pxNextFreeBlock == NULL );
;;;269    		
;;;270    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
00015e  4913              LDR      r1,|L1.428|
000160  6860              LDR      r0,[r4,#4]
000162  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000164  4208              TST      r0,r1
000166  d013              BEQ      |L1.400|
;;;271    		{
;;;272    			if( pxLink->pxNextFreeBlock == NULL )
000168  6820              LDR      r0,[r4,#0]
00016a  b988              CBNZ     r0,|L1.400|
;;;273    			{
;;;274    				/* The block is being returned to the heap - it is no longer
;;;275    				allocated. */
;;;276    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
00016c  490f              LDR      r1,|L1.428|
00016e  6860              LDR      r0,[r4,#4]
000170  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000172  4388              BICS     r0,r0,r1
000174  6060              STR      r0,[r4,#4]
;;;277    
;;;278    				vTaskSuspendAll();
000176  f7fffffe          BL       vTaskSuspendAll
;;;279    				{
;;;280    					/* Add this block to the list of free blocks. */
;;;281    					xFreeBytesRemaining += pxLink->xBlockSize;
00017a  490b              LDR      r1,|L1.424|
00017c  6860              LDR      r0,[r4,#4]
00017e  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
000180  4408              ADD      r0,r0,r1
000182  4909              LDR      r1,|L1.424|
000184  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;282    					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;283    					traceFREE( pv, pxLink->xBlockSize );
;;;284    				}
;;;285    				xTaskResumeAll();
00018c  f7fffffe          BL       xTaskResumeAll
                  |L1.400|
;;;286    			}
;;;287    		}
;;;288    	}
;;;289    }
000190  bd70              POP      {r4-r6,pc}
;;;290    /*-----------------------------------------------------------*/
                          ENDP

                  xPortGetFreeHeapSize PROC
;;;291    
;;;292    size_t xPortGetFreeHeapSize( void )
000192  4805              LDR      r0,|L1.424|
;;;293    {
;;;294    	return xFreeBytesRemaining;
000194  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;295    }
000196  4770              BX       lr
;;;296    /*-----------------------------------------------------------*/
                          ENDP

                  vPortInitialiseBlocks PROC
;;;297    
;;;298    void vPortInitialiseBlocks( void )
000198  4770              BX       lr
;;;299    {
;;;300    	/* This just exists to keep the linker quiet. */
;;;301    }
;;;302    /*-----------------------------------------------------------*/
                          ENDP

00019a  0000              DCW      0x0000
                  |L1.412|
                          DCD      xStart
                  |L1.416|
                          DCD      pxEnd
                  |L1.420|
                          DCD      ucHeap+0x8
                  |L1.424|
                          DCD      xFreeBytesRemaining
                  |L1.428|
                          DCD      xBlockAllocatedBit

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        45056

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x0000aff8
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8
